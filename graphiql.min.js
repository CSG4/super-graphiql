!(function(f) {
  if ("object" == typeof exports && "undefined" != typeof module)
    module.exports = f();
  else if ("function" == typeof define && define.amd) define([], f);
  else {
    ("undefined" != typeof window
      ? window
      : "undefined" != typeof global
        ? global
        : "undefined" != typeof self ? self : this
    ).GraphiQL = f();
  }
})(function() {
  return (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = "function" == typeof require && require;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw ((f.code = "MODULE_NOT_FOUND"), f);
        }
        var l = (n[o] = { exports: {} });
        t[o][0].call(
          l.exports,
          function(e) {
            var n = t[o][1][e];
            return s(n || e);
          },
          l,
          l.exports,
          e,
          t,
          n,
          r
        );
      }
      return n[o].exports;
    }
    for (
      var i = "function" == typeof require && require, o = 0;
      o < r.length;
      o++
    )
      s(r[o]);
    return s;
  })(
    {
      1: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.DocExplorer = void 0);
            var _extends =
                Object.assign ||
                function(e) {
                  for (var t = 1; t < arguments.length; t++) {
                    var a = arguments[t];
                    for (var r in a)
                      Object.prototype.hasOwnProperty.call(a, r) &&
                        (e[r] = a[r]);
                  }
                  return e;
                },
              _createClass = (function() {
                function e(e, t) {
                  for (var a = 0; a < t.length; a++) {
                    var r = t[a];
                    (r.enumerable = r.enumerable || !1),
                      (r.configurable = !0),
                      "value" in r && (r.writable = !0),
                      Object.defineProperty(e, r.key, r);
                  }
                }
                return function(t, a, r) {
                  return a && e(t.prototype, a), r && e(t, r), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _graphql = require("graphql"),
              _FieldDoc2 = _interopRequireDefault(
                require("./DocExplorer/FieldDoc")
              ),
              _SchemaDoc2 = _interopRequireDefault(
                require("./DocExplorer/SchemaDoc")
              ),
              _SearchBox2 = _interopRequireDefault(
                require("./DocExplorer/SearchBox")
              ),
              _SearchResults2 = _interopRequireDefault(
                require("./DocExplorer/SearchResults")
              ),
              _TypeDoc2 = _interopRequireDefault(
                require("./DocExplorer/TypeDoc")
              );
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            var initialNav = { name: "Schema", title: "Schema Explorer" };
            (exports.DocExplorer = (function(e) {
              function t() {
                !(function(e, t) {
                  if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function");
                })(this, t);
                var e = (function(e, t) {
                  if (!e)
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  return !t || ("object" != typeof t && "function" != typeof t)
                    ? e
                    : t;
                })(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this));
                return (
                  (e.handleNavBackClick = function() {
                    1 < e.state.navStack.length &&
                      e.setState({ navStack: e.state.navStack.slice(0, -1) });
                  }),
                  (e.handleClickTypeOrField = function(t) {
                    e.showDoc(t);
                  }),
                  (e.handleSearch = function(t) {
                    e.showSearch(t);
                  }),
                  (e.state = { navStack: [initialNav] }),
                  e
                );
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "shouldComponentUpdate",
                    value: function(e, t) {
                      return (
                        this.props.schema !== e.schema ||
                        this.state.navStack !== t.navStack
                      );
                    }
                  },
                  {
                    key: "render",
                    value: function() {
                      var r,
                        e = this.props.schema,
                        t = this.state.navStack,
                        a = t[t.length - 1];
                      r =
                        void 0 === e
                          ? _react2.default.createElement(
                              "div",
                              { className: "spinner-container" },
                              _react2.default.createElement("div", {
                                className: "spinner"
                              })
                            )
                          : e
                            ? a.search
                              ? _react2.default.createElement(
                                  _SearchResults2.default,
                                  {
                                    searchValue: a.search,
                                    withinType: a.def,
                                    schema: e,
                                    onClickType: this.handleClickTypeOrField,
                                    onClickField: this.handleClickTypeOrField
                                  }
                                )
                              : 1 === t.length
                                ? _react2.default.createElement(
                                    _SchemaDoc2.default,
                                    {
                                      schema: e,
                                      onClickType: this.handleClickTypeOrField
                                    }
                                  )
                                : (0, _graphql.isType)(a.def)
                                  ? _react2.default.createElement(
                                      _TypeDoc2.default,
                                      {
                                        schema: e,
                                        type: a.def,
                                        onClickType: this
                                          .handleClickTypeOrField,
                                        onClickField: this
                                          .handleClickTypeOrField
                                      }
                                    )
                                  : _react2.default.createElement(
                                      _FieldDoc2.default,
                                      {
                                        field: a.def,
                                        onClickType: this.handleClickTypeOrField
                                      }
                                    )
                            : _react2.default.createElement(
                                "div",
                                { className: "error-container" },
                                "No Schema Available",
                                _react2.default.createElement("br", null),
                                "(Enter Route in Path field)"
                              );
                      var c =
                          1 === t.length ||
                          ((0, _graphql.isType)(a.def) && a.def.getFields),
                        l = void 0;
                      return (
                        1 < t.length && (l = t[t.length - 2].name),
                        _react2.default.createElement(
                          "div",
                          { className: "doc-explorer", key: a.name },
                          _react2.default.createElement(
                            "div",
                            { className: "doc-explorer-title-bar" },
                            l &&
                              _react2.default.createElement(
                                "div",
                                {
                                  className: "doc-explorer-back",
                                  onClick: this.handleNavBackClick
                                },
                                l
                              ),
                            _react2.default.createElement(
                              "div",
                              { className: "doc-explorer-title" },
                              a.title || a.name
                            ),
                            _react2.default.createElement(
                              "div",
                              { className: "doc-explorer-rhs" },
                              this.props.children
                            )
                          ),
                          _react2.default.createElement(
                            "div",
                            { className: "doc-explorer-contents" },
                            c &&
                              _react2.default.createElement(
                                _SearchBox2.default,
                                {
                                  value: a.search,
                                  placeholder: "Search " + a.name + "...",
                                  onSearch: this.handleSearch
                                }
                              ),
                            r
                          )
                        )
                      );
                    }
                  },
                  {
                    key: "showDoc",
                    value: function(e) {
                      var t = this.state.navStack;
                      t[t.length - 1].def !== e &&
                        this.setState({
                          navStack: t.concat([{ name: e.name, def: e }])
                        });
                    }
                  },
                  {
                    key: "showDocForReference",
                    value: function(e) {
                      "Type" === e.kind
                        ? this.showDoc(e.type)
                        : "Field" === e.kind
                          ? this.showDoc(e.field)
                          : "Argument" === e.kind && e.field
                            ? this.showDoc(e.field)
                            : "EnumValue" === e.kind &&
                              e.type &&
                              this.showDoc(e.type);
                    }
                  },
                  {
                    key: "showSearch",
                    value: function(e) {
                      var t = this.state.navStack.slice(),
                        a = t[t.length - 1];
                      (t[t.length - 1] = _extends({}, a, { search: e })),
                        this.setState({ navStack: t });
                    }
                  },
                  {
                    key: "reset",
                    value: function() {
                      this.setState({ navStack: [initialNav] });
                    }
                  }
                ]),
                t
              );
            })()).propTypes = {
              schema: _propTypes2.default.instanceOf(_graphql.GraphQLSchema)
            };
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        {
          "./DocExplorer/FieldDoc": 4,
          "./DocExplorer/SchemaDoc": 6,
          "./DocExplorer/SearchBox": 7,
          "./DocExplorer/SearchResults": 8,
          "./DocExplorer/TypeDoc": 9,
          graphql: 101,
          "prop-types": 239
        }
      ],
      2: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.default = Argument);
            var _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _TypeLink2 = _interopRequireDefault(require("./TypeLink")),
              _DefaultValue2 = _interopRequireDefault(
                require("./DefaultValue")
              );
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            function Argument(e) {
              var t = e.arg,
                r = e.onClickType,
                a = e.showDefaultValue;
              return _react2.default.createElement(
                "span",
                { className: "arg" },
                _react2.default.createElement(
                  "span",
                  { className: "arg-name" },
                  t.name
                ),
                ": ",
                _react2.default.createElement(_TypeLink2.default, {
                  type: t.type,
                  onClick: r
                }),
                !1 !== a &&
                  _react2.default.createElement(_DefaultValue2.default, {
                    field: t
                  })
              );
            }
            Argument.propTypes = {
              arg: _propTypes2.default.object.isRequired,
              onClickType: _propTypes2.default.func.isRequired,
              showDefaultValue: _propTypes2.default.bool
            };
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { "./DefaultValue": 3, "./TypeLink": 10, "prop-types": 239 }
      ],
      3: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.default = DefaultValue);
            var _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _graphql = require("graphql");
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            function DefaultValue(e) {
              var r = e.field,
                t = r.type,
                a = r.defaultValue;
              return void 0 !== a
                ? _react2.default.createElement(
                    "span",
                    null,
                    " = ",
                    _react2.default.createElement(
                      "span",
                      { className: "arg-default-value" },
                      (0, _graphql.print)((0, _graphql.astFromValue)(a, t))
                    )
                  )
                : null;
            }
            DefaultValue.propTypes = {
              field: _propTypes2.default.object.isRequired
            };
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { graphql: 101, "prop-types": 239 }
      ],
      4: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 });
            var _createClass = (function() {
                function e(e, t) {
                  for (var r = 0; r < t.length; r++) {
                    var n = t[r];
                    (n.enumerable = n.enumerable || !1),
                      (n.configurable = !0),
                      "value" in n && (n.writable = !0),
                      Object.defineProperty(e, n.key, n);
                  }
                }
                return function(t, r, n) {
                  return r && e(t.prototype, r), n && e(t, n), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _Argument2 = _interopRequireDefault(require("./Argument")),
              _MarkdownContent2 = _interopRequireDefault(
                require("./MarkdownContent")
              ),
              _TypeLink2 = _interopRequireDefault(require("./TypeLink"));
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            var FieldDoc = (function(e) {
              function t() {
                return (
                  (function(e, t) {
                    if (!(e instanceof t))
                      throw new TypeError("Cannot call a class as a function");
                  })(this, t),
                  (function(e, t) {
                    if (!e)
                      throw new ReferenceError(
                        "this hasn't been initialised - super() hasn't been called"
                      );
                    return !t ||
                      ("object" != typeof t && "function" != typeof t)
                      ? e
                      : t;
                  })(
                    this,
                    (t.__proto__ || Object.getPrototypeOf(t)).apply(
                      this,
                      arguments
                    )
                  )
                );
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "shouldComponentUpdate",
                    value: function(e) {
                      return this.props.field !== e.field;
                    }
                  },
                  {
                    key: "render",
                    value: function() {
                      var e = this,
                        t = this.props.field,
                        r = void 0;
                      return (
                        t.args &&
                          0 < t.args.length &&
                          (r = _react2.default.createElement(
                            "div",
                            { className: "doc-category" },
                            _react2.default.createElement(
                              "div",
                              { className: "doc-category-title" },
                              "arguments"
                            ),
                            t.args.map(function(t) {
                              return _react2.default.createElement(
                                "div",
                                { key: t.name, className: "doc-category-item" },
                                _react2.default.createElement(
                                  "div",
                                  null,
                                  _react2.default.createElement(
                                    _Argument2.default,
                                    { arg: t, onClickType: e.props.onClickType }
                                  )
                                ),
                                _react2.default.createElement(
                                  _MarkdownContent2.default,
                                  {
                                    className: "doc-value-description",
                                    markdown: t.description
                                  }
                                )
                              );
                            })
                          )),
                        _react2.default.createElement(
                          "div",
                          null,
                          _react2.default.createElement(
                            _MarkdownContent2.default,
                            {
                              className: "doc-type-description",
                              markdown: t.description || "No Description"
                            }
                          ),
                          t.deprecationReason &&
                            _react2.default.createElement(
                              _MarkdownContent2.default,
                              {
                                className: "doc-deprecation",
                                markdown: t.deprecationReason
                              }
                            ),
                          _react2.default.createElement(
                            "div",
                            { className: "doc-category" },
                            _react2.default.createElement(
                              "div",
                              { className: "doc-category-title" },
                              "type"
                            ),
                            _react2.default.createElement(_TypeLink2.default, {
                              type: t.type,
                              onClick: this.props.onClickType
                            })
                          ),
                          r
                        )
                      );
                    }
                  }
                ]),
                t
              );
            })();
            (FieldDoc.propTypes = {
              field: _propTypes2.default.object,
              onClickType: _propTypes2.default.func
            }),
              (exports.default = FieldDoc);
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        {
          "./Argument": 2,
          "./MarkdownContent": 5,
          "./TypeLink": 10,
          "prop-types": 239
        }
      ],
      5: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 });
            var _createClass = (function() {
                function e(e, t) {
                  for (var r = 0; r < t.length; r++) {
                    var n = t[r];
                    (n.enumerable = n.enumerable || !1),
                      (n.configurable = !0),
                      "value" in n && (n.writable = !0),
                      Object.defineProperty(e, n.key, n);
                  }
                }
                return function(t, r, n) {
                  return r && e(t.prototype, r), n && e(t, n), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types"));
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            var md = new (_interopRequireDefault(
                require("markdown-it")
              )).default(),
              MarkdownContent = (function(e) {
                function t() {
                  return (
                    (function(e, t) {
                      if (!(e instanceof t))
                        throw new TypeError(
                          "Cannot call a class as a function"
                        );
                    })(this, t),
                    (function(e, t) {
                      if (!e)
                        throw new ReferenceError(
                          "this hasn't been initialised - super() hasn't been called"
                        );
                      return !t ||
                        ("object" != typeof t && "function" != typeof t)
                        ? e
                        : t;
                    })(
                      this,
                      (t.__proto__ || Object.getPrototypeOf(t)).apply(
                        this,
                        arguments
                      )
                    )
                  );
                }
                return (
                  (function(e, t) {
                    if ("function" != typeof t && null !== t)
                      throw new TypeError(
                        "Super expression must either be null or a function, not " +
                          typeof t
                      );
                    (e.prototype = Object.create(t && t.prototype, {
                      constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                      }
                    })),
                      t &&
                        (Object.setPrototypeOf
                          ? Object.setPrototypeOf(e, t)
                          : (e.__proto__ = t));
                  })(t, _react2.default.Component),
                  _createClass(t, [
                    {
                      key: "shouldComponentUpdate",
                      value: function(e) {
                        return this.props.markdown !== e.markdown;
                      }
                    },
                    {
                      key: "render",
                      value: function() {
                        var e = this.props.markdown;
                        return e
                          ? _react2.default.createElement("div", {
                              className: this.props.className,
                              dangerouslySetInnerHTML: { __html: md.render(e) }
                            })
                          : _react2.default.createElement("div", null);
                      }
                    }
                  ]),
                  t
                );
              })();
            (MarkdownContent.propTypes = {
              markdown: _propTypes2.default.string,
              className: _propTypes2.default.string
            }),
              (exports.default = MarkdownContent);
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { "markdown-it": 178, "prop-types": 239 }
      ],
      6: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 });
            var _createClass = (function() {
                function e(e, t) {
                  for (var r = 0; r < t.length; r++) {
                    var a = t[r];
                    (a.enumerable = a.enumerable || !1),
                      (a.configurable = !0),
                      "value" in a && (a.writable = !0),
                      Object.defineProperty(e, a.key, a);
                  }
                }
                return function(t, r, a) {
                  return r && e(t.prototype, r), a && e(t, a), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _TypeLink2 = _interopRequireDefault(require("./TypeLink")),
              _MarkdownContent2 = _interopRequireDefault(
                require("./MarkdownContent")
              );
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            var SchemaDoc = (function(e) {
              function t() {
                return (
                  (function(e, t) {
                    if (!(e instanceof t))
                      throw new TypeError("Cannot call a class as a function");
                  })(this, t),
                  (function(e, t) {
                    if (!e)
                      throw new ReferenceError(
                        "this hasn't been initialised - super() hasn't been called"
                      );
                    return !t ||
                      ("object" != typeof t && "function" != typeof t)
                      ? e
                      : t;
                  })(
                    this,
                    (t.__proto__ || Object.getPrototypeOf(t)).apply(
                      this,
                      arguments
                    )
                  )
                );
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "shouldComponentUpdate",
                    value: function(e) {
                      return this.props.schema !== e.schema;
                    }
                  },
                  {
                    key: "render",
                    value: function() {
                      var e = this.props.schema,
                        t = e.getQueryType(),
                        r = e.getMutationType && e.getMutationType(),
                        a = e.getSubscriptionType && e.getSubscriptionType();
                      return _react2.default.createElement(
                        "div",
                        null,
                        _react2.default.createElement(
                          _MarkdownContent2.default,
                          {
                            className: "doc-type-description",
                            markdown:
                              "A GraphQL schema provides a root type for each kind of operation."
                          }
                        ),
                        _react2.default.createElement(
                          "div",
                          { className: "doc-category" },
                          _react2.default.createElement(
                            "div",
                            { className: "doc-category-title" },
                            "root types"
                          ),
                          _react2.default.createElement(
                            "div",
                            { className: "doc-category-item" },
                            _react2.default.createElement(
                              "span",
                              { className: "keyword" },
                              "query"
                            ),
                            ": ",
                            _react2.default.createElement(_TypeLink2.default, {
                              type: t,
                              onClick: this.props.onClickType
                            })
                          ),
                          r &&
                            _react2.default.createElement(
                              "div",
                              { className: "doc-category-item" },
                              _react2.default.createElement(
                                "span",
                                { className: "keyword" },
                                "mutation"
                              ),
                              ": ",
                              _react2.default.createElement(
                                _TypeLink2.default,
                                { type: r, onClick: this.props.onClickType }
                              )
                            ),
                          a &&
                            _react2.default.createElement(
                              "div",
                              { className: "doc-category-item" },
                              _react2.default.createElement(
                                "span",
                                { className: "keyword" },
                                "subscription"
                              ),
                              ": ",
                              _react2.default.createElement(
                                _TypeLink2.default,
                                { type: a, onClick: this.props.onClickType }
                              )
                            )
                        )
                      );
                    }
                  }
                ]),
                t
              );
            })();
            (SchemaDoc.propTypes = {
              schema: _propTypes2.default.object,
              onClickType: _propTypes2.default.func
            }),
              (exports.default = SchemaDoc);
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { "./MarkdownContent": 5, "./TypeLink": 10, "prop-types": 239 }
      ],
      7: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 });
            var _createClass = (function() {
                function e(e, t) {
                  for (var r = 0; r < t.length; r++) {
                    var a = t[r];
                    (a.enumerable = a.enumerable || !1),
                      (a.configurable = !0),
                      "value" in a && (a.writable = !0),
                      Object.defineProperty(e, a.key, a);
                  }
                }
                return function(t, r, a) {
                  return r && e(t.prototype, r), a && e(t, a), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _debounce2 = _interopRequireDefault(
                require("../../utility/debounce")
              );
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            var SearchBox = (function(e) {
              function t(e) {
                !(function(e, t) {
                  if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function");
                })(this, t);
                var r = (function(e, t) {
                  if (!e)
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  return !t || ("object" != typeof t && "function" != typeof t)
                    ? e
                    : t;
                })(
                  this,
                  (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)
                );
                return (
                  (r.handleChange = function(e) {
                    var t = e.target.value;
                    r.setState({ value: t }), r.debouncedOnSearch(t);
                  }),
                  (r.handleClear = function() {
                    r.setState({ value: "" }), r.props.onSearch("");
                  }),
                  (r.state = { value: e.value || "" }),
                  (r.debouncedOnSearch = (0, _debounce2.default)(
                    200,
                    r.props.onSearch
                  )),
                  r
                );
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "render",
                    value: function() {
                      return _react2.default.createElement(
                        "label",
                        { className: "search-box" },
                        _react2.default.createElement("input", {
                          value: this.state.value,
                          onChange: this.handleChange,
                          type: "text",
                          placeholder: this.props.placeholder
                        }),
                        this.state.value &&
                          _react2.default.createElement(
                            "div",
                            {
                              className: "search-box-clear",
                              onClick: this.handleClear
                            },
                            "✕"
                          )
                      );
                    }
                  }
                ]),
                t
              );
            })();
            (SearchBox.propTypes = {
              value: _propTypes2.default.string,
              placeholder: _propTypes2.default.string,
              onSearch: _propTypes2.default.func
            }),
              (exports.default = SearchBox);
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { "../../utility/debounce": 27, "prop-types": 239 }
      ],
      8: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 });
            var _createClass = (function() {
                function e(e, t) {
                  for (var r = 0; r < t.length; r++) {
                    var a = t[r];
                    (a.enumerable = a.enumerable || !1),
                      (a.configurable = !0),
                      "value" in a && (a.writable = !0),
                      Object.defineProperty(e, a.key, a);
                  }
                }
                return function(t, r, a) {
                  return r && e(t.prototype, r), a && e(t, a), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _Argument2 = _interopRequireDefault(require("./Argument")),
              _TypeLink2 = _interopRequireDefault(require("./TypeLink"));
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            var SearchResults = (function(e) {
              function t() {
                return (
                  (function(e, t) {
                    if (!(e instanceof t))
                      throw new TypeError("Cannot call a class as a function");
                  })(this, t),
                  (function(e, t) {
                    if (!e)
                      throw new ReferenceError(
                        "this hasn't been initialised - super() hasn't been called"
                      );
                    return !t ||
                      ("object" != typeof t && "function" != typeof t)
                      ? e
                      : t;
                  })(
                    this,
                    (t.__proto__ || Object.getPrototypeOf(t)).apply(
                      this,
                      arguments
                    )
                  )
                );
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "shouldComponentUpdate",
                    value: function(e) {
                      return (
                        this.props.schema !== e.schema ||
                        this.props.searchValue !== e.searchValue
                      );
                    }
                  },
                  {
                    key: "render",
                    value: function() {
                      var e = this.props.searchValue,
                        t = this.props.withinType,
                        r = this.props.schema,
                        a = this.props.onClickType,
                        n = this.props.onClickField,
                        o = [],
                        l = [],
                        u = [],
                        c = r.getTypeMap(),
                        i = Object.keys(c);
                      t &&
                        (i = i.filter(function(e) {
                          return e !== t.name;
                        })).unshift(t.name);
                      var s = !0,
                        p = !1,
                        f = void 0;
                      try {
                        for (
                          var h,
                            y = function() {
                              var r = h.value;
                              if (100 <= o.length + l.length + u.length)
                                return "break";
                              var i = c[r];
                              if (
                                (t !== i &&
                                  isMatch(r, e) &&
                                  l.push(
                                    _react2.default.createElement(
                                      "div",
                                      {
                                        className: "doc-category-item",
                                        key: r
                                      },
                                      _react2.default.createElement(
                                        _TypeLink2.default,
                                        { type: i, onClick: a }
                                      )
                                    )
                                  ),
                                i.getFields)
                              ) {
                                var s = i.getFields();
                                Object.keys(s).forEach(function(l) {
                                  var c = s[l],
                                    p = void 0;
                                  if (!isMatch(l, e)) {
                                    if (!c.args || !c.args.length) return;
                                    if (
                                      0 ===
                                      (p = c.args.filter(function(t) {
                                        return isMatch(t.name, e);
                                      })).length
                                    )
                                      return;
                                  }
                                  var f = _react2.default.createElement(
                                    "div",
                                    {
                                      className: "doc-category-item",
                                      key: r + "." + l
                                    },
                                    t !== i && [
                                      _react2.default.createElement(
                                        _TypeLink2.default,
                                        { key: "type", type: i, onClick: a }
                                      ),
                                      "."
                                    ],
                                    _react2.default.createElement(
                                      "a",
                                      {
                                        className: "field-name",
                                        onClick: function(e) {
                                          return n(c, i, e);
                                        }
                                      },
                                      c.name
                                    ),
                                    p && [
                                      "(",
                                      _react2.default.createElement(
                                        "span",
                                        { key: "args" },
                                        p.map(function(e) {
                                          return _react2.default.createElement(
                                            _Argument2.default,
                                            {
                                              key: e.name,
                                              arg: e,
                                              onClickType: a,
                                              showDefaultValue: !1
                                            }
                                          );
                                        })
                                      ),
                                      ")"
                                    ]
                                  );
                                  t === i ? o.push(f) : u.push(f);
                                });
                              }
                            },
                            _ = i[Symbol.iterator]();
                          !(s = (h = _.next()).done) && "break" !== y();
                          s = !0
                        );
                      } catch (e) {
                        (p = !0), (f = e);
                      } finally {
                        try {
                          !s && _.return && _.return();
                        } finally {
                          if (p) throw f;
                        }
                      }
                      return o.length + l.length + u.length === 0
                        ? _react2.default.createElement(
                            "span",
                            { className: "doc-alert-text" },
                            "No results found."
                          )
                        : t && 0 < l.length + u.length
                          ? _react2.default.createElement(
                              "div",
                              null,
                              o,
                              _react2.default.createElement(
                                "div",
                                { className: "doc-category" },
                                _react2.default.createElement(
                                  "div",
                                  { className: "doc-category-title" },
                                  "other results"
                                ),
                                l,
                                u
                              )
                            )
                          : _react2.default.createElement("div", null, o, l, u);
                    }
                  }
                ]),
                t
              );
            })();
            function isMatch(e, t) {
              try {
                var r = t.replace(/[^_0-9A-Za-z]/g, function(e) {
                  return "\\" + e;
                });
                return -1 !== e.search(new RegExp(r, "i"));
              } catch (r) {
                return -1 !== e.toLowerCase().indexOf(t.toLowerCase());
              }
            }
            (SearchResults.propTypes = {
              schema: _propTypes2.default.object,
              withinType: _propTypes2.default.object,
              searchValue: _propTypes2.default.string,
              onClickType: _propTypes2.default.func,
              onClickField: _propTypes2.default.func
            }),
              (exports.default = SearchResults);
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { "./Argument": 2, "./TypeLink": 10, "prop-types": 239 }
      ],
      9: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 });
            var _createClass = (function() {
                function e(e, t) {
                  for (var a = 0; a < t.length; a++) {
                    var r = t[a];
                    (r.enumerable = r.enumerable || !1),
                      (r.configurable = !0),
                      "value" in r && (r.writable = !0),
                      Object.defineProperty(e, r.key, r);
                  }
                }
                return function(t, a, r) {
                  return a && e(t.prototype, a), r && e(t, r), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _graphql = require("graphql"),
              _Argument2 = _interopRequireDefault(require("./Argument")),
              _MarkdownContent2 = _interopRequireDefault(
                require("./MarkdownContent")
              ),
              _TypeLink2 = _interopRequireDefault(require("./TypeLink")),
              _DefaultValue2 = _interopRequireDefault(
                require("./DefaultValue")
              );
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            var TypeDoc = (function(e) {
              function t(e) {
                !(function(e, t) {
                  if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function");
                })(this, t);
                var a = (function(e, t) {
                  if (!e)
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  return !t || ("object" != typeof t && "function" != typeof t)
                    ? e
                    : t;
                })(
                  this,
                  (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)
                );
                return (
                  (a.handleShowDeprecated = function() {
                    return a.setState({ showDeprecated: !0 });
                  }),
                  (a.state = { showDeprecated: !1 }),
                  a
                );
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "shouldComponentUpdate",
                    value: function(e, t) {
                      return (
                        this.props.type !== e.type ||
                        this.props.schema !== e.schema ||
                        this.state.showDeprecated !== t.showDeprecated
                      );
                    }
                  },
                  {
                    key: "render",
                    value: function() {
                      var e = this.props.schema,
                        t = this.props.type,
                        a = this.props.onClickType,
                        r = this.props.onClickField,
                        n = void 0,
                        c = void 0;
                      t instanceof _graphql.GraphQLUnionType
                        ? ((n = "possible types"), (c = e.getPossibleTypes(t)))
                        : t instanceof _graphql.GraphQLInterfaceType
                          ? ((n = "implementations"),
                            (c = e.getPossibleTypes(t)))
                          : t instanceof _graphql.GraphQLObjectType &&
                            ((n = "implements"), (c = t.getInterfaces()));
                      var l = void 0;
                      c &&
                        0 < c.length &&
                        (l = _react2.default.createElement(
                          "div",
                          { className: "doc-category" },
                          _react2.default.createElement(
                            "div",
                            { className: "doc-category-title" },
                            n
                          ),
                          c.map(function(e) {
                            return _react2.default.createElement(
                              "div",
                              { key: e.name, className: "doc-category-item" },
                              _react2.default.createElement(
                                _TypeLink2.default,
                                { type: e, onClick: a }
                              )
                            );
                          })
                        ));
                      var o = void 0,
                        i = void 0;
                      if (t.getFields) {
                        var u = t.getFields(),
                          p = Object.keys(u).map(function(e) {
                            return u[e];
                          });
                        o = _react2.default.createElement(
                          "div",
                          { className: "doc-category" },
                          _react2.default.createElement(
                            "div",
                            { className: "doc-category-title" },
                            "fields"
                          ),
                          p
                            .filter(function(e) {
                              return !e.isDeprecated;
                            })
                            .map(function(e) {
                              return _react2.default.createElement(Field, {
                                key: e.name,
                                type: t,
                                field: e,
                                onClickType: a,
                                onClickField: r
                              });
                            })
                        );
                        var s = p.filter(function(e) {
                          return e.isDeprecated;
                        });
                        0 < s.length &&
                          (i = _react2.default.createElement(
                            "div",
                            { className: "doc-category" },
                            _react2.default.createElement(
                              "div",
                              { className: "doc-category-title" },
                              "deprecated fields"
                            ),
                            this.state.showDeprecated
                              ? s.map(function(e) {
                                  return _react2.default.createElement(Field, {
                                    key: e.name,
                                    type: t,
                                    field: e,
                                    onClickType: a,
                                    onClickField: r
                                  });
                                })
                              : _react2.default.createElement(
                                  "button",
                                  {
                                    className: "show-btn",
                                    onClick: this.handleShowDeprecated
                                  },
                                  "Show deprecated fields..."
                                )
                          ));
                      }
                      var d = void 0,
                        f = void 0;
                      if (t instanceof _graphql.GraphQLEnumType) {
                        var m = t.getValues();
                        d = _react2.default.createElement(
                          "div",
                          { className: "doc-category" },
                          _react2.default.createElement(
                            "div",
                            { className: "doc-category-title" },
                            "values"
                          ),
                          m
                            .filter(function(e) {
                              return !e.isDeprecated;
                            })
                            .map(function(e) {
                              return _react2.default.createElement(EnumValue, {
                                key: e.name,
                                value: e
                              });
                            })
                        );
                        var _ = m.filter(function(e) {
                          return e.isDeprecated;
                        });
                        0 < _.length &&
                          (f = _react2.default.createElement(
                            "div",
                            { className: "doc-category" },
                            _react2.default.createElement(
                              "div",
                              { className: "doc-category-title" },
                              "deprecated values"
                            ),
                            this.state.showDeprecated
                              ? _.map(function(e) {
                                  return _react2.default.createElement(
                                    EnumValue,
                                    { key: e.name, value: e }
                                  );
                                })
                              : _react2.default.createElement(
                                  "button",
                                  {
                                    className: "show-btn",
                                    onClick: this.handleShowDeprecated
                                  },
                                  "Show deprecated values..."
                                )
                          ));
                      }
                      return _react2.default.createElement(
                        "div",
                        null,
                        _react2.default.createElement(
                          _MarkdownContent2.default,
                          {
                            className: "doc-type-description",
                            markdown: t.description || "No Description"
                          }
                        ),
                        t instanceof _graphql.GraphQLObjectType && l,
                        o,
                        i,
                        d,
                        f,
                        !(t instanceof _graphql.GraphQLObjectType) && l
                      );
                    }
                  }
                ]),
                t
              );
            })();
            function Field(e) {
              var t = e.type,
                a = e.field,
                r = e.onClickType,
                n = e.onClickField;
              return _react2.default.createElement(
                "div",
                { className: "doc-category-item" },
                _react2.default.createElement(
                  "a",
                  {
                    className: "field-name",
                    onClick: function(e) {
                      return n(a, t, e);
                    }
                  },
                  a.name
                ),
                a.args &&
                  0 < a.args.length && [
                    "(",
                    _react2.default.createElement(
                      "span",
                      { key: "args" },
                      a.args.map(function(e) {
                        return _react2.default.createElement(
                          _Argument2.default,
                          { key: e.name, arg: e, onClickType: r }
                        );
                      })
                    ),
                    ")"
                  ],
                ": ",
                _react2.default.createElement(_TypeLink2.default, {
                  type: a.type,
                  onClick: r
                }),
                _react2.default.createElement(_DefaultValue2.default, {
                  field: a
                }),
                a.description &&
                  _react2.default.createElement(_MarkdownContent2.default, {
                    className: "field-short-description",
                    markdown: a.description
                  }),
                a.deprecationReason &&
                  _react2.default.createElement(_MarkdownContent2.default, {
                    className: "doc-deprecation",
                    markdown: a.deprecationReason
                  })
              );
            }
            function EnumValue(e) {
              var t = e.value;
              return _react2.default.createElement(
                "div",
                { className: "doc-category-item" },
                _react2.default.createElement(
                  "div",
                  { className: "enum-value" },
                  t.name
                ),
                _react2.default.createElement(_MarkdownContent2.default, {
                  className: "doc-value-description",
                  markdown: t.description
                }),
                t.deprecationReason &&
                  _react2.default.createElement(_MarkdownContent2.default, {
                    className: "doc-deprecation",
                    markdown: t.deprecationReason
                  })
              );
            }
            (TypeDoc.propTypes = {
              schema: _propTypes2.default.instanceOf(_graphql.GraphQLSchema),
              type: _propTypes2.default.object,
              onClickType: _propTypes2.default.func,
              onClickField: _propTypes2.default.func
            }),
              (exports.default = TypeDoc),
              (Field.propTypes = {
                type: _propTypes2.default.object,
                field: _propTypes2.default.object,
                onClickType: _propTypes2.default.func,
                onClickField: _propTypes2.default.func
              }),
              (EnumValue.propTypes = { value: _propTypes2.default.object });
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        {
          "./Argument": 2,
          "./DefaultValue": 3,
          "./MarkdownContent": 5,
          "./TypeLink": 10,
          graphql: 101,
          "prop-types": 239
        }
      ],
      10: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 });
            var _createClass = (function() {
                function e(e, t) {
                  for (var r = 0; r < t.length; r++) {
                    var n = t[r];
                    (n.enumerable = n.enumerable || !1),
                      (n.configurable = !0),
                      "value" in n && (n.writable = !0),
                      Object.defineProperty(e, n.key, n);
                  }
                }
                return function(t, r, n) {
                  return r && e(t.prototype, r), n && e(t, n), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _graphql = require("graphql");
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            var TypeLink = (function(e) {
              function t() {
                return (
                  (function(e, t) {
                    if (!(e instanceof t))
                      throw new TypeError("Cannot call a class as a function");
                  })(this, t),
                  (function(e, t) {
                    if (!e)
                      throw new ReferenceError(
                        "this hasn't been initialised - super() hasn't been called"
                      );
                    return !t ||
                      ("object" != typeof t && "function" != typeof t)
                      ? e
                      : t;
                  })(
                    this,
                    (t.__proto__ || Object.getPrototypeOf(t)).apply(
                      this,
                      arguments
                    )
                  )
                );
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "shouldComponentUpdate",
                    value: function(e) {
                      return this.props.type !== e.type;
                    }
                  },
                  {
                    key: "render",
                    value: function() {
                      return (function renderType(e, t) {
                        return e instanceof _graphql.GraphQLNonNull
                          ? _react2.default.createElement(
                              "span",
                              null,
                              renderType(e.ofType, t),
                              "!"
                            )
                          : e instanceof _graphql.GraphQLList
                            ? _react2.default.createElement(
                                "span",
                                null,
                                "[",
                                renderType(e.ofType, t),
                                "]"
                              )
                            : _react2.default.createElement(
                                "a",
                                {
                                  className: "type-name",
                                  onClick: function(r) {
                                    return t(e, r);
                                  }
                                },
                                e.name
                              );
                      })(this.props.type, this.props.onClick);
                    }
                  }
                ]),
                t
              );
            })();
            (TypeLink.propTypes = {
              type: _propTypes2.default.object,
              onClick: _propTypes2.default.func
            }),
              (exports.default = TypeLink);
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { graphql: 101, "prop-types": 239 }
      ],
      11: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.ExecuteButton = void 0);
            var _createClass = (function() {
                function e(e, t) {
                  for (var n = 0; n < t.length; n++) {
                    var o = t[n];
                    (o.enumerable = o.enumerable || !1),
                      (o.configurable = !0),
                      "value" in o && (o.writable = !0),
                      Object.defineProperty(e, o.key, o);
                  }
                }
                return function(t, n, o) {
                  return n && e(t.prototype, n), o && e(t, o), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types"));
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            (exports.ExecuteButton = (function(e) {
              function t(e) {
                !(function(e, t) {
                  if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function");
                })(this, t);
                var n = (function(e, t) {
                  if (!e)
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  return !t || ("object" != typeof t && "function" != typeof t)
                    ? e
                    : t;
                })(
                  this,
                  (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)
                );
                return (
                  (n._onClick = function() {
                    n.props.isRunning ? n.props.onStop() : n.props.onRun();
                  }),
                  (n._onOptionSelected = function(e) {
                    n.setState({ optionsOpen: !1 }),
                      n.props.onRun(e.name && e.name.value);
                  }),
                  (n._onOptionsOpen = function(e) {
                    var t = !0,
                      o = e.target;
                    n.setState({ highlight: null, optionsOpen: !0 });
                    var r = function(e) {
                      t && e.target === o
                        ? (t = !1)
                        : (document.removeEventListener("mouseup", r),
                          (r = null),
                          o.parentNode.compareDocumentPosition(e.target) &
                            Node.DOCUMENT_POSITION_CONTAINED_BY ||
                            n.setState({ optionsOpen: !1 }));
                    };
                    document.addEventListener("mouseup", r);
                  }),
                  (n.state = { optionsOpen: !1, highlight: null }),
                  n
                );
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "render",
                    value: function() {
                      var e = this,
                        t = this.props.operations,
                        n = this.state.optionsOpen,
                        o = t && 1 < t.length,
                        r = null;
                      if (o && n) {
                        var u = this.state.highlight;
                        r = _react2.default.createElement(
                          "ul",
                          { className: "execute-options" },
                          t.map(function(t) {
                            return _react2.default.createElement(
                              "li",
                              {
                                key: t.name ? t.name.value : "*",
                                className: t === u ? "selected" : null,
                                onMouseOver: function() {
                                  return e.setState({ highlight: t });
                                },
                                onMouseOut: function() {
                                  return e.setState({ highlight: null });
                                },
                                onMouseUp: function() {
                                  return e._onOptionSelected(t);
                                }
                              },
                              t.name ? t.name.value : "<Unnamed>"
                            );
                          })
                        );
                      }
                      var a = void 0;
                      (!this.props.isRunning && o) || (a = this._onClick);
                      var i = void 0;
                      this.props.isRunning ||
                        !o ||
                        n ||
                        (i = this._onOptionsOpen);
                      var s = this.props.isRunning
                        ? _react2.default.createElement("path", {
                            d: "M 10 10 L 23 10 L 23 23 L 10 23 z"
                          })
                        : _react2.default.createElement("path", {
                            d: "M 11 9 L 24 16 L 11 23 z"
                          });
                      return _react2.default.createElement(
                        "div",
                        { className: "execute-button-wrap" },
                        _react2.default.createElement(
                          "button",
                          {
                            type: "button",
                            className: "execute-button",
                            onMouseDown: i,
                            onClick: a,
                            title: "Execute Query (Ctrl-Enter)"
                          },
                          _react2.default.createElement(
                            "svg",
                            { width: "34", height: "34" },
                            s
                          )
                        ),
                        r
                      );
                    }
                  }
                ]),
                t
              );
            })()).propTypes = {
              onRun: _propTypes2.default.func,
              onStop: _propTypes2.default.func,
              isRunning: _propTypes2.default.bool,
              operations: _propTypes2.default.array
            };
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { "prop-types": 239 }
      ],
      12: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.GraphiQL = void 0);
            var _typeof =
                "function" == typeof Symbol &&
                "symbol" == typeof Symbol.iterator
                  ? function(e) {
                      return typeof e;
                    }
                  : function(e) {
                      return e &&
                        "function" == typeof Symbol &&
                        e.constructor === Symbol &&
                        e !== Symbol.prototype
                        ? "symbol"
                        : typeof e;
                    },
              _extends =
                Object.assign ||
                function(e) {
                  for (var t = 1; t < arguments.length; t++) {
                    var r = arguments[t];
                    for (var o in r)
                      Object.prototype.hasOwnProperty.call(r, o) &&
                        (e[o] = r[o]);
                  }
                  return e;
                },
              _createClass = (function() {
                function e(e, t) {
                  for (var r = 0; r < t.length; r++) {
                    var o = t[r];
                    (o.enumerable = o.enumerable || !1),
                      (o.configurable = !0),
                      "value" in o && (o.writable = !0),
                      Object.defineProperty(e, o.key, o);
                  }
                }
                return function(t, r, o) {
                  return r && e(t.prototype, r), o && e(t, o), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _reactDom2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.ReactDOM
                  : void 0 !== global ? global.ReactDOM : null
              ),
              _graphql = require("graphql"),
              _ExecuteButton = require("./ExecuteButton"),
              _ToolbarButton = require("./ToolbarButton"),
              _ToolbarGroup = require("./ToolbarGroup"),
              _ToolbarMenu = require("./ToolbarMenu"),
              _ToolbarSelect = require("./ToolbarSelect"),
              _PathEditor = require("./PathEditor"),
              _QueryEditor = require("./QueryEditor"),
              _VariableEditor = require("./VariableEditor"),
              _ResultViewer = require("./ResultViewer"),
              _DocExplorer = require("./DocExplorer"),
              _QueryHistory = require("./QueryHistory"),
              _CodeMirrorSizer2 = _interopRequireDefault(
                require("../utility/CodeMirrorSizer")
              ),
              _StorageAPI2 = _interopRequireDefault(
                require("../utility/StorageAPI")
              ),
              _getQueryFacts2 = _interopRequireDefault(
                require("../utility/getQueryFacts")
              ),
              _getSelectedOperationName2 = _interopRequireDefault(
                require("../utility/getSelectedOperationName")
              ),
              _debounce2 = _interopRequireDefault(
                require("../utility/debounce")
              ),
              _find2 = _interopRequireDefault(require("../utility/find")),
              _fillLeafs2 = require("../utility/fillLeafs"),
              _elementPosition = require("../utility/elementPosition"),
              _introspectionQueries = require("../utility/introspectionQueries");
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            var DEFAULT_DOC_EXPLORER_WIDTH = 350,
              GraphiQL = (exports.GraphiQL = (function(e) {
                function t(e) {
                  !(function(e, t) {
                    if (!(e instanceof t))
                      throw new TypeError("Cannot call a class as a function");
                  })(this, t);
                  var r = (function(e, t) {
                    if (!e)
                      throw new ReferenceError(
                        "this hasn't been initialised - super() hasn't been called"
                      );
                    return !t ||
                      ("object" != typeof t && "function" != typeof t)
                      ? e
                      : t;
                  })(
                    this,
                    (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)
                  );
                  if (
                    (_initialiseProps.call(r), "function" != typeof e.fetcher)
                  )
                    throw new TypeError(
                      "GraphiQL requires a fetcher function."
                    );
                  r._storage = new _StorageAPI2.default(e.storage);
                  var o =
                      void 0 !== e.query
                        ? e.query
                        : null !== r._storage.get("query")
                          ? r._storage.get("query")
                          : void 0 !== e.defaultQuery
                            ? e.defaultQuery
                            : defaultQuery,
                    a =
                      void 0 !== e.path
                        ? e.path
                        : null !== r._storage.get("path")
                          ? r._storage.get("path")
                          : void 0 !== e.defaultPath
                            ? e.defaultPath
                            : defaultPath,
                    i = (0, _getQueryFacts2.default)(e.schema, o),
                    n =
                      void 0 !== e.variables
                        ? e.variables
                        : r._storage.get("variables"),
                    s =
                      void 0 !== e.operationName
                        ? e.operationName
                        : (0, _getSelectedOperationName2.default)(
                            null,
                            r._storage.get("operationName"),
                            i && i.operations
                          );
                  return (
                    (r.state = _extends(
                      {
                        path: a,
                        schema: e.schema,
                        queriesQuantity: [0],
                        query: o,
                        variables: n,
                        operationName: s,
                        response: e.response,
                        editorFlex: Number(r._storage.get("editorFlex")) || 1,
                        variableEditorOpen: Boolean(n),
                        variableEditorHeight:
                          Number(r._storage.get("variableEditorHeight")) || 200,
                        docExplorerOpen:
                          "true" === r._storage.get("docExplorerOpen") || !1,
                        historyPaneOpen:
                          "true" === r._storage.get("historyPaneOpen") || !1,
                        docExplorerWidth:
                          Number(r._storage.get("docExplorerWidth")) ||
                          DEFAULT_DOC_EXPLORER_WIDTH,
                        isWaitingForResponse: !1,
                        subscription: null
                      },
                      i
                    )),
                    (r._editorQueryID = r.state.queriesQuantity.length - 1),
                    "object" ===
                      ("undefined" == typeof window
                        ? "undefined"
                        : _typeof(window)) &&
                      window.addEventListener("beforeunload", function() {
                        return r.componentWillUnmount();
                      }),
                    r
                  );
                }
                return (
                  (function(e, t) {
                    if ("function" != typeof t && null !== t)
                      throw new TypeError(
                        "Super expression must either be null or a function, not " +
                          typeof t
                      );
                    (e.prototype = Object.create(t && t.prototype, {
                      constructor: {
                        value: e,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                      }
                    })),
                      t &&
                        (Object.setPrototypeOf
                          ? Object.setPrototypeOf(e, t)
                          : (e.__proto__ = t));
                  })(t, _react2.default.Component),
                  _createClass(t, [
                    {
                      key: "componentDidMount",
                      value: function() {
                        void 0 === this.state.schema &&
                          (console.log(this.state.path), this._fetchSchema()),
                          (this.codeMirrorSizer = new _CodeMirrorSizer2.default()),
                          (global.g = this);
                      }
                    },
                    {
                      key: "componentWillReceiveProps",
                      value: function(e) {
                        var t = this,
                          r = this.state.schema,
                          o = this.state.query,
                          a = this.state.variables,
                          i = this.state.operationName,
                          n = this.state.response;
                        if (
                          (void 0 !== e.schema && (r = e.schema),
                          void 0 !== e.query && (o = e.query),
                          void 0 !== e.variables && (a = e.variables),
                          void 0 !== e.operationName && (i = e.operationName),
                          void 0 !== e.response && (n = e.response),
                          r !== this.state.schema ||
                            o !== this.state.query ||
                            i !== this.state.operationName)
                        ) {
                          var s = this._updateQueryFacts(
                            o,
                            i,
                            this.state.operations,
                            r
                          );
                          void 0 !== s &&
                            ((i = s.operationName), this.setState(s));
                        }
                        void 0 === e.schema &&
                          e.fetcher !== this.props.fetcher &&
                          (r = void 0),
                          this.setState(
                            {
                              schema: r,
                              query: o,
                              variables: a,
                              operationName: i,
                              response: n
                            },
                            function() {
                              void 0 === t.state.schema &&
                                (t.docExplorerComponent.reset(),
                                t._fetchSchema());
                            }
                          );
                      }
                    },
                    {
                      key: "componentDidUpdate",
                      value: function() {
                        this.codeMirrorSizer.updateSizes([
                          this.queryEditorComponent,
                          this.variableEditorComponent,
                          this.resultComponent
                        ]);
                      }
                    },
                    {
                      key: "componentWillUnmount",
                      value: function() {
                        this._storage.set("query", this.state.query),
                          this._storage.set("path", this.state.path),
                          this._storage.set("variables", this.state.variables),
                          this._storage.set(
                            "operationName",
                            this.state.operationName
                          ),
                          this._storage.set(
                            "editorFlex",
                            this.state.editorFlex
                          ),
                          this._storage.set(
                            "variableEditorHeight",
                            this.state.variableEditorHeight
                          ),
                          this._storage.set(
                            "docExplorerWidth",
                            this.state.docExplorerWidth
                          ),
                          this._storage.set(
                            "docExplorerOpen",
                            this.state.docExplorerOpen
                          ),
                          this._storage.set(
                            "historyPaneOpen",
                            this.state.historyPaneOpen
                          );
                      }
                    },
                    {
                      key: "render",
                      value: function() {
                        var e = this,
                          r = _react2.default.Children.toArray(
                            this.props.children
                          ),
                          o =
                            (0, _find2.default)(r, function(e) {
                              return e.type === t.Logo;
                            }) || _react2.default.createElement(t.Logo, null),
                          a =
                            (0, _find2.default)(r, function(e) {
                              return e.type === t.Toolbar;
                            }) ||
                            _react2.default.createElement(
                              t.Toolbar,
                              null,
                              _react2.default.createElement(
                                _ToolbarButton.ToolbarButton,
                                {
                                  onClick: this.handlePrettifyQuery,
                                  title: "Prettify Query (Shift-Ctrl-P)",
                                  label: "Prettify"
                                }
                              ),
                              _react2.default.createElement(
                                _ToolbarButton.ToolbarButton,
                                {
                                  onClick: this.handleNewQueryBox,
                                  title:
                                    "Add a new query to the execution stack",
                                  label: "Add Query"
                                }
                              ),
                              _react2.default.createElement(
                                _ToolbarButton.ToolbarButton,
                                {
                                  onClick: this.handleToggleHistory,
                                  title: "Show History",
                                  label: "History"
                                }
                              )
                            ),
                          i = (0, _find2.default)(r, function(e) {
                            return e.type === t.Footer;
                          }),
                          n = {
                            WebkitFlex: this.state.editorFlex,
                            flex: this.state.editorFlex
                          },
                          s = {
                            display: this.state.docExplorerOpen
                              ? "block"
                              : "none",
                            width: this.state.docExplorerWidth
                          },
                          l =
                            "docExplorerWrap" +
                            (this.state.docExplorerWidth < 200
                              ? " doc-explorer-narrow"
                              : ""),
                          u = {
                            display: this.state.historyPaneOpen
                              ? "block"
                              : "none",
                            width: "230px",
                            zIndex: "7"
                          },
                          c = this.state.variableEditorOpen,
                          d = {
                            height: c ? this.state.variableEditorHeight : null
                          };
                        return _react2.default.createElement(
                          "div",
                          { className: "graphiql-container" },
                          _react2.default.createElement(
                            "div",
                            { className: "historyPaneWrap", style: u },
                            _react2.default.createElement(
                              _QueryHistory.QueryHistory,
                              {
                                operationName: this.state.operationName,
                                query: this.state.query,
                                variables: this.state.variables,
                                onSelectQuery: this.handleSelectHistoryQuery,
                                storage: this._storage,
                                queryID: this._editorQueryID
                              },
                              _react2.default.createElement(
                                "div",
                                {
                                  className: "docExplorerHide",
                                  onClick: this.handleToggleHistory
                                },
                                "✕"
                              )
                            )
                          ),
                          _react2.default.createElement(
                            "div",
                            { className: "editorWrap" },
                            _react2.default.createElement(
                              "div",
                              { className: "topBarWrap" },
                              _react2.default.createElement(
                                "div",
                                { className: "topBar" },
                                o,
                                _react2.default.createElement(
                                  _ToolbarButton.ToolbarButton,
                                  {
                                    onClick: this.handleToggleDocs,
                                    title: "Show Schema Documentation",
                                    label: "Schema"
                                  }
                                )
                              )
                            ),
                            _react2.default.createElement(
                              "div",
                              { className: "topBarWrap" },
                              _react2.default.createElement(
                                "div",
                                { className: "topBar" },
                                a,
                                _react2.default.createElement(
                                  _ToolbarButton.ToolbarButton,
                                  {
                                    onClick: this.handleToggleHeaders,
                                    title: "Edit Request Headers",
                                    label: "Headers"
                                  }
                                ),
                                _react2.default.createElement(
                                  _PathEditor.PathEditor,
                                  {
                                    onEdit: this.handleEditPath,
                                    path: this.state.path
                                  }
                                ),
                                _react2.default.createElement(
                                  _ExecuteButton.ExecuteButton,
                                  {
                                    isRunning: Boolean(this.state.subscription),
                                    onRun: this.handleRunQuery,
                                    onStop: this.handleStopQuery,
                                    operations: this.state.operations
                                  }
                                )
                              )
                            ),
                            _react2.default.createElement(
                              "div",
                              {
                                ref: function(t) {
                                  e.editorBarComponent = t;
                                },
                                className: "editorBar",
                                onDoubleClick: this.handleResetResize,
                                onMouseDown: this.handleResizeStart
                              },
                              _react2.default.createElement(
                                "div",
                                { className: "queryWrap", style: n },
                                this.state.queriesQuantity.map(function(t, r) {
                                  return _react2.default.createElement(
                                    _QueryEditor.QueryEditor,
                                    {
                                      lastEditor:
                                        e.state.queriesQuantity.length - 1,
                                      key: r,
                                      editorId: r,
                                      ref: function(t) {
                                        e.queryEditorComponent = t;
                                      },
                                      schema: e.state.schema,
                                      onEdit: e.handleEditQuery,
                                      onHintInformationRender:
                                        e.handleHintInformationRender,
                                      onClickReference: e.handleClickReference,
                                      onPrettifyQuery: e.handlePrettifyQuery,
                                      onRunQuery: e.handleEditorRunQuery,
                                      editorTheme: e.props.editorTheme
                                    }
                                  );
                                }),
                                _react2.default.createElement(
                                  "div",
                                  { className: "variable-editor", style: d },
                                  _react2.default.createElement(
                                    "div",
                                    {
                                      className: "variable-editor-title",
                                      style: {
                                        cursor: c ? "row-resize" : "n-resize"
                                      },
                                      onMouseDown: this
                                        .handleVariableResizeStart
                                    },
                                    "Query Variables"
                                  ),
                                  _react2.default.createElement(
                                    _VariableEditor.VariableEditor,
                                    {
                                      ref: function(t) {
                                        e.variableEditorComponent = t;
                                      },
                                      value: this.state.variables,
                                      variableToType: this.state.variableToType,
                                      onEdit: this.handleEditVariables,
                                      onHintInformationRender: this
                                        .handleHintInformationRender,
                                      onPrettifyQuery: this.handlePrettifyQuery,
                                      onRunQuery: this.handleEditorRunQuery,
                                      editorTheme: this.props.editorTheme
                                    }
                                  )
                                )
                              ),
                              _react2.default.createElement(
                                "div",
                                { className: "resultWrap" },
                                this.state.isWaitingForResponse &&
                                  _react2.default.createElement(
                                    "div",
                                    { className: "spinner-container" },
                                    _react2.default.createElement("div", {
                                      className: "spinner"
                                    })
                                  ),
                                _react2.default.createElement(
                                  _ResultViewer.ResultViewer,
                                  {
                                    ref: function(t) {
                                      e.resultComponent = t;
                                    },
                                    value: this.state.response,
                                    editorTheme: this.props.editorTheme,
                                    ResultsTooltip: this.props.ResultsTooltip
                                  }
                                ),
                                i
                              )
                            )
                          ),
                          _react2.default.createElement(
                            "div",
                            { className: l, style: s },
                            _react2.default.createElement("div", {
                              className: "docExplorerResizer",
                              onDoubleClick: this.handleDocsResetResize,
                              onMouseDown: this.handleDocsResizeStart
                            }),
                            _react2.default.createElement(
                              _DocExplorer.DocExplorer,
                              {
                                ref: function(t) {
                                  e.docExplorerComponent = t;
                                },
                                schema: this.state.schema
                              },
                              _react2.default.createElement(
                                "div",
                                {
                                  className: "docExplorerHide",
                                  onClick: this.handleToggleDocs
                                },
                                "✕"
                              )
                            )
                          )
                        );
                      }
                    },
                    {
                      key: "getQueryEditor",
                      value: function() {
                        return this.queryEditorComponent.getCodeMirror();
                      }
                    },
                    {
                      key: "getVariableEditor",
                      value: function() {
                        return this.variableEditorComponent.getCodeMirror();
                      }
                    },
                    {
                      key: "refresh",
                      value: function() {
                        this.queryEditorComponent.getCodeMirror().refresh(),
                          this.variableEditorComponent
                            .getCodeMirror()
                            .refresh(),
                          this.resultComponent.getCodeMirror().refresh();
                      }
                    },
                    {
                      key: "autoCompleteLeafs",
                      value: function() {
                        var e = (0, _fillLeafs2.fillLeafs)(
                            this.state.schema,
                            this.state.query,
                            this.props.getDefaultFieldNames
                          ),
                          t = e.insertions,
                          r = e.result;
                        if (t && 0 < t.length) {
                          var o = this.getQueryEditor();
                          o.operation(function() {
                            var e = o.getCursor(),
                              a = o.indexFromPos(e);
                            o.setValue(r);
                            var i = 0,
                              n = t.map(function(e) {
                                var t = e.index,
                                  r = e.string;
                                return o.markText(
                                  o.posFromIndex(t + i),
                                  o.posFromIndex(t + (i += r.length)),
                                  {
                                    className: "autoInsertedLeaf",
                                    clearOnEnter: !0,
                                    title: "Automatically added leaf fields"
                                  }
                                );
                              });
                            setTimeout(function() {
                              return n.forEach(function(e) {
                                return e.clear();
                              });
                            }, 7e3);
                            var s = a;
                            t.forEach(function(e) {
                              var t = e.index,
                                r = e.string;
                              t < a && (s += r.length);
                            }),
                              o.setCursor(o.posFromIndex(s));
                          });
                        }
                        return r;
                      }
                    },
                    {
                      key: "_fetchSchema",
                      value: function() {
                        var e = this,
                          t = this.props.fetcher,
                          r = this.state.path,
                          o = observableToPromise(
                            t(
                              {
                                query: _introspectionQueries.introspectionQuery
                              },
                              r
                            )
                          );
                        isPromise(o)
                          ? o
                              .then(function(e) {
                                if (e.data) return e;
                                var a = observableToPromise(
                                  t(
                                    {
                                      query:
                                        _introspectionQueries.introspectionQuerySansSubscriptions
                                    },
                                    r
                                  )
                                );
                                if (!isPromise(o))
                                  throw new Error(
                                    "Fetcher did not return a Promise for introspection."
                                  );
                                return a;
                              })
                              .then(function(t) {
                                if (
                                  void 0 === e.state.schema ||
                                  null === e.state.schema
                                )
                                  if (t && t.data) {
                                    var r = (0, _graphql.buildClientSchema)(
                                        t.data
                                      ),
                                      o = (0, _getQueryFacts2.default)(
                                        r,
                                        e.state.query
                                      );
                                    e.setState(_extends({ schema: r }, o));
                                  } else {
                                    var a =
                                      "string" == typeof t
                                        ? t
                                        : JSON.stringify(t, null, 2);
                                    e.setState({ schema: null, response: a });
                                  }
                              })
                              .catch(function(t) {
                                e.setState({
                                  schema: null,
                                  response: t && String(t.stack || t)
                                });
                              })
                          : this.setState({
                              response:
                                "Fetcher did not return a Promise for introspection."
                            });
                      }
                    },
                    {
                      key: "_fetchQuery",
                      value: function(e, t, r, o) {
                        var a = this,
                          i = this.props.fetcher,
                          n = this.state.path,
                          s = null;
                        try {
                          s = t && "" !== t.trim() ? JSON.parse(t) : null;
                        } catch (e) {
                          throw new Error(
                            "Variables are invalid JSON: " + e.message + "."
                          );
                        }
                        if (
                          "object" !== (void 0 === s ? "undefined" : _typeof(s))
                        )
                          throw new Error("Variables are not a JSON object.");
                        var l = i(
                          { query: e, variables: s, operationName: r },
                          n
                        );
                        if (!isPromise(l)) {
                          if (isObservable(l))
                            return l.subscribe({
                              next: o,
                              error: function(e) {
                                a.setState({
                                  isWaitingForResponse: !1,
                                  response: e && String(e.stack || e),
                                  subscription: null
                                });
                              },
                              complete: function() {
                                a.setState({
                                  isWaitingForResponse: !1,
                                  subscription: null
                                });
                              }
                            });
                          throw new Error(
                            "Fetcher did not return Promise or Observable."
                          );
                        }
                        l.then(o).catch(function(e) {
                          a.setState({
                            isWaitingForResponse: !1,
                            response: e && String(e.stack || e)
                          });
                        });
                      }
                    },
                    {
                      key: "_runQueryAtCursor",
                      value: function() {
                        if (this.state.subscription) this.handleStopQuery();
                        else {
                          var e = void 0,
                            t = this.state.operations;
                          if (t) {
                            var r = this.getQueryEditor();
                            if (r.hasFocus())
                              for (
                                var o = r.getCursor(),
                                  a = r.indexFromPos(o),
                                  i = 0;
                                i < t.length;
                                i++
                              ) {
                                var n = t[i];
                                if (n.loc.start <= a && n.loc.end >= a) {
                                  e = n.name && n.name.value;
                                  break;
                                }
                              }
                          }
                          this.handleRunQuery(e);
                        }
                      }
                    },
                    {
                      key: "_didClickDragBar",
                      value: function(e) {
                        if (0 !== e.button || e.ctrlKey) return !1;
                        var t = e.target;
                        if (0 !== t.className.indexOf("CodeMirror-gutter"))
                          return !1;
                        for (
                          var r = _reactDom2.default.findDOMNode(
                            this.resultComponent
                          );
                          t;

                        ) {
                          if (t === r) return !0;
                          t = t.parentNode;
                        }
                        return !1;
                      }
                    }
                  ]),
                  t
                );
              })());
            GraphiQL.propTypes = {
              queriesQuantity: _propTypes2.default.array,
              fetcher: _propTypes2.default.func.isRequired,
              schema: _propTypes2.default.instanceOf(_graphql.GraphQLSchema),
              query: _propTypes2.default.string,
              variables: _propTypes2.default.string,
              operationName: _propTypes2.default.string,
              response: _propTypes2.default.string,
              storage: _propTypes2.default.shape({
                getItem: _propTypes2.default.func,
                setItem: _propTypes2.default.func,
                removeItem: _propTypes2.default.func
              }),
              defaultPath: _propTypes2.default.string,
              defaultQuery: _propTypes2.default.string,
              onEditQuery: _propTypes2.default.func,
              onEditVariables: _propTypes2.default.func,
              onEditOperationName: _propTypes2.default.func,
              onToggleDocs: _propTypes2.default.func,
              getDefaultFieldNames: _propTypes2.default.func,
              editorTheme: _propTypes2.default.string,
              onToggleHistory: _propTypes2.default.func,
              ResultsTooltip: _propTypes2.default.any
            };
            var _initialiseProps = function() {
              var e = this;
              (this.handleClickReference = function(t) {
                e.setState({ docExplorerOpen: !0 }, function() {
                  e.docExplorerComponent.showDocForReference(t);
                });
              }),
                (this.handleEditPath = (0, _debounce2.default)(100, function(
                  t
                ) {
                  e.setState({ path: t }, function() {
                    e.docExplorerComponent.reset(), e._fetchSchema();
                  });
                })),
                (this.handleRunQuery = function(t) {
                  e._editorQueryID++;
                  var r = e._editorQueryID,
                    o = (e.state.path, e.autoCompleteLeafs() || e.state.query),
                    a = e.state.variables,
                    i = e.state.operationName;
                  t && t !== i && ((i = t), e.handleEditOperationName(i));
                  try {
                    e.setState({
                      isWaitingForResponse: !0,
                      response: null,
                      operationName: i
                    });
                    var n = e._fetchQuery(o, a, i, function(t) {
                      r === e._editorQueryID &&
                        e.setState({
                          isWaitingForResponse: !1,
                          response: JSON.stringify(t, null, 2)
                        });
                    });
                    e.setState({ subscription: n });
                  } catch (t) {
                    e.setState({
                      isWaitingForResponse: !1,
                      response: t.message
                    });
                  }
                }),
                (this.handleStopQuery = function() {
                  var t = e.state.subscription;
                  e.setState({ isWaitingForResponse: !1, subscription: null }),
                    t && t.unsubscribe();
                }),
                (this.handleNewQueryBox = function() {
                  e._editorQueryID = e.state.queriesQuantity.length;
                  var t = [].concat(
                    (function(e) {
                      if (Array.isArray(e)) {
                        for (var t = 0, r = Array(e.length); t < e.length; t++)
                          r[t] = e[t];
                        return r;
                      }
                      return Array.from(e);
                    })(e.state.queriesQuantity)
                  );
                  t.push(t.length), e.setState({ queriesQuantity: t });
                }),
                (this.handlePrettifyQuery = function() {
                  var t = e.getQueryEditor();
                  t.setValue(
                    (0, _graphql.print)((0, _graphql.parse)(t.getValue()))
                  );
                }),
                (this.handleEditQuery = (0, _debounce2.default)(100, function(
                  t
                ) {
                  var r = e._updateQueryFacts(
                    t,
                    e.state.operationName,
                    e.state.operations,
                    e.state.schema
                  );
                  if (
                    (e.setState(_extends({ query: t }, r)), e.props.onEditQuery)
                  )
                    return e.props.onEditQuery(t);
                })),
                (this._updateQueryFacts = function(t, r, o, a) {
                  var i = (0, _getQueryFacts2.default)(a, t);
                  if (i) {
                    var n = (0, _getSelectedOperationName2.default)(
                        o,
                        r,
                        i.operations
                      ),
                      s = e.props.onEditOperationName;
                    return (
                      s && r !== n && s(n), _extends({ operationName: n }, i)
                    );
                  }
                }),
                (this.handleEditVariables = function(t) {
                  e.setState({ variables: t }),
                    e.props.onEditVariables && e.props.onEditVariables(t);
                }),
                (this.handleEditOperationName = function(t) {
                  var r = e.props.onEditOperationName;
                  r && r(t);
                }),
                (this.handleHintInformationRender = function(t) {
                  t.addEventListener("click", e._onClickHintInformation);
                  var r = void 0;
                  t.addEventListener(
                    "DOMNodeRemoved",
                    (r = function() {
                      t.removeEventListener("DOMNodeRemoved", r),
                        t.removeEventListener(
                          "click",
                          e._onClickHintInformation
                        );
                    })
                  );
                }),
                (this.handleEditorRunQuery = function() {
                  e._runQueryAtCursor();
                }),
                (this._onClickHintInformation = function(t) {
                  if ("typeName" === t.target.className) {
                    var r = t.target.innerHTML,
                      o = e.state.schema;
                    if (o) {
                      var a = o.getType(r);
                      a &&
                        e.setState({ docExplorerOpen: !0 }, function() {
                          e.docExplorerComponent.showDoc(a);
                        });
                    }
                  }
                }),
                (this.handleToggleDocs = function() {
                  "function" == typeof e.props.onToggleDocs &&
                    e.props.onToggleDocs(!e.state.docExplorerOpen),
                    e.setState({ docExplorerOpen: !e.state.docExplorerOpen });
                }),
                (this.handleToggleHistory = function() {
                  "function" == typeof e.props.onToggleHistory &&
                    e.props.onToggleHistory(!e.state.historyPaneOpen),
                    e.setState({ historyPaneOpen: !e.state.historyPaneOpen });
                }),
                (this.handleSelectHistoryQuery = function(t, r, o) {
                  e.handleEditQuery(t),
                    e.handleEditVariables(r),
                    e.handleEditOperationName(o);
                }),
                (this.handleResizeStart = function(t) {
                  if (e._didClickDragBar(t)) {
                    t.preventDefault();
                    var r = t.clientX - (0, _elementPosition.getLeft)(t.target),
                      o = function(t) {
                        if (0 === t.buttons) return a();
                        var o = _reactDom2.default.findDOMNode(
                            e.editorBarComponent
                          ),
                          i = t.clientX - (0, _elementPosition.getLeft)(o) - r,
                          n = o.clientWidth - i;
                        e.setState({ editorFlex: i / n });
                      },
                      a = (function(e) {
                        function t() {
                          return e.apply(this, arguments);
                        }
                        return (
                          (t.toString = function() {
                            return e.toString();
                          }),
                          t
                        );
                      })(function() {
                        document.removeEventListener("mousemove", o),
                          document.removeEventListener("mouseup", a),
                          (a = o = null);
                      });
                    document.addEventListener("mousemove", o),
                      document.addEventListener("mouseup", a);
                  }
                }),
                (this.handleResetResize = function() {
                  e.setState({ editorFlex: 1 });
                }),
                (this.handleDocsResizeStart = function(t) {
                  t.preventDefault();
                  var r = e.state.docExplorerWidth,
                    o = t.clientX - (0, _elementPosition.getLeft)(t.target),
                    a = function(t) {
                      if (0 === t.buttons) return i();
                      var r = _reactDom2.default.findDOMNode(e),
                        a = t.clientX - (0, _elementPosition.getLeft)(r) - o,
                        n = r.clientWidth - a;
                      n < 100
                        ? e.setState({ docExplorerOpen: !1 })
                        : e.setState({
                            docExplorerOpen: !0,
                            docExplorerWidth: Math.min(n, 650)
                          });
                    },
                    i = (function(e) {
                      function t() {
                        return e.apply(this, arguments);
                      }
                      return (
                        (t.toString = function() {
                          return e.toString();
                        }),
                        t
                      );
                    })(function() {
                      e.state.docExplorerOpen ||
                        e.setState({ docExplorerWidth: r }),
                        document.removeEventListener("mousemove", a),
                        document.removeEventListener("mouseup", i),
                        (i = a = null);
                    });
                  document.addEventListener("mousemove", a),
                    document.addEventListener("mouseup", i);
                }),
                (this.handleDocsResetResize = function() {
                  e.setState({ docExplorerWidth: DEFAULT_DOC_EXPLORER_WIDTH });
                }),
                (this.handleVariableResizeStart = function(t) {
                  t.preventDefault();
                  var r = !1,
                    o = e.state.variableEditorOpen,
                    a = e.state.variableEditorHeight,
                    i = t.clientY - (0, _elementPosition.getTop)(t.target),
                    n = function(t) {
                      if (0 === t.buttons) return s();
                      r = !0;
                      var o = _reactDom2.default.findDOMNode(
                          e.editorBarComponent
                        ),
                        n = t.clientY - (0, _elementPosition.getTop)(o) - i,
                        l = o.clientHeight - n;
                      l < 60
                        ? e.setState({
                            variableEditorOpen: !1,
                            variableEditorHeight: a
                          })
                        : e.setState({
                            variableEditorOpen: !0,
                            variableEditorHeight: l
                          });
                    },
                    s = (function(e) {
                      function t() {
                        return e.apply(this, arguments);
                      }
                      return (
                        (t.toString = function() {
                          return e.toString();
                        }),
                        t
                      );
                    })(function() {
                      r || e.setState({ variableEditorOpen: !o }),
                        document.removeEventListener("mousemove", n),
                        document.removeEventListener("mouseup", s),
                        (s = n = null);
                    });
                  document.addEventListener("mousemove", n),
                    document.addEventListener("mouseup", s);
                });
            };
            (GraphiQL.Logo = function(e) {
              return _react2.default.createElement(
                "div",
                { className: "title" },
                e.children ||
                  _react2.default.createElement(
                    "span",
                    null,
                    "Super Graph",
                    _react2.default.createElement("em", null, "i"),
                    "QL"
                  )
              );
            }),
              (GraphiQL.Toolbar = function(e) {
                return _react2.default.createElement(
                  "div",
                  { className: "toolbar" },
                  e.children
                );
              }),
              (GraphiQL.QueryEditor = _QueryEditor.QueryEditor),
              (GraphiQL.VariableEditor = _VariableEditor.VariableEditor),
              (GraphiQL.ResultViewer = _ResultViewer.ResultViewer),
              (GraphiQL.Button = _ToolbarButton.ToolbarButton),
              (GraphiQL.ToolbarButton = _ToolbarButton.ToolbarButton),
              (GraphiQL.Group = _ToolbarGroup.ToolbarGroup),
              (GraphiQL.Menu = _ToolbarMenu.ToolbarMenu),
              (GraphiQL.MenuItem = _ToolbarMenu.ToolbarMenuItem),
              (GraphiQL.Select = _ToolbarSelect.ToolbarSelect),
              (GraphiQL.SelectOption = _ToolbarSelect.ToolbarSelectOption),
              (GraphiQL.Footer = function(e) {
                return _react2.default.createElement(
                  "div",
                  { className: "footer" },
                  e.children
                );
              });
            var defaultQuery =
                '# Welcome to GraphiQL\n#\n# GraphiQL is an in-browser tool for writing, validating, and\n# testing GraphQL queries.\n#\n# Type queries into this side of the screen, and you will see intelligent\n# typeaheads aware of the current GraphQL type schema and live syntax and\n# validation errors highlighted within the text.\n#\n# GraphQL queries typically start with a "{" character. Lines that starts\n# with a # are ignored.\n#\n# An example GraphQL query might look like:\n#\n#     {\n#       field(arg: "value") {\n#         subField\n#       }\n#     }\n#\n# Keyboard shortcuts:\n#\n#  Prettify Query:  Shift-Ctrl-P (or press the prettify button above)\n#\n#       Run Query:  Ctrl-Enter (or press the play button above)\n#\n#   Auto Complete:  Ctrl-Space (or just start typing)\n#\n\n',
              defaultPath = "/graphql";
            function isPromise(e) {
              return (
                "object" === (void 0 === e ? "undefined" : _typeof(e)) &&
                "function" == typeof e.then
              );
            }
            function observableToPromise(e) {
              return isObservable(e)
                ? new Promise(function(t, r) {
                    var o = e.subscribe(
                      function(e) {
                        t(e), o.unsubscribe();
                      },
                      r,
                      function() {
                        r(new Error("no value resolved"));
                      }
                    );
                  })
                : e;
            }
            function isObservable(e) {
              return (
                "object" === (void 0 === e ? "undefined" : _typeof(e)) &&
                "function" == typeof e.subscribe
              );
            }
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        {
          "../utility/CodeMirrorSizer": 24,
          "../utility/StorageAPI": 26,
          "../utility/debounce": 27,
          "../utility/elementPosition": 28,
          "../utility/fillLeafs": 29,
          "../utility/find": 30,
          "../utility/getQueryFacts": 31,
          "../utility/getSelectedOperationName": 32,
          "../utility/introspectionQueries": 33,
          "./DocExplorer": 1,
          "./ExecuteButton": 11,
          "./PathEditor": 14,
          "./QueryEditor": 15,
          "./QueryHistory": 16,
          "./ResultViewer": 17,
          "./ToolbarButton": 18,
          "./ToolbarGroup": 19,
          "./ToolbarMenu": 20,
          "./ToolbarSelect": 21,
          "./VariableEditor": 22,
          graphql: 101,
          "prop-types": 239
        }
      ],
      13: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 });
            var _createClass = (function() {
                function e(e, t) {
                  for (var r = 0; r < t.length; r++) {
                    var i = t[r];
                    (i.enumerable = i.enumerable || !1),
                      (i.configurable = !0),
                      "value" in i && (i.writable = !0),
                      Object.defineProperty(e, i.key, i);
                  }
                }
                return function(t, r, i) {
                  return r && e(t.prototype, r), i && e(t, i), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types"));
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            var HistoryQuery = (function(e) {
              function t(e) {
                !(function(e, t) {
                  if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function");
                })(this, t);
                var r = (function(e, t) {
                    if (!e)
                      throw new ReferenceError(
                        "this hasn't been initialised - super() hasn't been called"
                      );
                    return !t ||
                      ("object" != typeof t && "function" != typeof t)
                      ? e
                      : t;
                  })(
                    this,
                    (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)
                  ),
                  i = r.props.favorite ? "visible" : "hidden";
                return (r.state = { starVisibility: i }), r;
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "render",
                    value: function() {
                      this.props.favorite &&
                        "hidden" === this.state.starVisibility &&
                        this.setState({ starVisibility: "visible" });
                      var e = {
                          float: "right",
                          visibility: this.state.starVisibility
                        },
                        t =
                          this.props.operationName ||
                          this.props.query
                            .split("\n")
                            .filter(function(e) {
                              return 0 !== e.indexOf("#");
                            })
                            .join(""),
                        r = this.props.favorite ? "★" : "☆";
                      return _react2.default.createElement(
                        "p",
                        {
                          onClick: this.handleClick.bind(this),
                          onMouseEnter: this.handleMouseEnter.bind(this),
                          onMouseLeave: this.handleMouseLeave.bind(this)
                        },
                        _react2.default.createElement("span", null, t),
                        _react2.default.createElement(
                          "span",
                          {
                            onClick: this.handleStarClick.bind(this),
                            style: e
                          },
                          r
                        )
                      );
                    }
                  },
                  {
                    key: "handleMouseEnter",
                    value: function() {
                      this.props.favorite ||
                        this.setState({ starVisibility: "visible" });
                    }
                  },
                  {
                    key: "handleMouseLeave",
                    value: function() {
                      this.props.favorite ||
                        this.setState({ starVisibility: "hidden" });
                    }
                  },
                  {
                    key: "handleClick",
                    value: function() {
                      this.props.onSelect(
                        this.props.query,
                        this.props.variables,
                        this.props.operationName
                      );
                    }
                  },
                  {
                    key: "handleStarClick",
                    value: function(e) {
                      e.stopPropagation(),
                        this.props.handleToggleFavorite(
                          this.props.query,
                          this.props.variables,
                          this.props.operationName,
                          this.props.favorite
                        );
                    }
                  }
                ]),
                t
              );
            })();
            (HistoryQuery.propTypes = {
              favorite: _propTypes2.default.bool,
              favoriteSize: _propTypes2.default.number,
              handleToggleFavorite: _propTypes2.default.func,
              operationName: _propTypes2.default.string,
              onSelect: _propTypes2.default.func,
              query: _propTypes2.default.string,
              variables: _propTypes2.default.string
            }),
              (exports.default = HistoryQuery);
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { "prop-types": 239 }
      ],
      14: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.PathEditor = void 0);
            var _createClass = (function() {
                function e(e, t) {
                  for (var r = 0; r < t.length; r++) {
                    var o = t[r];
                    (o.enumerable = o.enumerable || !1),
                      (o.configurable = !0),
                      "value" in o && (o.writable = !0),
                      Object.defineProperty(e, o.key, o);
                  }
                }
                return function(t, r, o) {
                  return r && e(t.prototype, r), o && e(t, o), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types"));
            require("graphql"),
              _interopRequireDefault(require("markdown-it")),
              require("../utility/normalizeWhitespace"),
              _interopRequireDefault(require("../utility/onHasCompletion"));
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            (exports.PathEditor = (function(e) {
              function t(e) {
                return (
                  (function(e, t) {
                    if (!(e instanceof t))
                      throw new TypeError("Cannot call a class as a function");
                  })(this, t),
                  (function(e, t) {
                    if (!e)
                      throw new ReferenceError(
                        "this hasn't been initialised - super() hasn't been called"
                      );
                    return !t ||
                      ("object" != typeof t && "function" != typeof t)
                      ? e
                      : t;
                  })(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this))
                );
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "render",
                    value: function() {
                      var e = this;
                      return _react2.default.createElement(
                        "div",
                        { className: "path-editor" },
                        "Path:",
                        _react2.default.createElement("input", {
                          className: "path-input",
                          defaultValue: this.props.path,
                          onChange: function(t) {
                            e.props.onEdit(t.target.value);
                          },
                          placeholder: "Enter server routes here"
                        })
                      );
                    }
                  }
                ]),
                t
              );
            })()).propTypes = {
              path: _propTypes2.default.string,
              onEdit: _propTypes2.default.func
            };
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        {
          "../utility/normalizeWhitespace": 34,
          "../utility/onHasCompletion": 35,
          graphql: 101,
          "markdown-it": 178,
          "prop-types": 239
        }
      ],
      15: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.QueryEditor = void 0);
            var _createClass = (function() {
                function e(e, r) {
                  for (var t = 0; t < r.length; t++) {
                    var o = r[t];
                    (o.enumerable = o.enumerable || !1),
                      (o.configurable = !0),
                      "value" in o && (o.writable = !0),
                      Object.defineProperty(e, o.key, o);
                  }
                }
                return function(r, t, o) {
                  return t && e(r.prototype, t), o && e(r, o), r;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _graphql = require("graphql"),
              _markdownIt2 = _interopRequireDefault(require("markdown-it")),
              _normalizeWhitespace = require("../utility/normalizeWhitespace"),
              _onHasCompletion2 = _interopRequireDefault(
                require("../utility/onHasCompletion")
              );
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            var md = new _markdownIt2.default(),
              AUTO_COMPLETE_AFTER_KEY = /^[a-zA-Z0-9_@(]$/;
            (exports.QueryEditor = (function(e) {
              function r(e) {
                !(function(e, r) {
                  if (!(e instanceof r))
                    throw new TypeError("Cannot call a class as a function");
                })(this, r);
                var t = (function(e, r) {
                  if (!e)
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  return !r || ("object" != typeof r && "function" != typeof r)
                    ? e
                    : r;
                })(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this));
                return (
                  (t._onKeyUp = function(e, r) {
                    AUTO_COMPLETE_AFTER_KEY.test(r.key) &&
                      t.editor.execCommand("autocomplete");
                  }),
                  (t._onEdit = function() {
                    t.ignoreChangeEvent ||
                      ((t.cachedValue = t.editor.getValue()),
                      t.props.onEdit && t.props.onEdit(t.cachedValue));
                  }),
                  (t._onHasCompletion = function(e, r) {
                    (0, _onHasCompletion2.default)(
                      e,
                      r,
                      t.props.onHintInformationRender
                    );
                  }),
                  (t.cachedValue = e.value || ""),
                  t
                );
              }
              return (
                (function(e, r) {
                  if ("function" != typeof r && null !== r)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof r
                    );
                  (e.prototype = Object.create(r && r.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    r &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, r)
                        : (e.__proto__ = r));
                })(r, _react2.default.Component),
                _createClass(r, [
                  {
                    key: "componentDidMount",
                    value: function() {
                      var e = this,
                        r = require("codemirror");
                      require("codemirror/addon/hint/show-hint"),
                        require("codemirror/addon/comment/comment"),
                        require("codemirror/addon/edit/matchbrackets"),
                        require("codemirror/addon/edit/closebrackets"),
                        require("codemirror/addon/fold/foldgutter"),
                        require("codemirror/addon/fold/brace-fold"),
                        require("codemirror/addon/search/search"),
                        require("codemirror/addon/search/searchcursor"),
                        require("codemirror/addon/search/jump-to-line"),
                        require("codemirror/addon/dialog/dialog"),
                        require("codemirror/addon/lint/lint"),
                        require("codemirror/keymap/sublime"),
                        require("codemirror-graphql/hint"),
                        require("codemirror-graphql/lint"),
                        require("codemirror-graphql/info"),
                        require("codemirror-graphql/jump"),
                        require("codemirror-graphql/mode"),
                        (this.editor = r(this._node, {
                          value: "",
                          lineNumbers: !0,
                          tabSize: 2,
                          mode: "graphql",
                          theme: this.props.editorTheme || "graphiql",
                          keyMap: "sublime",
                          autoCloseBrackets: !0,
                          matchBrackets: !0,
                          showCursorWhenSelecting: !0,
                          readOnly: !!this.props.readOnly && "nocursor",
                          foldGutter: { minFoldSize: 4 },
                          lint: { schema: this.props.schema },
                          hintOptions: {
                            schema: this.props.schema,
                            closeOnUnfocus: !1,
                            completeSingle: !1
                          },
                          info: {
                            schema: this.props.schema,
                            renderDescription: function(e) {
                              return md.render(e);
                            },
                            onClick: function(r) {
                              return e.props.onClickReference(r);
                            }
                          },
                          jump: {
                            schema: this.props.schema,
                            onClick: function(r) {
                              return e.props.onClickReference(r);
                            }
                          },
                          gutters: [
                            "CodeMirror-linenumbers",
                            "CodeMirror-foldgutter"
                          ],
                          extraKeys: {
                            "Cmd-Space": function() {
                              return e.editor.showHint({ completeSingle: !0 });
                            },
                            "Ctrl-Space": function() {
                              return e.editor.showHint({ completeSingle: !0 });
                            },
                            "Alt-Space": function() {
                              return e.editor.showHint({ completeSingle: !0 });
                            },
                            "Shift-Space": function() {
                              return e.editor.showHint({ completeSingle: !0 });
                            },
                            "Cmd-Enter": function() {
                              e.props.onRunQuery && e.props.onRunQuery();
                            },
                            "Ctrl-Enter": function() {
                              e.props.onRunQuery && e.props.onRunQuery();
                            },
                            "Shift-Ctrl-P": function() {
                              e.props.onPrettifyQuery &&
                                e.props.onPrettifyQuery();
                            },
                            "Cmd-F": "findPersistent",
                            "Ctrl-F": "findPersistent",
                            "Ctrl-Left": "goSubwordLeft",
                            "Ctrl-Right": "goSubwordRight",
                            "Alt-Left": "goGroupLeft",
                            "Alt-Right": "goGroupRight"
                          }
                        })),
                        this.editor.on("change", this._onEdit),
                        this.editor.on("keyup", this._onKeyUp),
                        this.editor.on("hasCompletion", this._onHasCompletion),
                        this.editor.on("beforeChange", this._onBeforeChange),
                        this.editor.on("cursorActivity", this._onEdit),
                        (this.textAreas = document.getElementsByTagName(
                          "textarea"
                        )),
                        void 0 !== this.textAreas[this.props.editorId] &&
                          this.textAreas[this.props.editorId].focus();
                    }
                  },
                  {
                    key: "componentDidUpdate",
                    value: function(e) {
                      var r = require("codemirror");
                      (this.ignoreChangeEvent = !0),
                        this.props.schema !== e.schema &&
                          ((this.editor.options.lint.schema = this.props.schema),
                          (this.editor.options.hintOptions.schema = this.props.schema),
                          (this.editor.options.info.schema = this.props.schema),
                          (this.editor.options.jump.schema = this.props.schema),
                          r.signal(this.editor, "change", this.editor)),
                        this.props.value !== e.value &&
                          this.props.value !== this.cachedValue &&
                          ((this.cachedValue = this.props.value),
                          this.editor.setValue(this.props.value)),
                        (this.ignoreChangeEvent = !1);
                    }
                  },
                  {
                    key: "componentWillUnmount",
                    value: function() {
                      this.editor.off("change", this._onEdit),
                        this.editor.off("keyup", this._onKeyUp),
                        this.editor.off("hasCompletion", this._onHasCompletion),
                        (this.editor = null);
                    }
                  },
                  {
                    key: "render",
                    value: function() {
                      var e = this;
                      return _react2.default.createElement("div", {
                        className: "query-editor",
                        id: this.props.editorId,
                        ref: function(r) {
                          e._node = r;
                        }
                      });
                    }
                  },
                  {
                    key: "getCodeMirror",
                    value: function() {
                      return this.editor;
                    }
                  },
                  {
                    key: "getClientHeight",
                    value: function() {
                      return this._node && this._node.clientHeight;
                    }
                  },
                  {
                    key: "_onBeforeChange",
                    value: function(e, r) {
                      if ("paste" === r.origin) {
                        var t = r.text.map(
                          _normalizeWhitespace.normalizeWhitespace
                        );
                        r.update(r.from, r.to, t);
                      }
                    }
                  }
                ]),
                r
              );
            })()).propTypes = {
              schema: _propTypes2.default.instanceOf(_graphql.GraphQLSchema),
              editorId: _propTypes2.default.number,
              value: _propTypes2.default.string,
              onEdit: _propTypes2.default.func,
              readOnly: _propTypes2.default.bool,
              onHintInformationRender: _propTypes2.default.func,
              onClickReference: _propTypes2.default.func,
              onPrettifyQuery: _propTypes2.default.func,
              onRunQuery: _propTypes2.default.func,
              editorTheme: _propTypes2.default.string
            };
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        {
          "../utility/normalizeWhitespace": 34,
          "../utility/onHasCompletion": 35,
          codemirror: 66,
          "codemirror-graphql/hint": 37,
          "codemirror-graphql/info": 38,
          "codemirror-graphql/jump": 39,
          "codemirror-graphql/lint": 40,
          "codemirror-graphql/mode": 41,
          "codemirror/addon/comment/comment": 53,
          "codemirror/addon/dialog/dialog": 54,
          "codemirror/addon/edit/closebrackets": 55,
          "codemirror/addon/edit/matchbrackets": 56,
          "codemirror/addon/fold/brace-fold": 57,
          "codemirror/addon/fold/foldgutter": 59,
          "codemirror/addon/hint/show-hint": 60,
          "codemirror/addon/lint/lint": 61,
          "codemirror/addon/search/jump-to-line": 62,
          "codemirror/addon/search/search": 63,
          "codemirror/addon/search/searchcursor": 64,
          "codemirror/keymap/sublime": 65,
          graphql: 101,
          "markdown-it": 178,
          "prop-types": 239
        }
      ],
      16: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.QueryHistory = void 0);
            var _extends =
                Object.assign ||
                function(e) {
                  for (var t = 1; t < arguments.length; t++) {
                    var r = arguments[t];
                    for (var o in r)
                      Object.prototype.hasOwnProperty.call(r, o) &&
                        (e[o] = r[o]);
                  }
                  return e;
                },
              _createClass = (function() {
                function e(e, t) {
                  for (var r = 0; r < t.length; r++) {
                    var o = t[r];
                    (o.enumerable = o.enumerable || !1),
                      (o.configurable = !0),
                      "value" in o && (o.writable = !0),
                      Object.defineProperty(e, o.key, o);
                  }
                }
                return function(t, r, o) {
                  return r && e(t.prototype, r), o && e(t, o), t;
                };
              })(),
              _graphql = require("graphql"),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _QueryStore2 = _interopRequireDefault(
                require("../utility/QueryStore")
              ),
              _HistoryQuery2 = _interopRequireDefault(
                require("./HistoryQuery")
              );
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            (exports.QueryHistory = (function(e) {
              function t(e) {
                !(function(e, t) {
                  if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function");
                })(this, t);
                var r = (function(e, t) {
                  if (!e)
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  return !t || ("object" != typeof t && "function" != typeof t)
                    ? e
                    : t;
                })(
                  this,
                  (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)
                );
                _initialiseProps.call(r),
                  (r.historyStore = new _QueryStore2.default(
                    "queries",
                    e.storage
                  )),
                  (r.favoriteStore = new _QueryStore2.default(
                    "favorites",
                    e.storage
                  ));
                var o = r.historyStore.fetchAll(),
                  i = r.favoriteStore.fetchAll(),
                  a = o.concat(i);
                return (r.state = { queries: a }), r;
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "componentWillReceiveProps",
                    value: function(e) {
                      if (
                        (function(e, t, r) {
                          if (e.queryID === t.queryID) return !1;
                          try {
                            (0, _graphql.parse)(e.query);
                          } catch (e) {
                            return !1;
                          }
                          if (!r) return !0;
                          if (
                            JSON.stringify(e.query) === JSON.stringify(r.query)
                          ) {
                            if (
                              JSON.stringify(e.variables) ===
                              JSON.stringify(r.variables)
                            )
                              return !1;
                            if (!e.variables && !r.variables) return !1;
                          }
                          return !0;
                        })(e, this.props, this.historyStore.fetchRecent())
                      ) {
                        var t = {
                          query: e.query,
                          variables: e.variables,
                          operationName: e.operationName
                        };
                        this.historyStore.push(t),
                          20 < this.historyStore.length &&
                            this.historyStore.shift();
                        var r = this.historyStore.items,
                          o = this.favoriteStore.items,
                          i = r.concat(o);
                        this.setState({ queries: i });
                      }
                    }
                  },
                  {
                    key: "render",
                    value: function() {
                      var e = this,
                        t = this.state.queries
                          .slice()
                          .reverse()
                          .map(function(t, r) {
                            return _react2.default.createElement(
                              _HistoryQuery2.default,
                              _extends(
                                {
                                  handleToggleFavorite: e.toggleFavorite,
                                  key: r,
                                  onSelect: e.props.onSelectQuery
                                },
                                t
                              )
                            );
                          });
                      return _react2.default.createElement(
                        "div",
                        null,
                        _react2.default.createElement(
                          "div",
                          { className: "history-title-bar" },
                          _react2.default.createElement(
                            "div",
                            { className: "history-title" },
                            "History"
                          ),
                          _react2.default.createElement(
                            "div",
                            { className: "doc-explorer-rhs" },
                            this.props.children
                          )
                        ),
                        _react2.default.createElement(
                          "div",
                          { className: "history-contents" },
                          t
                        )
                      );
                    }
                  }
                ]),
                t
              );
            })()).propTypes = {
              query: _propTypes2.default.string,
              variables: _propTypes2.default.string,
              operationName: _propTypes2.default.string,
              queryID: _propTypes2.default.number,
              onSelectQuery: _propTypes2.default.func,
              storage: _propTypes2.default.object
            };
            var _initialiseProps = function() {
              var e = this;
              this.toggleFavorite = function(t, r, o, i) {
                var a = { query: t, variables: r, operationName: o };
                e.favoriteStore.contains(a)
                  ? i && ((a.favorite = !1), e.favoriteStore.delete(a))
                  : ((a.favorite = !0), e.favoriteStore.push(a));
                var s = e.historyStore.items,
                  n = e.favoriteStore.items,
                  u = s.concat(n);
                e.setState({ queries: u });
              };
            };
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        {
          "../utility/QueryStore": 25,
          "./HistoryQuery": 13,
          graphql: 101,
          "prop-types": 239
        }
      ],
      17: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.ResultViewer = void 0);
            var _createClass = (function() {
                function e(e, r) {
                  for (var t = 0; t < r.length; t++) {
                    var o = r[t];
                    (o.enumerable = o.enumerable || !1),
                      (o.configurable = !0),
                      "value" in o && (o.writable = !0),
                      Object.defineProperty(e, o.key, o);
                  }
                }
                return function(r, t, o) {
                  return t && e(r.prototype, t), o && e(r, o), r;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _reactDom2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.ReactDOM
                  : void 0 !== global ? global.ReactDOM : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types"));
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            (exports.ResultViewer = (function(e) {
              function r() {
                return (
                  (function(e, r) {
                    if (!(e instanceof r))
                      throw new TypeError("Cannot call a class as a function");
                  })(this, r),
                  (function(e, r) {
                    if (!e)
                      throw new ReferenceError(
                        "this hasn't been initialised - super() hasn't been called"
                      );
                    return !r ||
                      ("object" != typeof r && "function" != typeof r)
                      ? e
                      : r;
                  })(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this))
                );
              }
              return (
                (function(e, r) {
                  if ("function" != typeof r && null !== r)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof r
                    );
                  (e.prototype = Object.create(r && r.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    r &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, r)
                        : (e.__proto__ = r));
                })(r, _react2.default.Component),
                _createClass(r, [
                  {
                    key: "componentDidMount",
                    value: function() {
                      var e = this,
                        r = require("codemirror");
                      if (
                        (require("codemirror/addon/fold/foldgutter"),
                        require("codemirror/addon/fold/brace-fold"),
                        require("codemirror/addon/dialog/dialog"),
                        require("codemirror/addon/search/search"),
                        require("codemirror/addon/search/searchcursor"),
                        require("codemirror/addon/search/jump-to-line"),
                        require("codemirror/keymap/sublime"),
                        require("codemirror-graphql/results/mode"),
                        this.props.ResultsTooltip)
                      ) {
                        require("codemirror-graphql/utils/info-addon");
                        var t = document.createElement("div");
                        r.registerHelper("info", "graphql-results", function(
                          r,
                          o,
                          i,
                          n
                        ) {
                          var u = e.props.ResultsTooltip;
                          return (
                            _reactDom2.default.render(
                              _react2.default.createElement(u, { pos: n }),
                              t
                            ),
                            t
                          );
                        });
                      }
                      this.viewer = r(this._node, {
                        lineWrapping: !0,
                        value: this.props.value || "",
                        readOnly: !0,
                        theme: this.props.editorTheme || "graphiql",
                        mode: "graphql-results",
                        keyMap: "sublime",
                        foldGutter: { minFoldSize: 4 },
                        gutters: ["CodeMirror-foldgutter"],
                        info: Boolean(this.props.ResultsTooltip),
                        extraKeys: {
                          "Cmd-F": "findPersistent",
                          "Ctrl-F": "findPersistent",
                          "Ctrl-Left": "goSubwordLeft",
                          "Ctrl-Right": "goSubwordRight",
                          "Alt-Left": "goGroupLeft",
                          "Alt-Right": "goGroupRight"
                        }
                      });
                    }
                  },
                  {
                    key: "shouldComponentUpdate",
                    value: function(e) {
                      return this.props.value !== e.value;
                    }
                  },
                  {
                    key: "componentDidUpdate",
                    value: function() {
                      this.viewer.setValue(this.props.value || "");
                    }
                  },
                  {
                    key: "componentWillUnmount",
                    value: function() {
                      this.viewer = null;
                    }
                  },
                  {
                    key: "render",
                    value: function() {
                      var e = this;
                      return _react2.default.createElement("div", {
                        className: "result-window",
                        ref: function(r) {
                          e._node = r;
                        }
                      });
                    }
                  },
                  {
                    key: "getCodeMirror",
                    value: function() {
                      return this.viewer;
                    }
                  },
                  {
                    key: "getClientHeight",
                    value: function() {
                      return this._node && this._node.clientHeight;
                    }
                  }
                ]),
                r
              );
            })()).propTypes = {
              value: _propTypes2.default.string,
              editorTheme: _propTypes2.default.string,
              ResultsTooltip: _propTypes2.default.any
            };
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        {
          codemirror: 66,
          "codemirror-graphql/results/mode": 42,
          "codemirror-graphql/utils/info-addon": 47,
          "codemirror/addon/dialog/dialog": 54,
          "codemirror/addon/fold/brace-fold": 57,
          "codemirror/addon/fold/foldgutter": 59,
          "codemirror/addon/search/jump-to-line": 62,
          "codemirror/addon/search/search": 63,
          "codemirror/addon/search/searchcursor": 64,
          "codemirror/keymap/sublime": 65,
          "prop-types": 239
        }
      ],
      18: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.ToolbarButton = void 0);
            var _createClass = (function() {
                function e(e, t) {
                  for (var r = 0; r < t.length; r++) {
                    var o = t[r];
                    (o.enumerable = o.enumerable || !1),
                      (o.configurable = !0),
                      "value" in o && (o.writable = !0),
                      Object.defineProperty(e, o.key, o);
                  }
                }
                return function(t, r, o) {
                  return r && e(t.prototype, r), o && e(t, o), t;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types"));
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            function preventDefault(e) {
              e.preventDefault();
            }
            (exports.ToolbarButton = (function(e) {
              function t(e) {
                !(function(e, t) {
                  if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function");
                })(this, t);
                var r = (function(e, t) {
                  if (!e)
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  return !t || ("object" != typeof t && "function" != typeof t)
                    ? e
                    : t;
                })(
                  this,
                  (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)
                );
                return (
                  (r.handleClick = function(e) {
                    e.preventDefault();
                    try {
                      r.props.onClick(), r.setState({ error: null });
                    } catch (e) {
                      r.setState({ error: e });
                    }
                  }),
                  (r.state = { error: null }),
                  r
                );
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "render",
                    value: function() {
                      var e = this.state.error;
                      return _react2.default.createElement(
                        "a",
                        {
                          className:
                            "toolbar-button" +
                            (e ? " error" : "") +
                            ("Schema" === this.props.label
                              ? " schema-button"
                              : ""),
                          onMouseDown: preventDefault,
                          onClick: this.handleClick,
                          title: e ? e.message : this.props.title
                        },
                        this.props.label
                      );
                    }
                  }
                ]),
                t
              );
            })()).propTypes = {
              onClick: _propTypes2.default.func,
              title: _propTypes2.default.string,
              label: _propTypes2.default.string
            };
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { "prop-types": 239 }
      ],
      19: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.ToolbarGroup = function(e) {
                var r = e.children;
                return _react2.default.createElement(
                  "div",
                  { className: "toolbar-button-group" },
                  r
                );
              });
            var e,
              _react =
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null,
              _react2 = (e = _react) && e.__esModule ? e : { default: e };
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        {}
      ],
      20: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.ToolbarMenu = void 0);
            var _createClass = (function() {
              function e(e, t) {
                for (var r = 0; r < t.length; r++) {
                  var n = t[r];
                  (n.enumerable = n.enumerable || !1),
                    (n.configurable = !0),
                    "value" in n && (n.writable = !0),
                    Object.defineProperty(e, n.key, n);
                }
              }
              return function(t, r, n) {
                return r && e(t.prototype, r), n && e(t, n), t;
              };
            })();
            exports.ToolbarMenuItem = ToolbarMenuItem;
            var _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types"));
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            function ToolbarMenuItem(e) {
              var t = e.onSelect,
                r = e.title,
                n = e.label;
              return _react2.default.createElement(
                "li",
                {
                  onMouseOver: function(e) {
                    e.target.className = "hover";
                  },
                  onMouseOut: function(e) {
                    e.target.className = null;
                  },
                  onMouseDown: preventDefault,
                  onMouseUp: t,
                  title: r
                },
                n
              );
            }
            function preventDefault(e) {
              e.preventDefault();
            }
            ((exports.ToolbarMenu = (function(e) {
              function t(e) {
                !(function(e, t) {
                  if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function");
                })(this, t);
                var r = (function(e, t) {
                  if (!e)
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  return !t || ("object" != typeof t && "function" != typeof t)
                    ? e
                    : t;
                })(
                  this,
                  (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)
                );
                return (
                  (r.handleOpen = function(e) {
                    preventDefault(e),
                      r.setState({ visible: !0 }),
                      r._subscribe();
                  }),
                  (r.state = { visible: !1 }),
                  r
                );
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "componentWillUnmount",
                    value: function() {
                      this._release();
                    }
                  },
                  {
                    key: "render",
                    value: function() {
                      var e = this,
                        t = this.state.visible;
                      return _react2.default.createElement(
                        "a",
                        {
                          className: "toolbar-menu toolbar-button",
                          onClick: this.handleOpen.bind(this),
                          onMouseDown: preventDefault,
                          ref: function(t) {
                            e._node = t;
                          },
                          title: this.props.title
                        },
                        this.props.label,
                        _react2.default.createElement(
                          "svg",
                          { width: "14", height: "8" },
                          _react2.default.createElement("path", {
                            fill: "#666",
                            d: "M 5 1.5 L 14 1.5 L 9.5 7 z"
                          })
                        ),
                        _react2.default.createElement(
                          "ul",
                          {
                            className: "toolbar-menu-items" + (t ? " open" : "")
                          },
                          this.props.children
                        )
                      );
                    }
                  },
                  {
                    key: "_subscribe",
                    value: function() {
                      this._listener ||
                        ((this._listener = this.handleClick.bind(this)),
                        document.addEventListener("click", this._listener));
                    }
                  },
                  {
                    key: "_release",
                    value: function() {
                      this._listener &&
                        (document.removeEventListener("click", this._listener),
                        (this._listener = null));
                    }
                  },
                  {
                    key: "handleClick",
                    value: function(e) {
                      this._node !== e.target &&
                        (preventDefault(e),
                        this.setState({ visible: !1 }),
                        this._release());
                    }
                  }
                ]),
                t
              );
            })()).propTypes = {
              title: _propTypes2.default.string,
              label: _propTypes2.default.string
            }),
              (ToolbarMenuItem.propTypes = {
                onSelect: _propTypes2.default.func,
                title: _propTypes2.default.string,
                label: _propTypes2.default.string
              });
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { "prop-types": 239 }
      ],
      21: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.ToolbarSelect = void 0);
            var _extends =
                Object.assign ||
                function(e) {
                  for (var t = 1; t < arguments.length; t++) {
                    var r = arguments[t];
                    for (var n in r)
                      Object.prototype.hasOwnProperty.call(r, n) &&
                        (e[n] = r[n]);
                  }
                  return e;
                },
              _createClass = (function() {
                function e(e, t) {
                  for (var r = 0; r < t.length; r++) {
                    var n = t[r];
                    (n.enumerable = n.enumerable || !1),
                      (n.configurable = !0),
                      "value" in n && (n.writable = !0),
                      Object.defineProperty(e, n.key, n);
                  }
                }
                return function(t, r, n) {
                  return r && e(t.prototype, r), n && e(t, n), t;
                };
              })();
            exports.ToolbarSelectOption = ToolbarSelectOption;
            var _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types"));
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            function ToolbarSelectOption(e) {
              var t = e.onSelect,
                r = e.label,
                n = e.selected;
              return _react2.default.createElement(
                "li",
                {
                  onMouseOver: function(e) {
                    e.target.className = "hover";
                  },
                  onMouseOut: function(e) {
                    e.target.className = null;
                  },
                  onMouseDown: preventDefault,
                  onMouseUp: t
                },
                r,
                n &&
                  _react2.default.createElement(
                    "svg",
                    { width: "13", height: "13" },
                    _react2.default.createElement("polygon", {
                      points:
                        "4.851,10.462 0,5.611 2.314,3.297 4.851,5.835 10.686,0 13,2.314 4.851,10.462"
                    })
                  )
              );
            }
            function preventDefault(e) {
              e.preventDefault();
            }
            ((exports.ToolbarSelect = (function(e) {
              function t(e) {
                !(function(e, t) {
                  if (!(e instanceof t))
                    throw new TypeError("Cannot call a class as a function");
                })(this, t);
                var r = (function(e, t) {
                  if (!e)
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  return !t || ("object" != typeof t && "function" != typeof t)
                    ? e
                    : t;
                })(
                  this,
                  (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)
                );
                return (
                  (r.handleOpen = function(e) {
                    preventDefault(e),
                      r.setState({ visible: !0 }),
                      r._subscribe();
                  }),
                  (r.state = { visible: !1 }),
                  r
                );
              }
              return (
                (function(e, t) {
                  if ("function" != typeof t && null !== t)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof t
                    );
                  (e.prototype = Object.create(t && t.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    t &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, t)
                        : (e.__proto__ = t));
                })(t, _react2.default.Component),
                _createClass(t, [
                  {
                    key: "componentWillUnmount",
                    value: function() {
                      this._release();
                    }
                  },
                  {
                    key: "render",
                    value: function() {
                      var e = this,
                        t = void 0,
                        r = this.state.visible,
                        n = _react2.default.Children.map(
                          this.props.children,
                          function(r, n) {
                            (t && !r.props.selected) || (t = r);
                            var o =
                              r.props.onSelect ||
                              (e.props.onSelect &&
                                e.props.onSelect.bind(null, r.props.value, n));
                            return _react2.default.createElement(
                              ToolbarSelectOption,
                              _extends({}, r.props, { onSelect: o })
                            );
                          }
                        );
                      return _react2.default.createElement(
                        "a",
                        {
                          className: "toolbar-select toolbar-button",
                          onClick: this.handleOpen.bind(this),
                          onMouseDown: preventDefault,
                          ref: function(t) {
                            e._node = t;
                          },
                          title: this.props.title
                        },
                        t.props.label,
                        _react2.default.createElement(
                          "svg",
                          { width: "13", height: "10" },
                          _react2.default.createElement("path", {
                            fill: "#666",
                            d: "M 5 5 L 13 5 L 9 1 z"
                          }),
                          _react2.default.createElement("path", {
                            fill: "#666",
                            d: "M 5 6 L 13 6 L 9 10 z"
                          })
                        ),
                        _react2.default.createElement(
                          "ul",
                          {
                            className:
                              "toolbar-select-options" + (r ? " open" : "")
                          },
                          n
                        )
                      );
                    }
                  },
                  {
                    key: "_subscribe",
                    value: function() {
                      this._listener ||
                        ((this._listener = this.handleClick.bind(this)),
                        document.addEventListener("click", this._listener));
                    }
                  },
                  {
                    key: "_release",
                    value: function() {
                      this._listener &&
                        (document.removeEventListener("click", this._listener),
                        (this._listener = null));
                    }
                  },
                  {
                    key: "handleClick",
                    value: function(e) {
                      this._node !== e.target &&
                        (preventDefault(e),
                        this.setState({ visible: !1 }),
                        this._release());
                    }
                  }
                ]),
                t
              );
            })()).propTypes = {
              title: _propTypes2.default.string,
              label: _propTypes2.default.string,
              onSelect: _propTypes2.default.func
            }),
              (ToolbarSelectOption.propTypes = {
                onSelect: _propTypes2.default.func,
                selected: _propTypes2.default.bool,
                label: _propTypes2.default.string,
                value: _propTypes2.default.any
              });
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { "prop-types": 239 }
      ],
      22: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.VariableEditor = void 0);
            var _createClass = (function() {
                function e(e, r) {
                  for (var o = 0; o < r.length; o++) {
                    var t = r[o];
                    (t.enumerable = t.enumerable || !1),
                      (t.configurable = !0),
                      "value" in t && (t.writable = !0),
                      Object.defineProperty(e, t.key, t);
                  }
                }
                return function(r, o, t) {
                  return o && e(r.prototype, o), t && e(r, t), r;
                };
              })(),
              _react2 = _interopRequireDefault(
                "undefined" != typeof window
                  ? window.React
                  : void 0 !== global ? global.React : null
              ),
              _propTypes2 = _interopRequireDefault(require("prop-types")),
              _onHasCompletion2 = _interopRequireDefault(
                require("../utility/onHasCompletion")
              );
            function _interopRequireDefault(e) {
              return e && e.__esModule ? e : { default: e };
            }
            (exports.VariableEditor = (function(e) {
              function r(e) {
                !(function(e, r) {
                  if (!(e instanceof r))
                    throw new TypeError("Cannot call a class as a function");
                })(this, r);
                var o = (function(e, r) {
                  if (!e)
                    throw new ReferenceError(
                      "this hasn't been initialised - super() hasn't been called"
                    );
                  return !r || ("object" != typeof r && "function" != typeof r)
                    ? e
                    : r;
                })(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this));
                return (
                  (o._onKeyUp = function(e, r) {
                    var t = r.keyCode;
                    ((65 <= t && t <= 90) ||
                      (!r.shiftKey && 48 <= t && t <= 57) ||
                      (r.shiftKey && 189 === t) ||
                      (r.shiftKey && 222 === t)) &&
                      o.editor.execCommand("autocomplete");
                  }),
                  (o._onEdit = function() {
                    o.ignoreChangeEvent ||
                      ((o.cachedValue = o.editor.getValue()),
                      o.props.onEdit && o.props.onEdit(o.cachedValue));
                  }),
                  (o._onHasCompletion = function(e, r) {
                    (0, _onHasCompletion2.default)(
                      e,
                      r,
                      o.props.onHintInformationRender
                    );
                  }),
                  (o.cachedValue = e.value || ""),
                  o
                );
              }
              return (
                (function(e, r) {
                  if ("function" != typeof r && null !== r)
                    throw new TypeError(
                      "Super expression must either be null or a function, not " +
                        typeof r
                    );
                  (e.prototype = Object.create(r && r.prototype, {
                    constructor: {
                      value: e,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  })),
                    r &&
                      (Object.setPrototypeOf
                        ? Object.setPrototypeOf(e, r)
                        : (e.__proto__ = r));
                })(r, _react2.default.Component),
                _createClass(r, [
                  {
                    key: "componentDidMount",
                    value: function() {
                      var e = this,
                        r = require("codemirror");
                      require("codemirror/addon/hint/show-hint"),
                        require("codemirror/addon/edit/matchbrackets"),
                        require("codemirror/addon/edit/closebrackets"),
                        require("codemirror/addon/fold/brace-fold"),
                        require("codemirror/addon/fold/foldgutter"),
                        require("codemirror/addon/lint/lint"),
                        require("codemirror/addon/search/searchcursor"),
                        require("codemirror/addon/search/jump-to-line"),
                        require("codemirror/addon/dialog/dialog"),
                        require("codemirror/keymap/sublime"),
                        require("codemirror-graphql/variables/hint"),
                        require("codemirror-graphql/variables/lint"),
                        require("codemirror-graphql/variables/mode"),
                        (this.editor = r(this._node, {
                          value: this.props.value || "",
                          lineNumbers: !0,
                          tabSize: 2,
                          mode: "graphql-variables",
                          theme: this.props.editorTheme || "graphiql",
                          keyMap: "sublime",
                          autoCloseBrackets: !0,
                          matchBrackets: !0,
                          showCursorWhenSelecting: !0,
                          readOnly: !!this.props.readOnly && "nocursor",
                          foldGutter: { minFoldSize: 4 },
                          lint: { variableToType: this.props.variableToType },
                          hintOptions: {
                            variableToType: this.props.variableToType,
                            closeOnUnfocus: !1,
                            completeSingle: !1
                          },
                          gutters: [
                            "CodeMirror-linenumbers",
                            "CodeMirror-foldgutter"
                          ],
                          extraKeys: {
                            "Cmd-Space": function() {
                              return e.editor.showHint({ completeSingle: !1 });
                            },
                            "Ctrl-Space": function() {
                              return e.editor.showHint({ completeSingle: !1 });
                            },
                            "Alt-Space": function() {
                              return e.editor.showHint({ completeSingle: !1 });
                            },
                            "Shift-Space": function() {
                              return e.editor.showHint({ completeSingle: !1 });
                            },
                            "Cmd-Enter": function() {
                              e.props.onRunQuery && e.props.onRunQuery();
                            },
                            "Ctrl-Enter": function() {
                              e.props.onRunQuery && e.props.onRunQuery();
                            },
                            "Shift-Ctrl-P": function() {
                              e.props.onPrettifyQuery &&
                                e.props.onPrettifyQuery();
                            },
                            "Cmd-F": "findPersistent",
                            "Ctrl-F": "findPersistent",
                            "Ctrl-Left": "goSubwordLeft",
                            "Ctrl-Right": "goSubwordRight",
                            "Alt-Left": "goGroupLeft",
                            "Alt-Right": "goGroupRight"
                          }
                        })),
                        this.editor.on("change", this._onEdit),
                        this.editor.on("keyup", this._onKeyUp),
                        this.editor.on("hasCompletion", this._onHasCompletion);
                    }
                  },
                  {
                    key: "componentDidUpdate",
                    value: function(e) {
                      var r = require("codemirror");
                      (this.ignoreChangeEvent = !0),
                        this.props.variableToType !== e.variableToType &&
                          ((this.editor.options.lint.variableToType = this.props.variableToType),
                          (this.editor.options.hintOptions.variableToType = this.props.variableToType),
                          r.signal(this.editor, "change", this.editor)),
                        this.props.value !== e.value &&
                          this.props.value !== this.cachedValue &&
                          ((this.cachedValue = this.props.value),
                          this.editor.setValue(this.props.value)),
                        (this.ignoreChangeEvent = !1);
                    }
                  },
                  {
                    key: "componentWillUnmount",
                    value: function() {
                      this.editor.off("change", this._onEdit),
                        this.editor.off("keyup", this._onKeyUp),
                        this.editor.off("hasCompletion", this._onHasCompletion),
                        (this.editor = null);
                    }
                  },
                  {
                    key: "render",
                    value: function() {
                      var e = this;
                      return _react2.default.createElement("div", {
                        className: "codemirrorWrap",
                        ref: function(r) {
                          e._node = r;
                        }
                      });
                    }
                  },
                  {
                    key: "getCodeMirror",
                    value: function() {
                      return this.editor;
                    }
                  },
                  {
                    key: "getClientHeight",
                    value: function() {
                      return this._node && this._node.clientHeight;
                    }
                  }
                ]),
                r
              );
            })()).propTypes = {
              variableToType: _propTypes2.default.object,
              value: _propTypes2.default.string,
              onEdit: _propTypes2.default.func,
              readOnly: _propTypes2.default.bool,
              onHintInformationRender: _propTypes2.default.func,
              onPrettifyQuery: _propTypes2.default.func,
              onRunQuery: _propTypes2.default.func,
              editorTheme: _propTypes2.default.string
            };
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        {
          "../utility/onHasCompletion": 35,
          codemirror: 66,
          "codemirror-graphql/variables/hint": 50,
          "codemirror-graphql/variables/lint": 51,
          "codemirror-graphql/variables/mode": 52,
          "codemirror/addon/dialog/dialog": 54,
          "codemirror/addon/edit/closebrackets": 55,
          "codemirror/addon/edit/matchbrackets": 56,
          "codemirror/addon/fold/brace-fold": 57,
          "codemirror/addon/fold/foldgutter": 59,
          "codemirror/addon/hint/show-hint": 60,
          "codemirror/addon/lint/lint": 61,
          "codemirror/addon/search/jump-to-line": 62,
          "codemirror/addon/search/searchcursor": 64,
          "codemirror/keymap/sublime": 65,
          "prop-types": 239
        }
      ],
      23: [
        function(require, module, exports) {
          "use strict";
          module.exports = require("./components/GraphiQL").GraphiQL;
        },
        { "./components/GraphiQL": 12 }
      ],
      24: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _createClass = (function() {
            function e(e, r) {
              for (var t = 0; t < r.length; t++) {
                var n = r[t];
                (n.enumerable = n.enumerable || !1),
                  (n.configurable = !0),
                  "value" in n && (n.writable = !0),
                  Object.defineProperty(e, n.key, n);
              }
            }
            return function(r, t, n) {
              return t && e(r.prototype, t), n && e(r, n), r;
            };
          })();
          var CodeMirrorSizer = (function() {
            function e() {
              (function(e, r) {
                if (!(e instanceof r))
                  throw new TypeError("Cannot call a class as a function");
              })(this, e),
                (this.sizes = []);
            }
            return (
              _createClass(e, [
                {
                  key: "updateSizes",
                  value: function(e) {
                    var r = this;
                    e.forEach(function(e, t) {
                      var n = e.getClientHeight();
                      t <= r.sizes.length &&
                        n !== r.sizes[t] &&
                        e.getCodeMirror().setSize(),
                        (r.sizes[t] = n);
                    });
                  }
                }
              ]),
              e
            );
          })();
          exports.default = CodeMirrorSizer;
        },
        {}
      ],
      25: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _createClass = (function() {
            function e(e, t) {
              for (var i = 0; i < t.length; i++) {
                var n = t[i];
                (n.enumerable = n.enumerable || !1),
                  (n.configurable = !0),
                  "value" in n && (n.writable = !0),
                  Object.defineProperty(e, n.key, n);
              }
            }
            return function(t, i, n) {
              return i && e(t.prototype, i), n && e(t, n), t;
            };
          })();
          var QueryStore = (function() {
            function e(t, i) {
              (function(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              })(this, e),
                (this.key = t),
                (this.storage = i),
                (this.items = this.fetchAll());
            }
            return (
              _createClass(e, [
                {
                  key: "contains",
                  value: function(e) {
                    return this.items.some(function(t) {
                      return (
                        t.query === e.query &&
                        t.variables === e.variables &&
                        t.operationName === e.operationName
                      );
                    });
                  }
                },
                {
                  key: "delete",
                  value: function(e) {
                    var t = this.items.findIndex(function(t) {
                      return (
                        t.query === e.query &&
                        t.variables === e.variables &&
                        t.operationName === e.operationName
                      );
                    });
                    -1 !== t && (this.items.splice(t, 1), this.save());
                  }
                },
                {
                  key: "fetchRecent",
                  value: function() {
                    return this.items[this.items.length - 1];
                  }
                },
                {
                  key: "fetchAll",
                  value: function() {
                    var e = this.storage.get(this.key);
                    return e ? JSON.parse(e)[this.key] : [];
                  }
                },
                {
                  key: "push",
                  value: function(e) {
                    this.items.push(e), this.save();
                  }
                },
                {
                  key: "shift",
                  value: function() {
                    this.items.shift(), this.save();
                  }
                },
                {
                  key: "save",
                  value: function() {
                    var e, t, i;
                    this.storage.set(
                      this.key,
                      JSON.stringify(
                        ((e = {}),
                        (t = this.key),
                        (i = this.items),
                        t in e
                          ? Object.defineProperty(e, t, {
                              value: i,
                              enumerable: !0,
                              configurable: !0,
                              writable: !0
                            })
                          : (e[t] = i),
                        e)
                      )
                    );
                  }
                },
                {
                  key: "length",
                  get: function() {
                    return this.items.length;
                  }
                }
              ]),
              e
            );
          })();
          exports.default = QueryStore;
        },
        {}
      ],
      26: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _createClass = (function() {
            function e(e, t) {
              for (var r = 0; r < t.length; r++) {
                var a = t[r];
                (a.enumerable = a.enumerable || !1),
                  (a.configurable = !0),
                  "value" in a && (a.writable = !0),
                  Object.defineProperty(e, a.key, a);
              }
            }
            return function(t, r, a) {
              return r && e(t.prototype, r), a && e(t, a), t;
            };
          })();
          var StorageAPI = (function() {
            function e(t) {
              (function(e, t) {
                if (!(e instanceof t))
                  throw new TypeError("Cannot call a class as a function");
              })(this, e),
                (this.storage = t || window.localStorage);
            }
            return (
              _createClass(e, [
                {
                  key: "get",
                  value: function(e) {
                    if (this.storage) {
                      var t = this.storage.getItem("graphiql:" + e);
                      if ("null" !== t && "undefined" !== t) return t;
                      this.storage.removeItem("graphiql:" + e);
                    }
                  }
                },
                {
                  key: "set",
                  value: function(e, t) {
                    if (this.storage) {
                      var r = "graphiql:" + e;
                      t
                        ? (function(e, t, r) {
                            try {
                              return e.setItem(t, r), !0;
                            } catch (t) {
                              return (
                                t instanceof DOMException &&
                                (22 === t.code ||
                                  1014 === t.code ||
                                  "QuotaExceededError" === t.name ||
                                  "NS_ERROR_DOM_QUOTA_REACHED" === t.name) &&
                                0 !== e.length
                              );
                            }
                          })(this.storage, r, t) && this.storage.setItem(r, t)
                        : this.storage.removeItem(r);
                    }
                  }
                }
              ]),
              e
            );
          })();
          exports.default = StorageAPI;
        },
        {}
      ],
      27: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(e, t) {
              var u = void 0;
              return function() {
                var o = this,
                  n = arguments;
                clearTimeout(u),
                  (u = setTimeout(function() {
                    (u = null), t.apply(o, n);
                  }, e));
              };
            });
        },
        {}
      ],
      28: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.getLeft = function(e) {
              for (var t = 0, f = e; f.offsetParent; )
                (t += f.offsetLeft), (f = f.offsetParent);
              return t;
            }),
            (exports.getTop = function(e) {
              for (var t = 0, f = e; f.offsetParent; )
                (t += f.offsetTop), (f = f.offsetParent);
              return t;
            });
        },
        {}
      ],
      29: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.fillLeafs = function(e, t, r) {
              var n = [];
              if (!e) return { insertions: n, result: t };
              var i = void 0;
              try {
                i = (0, _graphql.parse)(t);
              } catch (e) {
                return { insertions: n, result: t };
              }
              var a = r || defaultGetDefaultFieldNames,
                l = new _graphql.TypeInfo(e);
              return (
                (0, _graphql.visit)(i, {
                  leave: function(e) {
                    l.leave(e);
                  },
                  enter: function(e) {
                    if ((l.enter(e), "Field" === e.kind && !e.selectionSet)) {
                      var r = (function buildSelectionSet(e, t) {
                        var r = (0, _graphql.getNamedType)(e);
                        if (e && !(0, _graphql.isLeafType)(e)) {
                          var n = t(r);
                          if (Array.isArray(n) && 0 !== n.length)
                            return {
                              kind: "SelectionSet",
                              selections: n.map(function(e) {
                                var n = r.getFields()[e];
                                return {
                                  kind: "Field",
                                  name: { kind: "Name", value: e },
                                  selectionSet: buildSelectionSet(
                                    n ? n.type : null,
                                    t
                                  )
                                };
                              })
                            };
                        }
                      })(l.getType(), a);
                      if (r) {
                        var i = (function(e, t) {
                          for (var r = t, n = t; r; ) {
                            var i = e.charCodeAt(r - 1);
                            if (
                              10 === i ||
                              13 === i ||
                              8232 === i ||
                              8233 === i
                            )
                              break;
                            r--,
                              9 !== i &&
                                11 !== i &&
                                12 !== i &&
                                32 !== i &&
                                160 !== i &&
                                (n = r);
                          }
                          return e.substring(r, n);
                        })(t, e.loc.start);
                        n.push({
                          index: e.loc.end,
                          string:
                            " " +
                            (0, _graphql.print)(r).replace(/\n/g, "\n" + i)
                        });
                      }
                    }
                  }
                }),
                {
                  insertions: n,
                  result: (function(e, t) {
                    if (0 === t.length) return e;
                    var r = "",
                      n = 0;
                    return (
                      t.forEach(function(t) {
                        var i = t.index,
                          a = t.string;
                        (r += e.slice(n, i) + a), (n = i);
                      }),
                      (r += e.slice(n))
                    );
                  })(t, n)
                }
              );
            });
          var _graphql = require("graphql");
          function defaultGetDefaultFieldNames(e) {
            if (!e.getFields) return [];
            var t = e.getFields();
            if (t.id) return ["id"];
            if (t.edges) return ["edges"];
            if (t.node) return ["node"];
            var r = [];
            return (
              Object.keys(t).forEach(function(e) {
                (0, _graphql.isLeafType)(t[e].type) && r.push(e);
              }),
              r
            );
          }
        },
        { graphql: 101 }
      ],
      30: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(e, t) {
              for (var r = 0; r < e.length; r++) if (t(e[r])) return e[r];
            });
        },
        {}
      ],
      31: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(e, r) {
              if (r) {
                var a = void 0;
                try {
                  a = (0, _graphql.parse)(r);
                } catch (e) {
                  return;
                }
                var i = e ? collectVariables(e, a) : null,
                  t = [];
                return (
                  a.definitions.forEach(function(e) {
                    "OperationDefinition" === e.kind && t.push(e);
                  }),
                  { variableToType: i, operations: t }
                );
              }
            }),
            (exports.collectVariables = collectVariables);
          var _graphql = require("graphql");
          function collectVariables(e, r) {
            var a = Object.create(null);
            return (
              r.definitions.forEach(function(r) {
                if ("OperationDefinition" === r.kind) {
                  var i = r.variableDefinitions;
                  i &&
                    i.forEach(function(r) {
                      var i = r.variable,
                        t = r.type,
                        n = (0, _graphql.typeFromAST)(e, t);
                      n && (a[i.name.value] = n);
                    });
                }
              }),
              a
            );
          }
        },
        { graphql: 101 }
      ],
      32: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(e, t, n) {
              if (n && !(n.length < 1)) {
                var r = n.map(function(e) {
                  return e.name && e.name.value;
                });
                if (t && -1 !== r.indexOf(t)) return t;
                if (t && e) {
                  var a = e
                    .map(function(e) {
                      return e.name && e.name.value;
                    })
                    .indexOf(t);
                  if (-1 !== a && a < r.length) return r[a];
                }
                return r[0];
              }
            });
        },
        {}
      ],
      33: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _graphql = require("graphql");
          Object.defineProperty(exports, "introspectionQuery", {
            enumerable: !0,
            get: function() {
              return _graphql.introspectionQuery;
            }
          });
          exports.introspectionQuerySansSubscriptions =
            "\n  query IntrospectionQuery {\n    __schema {\n      queryType { name }\n      mutationType { name }\n      types {\n        ...FullType\n      }\n      directives {\n        name\n        description\n        locations\n        args {\n          ...InputValue\n        }\n      }\n    }\n  }\n\n  fragment FullType on __Type {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n\n  fragment InputValue on __InputValue {\n    name\n    description\n    type { ...TypeRef }\n    defaultValue\n  }\n\n  fragment TypeRef on __Type {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n";
        },
        { graphql: 101 }
      ],
      34: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.normalizeWhitespace = function(e) {
              return e.replace(sanitizeRegex, " ");
            });
          var invalidCharacters = (exports.invalidCharacters = Array.from(
              { length: 11 },
              function(e, r) {
                return String.fromCharCode(8192 + r);
              }
            ).concat(["\u2028", "\u2029", " "])),
            sanitizeRegex = new RegExp(
              "[" + invalidCharacters.join("|") + "]",
              "g"
            );
        },
        {}
      ],
      35: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(e, n, r) {
              var a = void 0,
                t = void 0;
              require("codemirror").on(n, "select", function(e, n) {
                if (!a) {
                  var o = n.parentNode;
                  ((a = document.createElement("div")).className =
                    "CodeMirror-hint-information"),
                    o.appendChild(a),
                    ((t = document.createElement("div")).className =
                      "CodeMirror-hint-deprecation"),
                    o.appendChild(t);
                  var i = void 0;
                  o.addEventListener(
                    "DOMNodeRemoved",
                    (i = function(e) {
                      e.target === o &&
                        (o.removeEventListener("DOMNodeRemoved", i),
                        (i = t = a = null));
                    })
                  );
                }
                var d = e.description
                    ? md.render(e.description)
                    : "Self descriptive.",
                  p = e.type
                    ? '<span class="infoType">' +
                      (function renderType(e) {
                        return e instanceof _graphql.GraphQLNonNull
                          ? renderType(e.ofType) + "!"
                          : e instanceof _graphql.GraphQLList
                            ? "[" + renderType(e.ofType) + "]"
                            : '<a class="typeName">' + e.name + "</a>";
                      })(e.type) +
                      "</span>"
                    : "";
                if (
                  ((a.innerHTML =
                    '<div class="content">' +
                    ("<p>" === d.slice(0, 3) ? "<p>" + p + d.slice(3) : p + d) +
                    "</div>"),
                  e.isDeprecated)
                ) {
                  var l = e.deprecationReason
                    ? md.render(e.deprecationReason)
                    : "";
                  (t.innerHTML =
                    '<span class="deprecation-label">Deprecated</span>' + l),
                    (t.style.display = "block");
                } else t.style.display = "none";
                r && r(a);
              });
            });
          var e,
            _graphql = require("graphql"),
            _markdownIt = require("markdown-it");
          var md = new ((e = _markdownIt) && e.__esModule
            ? e
            : { default: e }
          ).default();
        },
        { codemirror: 66, graphql: 101, "markdown-it": 178 }
      ],
      36: [
        function(require, module, exports) {
          (function(global) {
            "use strict";
            function compare(a, b) {
              if (a === b) return 0;
              for (
                var x = a.length, y = b.length, i = 0, len = Math.min(x, y);
                i < len;
                ++i
              )
                if (a[i] !== b[i]) {
                  (x = a[i]), (y = b[i]);
                  break;
                }
              return x < y ? -1 : y < x ? 1 : 0;
            }
            function isBuffer(b) {
              return global.Buffer &&
                "function" == typeof global.Buffer.isBuffer
                ? global.Buffer.isBuffer(b)
                : !(null == b || !b._isBuffer);
            }
            var util = require("util/"),
              hasOwn = Object.prototype.hasOwnProperty,
              pSlice = Array.prototype.slice,
              functionsHaveNames = "foo" === function() {}.name;
            function pToString(obj) {
              return Object.prototype.toString.call(obj);
            }
            function isView(arrbuf) {
              return (
                !isBuffer(arrbuf) &&
                ("function" == typeof global.ArrayBuffer &&
                  ("function" == typeof ArrayBuffer.isView
                    ? ArrayBuffer.isView(arrbuf)
                    : !!arrbuf &&
                      (arrbuf instanceof DataView ||
                        !!(
                          arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer
                        ))))
              );
            }
            var assert = (module.exports = ok),
              regex = /\s*function\s+([^\(\s]*)\s*/;
            function getName(func) {
              if (util.isFunction(func)) {
                if (functionsHaveNames) return func.name;
                var match = func.toString().match(regex);
                return match && match[1];
              }
            }
            function truncate(s, n) {
              return "string" == typeof s
                ? s.length < n ? s : s.slice(0, n)
                : s;
            }
            function inspect(something) {
              if (functionsHaveNames || !util.isFunction(something))
                return util.inspect(something);
              var rawname = getName(something);
              return "[Function" + (rawname ? ": " + rawname : "") + "]";
            }
            function fail(
              actual,
              expected,
              message,
              operator,
              stackStartFunction
            ) {
              throw new assert.AssertionError({
                message: message,
                actual: actual,
                expected: expected,
                operator: operator,
                stackStartFunction: stackStartFunction
              });
            }
            function ok(value, message) {
              value || fail(value, !0, message, "==", assert.ok);
            }
            function _deepEqual(actual, expected, strict, memos) {
              if (actual === expected) return !0;
              if (isBuffer(actual) && isBuffer(expected))
                return 0 === compare(actual, expected);
              if (util.isDate(actual) && util.isDate(expected))
                return actual.getTime() === expected.getTime();
              if (util.isRegExp(actual) && util.isRegExp(expected))
                return (
                  actual.source === expected.source &&
                  actual.global === expected.global &&
                  actual.multiline === expected.multiline &&
                  actual.lastIndex === expected.lastIndex &&
                  actual.ignoreCase === expected.ignoreCase
                );
              if (
                (null !== actual && "object" == typeof actual) ||
                (null !== expected && "object" == typeof expected)
              ) {
                if (
                  isView(actual) &&
                  isView(expected) &&
                  pToString(actual) === pToString(expected) &&
                  !(
                    actual instanceof Float32Array ||
                    actual instanceof Float64Array
                  )
                )
                  return (
                    0 ===
                    compare(
                      new Uint8Array(actual.buffer),
                      new Uint8Array(expected.buffer)
                    )
                  );
                if (isBuffer(actual) !== isBuffer(expected)) return !1;
                var actualIndex = (memos = memos || {
                  actual: [],
                  expected: []
                }).actual.indexOf(actual);
                return (
                  (-1 !== actualIndex &&
                    actualIndex === memos.expected.indexOf(expected)) ||
                  (memos.actual.push(actual),
                  memos.expected.push(expected),
                  (function(a, b, strict, actualVisitedObjects) {
                    if (null == a || null == b) return !1;
                    if (util.isPrimitive(a) || util.isPrimitive(b))
                      return a === b;
                    if (
                      strict &&
                      Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)
                    )
                      return !1;
                    var aIsArgs = isArguments(a),
                      bIsArgs = isArguments(b);
                    if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
                      return !1;
                    if (aIsArgs)
                      return (
                        (a = pSlice.call(a)),
                        (b = pSlice.call(b)),
                        _deepEqual(a, b, strict)
                      );
                    var key,
                      i,
                      ka = objectKeys(a),
                      kb = objectKeys(b);
                    if (ka.length !== kb.length) return !1;
                    for (ka.sort(), kb.sort(), i = ka.length - 1; 0 <= i; i--)
                      if (ka[i] !== kb[i]) return !1;
                    for (i = ka.length - 1; 0 <= i; i--)
                      if (
                        ((key = ka[i]),
                        !_deepEqual(
                          a[key],
                          b[key],
                          strict,
                          actualVisitedObjects
                        ))
                      )
                        return !1;
                    return !0;
                  })(actual, expected, strict, memos))
                );
              }
              return strict ? actual === expected : actual == expected;
            }
            function isArguments(object) {
              return (
                "[object Arguments]" == Object.prototype.toString.call(object)
              );
            }
            function expectedException(actual, expected) {
              if (!actual || !expected) return !1;
              if ("[object RegExp]" == Object.prototype.toString.call(expected))
                return expected.test(actual);
              try {
                if (actual instanceof expected) return !0;
              } catch (e) {}
              return (
                !Error.isPrototypeOf(expected) &&
                !0 === expected.call({}, actual)
              );
            }
            function _throws(shouldThrow, block, expected, message) {
              var actual;
              if ("function" != typeof block)
                throw new TypeError('"block" argument must be a function');
              "string" == typeof expected &&
                ((message = expected), (expected = null)),
                (actual = (function(block) {
                  var error;
                  try {
                    block();
                  } catch (e) {
                    error = e;
                  }
                  return error;
                })(block)),
                (message =
                  (expected && expected.name
                    ? " (" + expected.name + ")."
                    : ".") + (message ? " " + message : ".")),
                shouldThrow &&
                  !actual &&
                  fail(
                    actual,
                    expected,
                    "Missing expected exception" + message
                  );
              var userProvidedMessage = "string" == typeof message,
                isUnexpectedException = !shouldThrow && actual && !expected;
              if (
                (((!shouldThrow &&
                  util.isError(actual) &&
                  userProvidedMessage &&
                  expectedException(actual, expected)) ||
                  isUnexpectedException) &&
                  fail(actual, expected, "Got unwanted exception" + message),
                (shouldThrow &&
                  actual &&
                  expected &&
                  !expectedException(actual, expected)) ||
                  (!shouldThrow && actual))
              )
                throw actual;
            }
            (assert.AssertionError = function(options) {
              var self;
              (this.name = "AssertionError"),
                (this.actual = options.actual),
                (this.expected = options.expected),
                (this.operator = options.operator),
                options.message
                  ? ((this.message = options.message),
                    (this.generatedMessage = !1))
                  : ((this.message =
                      truncate(inspect((self = this).actual), 128) +
                      " " +
                      self.operator +
                      " " +
                      truncate(inspect(self.expected), 128)),
                    (this.generatedMessage = !0));
              var stackStartFunction = options.stackStartFunction || fail;
              if (Error.captureStackTrace)
                Error.captureStackTrace(this, stackStartFunction);
              else {
                var err = new Error();
                if (err.stack) {
                  var out = err.stack,
                    fn_name = getName(stackStartFunction),
                    idx = out.indexOf("\n" + fn_name);
                  if (0 <= idx) {
                    var next_line = out.indexOf("\n", idx + 1);
                    out = out.substring(next_line + 1);
                  }
                  this.stack = out;
                }
              }
            }),
              util.inherits(assert.AssertionError, Error),
              (assert.fail = fail),
              (assert.ok = ok),
              (assert.equal = function(actual, expected, message) {
                actual != expected &&
                  fail(actual, expected, message, "==", assert.equal);
              }),
              (assert.notEqual = function(actual, expected, message) {
                actual == expected &&
                  fail(actual, expected, message, "!=", assert.notEqual);
              }),
              (assert.deepEqual = function(actual, expected, message) {
                _deepEqual(actual, expected, !1) ||
                  fail(
                    actual,
                    expected,
                    message,
                    "deepEqual",
                    assert.deepEqual
                  );
              }),
              (assert.deepStrictEqual = function(actual, expected, message) {
                _deepEqual(actual, expected, !0) ||
                  fail(
                    actual,
                    expected,
                    message,
                    "deepStrictEqual",
                    assert.deepStrictEqual
                  );
              }),
              (assert.notDeepEqual = function(actual, expected, message) {
                _deepEqual(actual, expected, !1) &&
                  fail(
                    actual,
                    expected,
                    message,
                    "notDeepEqual",
                    assert.notDeepEqual
                  );
              }),
              (assert.notDeepStrictEqual = function notDeepStrictEqual(
                actual,
                expected,
                message
              ) {
                _deepEqual(actual, expected, !0) &&
                  fail(
                    actual,
                    expected,
                    message,
                    "notDeepStrictEqual",
                    notDeepStrictEqual
                  );
              }),
              (assert.strictEqual = function(actual, expected, message) {
                actual !== expected &&
                  fail(actual, expected, message, "===", assert.strictEqual);
              }),
              (assert.notStrictEqual = function(actual, expected, message) {
                actual === expected &&
                  fail(actual, expected, message, "!==", assert.notStrictEqual);
              }),
              (assert.throws = function(block, error, message) {
                _throws(!0, block, error, message);
              }),
              (assert.doesNotThrow = function(block, error, message) {
                _throws(!1, block, error, message);
              }),
              (assert.ifError = function(err) {
                if (err) throw err;
              });
            var objectKeys =
              Object.keys ||
              function(obj) {
                var keys = [];
                for (var key in obj) hasOwn.call(obj, key) && keys.push(key);
                return keys;
              };
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { "util/": 250 }
      ],
      37: [
        function(require, module, exports) {
          "use strict";
          var obj,
            _codemirror = require("codemirror"),
            _codemirror2 =
              (obj = _codemirror) && obj.__esModule ? obj : { default: obj },
            _graphqlLanguageServiceInterface = require("graphql-language-service-interface");
          _codemirror2.default.registerHelper("hint", "graphql", function(
            editor,
            options
          ) {
            var schema = options.schema;
            if (schema) {
              var cur = editor.getCursor(),
                token = editor.getTokenAt(cur),
                rawResults = (0,
                _graphqlLanguageServiceInterface.getAutocompleteSuggestions)(
                  schema,
                  editor.getValue(),
                  cur,
                  token
                ),
                tokenStart =
                  null !== token.type && /"|\w/.test(token.string[0])
                    ? token.start
                    : token.end,
                results = {
                  list: rawResults.map(function(item) {
                    return {
                      text: item.label,
                      type: schema.getType(item.detail),
                      description: item.documentation,
                      isDeprecated: item.isDeprecated,
                      deprecationReason: item.deprecationReason
                    };
                  }),
                  from: { line: cur.line, column: tokenStart },
                  to: { line: cur.line, column: token.end }
                };
              return (
                results &&
                  results.list &&
                  0 < results.list.length &&
                  ((results.from = _codemirror2.default.Pos(
                    results.from.line,
                    results.from.column
                  )),
                  (results.to = _codemirror2.default.Pos(
                    results.to.line,
                    results.to.column
                  )),
                  _codemirror2.default.signal(
                    editor,
                    "hasCompletion",
                    editor,
                    results,
                    token
                  )),
                results
              );
            }
          });
        },
        { codemirror: 66, "graphql-language-service-interface": 77 }
      ],
      38: [
        function(require, module, exports) {
          "use strict";
          var _graphql = require("graphql"),
            _codemirror2 = _interopRequireDefault(require("codemirror")),
            _getTypeInfo2 = _interopRequireDefault(
              require("./utils/getTypeInfo")
            ),
            _SchemaReference = require("./utils/SchemaReference");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function renderQualifiedField(into, typeInfo, options) {
            var fieldName = typeInfo.fieldDef.name;
            "__" !== fieldName.slice(0, 2) &&
              (renderType(into, typeInfo, options, typeInfo.parentType),
              text(into, ".")),
              text(
                into,
                fieldName,
                "field-name",
                options,
                (0, _SchemaReference.getFieldReference)(typeInfo)
              );
          }
          function renderDirective(into, typeInfo, options) {
            text(
              into,
              "@" + typeInfo.directiveDef.name,
              "directive-name",
              options,
              (0, _SchemaReference.getDirectiveReference)(typeInfo)
            );
          }
          function renderTypeAnnotation(into, typeInfo, options, t) {
            text(into, ": "), renderType(into, typeInfo, options, t);
          }
          function renderType(into, typeInfo, options, t) {
            t instanceof _graphql.GraphQLNonNull
              ? (renderType(into, typeInfo, options, t.ofType), text(into, "!"))
              : t instanceof _graphql.GraphQLList
                ? (text(into, "["),
                  renderType(into, typeInfo, options, t.ofType),
                  text(into, "]"))
                : text(
                    into,
                    t.name,
                    "type-name",
                    options,
                    (0, _SchemaReference.getTypeReference)(typeInfo, t)
                  );
          }
          function renderDescription(into, options, def) {
            var description = def.description;
            if (description) {
              var descriptionDiv = document.createElement("div");
              (descriptionDiv.className = "info-description"),
                options.renderDescription
                  ? (descriptionDiv.innerHTML = options.renderDescription(
                      description
                    ))
                  : descriptionDiv.appendChild(
                      document.createTextNode(description)
                    ),
                into.appendChild(descriptionDiv);
            }
            !(function(into, options, def) {
              var reason = def.deprecationReason;
              if (reason) {
                var deprecationDiv = document.createElement("div");
                (deprecationDiv.className = "info-deprecation"),
                  options.renderDescription
                    ? (deprecationDiv.innerHTML = options.renderDescription(
                        reason
                      ))
                    : deprecationDiv.appendChild(
                        document.createTextNode(reason)
                      );
                var label = document.createElement("span");
                (label.className = "info-deprecation-label"),
                  label.appendChild(document.createTextNode("Deprecated: ")),
                  deprecationDiv.insertBefore(label, deprecationDiv.firstChild),
                  into.appendChild(deprecationDiv);
              }
            })(into, options, def);
          }
          function text(into, content, className, options, ref) {
            if (className) {
              var onClick = options.onClick,
                node = document.createElement(onClick ? "a" : "span");
              onClick &&
                ((node.href = "javascript:void 0"),
                node.addEventListener("click", function(e) {
                  onClick(ref, e);
                })),
                (node.className = className),
                node.appendChild(document.createTextNode(content)),
                into.appendChild(node);
            } else into.appendChild(document.createTextNode(content));
          }
          require("./utils/info-addon"),
            _codemirror2.default.registerHelper("info", "graphql", function(
              token,
              options
            ) {
              if (options.schema && token.state) {
                var state = token.state,
                  kind = state.kind,
                  step = state.step,
                  typeInfo = (0, _getTypeInfo2.default)(
                    options.schema,
                    token.state
                  );
                if (
                  ("Field" === kind && 0 === step && typeInfo.fieldDef) ||
                  ("AliasedField" === kind && 2 === step && typeInfo.fieldDef)
                ) {
                  var into = document.createElement("div");
                  return (
                    (function(into, typeInfo, options) {
                      renderQualifiedField(into, typeInfo, options),
                        renderTypeAnnotation(
                          into,
                          typeInfo,
                          options,
                          typeInfo.type
                        );
                    })(into, typeInfo, options),
                    renderDescription(into, options, typeInfo.fieldDef),
                    into
                  );
                }
                if (
                  "Directive" === kind &&
                  1 === step &&
                  typeInfo.directiveDef
                ) {
                  var _into = document.createElement("div");
                  return (
                    renderDirective(_into, typeInfo, options),
                    renderDescription(_into, options, typeInfo.directiveDef),
                    _into
                  );
                }
                if ("Argument" === kind && 0 === step && typeInfo.argDef) {
                  var _into2 = document.createElement("div");
                  return (
                    (function(into, typeInfo, options) {
                      typeInfo.directiveDef
                        ? renderDirective(into, typeInfo, options)
                        : typeInfo.fieldDef &&
                          renderQualifiedField(into, typeInfo, options);
                      var name = typeInfo.argDef.name;
                      text(into, "("),
                        text(
                          into,
                          name,
                          "arg-name",
                          options,
                          (0, _SchemaReference.getArgumentReference)(typeInfo)
                        ),
                        renderTypeAnnotation(
                          into,
                          typeInfo,
                          options,
                          typeInfo.inputType
                        ),
                        text(into, ")");
                    })(_into2, typeInfo, options),
                    renderDescription(_into2, options, typeInfo.argDef),
                    _into2
                  );
                }
                if (
                  "EnumValue" === kind &&
                  typeInfo.enumValue &&
                  typeInfo.enumValue.description
                ) {
                  var _into3 = document.createElement("div");
                  return (
                    (function(into, typeInfo, options) {
                      var name = typeInfo.enumValue.name;
                      renderType(into, typeInfo, options, typeInfo.inputType),
                        text(into, "."),
                        text(
                          into,
                          name,
                          "enum-value",
                          options,
                          (0, _SchemaReference.getEnumValueReference)(typeInfo)
                        );
                    })(_into3, typeInfo, options),
                    renderDescription(_into3, options, typeInfo.enumValue),
                    _into3
                  );
                }
                if (
                  "NamedType" === kind &&
                  typeInfo.type &&
                  typeInfo.type.description
                ) {
                  var _into4 = document.createElement("div");
                  return (
                    renderType(_into4, typeInfo, options, typeInfo.type),
                    renderDescription(_into4, options, typeInfo.type),
                    _into4
                  );
                }
              }
            });
        },
        {
          "./utils/SchemaReference": 43,
          "./utils/getTypeInfo": 45,
          "./utils/info-addon": 47,
          codemirror: 66,
          graphql: 101
        }
      ],
      39: [
        function(require, module, exports) {
          "use strict";
          var _codemirror2 = _interopRequireDefault(require("codemirror")),
            _getTypeInfo2 = _interopRequireDefault(
              require("./utils/getTypeInfo")
            ),
            _SchemaReference = require("./utils/SchemaReference");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          require("./utils/jump-addon"),
            _codemirror2.default.registerHelper("jump", "graphql", function(
              token,
              options
            ) {
              if (options.schema && options.onClick && token.state) {
                var state = token.state,
                  kind = state.kind,
                  step = state.step,
                  typeInfo = (0, _getTypeInfo2.default)(options.schema, state);
                return ("Field" === kind && 0 === step && typeInfo.fieldDef) ||
                  ("AliasedField" === kind && 2 === step && typeInfo.fieldDef)
                  ? (0, _SchemaReference.getFieldReference)(typeInfo)
                  : "Directive" === kind && 1 === step && typeInfo.directiveDef
                    ? (0, _SchemaReference.getDirectiveReference)(typeInfo)
                    : "Argument" === kind && 0 === step && typeInfo.argDef
                      ? (0, _SchemaReference.getArgumentReference)(typeInfo)
                      : "EnumValue" === kind && typeInfo.enumValue
                        ? (0, _SchemaReference.getEnumValueReference)(typeInfo)
                        : "NamedType" === kind && typeInfo.type
                          ? (0, _SchemaReference.getTypeReference)(typeInfo)
                          : void 0;
              }
            });
        },
        {
          "./utils/SchemaReference": 43,
          "./utils/getTypeInfo": 45,
          "./utils/jump-addon": 49,
          codemirror: 66
        }
      ],
      40: [
        function(require, module, exports) {
          "use strict";
          var obj,
            _codemirror = require("codemirror"),
            _codemirror2 =
              (obj = _codemirror) && obj.__esModule ? obj : { default: obj },
            _graphqlLanguageServiceInterface = require("graphql-language-service-interface");
          var SEVERITY = ["error", "warning", "information", "hint"],
            TYPE = {
              "GraphQL: Validation": "validation",
              "GraphQL: Deprecation": "deprecation",
              "GraphQL: Syntax": "syntax"
            };
          _codemirror2.default.registerHelper("lint", "graphql", function(
            text,
            options
          ) {
            var schema = options.schema;
            return (0, _graphqlLanguageServiceInterface.getDiagnostics)(
              text,
              schema
            ).map(function(error) {
              return {
                message: error.message,
                severity: SEVERITY[error.severity - 1],
                type: TYPE[error.source],
                from: _codemirror2.default.Pos(
                  error.range.start.line,
                  error.range.start.character
                ),
                to: _codemirror2.default.Pos(
                  error.range.end.line,
                  error.range.end.character
                )
              };
            });
          });
        },
        { codemirror: 66, "graphql-language-service-interface": 77 }
      ],
      41: [
        function(require, module, exports) {
          "use strict";
          var obj,
            _codemirror = require("codemirror"),
            _codemirror2 =
              (obj = _codemirror) && obj.__esModule ? obj : { default: obj },
            _graphqlLanguageServiceParser = require("graphql-language-service-parser");
          function indent(state, textAfter) {
            var levels = state.levels;
            return (
              (levels && 0 !== levels.length
                ? levels[levels.length - 1] -
                  (this.electricInput.test(textAfter) ? 1 : 0)
                : state.indentLevel) * this.config.indentUnit
            );
          }
          _codemirror2.default.defineMode("graphql", function(config) {
            var parser = (0, _graphqlLanguageServiceParser.onlineParser)({
              eatWhitespace: function(stream) {
                return stream.eatWhile(_graphqlLanguageServiceParser.isIgnored);
              },
              lexRules: _graphqlLanguageServiceParser.LexRules,
              parseRules: _graphqlLanguageServiceParser.ParseRules,
              editorConfig: { tabSize: config.tabSize }
            });
            return {
              config: config,
              startState: parser.startState,
              token: parser.token,
              indent: indent,
              electricInput: /^\s*[})\]]/,
              fold: "brace",
              lineComment: "#",
              closeBrackets: { pairs: '()[]{}""', explode: "()[]{}" }
            };
          });
        },
        { codemirror: 66, "graphql-language-service-parser": 86 }
      ],
      42: [
        function(require, module, exports) {
          "use strict";
          var obj,
            _codemirror = require("codemirror"),
            _codemirror2 =
              (obj = _codemirror) && obj.__esModule ? obj : { default: obj },
            _graphqlLanguageServiceParser = require("graphql-language-service-parser");
          function indent(state, textAfter) {
            var levels = state.levels;
            return (
              (levels && 0 !== levels.length
                ? levels[levels.length - 1] -
                  (this.electricInput.test(textAfter) ? 1 : 0)
                : state.indentLevel) * this.config.indentUnit
            );
          }
          _codemirror2.default.defineMode("graphql-results", function(config) {
            var parser = (0, _graphqlLanguageServiceParser.onlineParser)({
              eatWhitespace: function(stream) {
                return stream.eatSpace();
              },
              lexRules: LexRules,
              parseRules: ParseRules,
              editorConfig: { tabSize: config.tabSize }
            });
            return {
              config: config,
              startState: parser.startState,
              token: parser.token,
              indent: indent,
              electricInput: /^\s*[}\]]/,
              fold: "brace",
              closeBrackets: { pairs: '[]{}""', explode: "[]{}" }
            };
          });
          var LexRules = {
              Punctuation: /^\[|]|\{|\}|:|,/,
              Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
              String: /^"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?/,
              Keyword: /^true|false|null/
            },
            ParseRules = {
              Document: [
                (0, _graphqlLanguageServiceParser.p)("{"),
                (0, _graphqlLanguageServiceParser.list)(
                  "Entry",
                  (0, _graphqlLanguageServiceParser.p)(",")
                ),
                (0, _graphqlLanguageServiceParser.p)("}")
              ],
              Entry: [
                (0, _graphqlLanguageServiceParser.t)("String", "def"),
                (0, _graphqlLanguageServiceParser.p)(":"),
                "Value"
              ],
              Value: function(token) {
                switch (token.kind) {
                  case "Number":
                    return "NumberValue";
                  case "String":
                    return "StringValue";
                  case "Punctuation":
                    switch (token.value) {
                      case "[":
                        return "ListValue";
                      case "{":
                        return "ObjectValue";
                    }
                    return null;
                  case "Keyword":
                    switch (token.value) {
                      case "true":
                      case "false":
                        return "BooleanValue";
                      case "null":
                        return "NullValue";
                    }
                    return null;
                }
              },
              NumberValue: [
                (0, _graphqlLanguageServiceParser.t)("Number", "number")
              ],
              StringValue: [
                (0, _graphqlLanguageServiceParser.t)("String", "string")
              ],
              BooleanValue: [
                (0, _graphqlLanguageServiceParser.t)("Keyword", "builtin")
              ],
              NullValue: [
                (0, _graphqlLanguageServiceParser.t)("Keyword", "keyword")
              ],
              ListValue: [
                (0, _graphqlLanguageServiceParser.p)("["),
                (0, _graphqlLanguageServiceParser.list)(
                  "Value",
                  (0, _graphqlLanguageServiceParser.p)(",")
                ),
                (0, _graphqlLanguageServiceParser.p)("]")
              ],
              ObjectValue: [
                (0, _graphqlLanguageServiceParser.p)("{"),
                (0, _graphqlLanguageServiceParser.list)(
                  "ObjectField",
                  (0, _graphqlLanguageServiceParser.p)(",")
                ),
                (0, _graphqlLanguageServiceParser.p)("}")
              ],
              ObjectField: [
                (0, _graphqlLanguageServiceParser.t)("String", "property"),
                (0, _graphqlLanguageServiceParser.p)(":"),
                "Value"
              ]
            };
        },
        { codemirror: 66, "graphql-language-service-parser": 86 }
      ],
      43: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.getFieldReference = function(typeInfo) {
              return {
                kind: "Field",
                schema: typeInfo.schema,
                field: typeInfo.fieldDef,
                type: isMetaField(typeInfo.fieldDef)
                  ? null
                  : typeInfo.parentType
              };
            }),
            (exports.getDirectiveReference = function(typeInfo) {
              return {
                kind: "Directive",
                schema: typeInfo.schema,
                directive: typeInfo.directiveDef
              };
            }),
            (exports.getArgumentReference = function(typeInfo) {
              return typeInfo.directiveDef
                ? {
                    kind: "Argument",
                    schema: typeInfo.schema,
                    argument: typeInfo.argDef,
                    directive: typeInfo.directiveDef
                  }
                : {
                    kind: "Argument",
                    schema: typeInfo.schema,
                    argument: typeInfo.argDef,
                    field: typeInfo.fieldDef,
                    type: isMetaField(typeInfo.fieldDef)
                      ? null
                      : typeInfo.parentType
                  };
            }),
            (exports.getEnumValueReference = function(typeInfo) {
              return {
                kind: "EnumValue",
                value: typeInfo.enumValue,
                type: (0, _graphql.getNamedType)(typeInfo.inputType)
              };
            }),
            (exports.getTypeReference = function(typeInfo, type) {
              return {
                kind: "Type",
                schema: typeInfo.schema,
                type: type || typeInfo.type
              };
            });
          var _graphql = require("graphql");
          function isMetaField(fieldDef) {
            return "__" === fieldDef.name.slice(0, 2);
          }
        },
        { graphql: 101 }
      ],
      44: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(stack, fn) {
              var reverseStateStack = [],
                state = stack;
              for (; state && state.kind; )
                reverseStateStack.push(state), (state = state.prevState);
              for (var i = reverseStateStack.length - 1; 0 <= i; i--)
                fn(reverseStateStack[i]);
            });
        },
        {}
      ],
      45: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(schema, tokenState) {
              var info = {
                schema: schema,
                type: null,
                parentType: null,
                inputType: null,
                directiveDef: null,
                fieldDef: null,
                argDef: null,
                argDefs: null,
                objectFieldDefs: null
              };
              return (
                (0, _forEachState2.default)(tokenState, function(state) {
                  switch (state.kind) {
                    case "Query":
                    case "ShortQuery":
                      info.type = schema.getQueryType();
                      break;
                    case "Mutation":
                      info.type = schema.getMutationType();
                      break;
                    case "Subscription":
                      info.type = schema.getSubscriptionType();
                      break;
                    case "InlineFragment":
                    case "FragmentDefinition":
                      state.type && (info.type = schema.getType(state.type));
                      break;
                    case "Field":
                    case "AliasedField":
                      (info.fieldDef =
                        info.type && state.name
                          ? getFieldDef(schema, info.parentType, state.name)
                          : null),
                        (info.type = info.fieldDef && info.fieldDef.type);
                      break;
                    case "SelectionSet":
                      info.parentType = (0, _graphql.getNamedType)(info.type);
                      break;
                    case "Directive":
                      info.directiveDef =
                        state.name && schema.getDirective(state.name);
                      break;
                    case "Arguments":
                      var parentDef =
                        "Field" === state.prevState.kind
                          ? info.fieldDef
                          : "Directive" === state.prevState.kind
                            ? info.directiveDef
                            : "AliasedField" === state.prevState.kind
                              ? state.prevState.name &&
                                getFieldDef(
                                  schema,
                                  info.parentType,
                                  state.prevState.name
                                )
                              : null;
                      info.argDefs = parentDef && parentDef.args;
                      break;
                    case "Argument":
                      if (((info.argDef = null), info.argDefs))
                        for (var i = 0; i < info.argDefs.length; i++)
                          if (info.argDefs[i].name === state.name) {
                            info.argDef = info.argDefs[i];
                            break;
                          }
                      info.inputType = info.argDef && info.argDef.type;
                      break;
                    case "EnumValue":
                      var enumType = (0, _graphql.getNamedType)(info.inputType);
                      info.enumValue =
                        enumType instanceof _graphql.GraphQLEnumType
                          ? (function(array, predicate) {
                              for (var i = 0; i < array.length; i++)
                                if (predicate(array[i])) return array[i];
                            })(enumType.getValues(), function(val) {
                              return val.value === state.name;
                            })
                          : null;
                      break;
                    case "ListValue":
                      var nullableType = (0, _graphql.getNullableType)(
                        info.inputType
                      );
                      info.inputType =
                        nullableType instanceof _graphql.GraphQLList
                          ? nullableType.ofType
                          : null;
                      break;
                    case "ObjectValue":
                      var objectType = (0, _graphql.getNamedType)(
                        info.inputType
                      );
                      info.objectFieldDefs =
                        objectType instanceof _graphql.GraphQLInputObjectType
                          ? objectType.getFields()
                          : null;
                      break;
                    case "ObjectField":
                      var objectField =
                        state.name && info.objectFieldDefs
                          ? info.objectFieldDefs[state.name]
                          : null;
                      info.inputType = objectField && objectField.type;
                      break;
                    case "NamedType":
                      info.type = schema.getType(state.name);
                  }
                }),
                info
              );
            });
          var obj,
            _graphql = require("graphql"),
            _introspection = require("graphql/type/introspection"),
            _forEachState = require("./forEachState"),
            _forEachState2 =
              (obj = _forEachState) && obj.__esModule ? obj : { default: obj };
          function getFieldDef(schema, type, fieldName) {
            return fieldName === _introspection.SchemaMetaFieldDef.name &&
              schema.getQueryType() === type
              ? _introspection.SchemaMetaFieldDef
              : fieldName === _introspection.TypeMetaFieldDef.name &&
                schema.getQueryType() === type
                ? _introspection.TypeMetaFieldDef
                : fieldName === _introspection.TypeNameMetaFieldDef.name &&
                  (0, _graphql.isCompositeType)(type)
                  ? _introspection.TypeNameMetaFieldDef
                  : type.getFields ? type.getFields()[fieldName] : void 0;
          }
        },
        {
          "./forEachState": 44,
          graphql: 101,
          "graphql/type/introspection": 124
        }
      ],
      46: [
        function(require, module, exports) {
          "use strict";
          function filterNonEmpty(array, predicate) {
            var filtered = array.filter(predicate);
            return 0 === filtered.length ? array : filtered;
          }
          function normalizeText(text) {
            return text.toLowerCase().replace(/\W/g, "");
          }
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(cursor, token, list) {
              var hints = (function(list, text) {
                if (!text)
                  return filterNonEmpty(list, function(entry) {
                    return !entry.isDeprecated;
                  });
                return filterNonEmpty(
                  filterNonEmpty(
                    list.map(function(entry) {
                      return {
                        proximity: (function(suggestion, text) {
                          var proximity = (function(a, b) {
                            var i = void 0,
                              j = void 0,
                              d = [],
                              aLength = a.length,
                              bLength = b.length;
                            for (i = 0; i <= aLength; i++) d[i] = [i];
                            for (j = 1; j <= bLength; j++) d[0][j] = j;
                            for (i = 1; i <= aLength; i++)
                              for (j = 1; j <= bLength; j++) {
                                var cost = a[i - 1] === b[j - 1] ? 0 : 1;
                                (d[i][j] = Math.min(
                                  d[i - 1][j] + 1,
                                  d[i][j - 1] + 1,
                                  d[i - 1][j - 1] + cost
                                )),
                                  1 < i &&
                                    1 < j &&
                                    a[i - 1] === b[j - 2] &&
                                    a[i - 2] === b[j - 1] &&
                                    (d[i][j] = Math.min(
                                      d[i][j],
                                      d[i - 2][j - 2] + cost
                                    ));
                              }
                            return d[aLength][bLength];
                          })(text, suggestion);
                          suggestion.length > text.length &&
                            ((proximity -= suggestion.length - text.length - 1),
                            (proximity +=
                              0 === suggestion.indexOf(text) ? 0 : 0.5));
                          return proximity;
                        })(normalizeText(entry.text), text),
                        entry: entry
                      };
                    }),
                    function(pair) {
                      return pair.proximity <= 2;
                    }
                  ),
                  function(pair) {
                    return !pair.entry.isDeprecated;
                  }
                )
                  .sort(function(a, b) {
                    return (
                      (a.entry.isDeprecated ? 1 : 0) -
                        (b.entry.isDeprecated ? 1 : 0) ||
                      a.proximity - b.proximity ||
                      a.entry.text.length - b.entry.text.length
                    );
                  })
                  .map(function(pair) {
                    return pair.entry;
                  });
              })(list, normalizeText(token.string));
              if (!hints) return;
              var tokenStart =
                null !== token.type && /"|\w/.test(token.string[0])
                  ? token.start
                  : token.end;
              return {
                list: hints,
                from: { line: cursor.line, column: tokenStart },
                to: { line: cursor.line, column: token.end }
              };
            });
        },
        {}
      ],
      47: [
        function(require, module, exports) {
          "use strict";
          var obj,
            _codemirror = require("codemirror"),
            _codemirror2 =
              (obj = _codemirror) && obj.__esModule ? obj : { default: obj };
          _codemirror2.default.defineOption("info", !1, function(
            cm,
            options,
            old
          ) {
            if (old && old !== _codemirror2.default.Init) {
              var oldOnMouseOver = cm.state.info.onMouseOver;
              _codemirror2.default.off(
                cm.getWrapperElement(),
                "mouseover",
                oldOnMouseOver
              ),
                clearTimeout(cm.state.info.hoverTimeout),
                delete cm.state.info;
            }
            if (options) {
              var state = (cm.state.info = (function(options) {
                return {
                  options:
                    options instanceof Function
                      ? { render: options }
                      : !0 === options ? {} : options
                };
              })(options));
              (state.onMouseOver = function(cm, e) {
                var state = cm.state.info,
                  target = e.target || e.srcElement;
                if ("SPAN" !== target.nodeName || void 0 !== state.hoverTimeout)
                  return;
                var box = target.getBoundingClientRect(),
                  hoverTime = (function(cm) {
                    var options = cm.state.info.options;
                    return (options && options.hoverTime) || 500;
                  })(cm);
                state.hoverTimeout = setTimeout(onHover, hoverTime);
                var onMouseMove = function() {
                    clearTimeout(state.hoverTimeout),
                      (state.hoverTimeout = setTimeout(onHover, hoverTime));
                  },
                  onMouseOut = function onMouseOut() {
                    _codemirror2.default.off(
                      document,
                      "mousemove",
                      onMouseMove
                    ),
                      _codemirror2.default.off(
                        cm.getWrapperElement(),
                        "mouseout",
                        onMouseOut
                      ),
                      clearTimeout(state.hoverTimeout),
                      (state.hoverTimeout = void 0);
                  },
                  onHover = function() {
                    _codemirror2.default.off(
                      document,
                      "mousemove",
                      onMouseMove
                    ),
                      _codemirror2.default.off(
                        cm.getWrapperElement(),
                        "mouseout",
                        onMouseOut
                      ),
                      (state.hoverTimeout = void 0),
                      (function(cm, box) {
                        var pos = cm.coordsChar({
                            left: (box.left + box.right) / 2,
                            top: (box.top + box.bottom) / 2
                          }),
                          options = cm.state.info.options,
                          render = options.render || cm.getHelper(pos, "info");
                        if (render) {
                          var token = cm.getTokenAt(pos, !0);
                          if (token) {
                            var info = render(token, options, cm, pos);
                            info &&
                              (function(cm, box, info) {
                                var popup = document.createElement("div");
                                (popup.className = "CodeMirror-info"),
                                  popup.appendChild(info),
                                  document.body.appendChild(popup);
                                var popupBox = popup.getBoundingClientRect(),
                                  popupStyle =
                                    popup.currentStyle ||
                                    window.getComputedStyle(popup),
                                  popupWidth =
                                    popupBox.right -
                                    popupBox.left +
                                    parseFloat(popupStyle.marginLeft) +
                                    parseFloat(popupStyle.marginRight),
                                  popupHeight =
                                    popupBox.bottom -
                                    popupBox.top +
                                    parseFloat(popupStyle.marginTop) +
                                    parseFloat(popupStyle.marginBottom),
                                  topPos = box.bottom;
                                popupHeight >
                                  window.innerHeight - box.bottom - 15 &&
                                  box.top > window.innerHeight - box.bottom &&
                                  (topPos = box.top - popupHeight);
                                topPos < 0 && (topPos = box.bottom);
                                var leftPos = Math.max(
                                  0,
                                  window.innerWidth - popupWidth - 15
                                );
                                leftPos > box.left && (leftPos = box.left);
                                (popup.style.opacity = 1),
                                  (popup.style.top = topPos + "px"),
                                  (popup.style.left = leftPos + "px");
                                var popupTimeout = void 0,
                                  onMouseOverPopup = function() {
                                    clearTimeout(popupTimeout);
                                  },
                                  onMouseOut = function() {
                                    clearTimeout(popupTimeout),
                                      (popupTimeout = setTimeout(
                                        hidePopup,
                                        200
                                      ));
                                  },
                                  hidePopup = function() {
                                    _codemirror2.default.off(
                                      popup,
                                      "mouseover",
                                      onMouseOverPopup
                                    ),
                                      _codemirror2.default.off(
                                        popup,
                                        "mouseout",
                                        onMouseOut
                                      ),
                                      _codemirror2.default.off(
                                        cm.getWrapperElement(),
                                        "mouseout",
                                        onMouseOut
                                      ),
                                      popup.style.opacity
                                        ? ((popup.style.opacity = 0),
                                          setTimeout(function() {
                                            popup.parentNode &&
                                              popup.parentNode.removeChild(
                                                popup
                                              );
                                          }, 600))
                                        : popup.parentNode &&
                                          popup.parentNode.removeChild(popup);
                                  };
                                _codemirror2.default.on(
                                  popup,
                                  "mouseover",
                                  onMouseOverPopup
                                ),
                                  _codemirror2.default.on(
                                    popup,
                                    "mouseout",
                                    onMouseOut
                                  ),
                                  _codemirror2.default.on(
                                    cm.getWrapperElement(),
                                    "mouseout",
                                    onMouseOut
                                  );
                              })(cm, box, info);
                          }
                        }
                      })(cm, box);
                  };
                _codemirror2.default.on(document, "mousemove", onMouseMove),
                  _codemirror2.default.on(
                    cm.getWrapperElement(),
                    "mouseout",
                    onMouseOut
                  );
              }.bind(null, cm)),
                _codemirror2.default.on(
                  cm.getWrapperElement(),
                  "mouseover",
                  state.onMouseOver
                );
            }
          });
        },
        { codemirror: 66 }
      ],
      48: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(str) {
              (strLen = (string = str).length),
                (start = end = lastEnd = -1),
                ch(),
                lex();
              var ast = parseObj();
              return expect("EOF"), ast;
            });
          var string = void 0,
            strLen = void 0,
            start = void 0,
            end = void 0,
            lastEnd = void 0,
            code = void 0,
            kind = void 0;
          function parseObj() {
            var nodeStart = start,
              members = [];
            if ((expect("{"), !skip("}"))) {
              for (; members.push(parseMember()), skip(","); );
              expect("}");
            }
            return {
              kind: "Object",
              start: nodeStart,
              end: lastEnd,
              members: members
            };
          }
          function parseMember() {
            var nodeStart = start,
              key = "String" === kind ? curToken() : null;
            expect("String"), expect(":");
            var value = parseVal();
            return {
              kind: "Member",
              start: nodeStart,
              end: lastEnd,
              key: key,
              value: value
            };
          }
          function parseVal() {
            switch (kind) {
              case "[":
                return (function() {
                  var nodeStart = start,
                    values = [];
                  if ((expect("["), !skip("]"))) {
                    for (; values.push(parseVal()), skip(","); );
                    expect("]");
                  }
                  return {
                    kind: "Array",
                    start: nodeStart,
                    end: lastEnd,
                    values: values
                  };
                })();
              case "{":
                return parseObj();
              case "String":
              case "Number":
              case "Boolean":
              case "Null":
                var token = curToken();
                return lex(), token;
            }
            return expect("Value");
          }
          function curToken() {
            return {
              kind: kind,
              start: start,
              end: end,
              value: JSON.parse(string.slice(start, end))
            };
          }
          function expect(str) {
            if (kind !== str) {
              var found = void 0;
              if ("EOF" === kind) found = "[end of file]";
              else if (1 < end - start)
                found = "`" + string.slice(start, end) + "`";
              else {
                var match = string.slice(start).match(/^.+?\b/);
                found = "`" + (match ? match[0] : string[start]) + "`";
              }
              throw syntaxError(
                "Expected " + str + " but found " + found + "."
              );
            }
            lex();
          }
          function syntaxError(message) {
            return { message: message, start: start, end: end };
          }
          function skip(k) {
            if (kind === k) return lex(), !0;
          }
          function ch() {
            end < strLen &&
              (code = ++end === strLen ? 0 : string.charCodeAt(end));
          }
          function lex() {
            for (
              lastEnd = end;
              9 === code || 10 === code || 13 === code || 32 === code;

            )
              ch();
            if (0 !== code) {
              switch (((start = end), code)) {
                case 34:
                  return (
                    (kind = "String"),
                    (function() {
                      ch();
                      for (; 34 !== code && 31 < code; )
                        if (92 === code)
                          switch ((ch(), code)) {
                            case 34:
                            case 47:
                            case 92:
                            case 98:
                            case 102:
                            case 110:
                            case 114:
                            case 116:
                              ch();
                              break;
                            case 117:
                              ch(), readHex(), readHex(), readHex(), readHex();
                              break;
                            default:
                              throw syntaxError(
                                "Bad character escape sequence."
                              );
                          }
                        else {
                          if (end === strLen)
                            throw syntaxError("Unterminated string.");
                          ch();
                        }
                      if (34 === code) return void ch();
                      throw syntaxError("Unterminated string.");
                    })()
                  );
                case 45:
                case 48:
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                  return (
                    (kind = "Number"),
                    (function() {
                      45 === code && ch();
                      48 === code ? ch() : readDigits();
                      46 === code && (ch(), readDigits());
                      (69 !== code && 101 !== code) ||
                        (ch(),
                        (43 !== code && 45 !== code) || ch(),
                        readDigits());
                    })()
                  );
                case 102:
                  if ("false" !== string.slice(start, start + 5)) break;
                  return (end += 4), ch(), void (kind = "Boolean");
                case 110:
                  if ("null" !== string.slice(start, start + 4)) break;
                  return (end += 3), ch(), void (kind = "Null");
                case 116:
                  if ("true" !== string.slice(start, start + 4)) break;
                  return (end += 3), ch(), void (kind = "Boolean");
              }
              (kind = string[start]), ch();
            } else kind = "EOF";
          }
          function readHex() {
            if (
              (48 <= code && code <= 57) ||
              (65 <= code && code <= 70) ||
              (97 <= code && code <= 102)
            )
              return ch();
            throw syntaxError("Expected hexadecimal digit.");
          }
          function readDigits() {
            if (code < 48 || 57 < code)
              throw syntaxError("Expected decimal digit.");
            for (; ch(), 48 <= code && code <= 57; );
          }
        },
        {}
      ],
      49: [
        function(require, module, exports) {
          "use strict";
          var obj,
            _codemirror = require("codemirror"),
            _codemirror2 =
              (obj = _codemirror) && obj.__esModule ? obj : { default: obj };
          _codemirror2.default.defineOption("jump", !1, function(
            cm,
            options,
            old
          ) {
            if (old && old !== _codemirror2.default.Init) {
              var oldOnMouseOver = cm.state.jump.onMouseOver;
              _codemirror2.default.off(
                cm.getWrapperElement(),
                "mouseover",
                oldOnMouseOver
              );
              var oldOnMouseOut = cm.state.jump.onMouseOut;
              _codemirror2.default.off(
                cm.getWrapperElement(),
                "mouseout",
                oldOnMouseOut
              ),
                _codemirror2.default.off(
                  document,
                  "keydown",
                  cm.state.jump.onKeyDown
                ),
                delete cm.state.jump;
            }
            if (options) {
              var state = (cm.state.jump = {
                options: options,
                onMouseOver: function(cm, event) {
                  var target = event.target || event.srcElement;
                  if ("SPAN" !== target.nodeName) return;
                  var box = target.getBoundingClientRect(),
                    cursor = {
                      left: (box.left + box.right) / 2,
                      top: (box.top + box.bottom) / 2
                    };
                  (cm.state.jump.cursor = cursor),
                    cm.state.jump.isHoldingModifier && enableJumpMode(cm);
                }.bind(null, cm),
                onMouseOut: function(cm) {
                  if (!cm.state.jump.isHoldingModifier && cm.state.jump.cursor)
                    return void (cm.state.jump.cursor = null);
                  cm.state.jump.isHoldingModifier &&
                    cm.state.jump.marker &&
                    disableJumpMode(cm);
                }.bind(null, cm),
                onKeyDown: function(cm, event) {
                  if (
                    cm.state.jump.isHoldingModifier ||
                    ((key = event.key), key !== (isMac ? "Meta" : "Control"))
                  )
                    return;
                  var key;
                  (cm.state.jump.isHoldingModifier = !0),
                    cm.state.jump.cursor && enableJumpMode(cm);
                  var onClick = function(clickEvent) {
                      var destination = cm.state.jump.destination;
                      destination &&
                        cm.state.jump.options.onClick(destination, clickEvent);
                    },
                    onMouseDown = function(_, downEvent) {
                      cm.state.jump.destination &&
                        (downEvent.codemirrorIgnore = !0);
                    };
                  _codemirror2.default.on(document, "keyup", function onKeyUp(
                    upEvent
                  ) {
                    if (upEvent.code !== event.code) return;
                    (cm.state.jump.isHoldingModifier = !1),
                      cm.state.jump.marker && disableJumpMode(cm);
                    _codemirror2.default.off(document, "keyup", onKeyUp),
                      _codemirror2.default.off(document, "click", onClick),
                      cm.off("mousedown", onMouseDown);
                  }),
                    _codemirror2.default.on(document, "click", onClick),
                    cm.on("mousedown", onMouseDown);
                }.bind(null, cm)
              });
              _codemirror2.default.on(
                cm.getWrapperElement(),
                "mouseover",
                state.onMouseOver
              ),
                _codemirror2.default.on(
                  cm.getWrapperElement(),
                  "mouseout",
                  state.onMouseOut
                ),
                _codemirror2.default.on(document, "keydown", state.onKeyDown);
            }
          });
          var isMac = navigator && -1 !== navigator.appVersion.indexOf("Mac");
          function enableJumpMode(cm) {
            if (!cm.state.jump.marker) {
              var cursor = cm.state.jump.cursor,
                pos = cm.coordsChar(cursor),
                token = cm.getTokenAt(pos, !0),
                options = cm.state.jump.options,
                getDestination =
                  options.getDestination || cm.getHelper(pos, "jump");
              if (getDestination) {
                var destination = getDestination(token, options, cm);
                if (destination) {
                  var marker = cm.markText(
                    { line: pos.line, ch: token.start },
                    { line: pos.line, ch: token.end },
                    { className: "CodeMirror-jump-token" }
                  );
                  (cm.state.jump.marker = marker),
                    (cm.state.jump.destination = destination);
                }
              }
            }
          }
          function disableJumpMode(cm) {
            var marker = cm.state.jump.marker;
            (cm.state.jump.marker = null),
              (cm.state.jump.destination = null),
              marker.clear();
          }
        },
        { codemirror: 66 }
      ],
      50: [
        function(require, module, exports) {
          "use strict";
          var _codemirror2 = _interopRequireDefault(require("codemirror")),
            _graphql = require("graphql"),
            _forEachState2 = _interopRequireDefault(
              require("../utils/forEachState")
            ),
            _hintList2 = _interopRequireDefault(require("../utils/hintList"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          _codemirror2.default.registerHelper(
            "hint",
            "graphql-variables",
            function(editor, options) {
              var cur = editor.getCursor(),
                token = editor.getTokenAt(cur),
                results = (function(cur, token, options) {
                  var state =
                      "Invalid" === token.state.kind
                        ? token.state.prevState
                        : token.state,
                    kind = state.kind,
                    step = state.step;
                  if ("Document" === kind && 0 === step)
                    return (0, _hintList2.default)(cur, token, [{ text: "{" }]);
                  var variableToType = options.variableToType;
                  if (!variableToType) return;
                  var typeInfo = (function(variableToType, tokenState) {
                    var info = { type: null, fields: null };
                    return (
                      (0, _forEachState2.default)(tokenState, function(state) {
                        if ("Variable" === state.kind)
                          info.type = variableToType[state.name];
                        else if ("ListValue" === state.kind) {
                          var nullableType = (0, _graphql.getNullableType)(
                            info.type
                          );
                          info.type =
                            nullableType instanceof _graphql.GraphQLList
                              ? nullableType.ofType
                              : null;
                        } else if ("ObjectValue" === state.kind) {
                          var objectType = (0, _graphql.getNamedType)(
                            info.type
                          );
                          info.fields =
                            objectType instanceof
                            _graphql.GraphQLInputObjectType
                              ? objectType.getFields()
                              : null;
                        } else if ("ObjectField" === state.kind) {
                          var objectField =
                            state.name && info.fields
                              ? info.fields[state.name]
                              : null;
                          info.type = objectField && objectField.type;
                        }
                      }),
                      info
                    );
                  })(variableToType, token.state);
                  if (
                    "Document" === kind ||
                    ("Variable" === kind && 0 === step)
                  ) {
                    var variableNames = Object.keys(variableToType);
                    return (0, _hintList2.default)(
                      cur,
                      token,
                      variableNames.map(function(name) {
                        return {
                          text: '"' + name + '": ',
                          type: variableToType[name]
                        };
                      })
                    );
                  }
                  if (
                    ("ObjectValue" === kind ||
                      ("ObjectField" === kind && 0 === step)) &&
                    typeInfo.fields
                  ) {
                    var inputFields = Object.keys(typeInfo.fields).map(function(
                      fieldName
                    ) {
                      return typeInfo.fields[fieldName];
                    });
                    return (0, _hintList2.default)(
                      cur,
                      token,
                      inputFields.map(function(field) {
                        return {
                          text: '"' + field.name + '": ',
                          type: field.type,
                          description: field.description
                        };
                      })
                    );
                  }
                  if (
                    "StringValue" === kind ||
                    "NumberValue" === kind ||
                    "BooleanValue" === kind ||
                    "NullValue" === kind ||
                    ("ListValue" === kind && 1 === step) ||
                    ("ObjectField" === kind && 2 === step) ||
                    ("Variable" === kind && 2 === step)
                  ) {
                    var namedInputType = (0, _graphql.getNamedType)(
                      typeInfo.type
                    );
                    if (
                      namedInputType instanceof _graphql.GraphQLInputObjectType
                    )
                      return (0, _hintList2.default)(cur, token, [
                        { text: "{" }
                      ]);
                    if (namedInputType instanceof _graphql.GraphQLEnumType) {
                      var valueMap = namedInputType.getValues(),
                        values = Object.keys(valueMap).map(function(name) {
                          return valueMap[name];
                        });
                      return (0, _hintList2.default)(
                        cur,
                        token,
                        values.map(function(value) {
                          return {
                            text: '"' + value.name + '"',
                            type: namedInputType,
                            description: value.description
                          };
                        })
                      );
                    }
                    if (namedInputType === _graphql.GraphQLBoolean)
                      return (0, _hintList2.default)(cur, token, [
                        {
                          text: "true",
                          type: _graphql.GraphQLBoolean,
                          description: "Not false."
                        },
                        {
                          text: "false",
                          type: _graphql.GraphQLBoolean,
                          description: "Not true."
                        }
                      ]);
                  }
                })(cur, token, options);
              return (
                results &&
                  results.list &&
                  0 < results.list.length &&
                  ((results.from = _codemirror2.default.Pos(
                    results.from.line,
                    results.from.column
                  )),
                  (results.to = _codemirror2.default.Pos(
                    results.to.line,
                    results.to.column
                  )),
                  _codemirror2.default.signal(
                    editor,
                    "hasCompletion",
                    editor,
                    results,
                    token
                  )),
                results
              );
            }
          );
        },
        {
          "../utils/forEachState": 44,
          "../utils/hintList": 46,
          codemirror: 66,
          graphql: 101
        }
      ],
      51: [
        function(require, module, exports) {
          "use strict";
          var _codemirror2 = _interopRequireDefault(require("codemirror")),
            _graphql = require("graphql"),
            _jsonParse2 = _interopRequireDefault(require("../utils/jsonParse"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function lintError(editor, node, message) {
            return {
              message: message,
              severity: "error",
              type: "validation",
              from: editor.posFromIndex(node.start),
              to: editor.posFromIndex(node.end)
            };
          }
          function mapCat(array, mapper) {
            return Array.prototype.concat.apply([], array.map(mapper));
          }
          _codemirror2.default.registerHelper(
            "lint",
            "graphql-variables",
            function(text, options, editor) {
              if (!text) return [];
              var ast = void 0;
              try {
                ast = (0, _jsonParse2.default)(text);
              } catch (syntaxError) {
                if (syntaxError.stack) throw syntaxError;
                return [lintError(editor, syntaxError, syntaxError.message)];
              }
              var variableToType = options.variableToType;
              return variableToType
                ? (function(editor, variableToType, variablesAST) {
                    var errors = [];
                    return (
                      variablesAST.members.forEach(function(member) {
                        var variableName = member.key.value,
                          type = variableToType[variableName];
                        type
                          ? (function validateValue(type, valueAST) {
                              if (type instanceof _graphql.GraphQLNonNull)
                                return "Null" === valueAST.kind
                                  ? [
                                      [
                                        valueAST,
                                        'Type "' +
                                          type +
                                          '" is non-nullable and cannot be null.'
                                      ]
                                    ]
                                  : validateValue(type.ofType, valueAST);
                              if ("Null" === valueAST.kind) return [];
                              if (type instanceof _graphql.GraphQLList) {
                                var itemType = type.ofType;
                                return "Array" === valueAST.kind
                                  ? mapCat(valueAST.values, function(item) {
                                      return validateValue(itemType, item);
                                    })
                                  : validateValue(itemType, valueAST);
                              }
                              if (
                                type instanceof _graphql.GraphQLInputObjectType
                              ) {
                                if ("Object" !== valueAST.kind)
                                  return [
                                    [
                                      valueAST,
                                      'Type "' + type + '" must be an Object.'
                                    ]
                                  ];
                                var providedFields = Object.create(null),
                                  fieldErrors = mapCat(
                                    valueAST.members,
                                    function(member) {
                                      var fieldName = member.key.value;
                                      providedFields[fieldName] = !0;
                                      var inputField = type.getFields()[
                                        fieldName
                                      ];
                                      if (!inputField)
                                        return [
                                          [
                                            member.key,
                                            'Type "' +
                                              type +
                                              '" does not have a field "' +
                                              fieldName +
                                              '".'
                                          ]
                                        ];
                                      var fieldType = inputField
                                        ? inputField.type
                                        : void 0;
                                      return validateValue(
                                        fieldType,
                                        member.value
                                      );
                                    }
                                  );
                                return (
                                  Object.keys(type.getFields()).forEach(
                                    function(fieldName) {
                                      if (!providedFields[fieldName]) {
                                        var fieldType = type.getFields()[
                                          fieldName
                                        ].type;
                                        fieldType instanceof
                                          _graphql.GraphQLNonNull &&
                                          fieldErrors.push([
                                            valueAST,
                                            'Object of type "' +
                                              type +
                                              '" is missing required field "' +
                                              fieldName +
                                              '".'
                                          ]);
                                      }
                                    }
                                  ),
                                  fieldErrors
                                );
                              }
                              return ("Boolean" === type.name &&
                                "Boolean" !== valueAST.kind) ||
                                ("String" === type.name &&
                                  "String" !== valueAST.kind) ||
                                ("ID" === type.name &&
                                  "Number" !== valueAST.kind &&
                                  "String" !== valueAST.kind) ||
                                ("Float" === type.name &&
                                  "Number" !== valueAST.kind) ||
                                ("Int" === type.name &&
                                  ("Number" !== valueAST.kind ||
                                    (0 | valueAST.value) !== valueAST.value))
                                ? [
                                    [
                                      valueAST,
                                      'Expected value of type "' + type + '".'
                                    ]
                                  ]
                                : (type instanceof _graphql.GraphQLEnumType ||
                                    type instanceof
                                      _graphql.GraphQLScalarType) &&
                                  (("String" !== valueAST.kind &&
                                    "Number" !== valueAST.kind &&
                                    "Boolean" !== valueAST.kind &&
                                    "Null" !== valueAST.kind) ||
                                    null ==
                                      (value = type.parseValue(
                                        valueAST.value
                                      )) ||
                                    value != value)
                                  ? [
                                      [
                                        valueAST,
                                        'Expected value of type "' + type + '".'
                                      ]
                                    ]
                                  : [];
                              var value;
                            })(type, member.value).forEach(function(_ref) {
                              var node = _ref[0],
                                message = _ref[1];
                              errors.push(lintError(editor, node, message));
                            })
                          : errors.push(
                              lintError(
                                editor,
                                member.key,
                                'Variable "$' +
                                  variableName +
                                  '" does not appear in any GraphQL query.'
                              )
                            );
                      }),
                      errors
                    );
                  })(editor, variableToType, ast)
                : [];
            }
          );
        },
        { "../utils/jsonParse": 48, codemirror: 66, graphql: 101 }
      ],
      52: [
        function(require, module, exports) {
          "use strict";
          var obj,
            _codemirror = require("codemirror"),
            _codemirror2 =
              (obj = _codemirror) && obj.__esModule ? obj : { default: obj },
            _graphqlLanguageServiceParser = require("graphql-language-service-parser");
          function indent(state, textAfter) {
            var levels = state.levels;
            return (
              (levels && 0 !== levels.length
                ? levels[levels.length - 1] -
                  (this.electricInput.test(textAfter) ? 1 : 0)
                : state.indentLevel) * this.config.indentUnit
            );
          }
          _codemirror2.default.defineMode("graphql-variables", function(
            config
          ) {
            var parser = (0, _graphqlLanguageServiceParser.onlineParser)({
              eatWhitespace: function(stream) {
                return stream.eatSpace();
              },
              lexRules: LexRules,
              parseRules: ParseRules,
              editorConfig: { tabSize: config.tabSize }
            });
            return {
              config: config,
              startState: parser.startState,
              token: parser.token,
              indent: indent,
              electricInput: /^\s*[}\]]/,
              fold: "brace",
              closeBrackets: { pairs: '[]{}""', explode: "[]{}" }
            };
          });
          var LexRules = {
              Punctuation: /^\[|]|\{|\}|:|,/,
              Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
              String: /^"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?/,
              Keyword: /^true|false|null/
            },
            ParseRules = {
              Document: [
                (0, _graphqlLanguageServiceParser.p)("{"),
                (0, _graphqlLanguageServiceParser.list)(
                  "Variable",
                  (0, _graphqlLanguageServiceParser.opt)(
                    (0, _graphqlLanguageServiceParser.p)(",")
                  )
                ),
                (0, _graphqlLanguageServiceParser.p)("}")
              ],
              Variable: [
                namedKey("variable"),
                (0, _graphqlLanguageServiceParser.p)(":"),
                "Value"
              ],
              Value: function(token) {
                switch (token.kind) {
                  case "Number":
                    return "NumberValue";
                  case "String":
                    return "StringValue";
                  case "Punctuation":
                    switch (token.value) {
                      case "[":
                        return "ListValue";
                      case "{":
                        return "ObjectValue";
                    }
                    return null;
                  case "Keyword":
                    switch (token.value) {
                      case "true":
                      case "false":
                        return "BooleanValue";
                      case "null":
                        return "NullValue";
                    }
                    return null;
                }
              },
              NumberValue: [
                (0, _graphqlLanguageServiceParser.t)("Number", "number")
              ],
              StringValue: [
                (0, _graphqlLanguageServiceParser.t)("String", "string")
              ],
              BooleanValue: [
                (0, _graphqlLanguageServiceParser.t)("Keyword", "builtin")
              ],
              NullValue: [
                (0, _graphqlLanguageServiceParser.t)("Keyword", "keyword")
              ],
              ListValue: [
                (0, _graphqlLanguageServiceParser.p)("["),
                (0, _graphqlLanguageServiceParser.list)(
                  "Value",
                  (0, _graphqlLanguageServiceParser.opt)(
                    (0, _graphqlLanguageServiceParser.p)(",")
                  )
                ),
                (0, _graphqlLanguageServiceParser.p)("]")
              ],
              ObjectValue: [
                (0, _graphqlLanguageServiceParser.p)("{"),
                (0, _graphqlLanguageServiceParser.list)(
                  "ObjectField",
                  (0, _graphqlLanguageServiceParser.opt)(
                    (0, _graphqlLanguageServiceParser.p)(",")
                  )
                ),
                (0, _graphqlLanguageServiceParser.p)("}")
              ],
              ObjectField: [
                namedKey("attribute"),
                (0, _graphqlLanguageServiceParser.p)(":"),
                "Value"
              ]
            };
          function namedKey(style) {
            return {
              style: style,
              match: function(token) {
                return "String" === token.kind;
              },
              update: function(state, token) {
                state.name = token.value.slice(1, -1);
              }
            };
          }
        },
        { codemirror: 66, "graphql-language-service-parser": 86 }
      ],
      53: [
        function(require, module, exports) {
          (function(CodeMirror) {
            "use strict";
            var noOptions = {},
              nonWS = /[^\s\u00a0]/,
              Pos = CodeMirror.Pos;
            function firstNonWS(str) {
              var found = str.search(nonWS);
              return -1 == found ? 0 : found;
            }
            function getMode(cm, pos) {
              var mode = cm.getMode();
              return !1 !== mode.useInnerComments && mode.innerMode
                ? cm.getModeAt(pos)
                : mode;
            }
            (CodeMirror.commands.toggleComment = function(cm) {
              cm.toggleComment();
            }),
              CodeMirror.defineExtension("toggleComment", function(options) {
                options || (options = noOptions);
                for (
                  var minLine = 1 / 0,
                    ranges = this.listSelections(),
                    mode = null,
                    i = ranges.length - 1;
                  0 <= i;
                  i--
                ) {
                  var from = ranges[i].from(),
                    to = ranges[i].to();
                  from.line >= minLine ||
                    (to.line >= minLine && (to = Pos(minLine, 0)),
                    (minLine = from.line),
                    null == mode
                      ? this.uncomment(from, to, options)
                        ? (mode = "un")
                        : (this.lineComment(from, to, options), (mode = "line"))
                      : "un" == mode
                        ? this.uncomment(from, to, options)
                        : this.lineComment(from, to, options));
                }
              }),
              CodeMirror.defineExtension("lineComment", function(
                from,
                to,
                options
              ) {
                options || (options = noOptions);
                var self = this,
                  mode = getMode(self, from),
                  firstLine = self.getLine(from.line);
                if (
                  null != firstLine &&
                  ((pos = from),
                  (line = firstLine),
                  !/\bstring\b/.test(self.getTokenTypeAt(Pos(pos.line, 0))) ||
                    /^[\'\"\`]/.test(line))
                ) {
                  var pos,
                    line,
                    commentString = options.lineComment || mode.lineComment;
                  if (commentString) {
                    var end = Math.min(
                        0 != to.ch || to.line == from.line
                          ? to.line + 1
                          : to.line,
                        self.lastLine() + 1
                      ),
                      pad = null == options.padding ? " " : options.padding,
                      blankLines =
                        options.commentBlankLines || from.line == to.line;
                    self.operation(function() {
                      if (options.indent) {
                        for (
                          var baseString = null, i = from.line;
                          i < end;
                          ++i
                        ) {
                          var whitespace = (line = self.getLine(i)).slice(
                            0,
                            firstNonWS(line)
                          );
                          (null == baseString ||
                            baseString.length > whitespace.length) &&
                            (baseString = whitespace);
                        }
                        for (i = from.line; i < end; ++i) {
                          var line = self.getLine(i),
                            cut = baseString.length;
                          (blankLines || nonWS.test(line)) &&
                            (line.slice(0, cut) != baseString &&
                              (cut = firstNonWS(line)),
                            self.replaceRange(
                              baseString + commentString + pad,
                              Pos(i, 0),
                              Pos(i, cut)
                            ));
                        }
                      } else for (i = from.line; i < end; ++i) (blankLines || nonWS.test(self.getLine(i))) && self.replaceRange(commentString + pad, Pos(i, 0));
                    });
                  } else
                    (options.blockCommentStart || mode.blockCommentStart) &&
                      ((options.fullLines = !0),
                      self.blockComment(from, to, options));
                }
              }),
              CodeMirror.defineExtension("blockComment", function(
                from,
                to,
                options
              ) {
                options || (options = noOptions);
                var self = this,
                  mode = getMode(self, from),
                  startString =
                    options.blockCommentStart || mode.blockCommentStart,
                  endString = options.blockCommentEnd || mode.blockCommentEnd;
                if (startString && endString) {
                  if (
                    !/\bcomment\b/.test(self.getTokenTypeAt(Pos(from.line, 0)))
                  ) {
                    var end = Math.min(to.line, self.lastLine());
                    end != from.line &&
                      0 == to.ch &&
                      nonWS.test(self.getLine(end)) &&
                      --end;
                    var pad = null == options.padding ? " " : options.padding;
                    from.line > end ||
                      self.operation(function() {
                        if (0 != options.fullLines) {
                          var lastLineHasText = nonWS.test(self.getLine(end));
                          self.replaceRange(pad + endString, Pos(end)),
                            self.replaceRange(
                              startString + pad,
                              Pos(from.line, 0)
                            );
                          var lead =
                            options.blockCommentLead || mode.blockCommentLead;
                          if (null != lead)
                            for (var i = from.line + 1; i <= end; ++i)
                              (i != end || lastLineHasText) &&
                                self.replaceRange(lead + pad, Pos(i, 0));
                        } else self.replaceRange(endString, to), self.replaceRange(startString, from);
                      });
                  }
                } else
                  (options.lineComment || mode.lineComment) &&
                    0 != options.fullLines &&
                    self.lineComment(from, to, options);
              }),
              CodeMirror.defineExtension("uncomment", function(
                from,
                to,
                options
              ) {
                options || (options = noOptions);
                var didSomething,
                  self = this,
                  mode = getMode(self, from),
                  end = Math.min(
                    0 != to.ch || to.line == from.line ? to.line : to.line - 1,
                    self.lastLine()
                  ),
                  start = Math.min(from.line, end),
                  lineString = options.lineComment || mode.lineComment,
                  lines = [],
                  pad = null == options.padding ? " " : options.padding;
                lineComment: if (lineString) {
                  for (var i = start; i <= end; ++i) {
                    var line = self.getLine(i),
                      found = line.indexOf(lineString);
                    if (
                      (-1 < found &&
                        !/comment/.test(
                          self.getTokenTypeAt(Pos(i, found + 1))
                        ) &&
                        (found = -1),
                      -1 == found && nonWS.test(line))
                    )
                      break lineComment;
                    if (-1 < found && nonWS.test(line.slice(0, found)))
                      break lineComment;
                    lines.push(line);
                  }
                  if (
                    (self.operation(function() {
                      for (var i = start; i <= end; ++i) {
                        var line = lines[i - start],
                          pos = line.indexOf(lineString),
                          endPos = pos + lineString.length;
                        pos < 0 ||
                          (line.slice(endPos, endPos + pad.length) == pad &&
                            (endPos += pad.length),
                          (didSomething = !0),
                          self.replaceRange("", Pos(i, pos), Pos(i, endPos)));
                      }
                    }),
                    didSomething)
                  )
                    return !0;
                }
                var startString =
                    options.blockCommentStart || mode.blockCommentStart,
                  endString = options.blockCommentEnd || mode.blockCommentEnd;
                if (!startString || !endString) return !1;
                var lead = options.blockCommentLead || mode.blockCommentLead,
                  startLine = self.getLine(start),
                  open = startLine.indexOf(startString);
                if (-1 == open) return !1;
                var endLine = end == start ? startLine : self.getLine(end),
                  close = endLine.indexOf(
                    endString,
                    end == start ? open + startString.length : 0
                  ),
                  insideStart = Pos(start, open + 1),
                  insideEnd = Pos(end, close + 1);
                if (
                  -1 == close ||
                  !/comment/.test(self.getTokenTypeAt(insideStart)) ||
                  !/comment/.test(self.getTokenTypeAt(insideEnd)) ||
                  -1 <
                    self
                      .getRange(insideStart, insideEnd, "\n")
                      .indexOf(endString)
                )
                  return !1;
                var lastStart = startLine.lastIndexOf(startString, from.ch),
                  firstEnd =
                    -1 == lastStart
                      ? -1
                      : startLine
                          .slice(0, from.ch)
                          .indexOf(endString, lastStart + startString.length);
                if (
                  -1 != lastStart &&
                  -1 != firstEnd &&
                  firstEnd + endString.length != from.ch
                )
                  return !1;
                firstEnd = endLine.indexOf(endString, to.ch);
                var almostLastStart = endLine
                  .slice(to.ch)
                  .lastIndexOf(startString, firstEnd - to.ch);
                return (
                  (lastStart =
                    -1 == firstEnd || -1 == almostLastStart
                      ? -1
                      : to.ch + almostLastStart),
                  (-1 == firstEnd || -1 == lastStart || lastStart == to.ch) &&
                    (self.operation(function() {
                      self.replaceRange(
                        "",
                        Pos(
                          end,
                          close -
                            (pad &&
                            endLine.slice(close - pad.length, close) == pad
                              ? pad.length
                              : 0)
                        ),
                        Pos(end, close + endString.length)
                      );
                      var openEnd = open + startString.length;
                      if (
                        (pad &&
                          startLine.slice(openEnd, openEnd + pad.length) ==
                            pad &&
                          (openEnd += pad.length),
                        self.replaceRange(
                          "",
                          Pos(start, open),
                          Pos(start, openEnd)
                        ),
                        lead)
                      )
                        for (var i = start + 1; i <= end; ++i) {
                          var line = self.getLine(i),
                            found = line.indexOf(lead);
                          if (
                            -1 != found &&
                            !nonWS.test(line.slice(0, found))
                          ) {
                            var foundEnd = found + lead.length;
                            pad &&
                              line.slice(foundEnd, foundEnd + pad.length) ==
                                pad &&
                              (foundEnd += pad.length),
                              self.replaceRange(
                                "",
                                Pos(i, found),
                                Pos(i, foundEnd)
                              );
                          }
                        }
                    }),
                    !0)
                );
              });
          })(
            "object" == typeof exports && "object" == typeof module
              ? require("../../lib/codemirror")
              : CodeMirror
          );
        },
        { "../../lib/codemirror": 66 }
      ],
      54: [
        function(require, module, exports) {
          (function(CodeMirror) {
            function dialogDiv(cm, template, bottom) {
              var dialog;
              return (
                ((dialog = cm
                  .getWrapperElement()
                  .appendChild(
                    document.createElement("div")
                  )).className = bottom
                  ? "CodeMirror-dialog CodeMirror-dialog-bottom"
                  : "CodeMirror-dialog CodeMirror-dialog-top"),
                "string" == typeof template
                  ? (dialog.innerHTML = template)
                  : dialog.appendChild(template),
                dialog
              );
            }
            function closeNotification(cm, newVal) {
              cm.state.currentNotificationClose &&
                cm.state.currentNotificationClose(),
                (cm.state.currentNotificationClose = newVal);
            }
            CodeMirror.defineExtension("openDialog", function(
              template,
              callback,
              options
            ) {
              options || (options = {}), closeNotification(this, null);
              var dialog = dialogDiv(this, template, options.bottom),
                closed = !1,
                me = this;
              function close(newVal) {
                if ("string" == typeof newVal) inp.value = newVal;
                else {
                  if (closed) return;
                  (closed = !0),
                    dialog.parentNode.removeChild(dialog),
                    me.focus(),
                    options.onClose && options.onClose(dialog);
                }
              }
              var button,
                inp = dialog.getElementsByTagName("input")[0];
              return (
                inp
                  ? (inp.focus(),
                    options.value &&
                      ((inp.value = options.value),
                      !1 !== options.selectValueOnOpen && inp.select()),
                    options.onInput &&
                      CodeMirror.on(inp, "input", function(e) {
                        options.onInput(e, inp.value, close);
                      }),
                    options.onKeyUp &&
                      CodeMirror.on(inp, "keyup", function(e) {
                        options.onKeyUp(e, inp.value, close);
                      }),
                    CodeMirror.on(inp, "keydown", function(e) {
                      (options &&
                        options.onKeyDown &&
                        options.onKeyDown(e, inp.value, close)) ||
                        ((27 == e.keyCode ||
                          (!1 !== options.closeOnEnter && 13 == e.keyCode)) &&
                          (inp.blur(), CodeMirror.e_stop(e), close()),
                        13 == e.keyCode && callback(inp.value, e));
                    }),
                    !1 !== options.closeOnBlur &&
                      CodeMirror.on(inp, "blur", close))
                  : (button = dialog.getElementsByTagName("button")[0]) &&
                    (CodeMirror.on(button, "click", function() {
                      close(), me.focus();
                    }),
                    !1 !== options.closeOnBlur &&
                      CodeMirror.on(button, "blur", close),
                    button.focus()),
                close
              );
            }),
              CodeMirror.defineExtension("openConfirm", function(
                template,
                callbacks,
                options
              ) {
                closeNotification(this, null);
                var dialog = dialogDiv(
                    this,
                    template,
                    options && options.bottom
                  ),
                  buttons = dialog.getElementsByTagName("button"),
                  closed = !1,
                  me = this,
                  blurring = 1;
                function close() {
                  closed ||
                    ((closed = !0),
                    dialog.parentNode.removeChild(dialog),
                    me.focus());
                }
                buttons[0].focus();
                for (var i = 0; i < buttons.length; ++i) {
                  var b = buttons[i];
                  !(function(callback) {
                    CodeMirror.on(b, "click", function(e) {
                      CodeMirror.e_preventDefault(e),
                        close(),
                        callback && callback(me);
                    });
                  })(callbacks[i]),
                    CodeMirror.on(b, "blur", function() {
                      --blurring,
                        setTimeout(function() {
                          blurring <= 0 && close();
                        }, 200);
                    }),
                    CodeMirror.on(b, "focus", function() {
                      ++blurring;
                    });
                }
              }),
              CodeMirror.defineExtension("openNotification", function(
                template,
                options
              ) {
                closeNotification(this, close);
                var doneTimer,
                  dialog = dialogDiv(this, template, options && options.bottom),
                  closed = !1,
                  duration =
                    options && void 0 !== options.duration
                      ? options.duration
                      : 5e3;
                function close() {
                  closed ||
                    ((closed = !0),
                    clearTimeout(doneTimer),
                    dialog.parentNode.removeChild(dialog));
                }
                return (
                  CodeMirror.on(dialog, "click", function(e) {
                    CodeMirror.e_preventDefault(e), close();
                  }),
                  duration && (doneTimer = setTimeout(close, duration)),
                  close
                );
              });
          })(
            "object" == typeof exports && "object" == typeof module
              ? require("../../lib/codemirror")
              : CodeMirror
          );
        },
        { "../../lib/codemirror": 66 }
      ],
      55: [
        function(require, module, exports) {
          (function(CodeMirror) {
            var defaults = {
                pairs: "()[]{}''\"\"",
                triples: "",
                explode: "[]{}"
              },
              Pos = CodeMirror.Pos;
            function getOption(conf, name) {
              return "pairs" == name && "string" == typeof conf
                ? conf
                : "object" == typeof conf && null != conf[name]
                  ? conf[name]
                  : defaults[name];
            }
            CodeMirror.defineOption("autoCloseBrackets", !1, function(
              cm,
              val,
              old
            ) {
              old &&
                old != CodeMirror.Init &&
                (cm.removeKeyMap(keyMap), (cm.state.closeBrackets = null)),
                val &&
                  (ensureBound(getOption(val, "pairs")),
                  (cm.state.closeBrackets = val),
                  cm.addKeyMap(keyMap));
            });
            var keyMap = {
              Backspace: function(cm) {
                var conf = getConfig(cm);
                if (!conf || cm.getOption("disableInput"))
                  return CodeMirror.Pass;
                for (
                  var pairs = getOption(conf, "pairs"),
                    ranges = cm.listSelections(),
                    i = 0;
                  i < ranges.length;
                  i++
                ) {
                  if (!ranges[i].empty()) return CodeMirror.Pass;
                  var around = charsAround(cm, ranges[i].head);
                  if (!around || pairs.indexOf(around) % 2 != 0)
                    return CodeMirror.Pass;
                }
                for (var i = ranges.length - 1; 0 <= i; i--) {
                  var cur = ranges[i].head;
                  cm.replaceRange(
                    "",
                    Pos(cur.line, cur.ch - 1),
                    Pos(cur.line, cur.ch + 1),
                    "+delete"
                  );
                }
              },
              Enter: function(cm) {
                var conf = getConfig(cm),
                  explode = conf && getOption(conf, "explode");
                if (!explode || cm.getOption("disableInput"))
                  return CodeMirror.Pass;
                for (
                  var ranges = cm.listSelections(), i = 0;
                  i < ranges.length;
                  i++
                ) {
                  if (!ranges[i].empty()) return CodeMirror.Pass;
                  var around = charsAround(cm, ranges[i].head);
                  if (!around || explode.indexOf(around) % 2 != 0)
                    return CodeMirror.Pass;
                }
                cm.operation(function() {
                  var linesep = cm.lineSeparator() || "\n";
                  cm.replaceSelection(linesep + linesep, null),
                    cm.execCommand("goCharLeft"),
                    (ranges = cm.listSelections());
                  for (var i = 0; i < ranges.length; i++) {
                    var line = ranges[i].head.line;
                    cm.indentLine(line, null, !0),
                      cm.indentLine(line + 1, null, !0);
                  }
                });
              }
            };
            function ensureBound(chars) {
              for (var i = 0; i < chars.length; i++) {
                var ch = chars.charAt(i),
                  key = "'" + ch + "'";
                keyMap[key] || (keyMap[key] = handler(ch));
              }
            }
            function handler(ch) {
              return function(cm) {
                return (function(cm, ch) {
                  var conf = getConfig(cm);
                  if (!conf || cm.getOption("disableInput"))
                    return CodeMirror.Pass;
                  var pairs = getOption(conf, "pairs"),
                    pos = pairs.indexOf(ch);
                  if (-1 == pos) return CodeMirror.Pass;
                  for (
                    var type,
                      triples = getOption(conf, "triples"),
                      identical = pairs.charAt(pos + 1) == ch,
                      ranges = cm.listSelections(),
                      opening = pos % 2 == 0,
                      i = 0;
                    i < ranges.length;
                    i++
                  ) {
                    var curType,
                      range = ranges[i],
                      cur = range.head,
                      next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
                    if (opening && !range.empty()) curType = "surround";
                    else if ((!identical && opening) || next != ch)
                      if (
                        identical &&
                        1 < cur.ch &&
                        0 <= triples.indexOf(ch) &&
                        cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch
                      ) {
                        if (
                          2 < cur.ch &&
                          /\bstring/.test(
                            cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2))
                          )
                        )
                          return CodeMirror.Pass;
                        curType = "addFour";
                      } else if (identical) {
                        var prev =
                          0 == cur.ch
                            ? " "
                            : cm.getRange(Pos(cur.line, cur.ch - 1), cur);
                        if (
                          CodeMirror.isWordChar(next) ||
                          prev == ch ||
                          CodeMirror.isWordChar(prev)
                        )
                          return CodeMirror.Pass;
                        curType = "both";
                      } else {
                        if (
                          !opening ||
                          (cm.getLine(cur.line).length != cur.ch &&
                            !isClosingBracket(next, pairs) &&
                            !/\s/.test(next))
                        )
                          return CodeMirror.Pass;
                        curType = "both";
                      }
                    else
                      curType =
                        identical && stringStartsAfter(cm, cur)
                          ? "both"
                          : 0 <= triples.indexOf(ch) &&
                            cm.getRange(cur, Pos(cur.line, cur.ch + 3)) ==
                              ch + ch + ch
                            ? "skipThree"
                            : "skip";
                    if (type) {
                      if (type != curType) return CodeMirror.Pass;
                    } else type = curType;
                  }
                  var left = pos % 2 ? pairs.charAt(pos - 1) : ch,
                    right = pos % 2 ? ch : pairs.charAt(pos + 1);
                  cm.operation(function() {
                    if ("skip" == type) cm.execCommand("goCharRight");
                    else if ("skipThree" == type)
                      for (var i = 0; i < 3; i++) cm.execCommand("goCharRight");
                    else if ("surround" == type) {
                      for (
                        var sels = cm.getSelections(), i = 0;
                        i < sels.length;
                        i++
                      )
                        sels[i] = left + sels[i] + right;
                      cm.replaceSelections(sels, "around"),
                        (sels = cm.listSelections().slice());
                      for (var i = 0; i < sels.length; i++)
                        sels[i] = ((sel = sels[i]),
                        void 0,
                        (inverted =
                          0 < CodeMirror.cmpPos(sel.anchor, sel.head)),
                        {
                          anchor: new Pos(
                            sel.anchor.line,
                            sel.anchor.ch + (inverted ? -1 : 1)
                          ),
                          head: new Pos(
                            sel.head.line,
                            sel.head.ch + (inverted ? 1 : -1)
                          )
                        });
                      cm.setSelections(sels);
                    } else
                      "both" == type
                        ? (cm.replaceSelection(left + right, null),
                          cm.triggerElectric(left + right),
                          cm.execCommand("goCharLeft"))
                        : "addFour" == type &&
                          (cm.replaceSelection(
                            left + left + left + left,
                            "before"
                          ),
                          cm.execCommand("goCharRight"));
                    var sel, inverted;
                  });
                })(cm, ch);
              };
            }
            function getConfig(cm) {
              var deflt = cm.state.closeBrackets;
              return !deflt || deflt.override
                ? deflt
                : cm.getModeAt(cm.getCursor()).closeBrackets || deflt;
            }
            function isClosingBracket(ch, pairs) {
              var pos = pairs.lastIndexOf(ch);
              return -1 < pos && pos % 2 == 1;
            }
            function charsAround(cm, pos) {
              var str = cm.getRange(
                Pos(pos.line, pos.ch - 1),
                Pos(pos.line, pos.ch + 1)
              );
              return 2 == str.length ? str : null;
            }
            function stringStartsAfter(cm, pos) {
              var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1));
              return (
                /\bstring/.test(token.type) &&
                token.start == pos.ch &&
                (0 == pos.ch || !/\bstring/.test(cm.getTokenTypeAt(pos)))
              );
            }
            ensureBound(defaults.pairs + "`");
          })(
            "object" == typeof exports && "object" == typeof module
              ? require("../../lib/codemirror")
              : CodeMirror
          );
        },
        { "../../lib/codemirror": 66 }
      ],
      56: [
        function(require, module, exports) {
          (function(CodeMirror) {
            var ie_lt8 =
                /MSIE \d/.test(navigator.userAgent) &&
                (null == document.documentMode || document.documentMode < 8),
              Pos = CodeMirror.Pos,
              matching = {
                "(": ")>",
                ")": "(<",
                "[": "]>",
                "]": "[<",
                "{": "}>",
                "}": "{<"
              };
            function findMatchingBracket(cm, where, config) {
              var line = cm.getLineHandle(where.line),
                pos = where.ch - 1,
                afterCursor = config && config.afterCursor;
              null == afterCursor &&
                (afterCursor = /(^| )cm-fat-cursor($| )/.test(
                  cm.getWrapperElement().className
                ));
              var match =
                (!afterCursor && 0 <= pos && matching[line.text.charAt(pos)]) ||
                matching[line.text.charAt(++pos)];
              if (!match) return null;
              var dir = ">" == match.charAt(1) ? 1 : -1;
              if (config && config.strict && 0 < dir != (pos == where.ch))
                return null;
              var style = cm.getTokenTypeAt(Pos(where.line, pos + 1)),
                found = scanForBracket(
                  cm,
                  Pos(where.line, pos + (0 < dir ? 1 : 0)),
                  dir,
                  style || null,
                  config
                );
              return null == found
                ? null
                : {
                    from: Pos(where.line, pos),
                    to: found && found.pos,
                    match: found && found.ch == match.charAt(0),
                    forward: 0 < dir
                  };
            }
            function scanForBracket(cm, where, dir, style, config) {
              for (
                var maxScanLen = (config && config.maxScanLineLength) || 1e4,
                  maxScanLines = (config && config.maxScanLines) || 1e3,
                  stack = [],
                  re =
                    config && config.bracketRegex
                      ? config.bracketRegex
                      : /[(){}[\]]/,
                  lineEnd =
                    0 < dir
                      ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)
                      : Math.max(cm.firstLine() - 1, where.line - maxScanLines),
                  lineNo = where.line;
                lineNo != lineEnd;
                lineNo += dir
              ) {
                var line = cm.getLine(lineNo);
                if (line) {
                  var pos = 0 < dir ? 0 : line.length - 1,
                    end = 0 < dir ? line.length : -1;
                  if (!(line.length > maxScanLen))
                    for (
                      lineNo == where.line &&
                      (pos = where.ch - (dir < 0 ? 1 : 0));
                      pos != end;
                      pos += dir
                    ) {
                      var ch = line.charAt(pos);
                      if (
                        re.test(ch) &&
                        (void 0 === style ||
                          cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)
                      )
                        if ((">" == matching[ch].charAt(1)) == 0 < dir)
                          stack.push(ch);
                        else {
                          if (!stack.length)
                            return { pos: Pos(lineNo, pos), ch: ch };
                          stack.pop();
                        }
                    }
                }
              }
              return (
                lineNo - dir != (0 < dir ? cm.lastLine() : cm.firstLine()) &&
                null
              );
            }
            function matchBrackets(cm, autoclear, config) {
              for (
                var maxHighlightLen =
                    cm.state.matchBrackets.maxHighlightLineLength || 1e3,
                  marks = [],
                  ranges = cm.listSelections(),
                  i = 0;
                i < ranges.length;
                i++
              ) {
                var match =
                  ranges[i].empty() &&
                  findMatchingBracket(cm, ranges[i].head, config);
                if (
                  match &&
                  cm.getLine(match.from.line).length <= maxHighlightLen
                ) {
                  var style = match.match
                    ? "CodeMirror-matchingbracket"
                    : "CodeMirror-nonmatchingbracket";
                  marks.push(
                    cm.markText(
                      match.from,
                      Pos(match.from.line, match.from.ch + 1),
                      { className: style }
                    )
                  ),
                    match.to &&
                      cm.getLine(match.to.line).length <= maxHighlightLen &&
                      marks.push(
                        cm.markText(
                          match.to,
                          Pos(match.to.line, match.to.ch + 1),
                          { className: style }
                        )
                      );
                }
              }
              if (marks.length) {
                ie_lt8 && cm.state.focused && cm.focus();
                var clear = function() {
                  cm.operation(function() {
                    for (var i = 0; i < marks.length; i++) marks[i].clear();
                  });
                };
                if (!autoclear) return clear;
                setTimeout(clear, 800);
              }
            }
            function doMatchBrackets(cm) {
              cm.operation(function() {
                cm.state.matchBrackets.currentlyHighlighted &&
                  (cm.state.matchBrackets.currentlyHighlighted(),
                  (cm.state.matchBrackets.currentlyHighlighted = null)),
                  (cm.state.matchBrackets.currentlyHighlighted = matchBrackets(
                    cm,
                    !1,
                    cm.state.matchBrackets
                  ));
              });
            }
            CodeMirror.defineOption("matchBrackets", !1, function(
              cm,
              val,
              old
            ) {
              old &&
                old != CodeMirror.Init &&
                (cm.off("cursorActivity", doMatchBrackets),
                cm.state.matchBrackets &&
                  cm.state.matchBrackets.currentlyHighlighted &&
                  (cm.state.matchBrackets.currentlyHighlighted(),
                  (cm.state.matchBrackets.currentlyHighlighted = null))),
                val &&
                  ((cm.state.matchBrackets = "object" == typeof val ? val : {}),
                  cm.on("cursorActivity", doMatchBrackets));
            }),
              CodeMirror.defineExtension("matchBrackets", function() {
                matchBrackets(this, !0);
              }),
              CodeMirror.defineExtension("findMatchingBracket", function(
                pos,
                config,
                oldConfig
              ) {
                return (
                  (oldConfig || "boolean" == typeof config) &&
                    (oldConfig
                      ? ((oldConfig.strict = config), (config = oldConfig))
                      : (config = config ? { strict: !0 } : null)),
                  findMatchingBracket(this, pos, config)
                );
              }),
              CodeMirror.defineExtension("scanForBracket", function(
                pos,
                dir,
                style,
                config
              ) {
                return scanForBracket(this, pos, dir, style, config);
              });
          })(
            "object" == typeof exports && "object" == typeof module
              ? require("../../lib/codemirror")
              : CodeMirror
          );
        },
        { "../../lib/codemirror": 66 }
      ],
      57: [
        function(require, module, exports) {
          (function(CodeMirror) {
            "use strict";
            CodeMirror.registerHelper("fold", "brace", function(cm, start) {
              var tokenType,
                line = start.line,
                lineText = cm.getLine(line);
              function findOpening(openCh) {
                for (var at = start.ch, pass = 0; ; ) {
                  var found =
                    at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);
                  if (-1 != found) {
                    if (1 == pass && found < start.ch) break;
                    if (
                      ((tokenType = cm.getTokenTypeAt(
                        CodeMirror.Pos(line, found + 1)
                      )),
                      !/^(comment|string)/.test(tokenType))
                    )
                      return found + 1;
                    at = found - 1;
                  } else {
                    if (1 == pass) break;
                    (pass = 1), (at = lineText.length);
                  }
                }
              }
              var startToken = "{",
                endToken = "}",
                startCh = findOpening("{");
              if (
                (null == startCh &&
                  ((endToken = "]"),
                  (startCh = findOpening((startToken = "[")))),
                null != startCh)
              ) {
                var end,
                  endCh,
                  count = 1,
                  lastLine = cm.lastLine();
                outer: for (var i = line; i <= lastLine; ++i)
                  for (
                    var text = cm.getLine(i), pos = i == line ? startCh : 0;
                    ;

                  ) {
                    var nextOpen = text.indexOf(startToken, pos),
                      nextClose = text.indexOf(endToken, pos);
                    if (
                      (nextOpen < 0 && (nextOpen = text.length),
                      nextClose < 0 && (nextClose = text.length),
                      (pos = Math.min(nextOpen, nextClose)) == text.length)
                    )
                      break;
                    if (
                      cm.getTokenTypeAt(CodeMirror.Pos(i, pos + 1)) == tokenType
                    )
                      if (pos == nextOpen) ++count;
                      else if (!--count) {
                        (end = i), (endCh = pos);
                        break outer;
                      }
                    ++pos;
                  }
                if (null != end && (line != end || endCh != startCh))
                  return {
                    from: CodeMirror.Pos(line, startCh),
                    to: CodeMirror.Pos(end, endCh)
                  };
              }
            }),
              CodeMirror.registerHelper("fold", "import", function(cm, start) {
                function hasImport(line) {
                  if (line < cm.firstLine() || line > cm.lastLine())
                    return null;
                  var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
                  if (
                    (/\S/.test(start.string) ||
                      (start = cm.getTokenAt(
                        CodeMirror.Pos(line, start.end + 1)
                      )),
                    "keyword" != start.type || "import" != start.string)
                  )
                    return null;
                  for (
                    var i = line, e = Math.min(cm.lastLine(), line + 10);
                    i <= e;
                    ++i
                  ) {
                    var semi = cm.getLine(i).indexOf(";");
                    if (-1 != semi)
                      return {
                        startCh: start.end,
                        end: CodeMirror.Pos(i, semi)
                      };
                  }
                }
                var prev,
                  startLine = start.line,
                  has = hasImport(startLine);
                if (
                  !has ||
                  hasImport(startLine - 1) ||
                  ((prev = hasImport(startLine - 2)) &&
                    prev.end.line == startLine - 1)
                )
                  return null;
                for (var end = has.end; ; ) {
                  var next = hasImport(end.line + 1);
                  if (null == next) break;
                  end = next.end;
                }
                return {
                  from: cm.clipPos(CodeMirror.Pos(startLine, has.startCh + 1)),
                  to: end
                };
              }),
              CodeMirror.registerHelper("fold", "include", function(cm, start) {
                function hasInclude(line) {
                  if (line < cm.firstLine() || line > cm.lastLine())
                    return null;
                  var start = cm.getTokenAt(CodeMirror.Pos(line, 1));
                  return (
                    /\S/.test(start.string) ||
                      (start = cm.getTokenAt(
                        CodeMirror.Pos(line, start.end + 1)
                      )),
                    "meta" == start.type &&
                    "#include" == start.string.slice(0, 8)
                      ? start.start + 8
                      : void 0
                  );
                }
                var startLine = start.line,
                  has = hasInclude(startLine);
                if (null == has || null != hasInclude(startLine - 1))
                  return null;
                for (var end = startLine; ; ) {
                  if (null == hasInclude(end + 1)) break;
                  ++end;
                }
                return {
                  from: CodeMirror.Pos(startLine, has + 1),
                  to: cm.clipPos(CodeMirror.Pos(end))
                };
              });
          })(
            "object" == typeof exports && "object" == typeof module
              ? require("../../lib/codemirror")
              : CodeMirror
          );
        },
        { "../../lib/codemirror": 66 }
      ],
      58: [
        function(require, module, exports) {
          (function(CodeMirror) {
            "use strict";
            function doFold(cm, pos, options, force) {
              if (options && options.call) {
                var finder = options;
                options = null;
              } else finder = getOption(cm, options, "rangeFinder");
              "number" == typeof pos && (pos = CodeMirror.Pos(pos, 0));
              var minSize = getOption(cm, options, "minFoldSize");
              function getRange(allowFolded) {
                var range = finder(cm, pos);
                if (!range || range.to.line - range.from.line < minSize)
                  return null;
                for (
                  var marks = cm.findMarksAt(range.from), i = 0;
                  i < marks.length;
                  ++i
                )
                  if (marks[i].__isFold && "fold" !== force) {
                    if (!allowFolded) return null;
                    (range.cleared = !0), marks[i].clear();
                  }
                return range;
              }
              var range = getRange(!0);
              if (getOption(cm, options, "scanUp"))
                for (; !range && pos.line > cm.firstLine(); )
                  (pos = CodeMirror.Pos(pos.line - 1, 0)),
                    (range = getRange(!1));
              if (range && !range.cleared && "unfold" !== force) {
                var myWidget = (function(cm, options) {
                  var widget = getOption(cm, options, "widget");
                  if ("string" == typeof widget) {
                    var text = document.createTextNode(widget);
                    (widget = document.createElement("span")).appendChild(text),
                      (widget.className = "CodeMirror-foldmarker");
                  } else widget && (widget = widget.cloneNode(!0));
                  return widget;
                })(cm, options);
                CodeMirror.on(myWidget, "mousedown", function(e) {
                  myRange.clear(), CodeMirror.e_preventDefault(e);
                });
                var myRange = cm.markText(range.from, range.to, {
                  replacedWith: myWidget,
                  clearOnEnter: getOption(cm, options, "clearOnEnter"),
                  __isFold: !0
                });
                myRange.on("clear", function(from, to) {
                  CodeMirror.signal(cm, "unfold", cm, from, to);
                }),
                  CodeMirror.signal(cm, "fold", cm, range.from, range.to);
              }
            }
            (CodeMirror.newFoldFunction = function(rangeFinder, widget) {
              return function(cm, pos) {
                doFold(cm, pos, { rangeFinder: rangeFinder, widget: widget });
              };
            }),
              CodeMirror.defineExtension("foldCode", function(
                pos,
                options,
                force
              ) {
                doFold(this, pos, options, force);
              }),
              CodeMirror.defineExtension("isFolded", function(pos) {
                for (
                  var marks = this.findMarksAt(pos), i = 0;
                  i < marks.length;
                  ++i
                )
                  if (marks[i].__isFold) return !0;
              }),
              (CodeMirror.commands.toggleFold = function(cm) {
                cm.foldCode(cm.getCursor());
              }),
              (CodeMirror.commands.fold = function(cm) {
                cm.foldCode(cm.getCursor(), null, "fold");
              }),
              (CodeMirror.commands.unfold = function(cm) {
                cm.foldCode(cm.getCursor(), null, "unfold");
              }),
              (CodeMirror.commands.foldAll = function(cm) {
                cm.operation(function() {
                  for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
                    cm.foldCode(CodeMirror.Pos(i, 0), null, "fold");
                });
              }),
              (CodeMirror.commands.unfoldAll = function(cm) {
                cm.operation(function() {
                  for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
                    cm.foldCode(CodeMirror.Pos(i, 0), null, "unfold");
                });
              }),
              CodeMirror.registerHelper("fold", "combine", function() {
                var funcs = Array.prototype.slice.call(arguments, 0);
                return function(cm, start) {
                  for (var i = 0; i < funcs.length; ++i) {
                    var found = funcs[i](cm, start);
                    if (found) return found;
                  }
                };
              }),
              CodeMirror.registerHelper("fold", "auto", function(cm, start) {
                for (
                  var helpers = cm.getHelpers(start, "fold"), i = 0;
                  i < helpers.length;
                  i++
                ) {
                  var cur = helpers[i](cm, start);
                  if (cur) return cur;
                }
              });
            var defaultOptions = {
              rangeFinder: CodeMirror.fold.auto,
              widget: "↔",
              minFoldSize: 0,
              scanUp: !1,
              clearOnEnter: !0
            };
            function getOption(cm, options, name) {
              if (options && void 0 !== options[name]) return options[name];
              var editorOptions = cm.options.foldOptions;
              return editorOptions && void 0 !== editorOptions[name]
                ? editorOptions[name]
                : defaultOptions[name];
            }
            CodeMirror.defineOption("foldOptions", null),
              CodeMirror.defineExtension("foldOption", function(options, name) {
                return getOption(this, options, name);
              });
          })(
            "object" == typeof exports && "object" == typeof module
              ? require("../../lib/codemirror")
              : CodeMirror
          );
        },
        { "../../lib/codemirror": 66 }
      ],
      59: [
        function(require, module, exports) {
          var mod;
          (mod = function(CodeMirror) {
            "use strict";
            CodeMirror.defineOption("foldGutter", !1, function(cm, val, old) {
              old &&
                old != CodeMirror.Init &&
                (cm.clearGutter(cm.state.foldGutter.options.gutter),
                (cm.state.foldGutter = null),
                cm.off("gutterClick", onGutterClick),
                cm.off("change", onChange),
                cm.off("viewportChange", onViewportChange),
                cm.off("fold", onFold),
                cm.off("unfold", onFold),
                cm.off("swapDoc", onChange)),
                val &&
                  ((cm.state.foldGutter = new function(options) {
                    (this.options = options), (this.from = this.to = 0);
                  }(
                    (function(opts) {
                      !0 === opts && (opts = {});
                      null == opts.gutter &&
                        (opts.gutter = "CodeMirror-foldgutter");
                      null == opts.indicatorOpen &&
                        (opts.indicatorOpen = "CodeMirror-foldgutter-open");
                      null == opts.indicatorFolded &&
                        (opts.indicatorFolded = "CodeMirror-foldgutter-folded");
                      return opts;
                    })(val)
                  )),
                  updateInViewport(cm),
                  cm.on("gutterClick", onGutterClick),
                  cm.on("change", onChange),
                  cm.on("viewportChange", onViewportChange),
                  cm.on("fold", onFold),
                  cm.on("unfold", onFold),
                  cm.on("swapDoc", onChange));
            });
            var Pos = CodeMirror.Pos;
            function isFolded(cm, line) {
              for (
                var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0)), i = 0;
                i < marks.length;
                ++i
              )
                if (marks[i].__isFold && marks[i].find().from.line == line)
                  return marks[i];
            }
            function marker(spec) {
              if ("string" == typeof spec) {
                var elt = document.createElement("div");
                return (
                  (elt.className = spec + " CodeMirror-guttermarker-subtle"),
                  elt
                );
              }
              return spec.cloneNode(!0);
            }
            function updateFoldInfo(cm, from, to) {
              var opts = cm.state.foldGutter.options,
                cur = from,
                minSize = cm.foldOption(opts, "minFoldSize"),
                func = cm.foldOption(opts, "rangeFinder");
              cm.eachLine(from, to, function(line) {
                var mark = null;
                if (isFolded(cm, cur)) mark = marker(opts.indicatorFolded);
                else {
                  var pos = Pos(cur, 0),
                    range = func && func(cm, pos);
                  range &&
                    range.to.line - range.from.line >= minSize &&
                    (mark = marker(opts.indicatorOpen));
                }
                cm.setGutterMarker(line, opts.gutter, mark), ++cur;
              });
            }
            function updateInViewport(cm) {
              var vp = cm.getViewport(),
                state = cm.state.foldGutter;
              state &&
                (cm.operation(function() {
                  updateFoldInfo(cm, vp.from, vp.to);
                }),
                (state.from = vp.from),
                (state.to = vp.to));
            }
            function onGutterClick(cm, line, gutter) {
              var state = cm.state.foldGutter;
              if (state) {
                var opts = state.options;
                if (gutter == opts.gutter) {
                  var folded = isFolded(cm, line);
                  folded
                    ? folded.clear()
                    : cm.foldCode(Pos(line, 0), opts.rangeFinder);
                }
              }
            }
            function onChange(cm) {
              var state = cm.state.foldGutter;
              if (state) {
                var opts = state.options;
                (state.from = state.to = 0),
                  clearTimeout(state.changeUpdate),
                  (state.changeUpdate = setTimeout(function() {
                    updateInViewport(cm);
                  }, opts.foldOnChangeTimeSpan || 600));
              }
            }
            function onViewportChange(cm) {
              var state = cm.state.foldGutter;
              if (state) {
                var opts = state.options;
                clearTimeout(state.changeUpdate),
                  (state.changeUpdate = setTimeout(function() {
                    var vp = cm.getViewport();
                    state.from == state.to ||
                    20 < vp.from - state.to ||
                    20 < state.from - vp.to
                      ? updateInViewport(cm)
                      : cm.operation(function() {
                          vp.from < state.from &&
                            (updateFoldInfo(cm, vp.from, state.from),
                            (state.from = vp.from)),
                            vp.to > state.to &&
                              (updateFoldInfo(cm, state.to, vp.to),
                              (state.to = vp.to));
                        });
                  }, opts.updateViewportTimeSpan || 400));
              }
            }
            function onFold(cm, from) {
              var state = cm.state.foldGutter;
              if (state) {
                var line = from.line;
                line >= state.from &&
                  line < state.to &&
                  updateFoldInfo(cm, line, line + 1);
              }
            }
          }),
            "object" == typeof exports && "object" == typeof module
              ? mod(require("../../lib/codemirror"), require("./foldcode"))
              : mod(CodeMirror);
        },
        { "../../lib/codemirror": 66, "./foldcode": 58 }
      ],
      60: [
        function(require, module, exports) {
          (function(CodeMirror) {
            "use strict";
            var HINT_ELEMENT_CLASS = "CodeMirror-hint",
              ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";
            function Completion(cm, options) {
              (this.cm = cm),
                (this.options = options),
                (this.widget = null),
                (this.debounce = 0),
                (this.tick = 0),
                (this.startPos = this.cm.getCursor("start")),
                (this.startLen =
                  this.cm.getLine(this.startPos.line).length -
                  this.cm.getSelection().length);
              var self = this;
              cm.on(
                "cursorActivity",
                (this.activityFunc = function() {
                  self.cursorActivity();
                })
              );
            }
            (CodeMirror.showHint = function(cm, getHints, options) {
              if (!getHints) return cm.showHint(options);
              options && options.async && (getHints.async = !0);
              var newOpts = { hint: getHints };
              if (options)
                for (var prop in options) newOpts[prop] = options[prop];
              return cm.showHint(newOpts);
            }),
              CodeMirror.defineExtension("showHint", function(options) {
                options = (function(cm, pos, options) {
                  var editor = cm.options.hintOptions,
                    out = {};
                  for (var prop in defaultOptions)
                    out[prop] = defaultOptions[prop];
                  if (editor)
                    for (var prop in editor)
                      void 0 !== editor[prop] && (out[prop] = editor[prop]);
                  if (options)
                    for (var prop in options)
                      void 0 !== options[prop] && (out[prop] = options[prop]);
                  out.hint.resolve && (out.hint = out.hint.resolve(cm, pos));
                  return out;
                })(this, this.getCursor("start"), options);
                var selections = this.listSelections();
                if (!(1 < selections.length)) {
                  if (this.somethingSelected()) {
                    if (!options.hint.supportsSelection) return;
                    for (var i = 0; i < selections.length; i++)
                      if (selections[i].head.line != selections[i].anchor.line)
                        return;
                  }
                  this.state.completionActive &&
                    this.state.completionActive.close();
                  var completion = (this.state.completionActive = new Completion(
                    this,
                    options
                  ));
                  completion.options.hint &&
                    (CodeMirror.signal(this, "startCompletion", this),
                    completion.update(!0));
                }
              });
            var requestAnimationFrame =
                window.requestAnimationFrame ||
                function(fn) {
                  return setTimeout(fn, 1e3 / 60);
                },
              cancelAnimationFrame =
                window.cancelAnimationFrame || clearTimeout;
            function getText(completion) {
              return "string" == typeof completion
                ? completion
                : completion.text;
            }
            function getHintElement(hintsElement, el) {
              for (; el && el != hintsElement; ) {
                if (
                  "LI" === el.nodeName.toUpperCase() &&
                  el.parentNode == hintsElement
                )
                  return el;
                el = el.parentNode;
              }
            }
            function Widget(completion, data) {
              (this.completion = completion),
                (this.data = data),
                (this.picked = !1);
              var widget = this,
                cm = completion.cm,
                hints = (this.hints = document.createElement("ul"));
              (hints.className = "CodeMirror-hints"),
                (this.selectedHint = data.selectedHint || 0);
              for (
                var completions = data.list, i = 0;
                i < completions.length;
                ++i
              ) {
                var elt = hints.appendChild(document.createElement("li")),
                  cur = completions[i],
                  className =
                    HINT_ELEMENT_CLASS +
                    (i != this.selectedHint
                      ? ""
                      : " " + ACTIVE_HINT_ELEMENT_CLASS);
                null != cur.className &&
                  (className = cur.className + " " + className),
                  (elt.className = className),
                  cur.render
                    ? cur.render(elt, data, cur)
                    : elt.appendChild(
                        document.createTextNode(cur.displayText || getText(cur))
                      ),
                  (elt.hintId = i);
              }
              var pos = cm.cursorCoords(
                  completion.options.alignWithWord ? data.from : null
                ),
                left = pos.left,
                top = pos.bottom,
                below = !0;
              (hints.style.left = left + "px"), (hints.style.top = top + "px");
              var winW =
                  window.innerWidth ||
                  Math.max(
                    document.body.offsetWidth,
                    document.documentElement.offsetWidth
                  ),
                winH =
                  window.innerHeight ||
                  Math.max(
                    document.body.offsetHeight,
                    document.documentElement.offsetHeight
                  );
              (completion.options.container || document.body).appendChild(
                hints
              );
              var box = hints.getBoundingClientRect(),
                overlapY = box.bottom - winH,
                scrolls = hints.scrollHeight > hints.clientHeight + 1,
                startScroll = cm.getScrollInfo();
              if (0 < overlapY) {
                var height = box.bottom - box.top;
                if (0 < pos.top - (pos.bottom - box.top) - height)
                  (hints.style.top = (top = pos.top - height) + "px"),
                    (below = !1);
                else if (winH < height) {
                  (hints.style.height = winH - 5 + "px"),
                    (hints.style.top = (top = pos.bottom - box.top) + "px");
                  var cursor = cm.getCursor();
                  data.from.ch != cursor.ch &&
                    ((pos = cm.cursorCoords(cursor)),
                    (hints.style.left = (left = pos.left) + "px"),
                    (box = hints.getBoundingClientRect()));
                }
              }
              var closingOnBlur,
                overlapX = box.right - winW;
              if (
                (0 < overlapX &&
                  (box.right - box.left > winW &&
                    ((hints.style.width = winW - 5 + "px"),
                    (overlapX -= box.right - box.left - winW)),
                  (hints.style.left = (left = pos.left - overlapX) + "px")),
                scrolls)
              )
                for (var node = hints.firstChild; node; node = node.nextSibling)
                  node.style.paddingRight = cm.display.nativeBarWidth + "px";
              (cm.addKeyMap(
                (this.keyMap = (function(completion, handle) {
                  var baseMap = {
                      Up: function() {
                        handle.moveFocus(-1);
                      },
                      Down: function() {
                        handle.moveFocus(1);
                      },
                      PageUp: function() {
                        handle.moveFocus(1 - handle.menuSize(), !0);
                      },
                      PageDown: function() {
                        handle.moveFocus(handle.menuSize() - 1, !0);
                      },
                      Home: function() {
                        handle.setFocus(0);
                      },
                      End: function() {
                        handle.setFocus(handle.length - 1);
                      },
                      Enter: handle.pick,
                      Tab: handle.pick,
                      Esc: handle.close
                    },
                    custom = completion.options.customKeys,
                    ourMap = custom ? {} : baseMap;
                  function addBinding(key, val) {
                    var bound;
                    (bound =
                      "string" != typeof val
                        ? function(cm) {
                            return val(cm, handle);
                          }
                        : baseMap.hasOwnProperty(val) ? baseMap[val] : val),
                      (ourMap[key] = bound);
                  }
                  if (custom)
                    for (var key in custom)
                      custom.hasOwnProperty(key) &&
                        addBinding(key, custom[key]);
                  var extra = completion.options.extraKeys;
                  if (extra)
                    for (var key in extra)
                      extra.hasOwnProperty(key) && addBinding(key, extra[key]);
                  return ourMap;
                })(completion, {
                  moveFocus: function(n, avoidWrap) {
                    widget.changeActive(widget.selectedHint + n, avoidWrap);
                  },
                  setFocus: function(n) {
                    widget.changeActive(n);
                  },
                  menuSize: function() {
                    return widget.screenAmount();
                  },
                  length: completions.length,
                  close: function() {
                    completion.close();
                  },
                  pick: function() {
                    widget.pick();
                  },
                  data: data
                }))
              ),
              completion.options.closeOnUnfocus) &&
                (cm.on(
                  "blur",
                  (this.onBlur = function() {
                    closingOnBlur = setTimeout(function() {
                      completion.close();
                    }, 100);
                  })
                ),
                cm.on(
                  "focus",
                  (this.onFocus = function() {
                    clearTimeout(closingOnBlur);
                  })
                ));
              return (
                cm.on(
                  "scroll",
                  (this.onScroll = function() {
                    var curScroll = cm.getScrollInfo(),
                      editor = cm.getWrapperElement().getBoundingClientRect(),
                      newTop = top + startScroll.top - curScroll.top,
                      point =
                        newTop -
                        (window.pageYOffset ||
                          (document.documentElement || document.body)
                            .scrollTop);
                    if (
                      (below || (point += hints.offsetHeight),
                      point <= editor.top || point >= editor.bottom)
                    )
                      return completion.close();
                    (hints.style.top = newTop + "px"),
                      (hints.style.left =
                        left + startScroll.left - curScroll.left + "px");
                  })
                ),
                CodeMirror.on(hints, "dblclick", function(e) {
                  var t = getHintElement(hints, e.target || e.srcElement);
                  t &&
                    null != t.hintId &&
                    (widget.changeActive(t.hintId), widget.pick());
                }),
                CodeMirror.on(hints, "click", function(e) {
                  var t = getHintElement(hints, e.target || e.srcElement);
                  t &&
                    null != t.hintId &&
                    (widget.changeActive(t.hintId),
                    completion.options.completeOnSingleClick && widget.pick());
                }),
                CodeMirror.on(hints, "mousedown", function() {
                  setTimeout(function() {
                    cm.focus();
                  }, 20);
                }),
                CodeMirror.signal(
                  data,
                  "select",
                  completions[this.selectedHint],
                  hints.childNodes[this.selectedHint]
                ),
                !0
              );
            }
            function fetchHints(hint, cm, options, callback) {
              if (hint.async) hint(cm, callback, options);
              else {
                var result = hint(cm, options);
                result && result.then
                  ? result.then(callback)
                  : callback(result);
              }
            }
            (Completion.prototype = {
              close: function() {
                this.active() &&
                  ((this.cm.state.completionActive = null),
                  (this.tick = null),
                  this.cm.off("cursorActivity", this.activityFunc),
                  this.widget &&
                    this.data &&
                    CodeMirror.signal(this.data, "close"),
                  this.widget && this.widget.close(),
                  CodeMirror.signal(this.cm, "endCompletion", this.cm));
              },
              active: function() {
                return this.cm.state.completionActive == this;
              },
              pick: function(data, i) {
                var completion = data.list[i];
                completion.hint
                  ? completion.hint(this.cm, data, completion)
                  : this.cm.replaceRange(
                      getText(completion),
                      completion.from || data.from,
                      completion.to || data.to,
                      "complete"
                    ),
                  CodeMirror.signal(data, "pick", completion),
                  this.close();
              },
              cursorActivity: function() {
                this.debounce &&
                  (cancelAnimationFrame(this.debounce), (this.debounce = 0));
                var pos = this.cm.getCursor(),
                  line = this.cm.getLine(pos.line);
                if (
                  pos.line != this.startPos.line ||
                  line.length - pos.ch != this.startLen - this.startPos.ch ||
                  pos.ch < this.startPos.ch ||
                  this.cm.somethingSelected() ||
                  (pos.ch &&
                    this.options.closeCharacters.test(line.charAt(pos.ch - 1)))
                )
                  this.close();
                else {
                  var self = this;
                  (this.debounce = requestAnimationFrame(function() {
                    self.update();
                  })),
                    this.widget && this.widget.disable();
                }
              },
              update: function(first) {
                if (null != this.tick) {
                  var self = this,
                    myTick = ++this.tick;
                  fetchHints(this.options.hint, this.cm, this.options, function(
                    data
                  ) {
                    self.tick == myTick && self.finishUpdate(data, first);
                  });
                }
              },
              finishUpdate: function(data, first) {
                this.data && CodeMirror.signal(this.data, "update");
                var picked =
                  (this.widget && this.widget.picked) ||
                  (first && this.options.completeSingle);
                this.widget && this.widget.close(),
                  (this.data = data) &&
                    data.list.length &&
                    (picked && 1 == data.list.length
                      ? this.pick(data, 0)
                      : ((this.widget = new Widget(this, data)),
                        CodeMirror.signal(data, "shown")));
              }
            }),
              (Widget.prototype = {
                close: function() {
                  if (this.completion.widget == this) {
                    (this.completion.widget = null),
                      this.hints.parentNode.removeChild(this.hints),
                      this.completion.cm.removeKeyMap(this.keyMap);
                    var cm = this.completion.cm;
                    this.completion.options.closeOnUnfocus &&
                      (cm.off("blur", this.onBlur),
                      cm.off("focus", this.onFocus)),
                      cm.off("scroll", this.onScroll);
                  }
                },
                disable: function() {
                  this.completion.cm.removeKeyMap(this.keyMap);
                  var widget = this;
                  (this.keyMap = {
                    Enter: function() {
                      widget.picked = !0;
                    }
                  }),
                    this.completion.cm.addKeyMap(this.keyMap);
                },
                pick: function() {
                  this.completion.pick(this.data, this.selectedHint);
                },
                changeActive: function(i, avoidWrap) {
                  if (
                    (i >= this.data.list.length
                      ? (i = avoidWrap ? this.data.list.length - 1 : 0)
                      : i < 0 &&
                        (i = avoidWrap ? 0 : this.data.list.length - 1),
                    this.selectedHint != i)
                  ) {
                    var node = this.hints.childNodes[this.selectedHint];
                    (node.className = node.className.replace(
                      " " + ACTIVE_HINT_ELEMENT_CLASS,
                      ""
                    )),
                      ((node = this.hints.childNodes[
                        (this.selectedHint = i)
                      ]).className +=
                        " " + ACTIVE_HINT_ELEMENT_CLASS),
                      node.offsetTop < this.hints.scrollTop
                        ? (this.hints.scrollTop = node.offsetTop - 3)
                        : node.offsetTop + node.offsetHeight >
                            this.hints.scrollTop + this.hints.clientHeight &&
                          (this.hints.scrollTop =
                            node.offsetTop +
                            node.offsetHeight -
                            this.hints.clientHeight +
                            3),
                      CodeMirror.signal(
                        this.data,
                        "select",
                        this.data.list[this.selectedHint],
                        node
                      );
                  }
                },
                screenAmount: function() {
                  return (
                    Math.floor(
                      this.hints.clientHeight /
                        this.hints.firstChild.offsetHeight
                    ) || 1
                  );
                }
              }),
              CodeMirror.registerHelper("hint", "auto", {
                resolve: function(cm, pos) {
                  var words,
                    helpers = cm.getHelpers(pos, "hint");
                  if (helpers.length) {
                    var resolved = function(cm, callback, options) {
                      var app = (function(cm, helpers) {
                        if (!cm.somethingSelected()) return helpers;
                        for (var result = [], i = 0; i < helpers.length; i++)
                          helpers[i].supportsSelection &&
                            result.push(helpers[i]);
                        return result;
                      })(cm, helpers);
                      !(function run(i) {
                        if (i == app.length) return callback(null);
                        fetchHints(app[i], cm, options, function(result) {
                          result && 0 < result.list.length
                            ? callback(result)
                            : run(i + 1);
                        });
                      })(0);
                    };
                    return (
                      (resolved.async = !0),
                      (resolved.supportsSelection = !0),
                      resolved
                    );
                  }
                  return (words = cm.getHelper(cm.getCursor(), "hintWords"))
                    ? function(cm) {
                        return CodeMirror.hint.fromList(cm, { words: words });
                      }
                    : CodeMirror.hint.anyword
                      ? function(cm, options) {
                          return CodeMirror.hint.anyword(cm, options);
                        }
                      : function() {};
                }
              }),
              CodeMirror.registerHelper("hint", "fromList", function(
                cm,
                options
              ) {
                var cur = cm.getCursor(),
                  token = cm.getTokenAt(cur),
                  to = CodeMirror.Pos(cur.line, token.end);
                if (
                  token.string &&
                  /\w/.test(token.string[token.string.length - 1])
                )
                  var term = token.string,
                    from = CodeMirror.Pos(cur.line, token.start);
                else (term = ""), (from = to);
                for (var found = [], i = 0; i < options.words.length; i++) {
                  var word = options.words[i];
                  word.slice(0, term.length) == term && found.push(word);
                }
                if (found.length) return { list: found, from: from, to: to };
              }),
              (CodeMirror.commands.autocomplete = CodeMirror.showHint);
            var defaultOptions = {
              hint: CodeMirror.hint.auto,
              completeSingle: !0,
              alignWithWord: !0,
              closeCharacters: /[\s()\[\]{};:>,]/,
              closeOnUnfocus: !0,
              completeOnSingleClick: !0,
              container: null,
              customKeys: null,
              extraKeys: null
            };
            CodeMirror.defineOption("hintOptions", null);
          })(
            "object" == typeof exports && "object" == typeof module
              ? require("../../lib/codemirror")
              : CodeMirror
          );
        },
        { "../../lib/codemirror": 66 }
      ],
      61: [
        function(require, module, exports) {
          (function(CodeMirror) {
            "use strict";
            var GUTTER_ID = "CodeMirror-lint-markers";
            function rm(elt) {
              elt.parentNode && elt.parentNode.removeChild(elt);
            }
            function showTooltipFor(e, content, node) {
              var tooltip = (function(e, content) {
                var tt = document.createElement("div");
                function position(e) {
                  if (!tt.parentNode)
                    return CodeMirror.off(document, "mousemove", position);
                  (tt.style.top =
                    Math.max(0, e.clientY - tt.offsetHeight - 5) + "px"),
                    (tt.style.left = e.clientX + 5 + "px");
                }
                return (
                  (tt.className = "CodeMirror-lint-tooltip"),
                  tt.appendChild(content.cloneNode(!0)),
                  document.body.appendChild(tt),
                  CodeMirror.on(document, "mousemove", position),
                  position(e),
                  null != tt.style.opacity && (tt.style.opacity = 1),
                  tt
                );
              })(e, content);
              function hide() {
                var tt;
                CodeMirror.off(node, "mouseout", hide),
                  tooltip &&
                    ((tt = tooltip).parentNode &&
                      (null == tt.style.opacity && rm(tt),
                      (tt.style.opacity = 0),
                      setTimeout(function() {
                        rm(tt);
                      }, 600)),
                    (tooltip = null));
              }
              var poll = setInterval(function() {
                if (tooltip)
                  for (var n = node; ; n = n.parentNode) {
                    if (
                      (n && 11 == n.nodeType && (n = n.host),
                      n == document.body)
                    )
                      return;
                    if (!n) {
                      hide();
                      break;
                    }
                  }
                if (!tooltip) return clearInterval(poll);
              }, 400);
              CodeMirror.on(node, "mouseout", hide);
            }
            function LintState(cm, options, hasGutter) {
              (this.marked = []),
                (this.options = options),
                (this.timeout = null),
                (this.hasGutter = hasGutter),
                (this.onMouseOver = function(e) {
                  !(function(cm, e) {
                    var target = e.target || e.srcElement;
                    if (!/\bCodeMirror-lint-mark-/.test(target.className))
                      return;
                    for (
                      var box = target.getBoundingClientRect(),
                        x = (box.left + box.right) / 2,
                        y = (box.top + box.bottom) / 2,
                        spans = cm.findMarksAt(
                          cm.coordsChar({ left: x, top: y }, "client")
                        ),
                        annotations = [],
                        i = 0;
                      i < spans.length;
                      ++i
                    ) {
                      var ann = spans[i].__annotation;
                      ann && annotations.push(ann);
                    }
                    annotations.length &&
                      (function(annotations, e) {
                        for (
                          var target = e.target || e.srcElement,
                            tooltip = document.createDocumentFragment(),
                            i = 0;
                          i < annotations.length;
                          i++
                        ) {
                          var ann = annotations[i];
                          tooltip.appendChild(annotationTooltip(ann));
                        }
                        showTooltipFor(e, tooltip, target);
                      })(annotations, e);
                  })(cm, e);
                }),
                (this.waitingFor = 0);
            }
            function clearMarks(cm) {
              var state = cm.state.lint;
              state.hasGutter && cm.clearGutter(GUTTER_ID);
              for (var i = 0; i < state.marked.length; ++i)
                state.marked[i].clear();
              state.marked.length = 0;
            }
            function makeMarker(labels, severity, multiple, tooltips) {
              var marker = document.createElement("div"),
                inner = marker;
              return (
                (marker.className = "CodeMirror-lint-marker-" + severity),
                multiple &&
                  ((inner = marker.appendChild(
                    document.createElement("div")
                  )).className =
                    "CodeMirror-lint-marker-multiple"),
                0 != tooltips &&
                  CodeMirror.on(inner, "mouseover", function(e) {
                    showTooltipFor(e, labels, inner);
                  }),
                marker
              );
            }
            function annotationTooltip(ann) {
              var severity = ann.severity;
              severity || (severity = "error");
              var tip = document.createElement("div");
              return (
                (tip.className = "CodeMirror-lint-message-" + severity),
                void 0 !== ann.messageHTML
                  ? (tip.innerHTML = ann.messageHTML)
                  : tip.appendChild(document.createTextNode(ann.message)),
                tip
              );
            }
            function startLinting(cm) {
              var options = cm.state.lint.options,
                passOptions = options.options || options,
                getAnnotations =
                  options.getAnnotations ||
                  cm.getHelper(CodeMirror.Pos(0, 0), "lint");
              if (getAnnotations)
                if (options.async || getAnnotations.async)
                  !(function(cm, getAnnotations, passOptions) {
                    var state = cm.state.lint,
                      id = ++state.waitingFor;
                    function abort() {
                      (id = -1), cm.off("change", abort);
                    }
                    cm.on("change", abort),
                      getAnnotations(
                        cm.getValue(),
                        function(annotations, arg2) {
                          cm.off("change", abort),
                            state.waitingFor == id &&
                              (arg2 &&
                                annotations instanceof CodeMirror &&
                                (annotations = arg2),
                              cm.operation(function() {
                                updateLinting(cm, annotations);
                              }));
                        },
                        passOptions,
                        cm
                      );
                  })(cm, getAnnotations, passOptions);
                else {
                  var annotations = getAnnotations(
                    cm.getValue(),
                    passOptions,
                    cm
                  );
                  if (!annotations) return;
                  annotations.then
                    ? annotations.then(function(issues) {
                        cm.operation(function() {
                          updateLinting(cm, issues);
                        });
                      })
                    : cm.operation(function() {
                        updateLinting(cm, annotations);
                      });
                }
            }
            function updateLinting(cm, annotationsNotSorted) {
              clearMarks(cm);
              for (
                var a,
                  b,
                  state = cm.state.lint,
                  options = state.options,
                  annotations = (function(annotations) {
                    for (var lines = [], i = 0; i < annotations.length; ++i) {
                      var ann = annotations[i],
                        line = ann.from.line;
                      (lines[line] || (lines[line] = [])).push(ann);
                    }
                    return lines;
                  })(annotationsNotSorted),
                  line = 0;
                line < annotations.length;
                ++line
              ) {
                var anns = annotations[line];
                if (anns) {
                  for (
                    var maxSeverity = null,
                      tipLabel =
                        state.hasGutter && document.createDocumentFragment(),
                      i = 0;
                    i < anns.length;
                    ++i
                  ) {
                    var ann = anns[i],
                      severity = ann.severity;
                    severity || (severity = "error"),
                      (b = severity),
                      (maxSeverity = "error" == (a = maxSeverity) ? a : b),
                      options.formatAnnotation &&
                        (ann = options.formatAnnotation(ann)),
                      state.hasGutter &&
                        tipLabel.appendChild(annotationTooltip(ann)),
                      ann.to &&
                        state.marked.push(
                          cm.markText(ann.from, ann.to, {
                            className: "CodeMirror-lint-mark-" + severity,
                            __annotation: ann
                          })
                        );
                  }
                  state.hasGutter &&
                    cm.setGutterMarker(
                      line,
                      GUTTER_ID,
                      makeMarker(
                        tipLabel,
                        maxSeverity,
                        1 < anns.length,
                        state.options.tooltips
                      )
                    );
                }
              }
              options.onUpdateLinting &&
                options.onUpdateLinting(annotationsNotSorted, annotations, cm);
            }
            function onChange(cm) {
              var state = cm.state.lint;
              state &&
                (clearTimeout(state.timeout),
                (state.timeout = setTimeout(function() {
                  startLinting(cm);
                }, state.options.delay || 500)));
            }
            CodeMirror.defineOption("lint", !1, function(cm, val, old) {
              if (
                (old &&
                  old != CodeMirror.Init &&
                  (clearMarks(cm),
                  !1 !== cm.state.lint.options.lintOnChange &&
                    cm.off("change", onChange),
                  CodeMirror.off(
                    cm.getWrapperElement(),
                    "mouseover",
                    cm.state.lint.onMouseOver
                  ),
                  clearTimeout(cm.state.lint.timeout),
                  delete cm.state.lint),
                val)
              ) {
                for (
                  var gutters = cm.getOption("gutters"),
                    hasLintGutter = !1,
                    i = 0;
                  i < gutters.length;
                  ++i
                )
                  gutters[i] == GUTTER_ID && (hasLintGutter = !0);
                var state = (cm.state.lint = new LintState(
                  cm,
                  (options = val) instanceof Function
                    ? { getAnnotations: options }
                    : ((options && !0 !== options) || (options = {}), options),
                  hasLintGutter
                ));
                !1 !== state.options.lintOnChange && cm.on("change", onChange),
                  0 != state.options.tooltips &&
                    "gutter" != state.options.tooltips &&
                    CodeMirror.on(
                      cm.getWrapperElement(),
                      "mouseover",
                      state.onMouseOver
                    ),
                  startLinting(cm);
              }
              var options;
            }),
              CodeMirror.defineExtension("performLint", function() {
                this.state.lint && startLinting(this);
              });
          })(
            "object" == typeof exports && "object" == typeof module
              ? require("../../lib/codemirror")
              : CodeMirror
          );
        },
        { "../../lib/codemirror": 66 }
      ],
      62: [
        function(require, module, exports) {
          var mod;
          (mod = function(CodeMirror) {
            "use strict";
            function interpretLine(cm, string) {
              var num = Number(string);
              return /^[-+]/.test(string) ? cm.getCursor().line + num : num - 1;
            }
            (CodeMirror.commands.jumpToLine = function(cm) {
              var cur = cm.getCursor();
              !(function(cm, text, shortText, deflt, f) {
                cm.openDialog
                  ? cm.openDialog(text, f, {
                      value: deflt,
                      selectValueOnOpen: !0
                    })
                  : f(prompt(shortText, deflt));
              })(
                cm,
                'Jump to line: <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use line:column or scroll% syntax)</span>',
                "Jump to line:",
                cur.line + 1 + ":" + cur.ch,
                function(posStr) {
                  var match;
                  if (posStr)
                    if (
                      (match = /^\s*([\+\-]?\d+)\s*\:\s*(\d+)\s*$/.exec(posStr))
                    )
                      cm.setCursor(
                        interpretLine(cm, match[1]),
                        Number(match[2])
                      );
                    else if (
                      (match = /^\s*([\+\-]?\d+(\.\d+)?)\%\s*/.exec(posStr))
                    ) {
                      var line = Math.round(
                        cm.lineCount() * Number(match[1]) / 100
                      );
                      /^[-+]/.test(match[1]) && (line = cur.line + line + 1),
                        cm.setCursor(line - 1, cur.ch);
                    } else
                      (match = /^\s*\:?\s*([\+\-]?\d+)\s*/.exec(posStr)) &&
                        cm.setCursor(interpretLine(cm, match[1]), cur.ch);
                }
              );
            }),
              (CodeMirror.keyMap.default["Alt-G"] = "jumpToLine");
          }),
            "object" == typeof exports && "object" == typeof module
              ? mod(
                  require("../../lib/codemirror"),
                  require("../dialog/dialog")
                )
              : mod(CodeMirror);
        },
        { "../../lib/codemirror": 66, "../dialog/dialog": 54 }
      ],
      63: [
        function(require, module, exports) {
          var mod;
          (mod = function(CodeMirror) {
            "use strict";
            function getSearchState(cm) {
              return (
                cm.state.search ||
                (cm.state.search = new function() {
                  (this.posFrom = this.posTo = this.lastQuery = this.query = null),
                    (this.overlay = null);
                }())
              );
            }
            function queryCaseInsensitive(query) {
              return "string" == typeof query && query == query.toLowerCase();
            }
            function getSearchCursor(cm, query, pos) {
              return cm.getSearchCursor(query, pos, {
                caseFold: queryCaseInsensitive(query),
                multiline: !0
              });
            }
            function dialog(cm, text, shortText, deflt, f) {
              cm.openDialog
                ? cm.openDialog(text, f, {
                    value: deflt,
                    selectValueOnOpen: !0
                  })
                : f(prompt(shortText, deflt));
            }
            function parseString(string) {
              return string.replace(/\\(.)/g, function(_, ch) {
                return "n" == ch ? "\n" : "r" == ch ? "\r" : ch;
              });
            }
            function parseQuery(query) {
              var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
              if (isRE)
                try {
                  query = new RegExp(
                    isRE[1],
                    -1 == isRE[2].indexOf("i") ? "" : "i"
                  );
                } catch (e) {}
              else query = parseString(query);
              return (
                ("string" == typeof query ? "" == query : query.test("")) &&
                  (query = /x^/),
                query
              );
            }
            var queryDialog =
              '<span class="CodeMirror-search-label">Search:</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use /re/ syntax for regexp search)</span>';
            function startSearch(cm, state, query) {
              (state.queryText = query),
                (state.query = parseQuery(query)),
                cm.removeOverlay(
                  state.overlay,
                  queryCaseInsensitive(state.query)
                ),
                (state.overlay = (function(query, caseInsensitive) {
                  return (
                    "string" == typeof query
                      ? (query = new RegExp(
                          query.replace(
                            /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,
                            "\\$&"
                          ),
                          caseInsensitive ? "gi" : "g"
                        ))
                      : query.global ||
                        (query = new RegExp(
                          query.source,
                          query.ignoreCase ? "gi" : "g"
                        )),
                    {
                      token: function(stream) {
                        query.lastIndex = stream.pos;
                        var match = query.exec(stream.string);
                        if (match && match.index == stream.pos)
                          return (
                            (stream.pos += match[0].length || 1), "searching"
                          );
                        match ? (stream.pos = match.index) : stream.skipToEnd();
                      }
                    }
                  );
                })(state.query, queryCaseInsensitive(state.query))),
                cm.addOverlay(state.overlay),
                cm.showMatchesOnScrollbar &&
                  (state.annotate &&
                    (state.annotate.clear(), (state.annotate = null)),
                  (state.annotate = cm.showMatchesOnScrollbar(
                    state.query,
                    queryCaseInsensitive(state.query)
                  )));
            }
            function doSearch(cm, rev, persistent, immediate) {
              var state = getSearchState(cm);
              if (state.query) return findNext(cm, rev);
              var q = cm.getSelection() || state.lastQuery;
              if (
                (q instanceof RegExp && "x^" == q.source && (q = null),
                persistent && cm.openDialog)
              ) {
                var hiding = null,
                  searchNext = function(query, event) {
                    CodeMirror.e_stop(event),
                      query &&
                        (query != state.queryText &&
                          (startSearch(cm, state, query),
                          (state.posFrom = state.posTo = cm.getCursor())),
                        hiding && (hiding.style.opacity = 1),
                        findNext(cm, event.shiftKey, function(_, to) {
                          var dialog;
                          to.line < 3 &&
                            document.querySelector &&
                            (dialog = cm.display.wrapper.querySelector(
                              ".CodeMirror-dialog"
                            )) &&
                            dialog.getBoundingClientRect().bottom - 4 >
                              cm.cursorCoords(to, "window").top &&
                            ((hiding = dialog).style.opacity = 0.4);
                        }));
                  };
                !(function(cm, text, deflt, onEnter, onKeyDown) {
                  cm.openDialog(text, onEnter, {
                    value: deflt,
                    selectValueOnOpen: !0,
                    closeOnEnter: !1,
                    onClose: function() {
                      clearSearch(cm);
                    },
                    onKeyDown: onKeyDown
                  });
                })(cm, queryDialog, q, searchNext, function(event, query) {
                  var keyName = CodeMirror.keyName(event),
                    extra = cm.getOption("extraKeys"),
                    cmd =
                      (extra && extra[keyName]) ||
                      CodeMirror.keyMap[cm.getOption("keyMap")][keyName];
                  "findNext" == cmd ||
                  "findPrev" == cmd ||
                  "findPersistentNext" == cmd ||
                  "findPersistentPrev" == cmd
                    ? (CodeMirror.e_stop(event),
                      startSearch(cm, getSearchState(cm), query),
                      cm.execCommand(cmd))
                    : ("find" != cmd && "findPersistent" != cmd) ||
                      (CodeMirror.e_stop(event), searchNext(query, event));
                }),
                  immediate &&
                    q &&
                    (startSearch(cm, state, q), findNext(cm, rev));
              } else
                dialog(cm, queryDialog, "Search for:", q, function(query) {
                  query &&
                    !state.query &&
                    cm.operation(function() {
                      startSearch(cm, state, query),
                        (state.posFrom = state.posTo = cm.getCursor()),
                        findNext(cm, rev);
                    });
                });
            }
            function findNext(cm, rev, callback) {
              cm.operation(function() {
                var state = getSearchState(cm),
                  cursor = getSearchCursor(
                    cm,
                    state.query,
                    rev ? state.posFrom : state.posTo
                  );
                (cursor.find(rev) ||
                  (cursor = getSearchCursor(
                    cm,
                    state.query,
                    rev
                      ? CodeMirror.Pos(cm.lastLine())
                      : CodeMirror.Pos(cm.firstLine(), 0)
                  )).find(rev)) &&
                  (cm.setSelection(cursor.from(), cursor.to()),
                  cm.scrollIntoView(
                    { from: cursor.from(), to: cursor.to() },
                    20
                  ),
                  (state.posFrom = cursor.from()),
                  (state.posTo = cursor.to()),
                  callback && callback(cursor.from(), cursor.to()));
              });
            }
            function clearSearch(cm) {
              cm.operation(function() {
                var state = getSearchState(cm);
                (state.lastQuery = state.query),
                  state.query &&
                    ((state.query = state.queryText = null),
                    cm.removeOverlay(state.overlay),
                    state.annotate &&
                      (state.annotate.clear(), (state.annotate = null)));
              });
            }
            var replaceQueryDialog =
                ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">(Use /re/ syntax for regexp search)</span>',
              replacementQueryDialog =
                '<span class="CodeMirror-search-label">With:</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/>',
              doReplaceConfirm =
                '<span class="CodeMirror-search-label">Replace?</span> <button>Yes</button> <button>No</button> <button>All</button> <button>Stop</button>';
            function replaceAll(cm, query, text) {
              cm.operation(function() {
                for (
                  var cursor = getSearchCursor(cm, query);
                  cursor.findNext();

                )
                  if ("string" != typeof query) {
                    var match = cm
                      .getRange(cursor.from(), cursor.to())
                      .match(query);
                    cursor.replace(
                      text.replace(/\$(\d)/g, function(_, i) {
                        return match[i];
                      })
                    );
                  } else cursor.replace(text);
              });
            }
            function replace(cm, all) {
              if (!cm.getOption("readOnly")) {
                var query = cm.getSelection() || getSearchState(cm).lastQuery,
                  dialogText =
                    '<span class="CodeMirror-search-label">' +
                    (all ? "Replace all:" : "Replace:") +
                    "</span>";
                dialog(
                  cm,
                  dialogText + replaceQueryDialog,
                  dialogText,
                  query,
                  function(query) {
                    query &&
                      ((query = parseQuery(query)),
                      dialog(
                        cm,
                        replacementQueryDialog,
                        "Replace with:",
                        "",
                        function(text) {
                          if (((text = parseString(text)), all))
                            replaceAll(cm, query, text);
                          else {
                            clearSearch(cm);
                            var cursor = getSearchCursor(
                                cm,
                                query,
                                cm.getCursor("from")
                              ),
                              advance = function() {
                                var match,
                                  start = cursor.from();
                                (!(match = cursor.findNext()) &&
                                  ((cursor = getSearchCursor(cm, query)),
                                  !(match = cursor.findNext()) ||
                                    (start &&
                                      cursor.from().line == start.line &&
                                      cursor.from().ch == start.ch))) ||
                                  (cm.setSelection(cursor.from(), cursor.to()),
                                  cm.scrollIntoView({
                                    from: cursor.from(),
                                    to: cursor.to()
                                  }),
                                  (function(cm, text, shortText, fs) {
                                    cm.openConfirm
                                      ? cm.openConfirm(text, fs)
                                      : confirm(shortText) && fs[0]();
                                  })(cm, doReplaceConfirm, "Replace?", [
                                    function() {
                                      doReplace(match);
                                    },
                                    advance,
                                    function() {
                                      replaceAll(cm, query, text);
                                    }
                                  ]));
                              },
                              doReplace = function(match) {
                                cursor.replace(
                                  "string" == typeof query
                                    ? text
                                    : text.replace(/\$(\d)/g, function(_, i) {
                                        return match[i];
                                      })
                                ),
                                  advance();
                              };
                            advance();
                          }
                        }
                      ));
                  }
                );
              }
            }
            (CodeMirror.commands.find = function(cm) {
              clearSearch(cm), doSearch(cm);
            }),
              (CodeMirror.commands.findPersistent = function(cm) {
                clearSearch(cm), doSearch(cm, !1, !0);
              }),
              (CodeMirror.commands.findPersistentNext = function(cm) {
                doSearch(cm, !1, !0, !0);
              }),
              (CodeMirror.commands.findPersistentPrev = function(cm) {
                doSearch(cm, !0, !0, !0);
              }),
              (CodeMirror.commands.findNext = doSearch),
              (CodeMirror.commands.findPrev = function(cm) {
                doSearch(cm, !0);
              }),
              (CodeMirror.commands.clearSearch = clearSearch),
              (CodeMirror.commands.replace = replace),
              (CodeMirror.commands.replaceAll = function(cm) {
                replace(cm, !0);
              });
          }),
            "object" == typeof exports && "object" == typeof module
              ? mod(
                  require("../../lib/codemirror"),
                  require("./searchcursor"),
                  require("../dialog/dialog")
                )
              : mod(CodeMirror);
        },
        {
          "../../lib/codemirror": 66,
          "../dialog/dialog": 54,
          "./searchcursor": 64
        }
      ],
      64: [
        function(require, module, exports) {
          (function(CodeMirror) {
            "use strict";
            var doFold,
              noFold,
              Pos = CodeMirror.Pos;
            function ensureFlags(regexp, flags) {
              for (
                var current = (function(regexp) {
                    var flags = regexp.flags;
                    return null != flags
                      ? flags
                      : (regexp.ignoreCase ? "i" : "") +
                          (regexp.global ? "g" : "") +
                          (regexp.multiline ? "m" : "");
                  })(regexp),
                  target = current,
                  i = 0;
                i < flags.length;
                i++
              )
                -1 == target.indexOf(flags.charAt(i)) &&
                  (target += flags.charAt(i));
              return current == target
                ? regexp
                : new RegExp(regexp.source, target);
            }
            function searchRegexpForward(doc, regexp, start) {
              regexp = ensureFlags(regexp, "g");
              for (
                var line = start.line, ch = start.ch, last = doc.lastLine();
                line <= last;
                line++, ch = 0
              ) {
                regexp.lastIndex = ch;
                var string = doc.getLine(line),
                  match = regexp.exec(string);
                if (match)
                  return {
                    from: Pos(line, match.index),
                    to: Pos(line, match.index + match[0].length),
                    match: match
                  };
              }
            }
            function lastMatchIn(string, regexp) {
              for (var match, cutOff = 0; ; ) {
                regexp.lastIndex = cutOff;
                var newMatch = regexp.exec(string);
                if (!newMatch) return match;
                if (
                  (cutOff =
                    (match = newMatch).index + (match[0].length || 1)) ==
                  string.length
                )
                  return match;
              }
            }
            function adjustPos(orig, folded, pos, foldFunc) {
              if (orig.length == folded.length) return pos;
              for (
                var min = 0,
                  max = pos + Math.max(0, orig.length - folded.length);
                ;

              ) {
                if (min == max) return min;
                var mid = (min + max) >> 1,
                  len = foldFunc(orig.slice(0, mid)).length;
                if (len == pos) return mid;
                pos < len ? (max = mid) : (min = mid + 1);
              }
            }
            function SearchCursor(doc, query, pos, options) {
              var caseFold;
              (this.atOccurrence = !1),
                (this.doc = doc),
                (pos = pos ? doc.clipPos(pos) : Pos(0, 0)),
                (this.pos = { from: pos, to: pos }),
                "object" == typeof options
                  ? (caseFold = options.caseFold)
                  : ((caseFold = options), (options = null)),
                "string" == typeof query
                  ? (null == caseFold && (caseFold = !1),
                    (this.matches = function(reverse, pos) {
                      return (reverse
                        ? function(doc, query, start, caseFold) {
                            if (!query.length) return null;
                            var fold = caseFold ? doFold : noFold,
                              lines = fold(query).split(/\r|\n\r?/);
                            search: for (
                              var line = start.line,
                                ch = start.ch,
                                first = doc.firstLine() - 1 + lines.length;
                              first <= line;
                              line--, ch = -1
                            ) {
                              var orig = doc.getLine(line);
                              -1 < ch && (orig = orig.slice(0, ch));
                              var string = fold(orig);
                              if (1 == lines.length) {
                                var found = string.lastIndexOf(lines[0]);
                                if (-1 == found) continue search;
                                return {
                                  from: Pos(
                                    line,
                                    adjustPos(orig, string, found, fold)
                                  ),
                                  to: Pos(
                                    line,
                                    adjustPos(
                                      orig,
                                      string,
                                      found + lines[0].length,
                                      fold
                                    )
                                  )
                                };
                              }
                              var lastLine = lines[lines.length - 1];
                              if (
                                string.slice(0, lastLine.length) == lastLine
                              ) {
                                var i = 1;
                                for (
                                  start = line - lines.length + 1;
                                  i < lines.length - 1;
                                  i++
                                )
                                  if (fold(doc.getLine(start + i)) != lines[i])
                                    continue search;
                                var top = doc.getLine(line + 1 - lines.length),
                                  topString = fold(top);
                                if (
                                  topString.slice(
                                    topString.length - lines[0].length
                                  ) == lines[0]
                                )
                                  return {
                                    from: Pos(
                                      line + 1 - lines.length,
                                      adjustPos(
                                        top,
                                        topString,
                                        top.length - lines[0].length,
                                        fold
                                      )
                                    ),
                                    to: Pos(
                                      line,
                                      adjustPos(
                                        orig,
                                        string,
                                        lastLine.length,
                                        fold
                                      )
                                    )
                                  };
                              }
                            }
                          }
                        : function(doc, query, start, caseFold) {
                            if (!query.length) return null;
                            var fold = caseFold ? doFold : noFold,
                              lines = fold(query).split(/\r|\n\r?/);
                            search: for (
                              var line = start.line,
                                ch = start.ch,
                                last = doc.lastLine() + 1 - lines.length;
                              line <= last;
                              line++, ch = 0
                            ) {
                              var orig = doc.getLine(line).slice(ch),
                                string = fold(orig);
                              if (1 == lines.length) {
                                var found = string.indexOf(lines[0]);
                                if (-1 == found) continue search;
                                return (
                                  (start =
                                    adjustPos(orig, string, found, fold) + ch),
                                  {
                                    from: Pos(
                                      line,
                                      adjustPos(orig, string, found, fold) + ch
                                    ),
                                    to: Pos(
                                      line,
                                      adjustPos(
                                        orig,
                                        string,
                                        found + lines[0].length,
                                        fold
                                      ) + ch
                                    )
                                  }
                                );
                              }
                              var cutFrom = string.length - lines[0].length;
                              if (string.slice(cutFrom) == lines[0]) {
                                for (var i = 1; i < lines.length - 1; i++)
                                  if (fold(doc.getLine(line + i)) != lines[i])
                                    continue search;
                                var end = doc.getLine(line + lines.length - 1),
                                  endString = fold(end),
                                  lastLine = lines[lines.length - 1];
                                if (
                                  endString.slice(0, lastLine.length) ==
                                  lastLine
                                )
                                  return {
                                    from: Pos(
                                      line,
                                      adjustPos(orig, string, cutFrom, fold) +
                                        ch
                                    ),
                                    to: Pos(
                                      line + lines.length - 1,
                                      adjustPos(
                                        end,
                                        endString,
                                        lastLine.length,
                                        fold
                                      )
                                    )
                                  };
                              }
                            }
                          })(doc, query, pos, caseFold);
                    }))
                  : ((query = ensureFlags(query, "gm")),
                    options && !1 === options.multiline
                      ? (this.matches = function(reverse, pos) {
                          return (reverse
                            ? function(doc, regexp, start) {
                                regexp = ensureFlags(regexp, "g");
                                for (
                                  var line = start.line,
                                    ch = start.ch,
                                    first = doc.firstLine();
                                  first <= line;
                                  line--, ch = -1
                                ) {
                                  var string = doc.getLine(line);
                                  -1 < ch && (string = string.slice(0, ch));
                                  var match = lastMatchIn(string, regexp);
                                  if (match)
                                    return {
                                      from: Pos(line, match.index),
                                      to: Pos(
                                        line,
                                        match.index + match[0].length
                                      ),
                                      match: match
                                    };
                                }
                              }
                            : searchRegexpForward)(doc, query, pos);
                        })
                      : (this.matches = function(reverse, pos) {
                          return (reverse
                            ? function(doc, regexp, start) {
                                regexp = ensureFlags(regexp, "gm");
                                for (
                                  var string,
                                    chunk = 1,
                                    line = start.line,
                                    first = doc.firstLine();
                                  first <= line;

                                ) {
                                  for (var i = 0; i < chunk; i++) {
                                    var curLine = doc.getLine(line--);
                                    string =
                                      null == string
                                        ? curLine.slice(0, start.ch)
                                        : curLine + "\n" + string;
                                  }
                                  chunk *= 2;
                                  var match = lastMatchIn(string, regexp);
                                  if (match) {
                                    var before = string
                                        .slice(0, match.index)
                                        .split("\n"),
                                      inside = match[0].split("\n"),
                                      startLine = line + before.length,
                                      startCh =
                                        before[before.length - 1].length;
                                    return {
                                      from: Pos(startLine, startCh),
                                      to: Pos(
                                        startLine + inside.length - 1,
                                        1 == inside.length
                                          ? startCh + inside[0].length
                                          : inside[inside.length - 1].length
                                      ),
                                      match: match
                                    };
                                  }
                                }
                              }
                            : function(doc, regexp, start) {
                                if (
                                  !(function(regexp) {
                                    return /\\s|\\n|\n|\\W|\\D|\[\^/.test(
                                      regexp.source
                                    );
                                  })(regexp)
                                )
                                  return searchRegexpForward(
                                    doc,
                                    regexp,
                                    start
                                  );
                                regexp = ensureFlags(regexp, "gm");
                                for (
                                  var string,
                                    chunk = 1,
                                    line = start.line,
                                    last = doc.lastLine();
                                  line <= last;

                                ) {
                                  for (
                                    var i = 0;
                                    i < chunk && !(last < line);
                                    i++
                                  ) {
                                    var curLine = doc.getLine(line++);
                                    string =
                                      null == string
                                        ? curLine
                                        : string + "\n" + curLine;
                                  }
                                  (chunk *= 2), (regexp.lastIndex = start.ch);
                                  var match = regexp.exec(string);
                                  if (match) {
                                    var before = string
                                        .slice(0, match.index)
                                        .split("\n"),
                                      inside = match[0].split("\n"),
                                      startLine =
                                        start.line + before.length - 1,
                                      startCh =
                                        before[before.length - 1].length;
                                    return {
                                      from: Pos(startLine, startCh),
                                      to: Pos(
                                        startLine + inside.length - 1,
                                        1 == inside.length
                                          ? startCh + inside[0].length
                                          : inside[inside.length - 1].length
                                      ),
                                      match: match
                                    };
                                  }
                                }
                              })(doc, query, pos);
                        }));
            }
            String.prototype.normalize
              ? ((doFold = function(str) {
                  return str.normalize("NFD").toLowerCase();
                }),
                (noFold = function(str) {
                  return str.normalize("NFD");
                }))
              : ((doFold = function(str) {
                  return str.toLowerCase();
                }),
                (noFold = function(str) {
                  return str;
                })),
              (SearchCursor.prototype = {
                findNext: function() {
                  return this.find(!1);
                },
                findPrevious: function() {
                  return this.find(!0);
                },
                find: function(reverse) {
                  for (
                    var result = this.matches(
                      reverse,
                      this.doc.clipPos(reverse ? this.pos.from : this.pos.to)
                    );
                    result && 0 == CodeMirror.cmpPos(result.from, result.to);

                  )
                    reverse
                      ? result.from.ch
                        ? (result.from = Pos(
                            result.from.line,
                            result.from.ch - 1
                          ))
                        : (result =
                            result.from.line == this.doc.firstLine()
                              ? null
                              : this.matches(
                                  reverse,
                                  this.doc.clipPos(Pos(result.from.line - 1))
                                ))
                      : result.to.ch < this.doc.getLine(result.to.line).length
                        ? (result.to = Pos(result.to.line, result.to.ch + 1))
                        : (result =
                            result.to.line == this.doc.lastLine()
                              ? null
                              : this.matches(
                                  reverse,
                                  Pos(result.to.line + 1, 0)
                                ));
                  if (result)
                    return (
                      (this.pos = result),
                      (this.atOccurrence = !0),
                      this.pos.match || !0
                    );
                  var end = Pos(
                    reverse ? this.doc.firstLine() : this.doc.lastLine() + 1,
                    0
                  );
                  return (
                    (this.pos = { from: end, to: end }),
                    (this.atOccurrence = !1)
                  );
                },
                from: function() {
                  if (this.atOccurrence) return this.pos.from;
                },
                to: function() {
                  if (this.atOccurrence) return this.pos.to;
                },
                replace: function(newText, origin) {
                  if (this.atOccurrence) {
                    var lines = CodeMirror.splitLines(newText);
                    this.doc.replaceRange(
                      lines,
                      this.pos.from,
                      this.pos.to,
                      origin
                    ),
                      (this.pos.to = Pos(
                        this.pos.from.line + lines.length - 1,
                        lines[lines.length - 1].length +
                          (1 == lines.length ? this.pos.from.ch : 0)
                      ));
                  }
                }
              }),
              CodeMirror.defineExtension("getSearchCursor", function(
                query,
                pos,
                caseFold
              ) {
                return new SearchCursor(this.doc, query, pos, caseFold);
              }),
              CodeMirror.defineDocExtension("getSearchCursor", function(
                query,
                pos,
                caseFold
              ) {
                return new SearchCursor(this, query, pos, caseFold);
              }),
              CodeMirror.defineExtension("selectMatches", function(
                query,
                caseFold
              ) {
                for (
                  var ranges = [],
                    cur = this.getSearchCursor(
                      query,
                      this.getCursor("from"),
                      caseFold
                    );
                  cur.findNext() &&
                  !(0 < CodeMirror.cmpPos(cur.to(), this.getCursor("to")));

                )
                  ranges.push({ anchor: cur.from(), head: cur.to() });
                ranges.length && this.setSelections(ranges, 0);
              });
          })(
            "object" == typeof exports && "object" == typeof module
              ? require("../../lib/codemirror")
              : CodeMirror
          );
        },
        { "../../lib/codemirror": 66 }
      ],
      65: [
        function(require, module, exports) {
          var mod;
          (mod = function(CodeMirror) {
            "use strict";
            var cmds = CodeMirror.commands,
              Pos = CodeMirror.Pos;
            function moveSubword(cm, dir) {
              cm.extendSelectionsBy(function(range) {
                return cm.display.shift || cm.doc.extend || range.empty()
                  ? (function(doc, start, dir) {
                      if (dir < 0 && 0 == start.ch)
                        return doc.clipPos(Pos(start.line - 1));
                      var line = doc.getLine(start.line);
                      if (0 < dir && start.ch >= line.length)
                        return doc.clipPos(Pos(start.line + 1, 0));
                      for (
                        var type,
                          state = "start",
                          pos = start.ch,
                          e = dir < 0 ? 0 : line.length,
                          i = 0;
                        pos != e;
                        pos += dir, i++
                      ) {
                        var next = line.charAt(dir < 0 ? pos - 1 : pos),
                          cat =
                            "_" != next && CodeMirror.isWordChar(next)
                              ? "w"
                              : "o";
                        if (
                          ("w" == cat &&
                            next.toUpperCase() == next &&
                            (cat = "W"),
                          "start" == state)
                        )
                          "o" != cat && ((state = "in"), (type = cat));
                        else if ("in" == state && type != cat) {
                          if (
                            ("w" == type && "W" == cat && dir < 0 && pos--,
                            "W" == type && "w" == cat && 0 < dir)
                          ) {
                            type = "w";
                            continue;
                          }
                          break;
                        }
                      }
                      return Pos(start.line, pos);
                    })(cm.doc, range.head, dir)
                  : dir < 0 ? range.from() : range.to();
              });
            }
            function insertLine(cm, above) {
              if (cm.isReadOnly()) return CodeMirror.Pass;
              cm.operation(function() {
                for (
                  var len = cm.listSelections().length,
                    newSelection = [],
                    last = -1,
                    i = 0;
                  i < len;
                  i++
                ) {
                  var head = cm.listSelections()[i].head;
                  if (!(head.line <= last)) {
                    var at = Pos(head.line + (above ? 0 : 1), 0);
                    cm.replaceRange("\n", at, null, "+insertLine"),
                      cm.indentLine(at.line, null, !0),
                      newSelection.push({ head: at, anchor: at }),
                      (last = head.line + 1);
                  }
                }
                cm.setSelections(newSelection);
              }),
                cm.execCommand("indentAuto");
            }
            function wordAt(cm, pos) {
              for (
                var start = pos.ch, end = start, line = cm.getLine(pos.line);
                start && CodeMirror.isWordChar(line.charAt(start - 1));

              )
                --start;
              for (
                ;
                end < line.length && CodeMirror.isWordChar(line.charAt(end));

              )
                ++end;
              return {
                from: Pos(pos.line, start),
                to: Pos(pos.line, end),
                word: line.slice(start, end)
              };
            }
            function addCursorToSelection(cm, dir) {
              for (
                var ranges = cm.listSelections(), newRanges = [], i = 0;
                i < ranges.length;
                i++
              ) {
                var range = ranges[i],
                  newAnchor = cm.findPosV(
                    range.anchor,
                    dir,
                    "line",
                    range.anchor.goalColumn
                  ),
                  newHead = cm.findPosV(
                    range.head,
                    dir,
                    "line",
                    range.head.goalColumn
                  );
                (newAnchor.goalColumn =
                  null != range.anchor.goalColumn
                    ? range.anchor.goalColumn
                    : cm.cursorCoords(range.anchor, "div").left),
                  (newHead.goalColumn =
                    null != range.head.goalColumn
                      ? range.head.goalColumn
                      : cm.cursorCoords(range.head, "div").left);
                var newRange = { anchor: newAnchor, head: newHead };
                newRanges.push(range), newRanges.push(newRange);
              }
              cm.setSelections(newRanges);
            }
            (cmds.goSubwordLeft = function(cm) {
              moveSubword(cm, -1);
            }),
              (cmds.goSubwordRight = function(cm) {
                moveSubword(cm, 1);
              }),
              (cmds.scrollLineUp = function(cm) {
                var info = cm.getScrollInfo();
                if (!cm.somethingSelected()) {
                  var visibleBottomLine = cm.lineAtHeight(
                    info.top + info.clientHeight,
                    "local"
                  );
                  cm.getCursor().line >= visibleBottomLine &&
                    cm.execCommand("goLineUp");
                }
                cm.scrollTo(null, info.top - cm.defaultTextHeight());
              }),
              (cmds.scrollLineDown = function(cm) {
                var info = cm.getScrollInfo();
                if (!cm.somethingSelected()) {
                  var visibleTopLine = cm.lineAtHeight(info.top, "local") + 1;
                  cm.getCursor().line <= visibleTopLine &&
                    cm.execCommand("goLineDown");
                }
                cm.scrollTo(null, info.top + cm.defaultTextHeight());
              }),
              (cmds.splitSelectionByLine = function(cm) {
                for (
                  var ranges = cm.listSelections(), lineRanges = [], i = 0;
                  i < ranges.length;
                  i++
                )
                  for (
                    var from = ranges[i].from(),
                      to = ranges[i].to(),
                      line = from.line;
                    line <= to.line;
                    ++line
                  )
                    (to.line > from.line && line == to.line && 0 == to.ch) ||
                      lineRanges.push({
                        anchor: line == from.line ? from : Pos(line, 0),
                        head: line == to.line ? to : Pos(line)
                      });
                cm.setSelections(lineRanges, 0);
              }),
              (cmds.singleSelectionTop = function(cm) {
                var range = cm.listSelections()[0];
                cm.setSelection(range.anchor, range.head, { scroll: !1 });
              }),
              (cmds.selectLine = function(cm) {
                for (
                  var ranges = cm.listSelections(), extended = [], i = 0;
                  i < ranges.length;
                  i++
                ) {
                  var range = ranges[i];
                  extended.push({
                    anchor: Pos(range.from().line, 0),
                    head: Pos(range.to().line + 1, 0)
                  });
                }
                cm.setSelections(extended);
              }),
              (cmds.insertLineAfter = function(cm) {
                return insertLine(cm, !1);
              }),
              (cmds.insertLineBefore = function(cm) {
                return insertLine(cm, !0);
              }),
              (cmds.selectNextOccurrence = function(cm) {
                var from = cm.getCursor("from"),
                  to = cm.getCursor("to"),
                  fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;
                if (0 == CodeMirror.cmpPos(from, to)) {
                  var word = wordAt(cm, from);
                  if (!word.word) return;
                  cm.setSelection(word.from, word.to), (fullWord = !0);
                } else {
                  var text = cm.getRange(from, to),
                    query = fullWord ? new RegExp("\\b" + text + "\\b") : text,
                    cur = cm.getSearchCursor(query, to),
                    found = cur.findNext();
                  if (
                    (found ||
                      (found = (cur = cm.getSearchCursor(
                        query,
                        Pos(cm.firstLine(), 0)
                      )).findNext()),
                    !found ||
                      (function(ranges, from, to) {
                        for (var i = 0; i < ranges.length; i++)
                          if (ranges[i].from() == from && ranges[i].to() == to)
                            return !0;
                        return !1;
                      })(cm.listSelections(), cur.from(), cur.to()))
                  )
                    return CodeMirror.Pass;
                  cm.addSelection(cur.from(), cur.to());
                }
                fullWord && (cm.state.sublimeFindFullWord = cm.doc.sel);
              }),
              (cmds.addCursorToPrevLine = function(cm) {
                addCursorToSelection(cm, -1);
              }),
              (cmds.addCursorToNextLine = function(cm) {
                addCursorToSelection(cm, 1);
              });
            var mirror = "(){}[]";
            function selectBetweenBrackets(cm) {
              for (
                var ranges = cm.listSelections(), newRanges = [], i = 0;
                i < ranges.length;
                i++
              ) {
                var range = ranges[i],
                  pos = range.head,
                  opening = cm.scanForBracket(pos, -1);
                if (!opening) return !1;
                for (;;) {
                  var closing = cm.scanForBracket(pos, 1);
                  if (!closing) return !1;
                  if (
                    closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)
                  ) {
                    var startPos = Pos(opening.pos.line, opening.pos.ch + 1);
                    if (
                      0 != CodeMirror.cmpPos(startPos, range.from()) ||
                      0 != CodeMirror.cmpPos(closing.pos, range.to())
                    ) {
                      newRanges.push({ anchor: startPos, head: closing.pos });
                      break;
                    }
                    if (!(opening = cm.scanForBracket(opening.pos, -1)))
                      return !1;
                  }
                  pos = Pos(closing.pos.line, closing.pos.ch + 1);
                }
              }
              return cm.setSelections(newRanges), !0;
            }
            function sortLines(cm, caseSensitive) {
              if (cm.isReadOnly()) return CodeMirror.Pass;
              for (
                var selected, ranges = cm.listSelections(), toSort = [], i = 0;
                i < ranges.length;
                i++
              ) {
                var range = ranges[i];
                if (!range.empty()) {
                  for (
                    var from = range.from().line, to = range.to().line;
                    i < ranges.length - 1 && ranges[i + 1].from().line == to;

                  )
                    to = ranges[++i].to().line;
                  ranges[i].to().ch || to--, toSort.push(from, to);
                }
              }
              toSort.length
                ? (selected = !0)
                : toSort.push(cm.firstLine(), cm.lastLine()),
                cm.operation(function() {
                  for (var ranges = [], i = 0; i < toSort.length; i += 2) {
                    var from = toSort[i],
                      to = toSort[i + 1],
                      start = Pos(from, 0),
                      end = Pos(to),
                      lines = cm.getRange(start, end, !1);
                    caseSensitive
                      ? lines.sort()
                      : lines.sort(function(a, b) {
                          var au = a.toUpperCase(),
                            bu = b.toUpperCase();
                          return (
                            au != bu && ((a = au), (b = bu)),
                            a < b ? -1 : a == b ? 0 : 1
                          );
                        }),
                      cm.replaceRange(lines, start, end),
                      selected &&
                        ranges.push({ anchor: start, head: Pos(to + 1, 0) });
                  }
                  selected && cm.setSelections(ranges, 0);
                });
            }
            function modifyWordOrSelection(cm, mod) {
              cm.operation(function() {
                for (
                  var ranges = cm.listSelections(),
                    indices = [],
                    replacements = [],
                    i = 0;
                  i < ranges.length;
                  i++
                ) {
                  (range = ranges[i]).empty()
                    ? (indices.push(i), replacements.push(""))
                    : replacements.push(
                        mod(cm.getRange(range.from(), range.to()))
                      );
                }
                cm.replaceSelections(replacements, "around", "case");
                var at;
                for (i = indices.length - 1; 0 <= i; i--) {
                  var range = ranges[indices[i]];
                  if (!(at && 0 < CodeMirror.cmpPos(range.head, at))) {
                    var word = wordAt(cm, range.head);
                    (at = word.from),
                      cm.replaceRange(mod(word.word), word.from, word.to);
                  }
                }
              });
            }
            function getTarget(cm) {
              var from = cm.getCursor("from"),
                to = cm.getCursor("to");
              if (0 == CodeMirror.cmpPos(from, to)) {
                var word = wordAt(cm, from);
                if (!word.word) return;
                (from = word.from), (to = word.to);
              }
              return {
                from: from,
                to: to,
                query: cm.getRange(from, to),
                word: word
              };
            }
            function findAndGoTo(cm, forward) {
              var target = getTarget(cm);
              if (target) {
                var query = target.query,
                  cur = cm.getSearchCursor(
                    query,
                    forward ? target.to : target.from
                  );
                (forward ? cur.findNext() : cur.findPrevious())
                  ? cm.setSelection(cur.from(), cur.to())
                  : ((cur = cm.getSearchCursor(
                      query,
                      forward
                        ? Pos(cm.firstLine(), 0)
                        : cm.clipPos(Pos(cm.lastLine()))
                    )),
                    (forward ? cur.findNext() : cur.findPrevious())
                      ? cm.setSelection(cur.from(), cur.to())
                      : target.word && cm.setSelection(target.from, target.to));
              }
            }
            (cmds.selectScope = function(cm) {
              selectBetweenBrackets(cm) || cm.execCommand("selectAll");
            }),
              (cmds.selectBetweenBrackets = function(cm) {
                if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;
              }),
              (cmds.goToBracket = function(cm) {
                cm.extendSelectionsBy(function(range) {
                  var next = cm.scanForBracket(range.head, 1);
                  if (next && 0 != CodeMirror.cmpPos(next.pos, range.head))
                    return next.pos;
                  var prev = cm.scanForBracket(range.head, -1);
                  return (
                    (prev && Pos(prev.pos.line, prev.pos.ch + 1)) || range.head
                  );
                });
              }),
              (cmds.swapLineUp = function(cm) {
                if (cm.isReadOnly()) return CodeMirror.Pass;
                for (
                  var ranges = cm.listSelections(),
                    linesToMove = [],
                    at = cm.firstLine() - 1,
                    newSels = [],
                    i = 0;
                  i < ranges.length;
                  i++
                ) {
                  var range = ranges[i],
                    from = range.from().line - 1,
                    to = range.to().line;
                  newSels.push({
                    anchor: Pos(range.anchor.line - 1, range.anchor.ch),
                    head: Pos(range.head.line - 1, range.head.ch)
                  }),
                    0 != range.to().ch || range.empty() || --to,
                    at < from
                      ? linesToMove.push(from, to)
                      : linesToMove.length &&
                        (linesToMove[linesToMove.length - 1] = to),
                    (at = to);
                }
                cm.operation(function() {
                  for (var i = 0; i < linesToMove.length; i += 2) {
                    var from = linesToMove[i],
                      to = linesToMove[i + 1],
                      line = cm.getLine(from);
                    cm.replaceRange(
                      "",
                      Pos(from, 0),
                      Pos(from + 1, 0),
                      "+swapLine"
                    ),
                      to > cm.lastLine()
                        ? cm.replaceRange(
                            "\n" + line,
                            Pos(cm.lastLine()),
                            null,
                            "+swapLine"
                          )
                        : cm.replaceRange(
                            line + "\n",
                            Pos(to, 0),
                            null,
                            "+swapLine"
                          );
                  }
                  cm.setSelections(newSels), cm.scrollIntoView();
                });
              }),
              (cmds.swapLineDown = function(cm) {
                if (cm.isReadOnly()) return CodeMirror.Pass;
                for (
                  var ranges = cm.listSelections(),
                    linesToMove = [],
                    at = cm.lastLine() + 1,
                    i = ranges.length - 1;
                  0 <= i;
                  i--
                ) {
                  var range = ranges[i],
                    from = range.to().line + 1,
                    to = range.from().line;
                  0 != range.to().ch || range.empty() || from--,
                    from < at
                      ? linesToMove.push(from, to)
                      : linesToMove.length &&
                        (linesToMove[linesToMove.length - 1] = to),
                    (at = to);
                }
                cm.operation(function() {
                  for (var i = linesToMove.length - 2; 0 <= i; i -= 2) {
                    var from = linesToMove[i],
                      to = linesToMove[i + 1],
                      line = cm.getLine(from);
                    from == cm.lastLine()
                      ? cm.replaceRange(
                          "",
                          Pos(from - 1),
                          Pos(from),
                          "+swapLine"
                        )
                      : cm.replaceRange(
                          "",
                          Pos(from, 0),
                          Pos(from + 1, 0),
                          "+swapLine"
                        ),
                      cm.replaceRange(
                        line + "\n",
                        Pos(to, 0),
                        null,
                        "+swapLine"
                      );
                  }
                  cm.scrollIntoView();
                });
              }),
              (cmds.toggleCommentIndented = function(cm) {
                cm.toggleComment({ indent: !0 });
              }),
              (cmds.joinLines = function(cm) {
                for (
                  var ranges = cm.listSelections(), joined = [], i = 0;
                  i < ranges.length;
                  i++
                ) {
                  for (
                    var range = ranges[i],
                      from = range.from(),
                      start = from.line,
                      end = range.to().line;
                    i < ranges.length - 1 && ranges[i + 1].from().line == end;

                  )
                    end = ranges[++i].to().line;
                  joined.push({
                    start: start,
                    end: end,
                    anchor: !range.empty() && from
                  });
                }
                cm.operation(function() {
                  for (
                    var offset = 0, ranges = [], i = 0;
                    i < joined.length;
                    i++
                  ) {
                    for (
                      var head,
                        obj = joined[i],
                        anchor =
                          obj.anchor &&
                          Pos(obj.anchor.line - offset, obj.anchor.ch),
                        line = obj.start;
                      line <= obj.end;
                      line++
                    ) {
                      var actual = line - offset;
                      line == obj.end &&
                        (head = Pos(actual, cm.getLine(actual).length + 1)),
                        actual < cm.lastLine() &&
                          (cm.replaceRange(
                            " ",
                            Pos(actual),
                            Pos(
                              actual + 1,
                              /^\s*/.exec(cm.getLine(actual + 1))[0].length
                            )
                          ),
                          ++offset);
                    }
                    ranges.push({ anchor: anchor || head, head: head });
                  }
                  cm.setSelections(ranges, 0);
                });
              }),
              (cmds.duplicateLine = function(cm) {
                cm.operation(function() {
                  for (
                    var rangeCount = cm.listSelections().length, i = 0;
                    i < rangeCount;
                    i++
                  ) {
                    var range = cm.listSelections()[i];
                    range.empty()
                      ? cm.replaceRange(
                          cm.getLine(range.head.line) + "\n",
                          Pos(range.head.line, 0)
                        )
                      : cm.replaceRange(
                          cm.getRange(range.from(), range.to()),
                          range.from()
                        );
                  }
                  cm.scrollIntoView();
                });
              }),
              (cmds.sortLines = function(cm) {
                sortLines(cm, !0);
              }),
              (cmds.sortLinesInsensitive = function(cm) {
                sortLines(cm, !1);
              }),
              (cmds.nextBookmark = function(cm) {
                var marks = cm.state.sublimeBookmarks;
                if (marks)
                  for (; marks.length; ) {
                    var current = marks.shift(),
                      found = current.find();
                    if (found)
                      return (
                        marks.push(current),
                        cm.setSelection(found.from, found.to)
                      );
                  }
              }),
              (cmds.prevBookmark = function(cm) {
                var marks = cm.state.sublimeBookmarks;
                if (marks)
                  for (; marks.length; ) {
                    marks.unshift(marks.pop());
                    var found = marks[marks.length - 1].find();
                    if (found) return cm.setSelection(found.from, found.to);
                    marks.pop();
                  }
              }),
              (cmds.toggleBookmark = function(cm) {
                for (
                  var ranges = cm.listSelections(),
                    marks =
                      cm.state.sublimeBookmarks ||
                      (cm.state.sublimeBookmarks = []),
                    i = 0;
                  i < ranges.length;
                  i++
                ) {
                  for (
                    var from = ranges[i].from(),
                      to = ranges[i].to(),
                      found = ranges[i].empty()
                        ? cm.findMarksAt(from)
                        : cm.findMarks(from, to),
                      j = 0;
                    j < found.length;
                    j++
                  )
                    if (found[j].sublimeBookmark) {
                      found[j].clear();
                      for (var k = 0; k < marks.length; k++)
                        marks[k] == found[j] && marks.splice(k--, 1);
                      break;
                    }
                  j == found.length &&
                    marks.push(
                      cm.markText(from, to, {
                        sublimeBookmark: !0,
                        clearWhenEmpty: !1
                      })
                    );
                }
              }),
              (cmds.clearBookmarks = function(cm) {
                var marks = cm.state.sublimeBookmarks;
                if (marks)
                  for (var i = 0; i < marks.length; i++) marks[i].clear();
                marks.length = 0;
              }),
              (cmds.selectBookmarks = function(cm) {
                var marks = cm.state.sublimeBookmarks,
                  ranges = [];
                if (marks)
                  for (var i = 0; i < marks.length; i++) {
                    var found = marks[i].find();
                    found
                      ? ranges.push({ anchor: found.from, head: found.to })
                      : marks.splice(i--, 0);
                  }
                ranges.length && cm.setSelections(ranges, 0);
              }),
              (cmds.smartBackspace = function(cm) {
                if (cm.somethingSelected()) return CodeMirror.Pass;
                cm.operation(function() {
                  for (
                    var cursors = cm.listSelections(),
                      indentUnit = cm.getOption("indentUnit"),
                      i = cursors.length - 1;
                    0 <= i;
                    i--
                  ) {
                    var cursor = cursors[i].head,
                      toStartOfLine = cm.getRange(
                        { line: cursor.line, ch: 0 },
                        cursor
                      ),
                      column = CodeMirror.countColumn(
                        toStartOfLine,
                        null,
                        cm.getOption("tabSize")
                      ),
                      deletePos = cm.findPosH(cursor, -1, "char", !1);
                    if (
                      toStartOfLine &&
                      !/\S/.test(toStartOfLine) &&
                      column % indentUnit == 0
                    ) {
                      var prevIndent = new Pos(
                        cursor.line,
                        CodeMirror.findColumn(
                          toStartOfLine,
                          column - indentUnit,
                          indentUnit
                        )
                      );
                      prevIndent.ch != cursor.ch && (deletePos = prevIndent);
                    }
                    cm.replaceRange("", deletePos, cursor, "+delete");
                  }
                });
              }),
              (cmds.delLineRight = function(cm) {
                cm.operation(function() {
                  for (
                    var ranges = cm.listSelections(), i = ranges.length - 1;
                    0 <= i;
                    i--
                  )
                    cm.replaceRange(
                      "",
                      ranges[i].anchor,
                      Pos(ranges[i].to().line),
                      "+delete"
                    );
                  cm.scrollIntoView();
                });
              }),
              (cmds.upcaseAtCursor = function(cm) {
                modifyWordOrSelection(cm, function(str) {
                  return str.toUpperCase();
                });
              }),
              (cmds.downcaseAtCursor = function(cm) {
                modifyWordOrSelection(cm, function(str) {
                  return str.toLowerCase();
                });
              }),
              (cmds.setSublimeMark = function(cm) {
                cm.state.sublimeMark && cm.state.sublimeMark.clear(),
                  (cm.state.sublimeMark = cm.setBookmark(cm.getCursor()));
              }),
              (cmds.selectToSublimeMark = function(cm) {
                var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
                found && cm.setSelection(cm.getCursor(), found);
              }),
              (cmds.deleteToSublimeMark = function(cm) {
                var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
                if (found) {
                  var from = cm.getCursor(),
                    to = found;
                  if (0 < CodeMirror.cmpPos(from, to)) {
                    var tmp = to;
                    (to = from), (from = tmp);
                  }
                  (cm.state.sublimeKilled = cm.getRange(from, to)),
                    cm.replaceRange("", from, to);
                }
              }),
              (cmds.swapWithSublimeMark = function(cm) {
                var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
                found &&
                  (cm.state.sublimeMark.clear(),
                  (cm.state.sublimeMark = cm.setBookmark(cm.getCursor())),
                  cm.setCursor(found));
              }),
              (cmds.sublimeYank = function(cm) {
                null != cm.state.sublimeKilled &&
                  cm.replaceSelection(cm.state.sublimeKilled, null, "paste");
              }),
              (cmds.showInCenter = function(cm) {
                var pos = cm.cursorCoords(null, "local");
                cm.scrollTo(
                  null,
                  (pos.top + pos.bottom) / 2 -
                    cm.getScrollInfo().clientHeight / 2
                );
              }),
              (cmds.findUnder = function(cm) {
                findAndGoTo(cm, !0);
              }),
              (cmds.findUnderPrevious = function(cm) {
                findAndGoTo(cm, !1);
              }),
              (cmds.findAllUnder = function(cm) {
                var target = getTarget(cm);
                if (target) {
                  for (
                    var cur = cm.getSearchCursor(target.query),
                      matches = [],
                      primaryIndex = -1;
                    cur.findNext();

                  )
                    matches.push({ anchor: cur.from(), head: cur.to() }),
                      cur.from().line <= target.from.line &&
                        cur.from().ch <= target.from.ch &&
                        primaryIndex++;
                  cm.setSelections(matches, primaryIndex);
                }
              });
            var keyMap = CodeMirror.keyMap;
            (keyMap.macSublime = {
              "Cmd-Left": "goLineStartSmart",
              "Shift-Tab": "indentLess",
              "Shift-Ctrl-K": "deleteLine",
              "Alt-Q": "wrapLines",
              "Ctrl-Left": "goSubwordLeft",
              "Ctrl-Right": "goSubwordRight",
              "Ctrl-Alt-Up": "scrollLineUp",
              "Ctrl-Alt-Down": "scrollLineDown",
              "Cmd-L": "selectLine",
              "Shift-Cmd-L": "splitSelectionByLine",
              Esc: "singleSelectionTop",
              "Cmd-Enter": "insertLineAfter",
              "Shift-Cmd-Enter": "insertLineBefore",
              "Cmd-D": "selectNextOccurrence",
              "Shift-Cmd-Space": "selectScope",
              "Shift-Cmd-M": "selectBetweenBrackets",
              "Cmd-M": "goToBracket",
              "Cmd-Ctrl-Up": "swapLineUp",
              "Cmd-Ctrl-Down": "swapLineDown",
              "Cmd-/": "toggleCommentIndented",
              "Cmd-J": "joinLines",
              "Shift-Cmd-D": "duplicateLine",
              F9: "sortLines",
              "Cmd-F9": "sortLinesInsensitive",
              F2: "nextBookmark",
              "Shift-F2": "prevBookmark",
              "Cmd-F2": "toggleBookmark",
              "Shift-Cmd-F2": "clearBookmarks",
              "Alt-F2": "selectBookmarks",
              Backspace: "smartBackspace",
              "Cmd-K Cmd-K": "delLineRight",
              "Cmd-K Cmd-U": "upcaseAtCursor",
              "Cmd-K Cmd-L": "downcaseAtCursor",
              "Cmd-K Cmd-Space": "setSublimeMark",
              "Cmd-K Cmd-A": "selectToSublimeMark",
              "Cmd-K Cmd-W": "deleteToSublimeMark",
              "Cmd-K Cmd-X": "swapWithSublimeMark",
              "Cmd-K Cmd-Y": "sublimeYank",
              "Cmd-K Cmd-C": "showInCenter",
              "Cmd-K Cmd-G": "clearBookmarks",
              "Cmd-K Cmd-Backspace": "delLineLeft",
              "Cmd-K Cmd-0": "unfoldAll",
              "Cmd-K Cmd-J": "unfoldAll",
              "Ctrl-Shift-Up": "addCursorToPrevLine",
              "Ctrl-Shift-Down": "addCursorToNextLine",
              "Cmd-F3": "findUnder",
              "Shift-Cmd-F3": "findUnderPrevious",
              "Alt-F3": "findAllUnder",
              "Shift-Cmd-[": "fold",
              "Shift-Cmd-]": "unfold",
              "Cmd-I": "findIncremental",
              "Shift-Cmd-I": "findIncrementalReverse",
              "Cmd-H": "replace",
              F3: "findNext",
              "Shift-F3": "findPrev",
              fallthrough: "macDefault"
            }),
              CodeMirror.normalizeKeyMap(keyMap.macSublime),
              (keyMap.pcSublime = {
                "Shift-Tab": "indentLess",
                "Shift-Ctrl-K": "deleteLine",
                "Alt-Q": "wrapLines",
                "Ctrl-T": "transposeChars",
                "Alt-Left": "goSubwordLeft",
                "Alt-Right": "goSubwordRight",
                "Ctrl-Up": "scrollLineUp",
                "Ctrl-Down": "scrollLineDown",
                "Ctrl-L": "selectLine",
                "Shift-Ctrl-L": "splitSelectionByLine",
                Esc: "singleSelectionTop",
                "Ctrl-Enter": "insertLineAfter",
                "Shift-Ctrl-Enter": "insertLineBefore",
                "Ctrl-D": "selectNextOccurrence",
                "Shift-Ctrl-Space": "selectScope",
                "Shift-Ctrl-M": "selectBetweenBrackets",
                "Ctrl-M": "goToBracket",
                "Shift-Ctrl-Up": "swapLineUp",
                "Shift-Ctrl-Down": "swapLineDown",
                "Ctrl-/": "toggleCommentIndented",
                "Ctrl-J": "joinLines",
                "Shift-Ctrl-D": "duplicateLine",
                F9: "sortLines",
                "Ctrl-F9": "sortLinesInsensitive",
                F2: "nextBookmark",
                "Shift-F2": "prevBookmark",
                "Ctrl-F2": "toggleBookmark",
                "Shift-Ctrl-F2": "clearBookmarks",
                "Alt-F2": "selectBookmarks",
                Backspace: "smartBackspace",
                "Ctrl-K Ctrl-K": "delLineRight",
                "Ctrl-K Ctrl-U": "upcaseAtCursor",
                "Ctrl-K Ctrl-L": "downcaseAtCursor",
                "Ctrl-K Ctrl-Space": "setSublimeMark",
                "Ctrl-K Ctrl-A": "selectToSublimeMark",
                "Ctrl-K Ctrl-W": "deleteToSublimeMark",
                "Ctrl-K Ctrl-X": "swapWithSublimeMark",
                "Ctrl-K Ctrl-Y": "sublimeYank",
                "Ctrl-K Ctrl-C": "showInCenter",
                "Ctrl-K Ctrl-G": "clearBookmarks",
                "Ctrl-K Ctrl-Backspace": "delLineLeft",
                "Ctrl-K Ctrl-0": "unfoldAll",
                "Ctrl-K Ctrl-J": "unfoldAll",
                "Ctrl-Alt-Up": "addCursorToPrevLine",
                "Ctrl-Alt-Down": "addCursorToNextLine",
                "Ctrl-F3": "findUnder",
                "Shift-Ctrl-F3": "findUnderPrevious",
                "Alt-F3": "findAllUnder",
                "Shift-Ctrl-[": "fold",
                "Shift-Ctrl-]": "unfold",
                "Ctrl-I": "findIncremental",
                "Shift-Ctrl-I": "findIncrementalReverse",
                "Ctrl-H": "replace",
                F3: "findNext",
                "Shift-F3": "findPrev",
                fallthrough: "pcDefault"
              }),
              CodeMirror.normalizeKeyMap(keyMap.pcSublime);
            var mac = keyMap.default == keyMap.macDefault;
            keyMap.sublime = mac ? keyMap.macSublime : keyMap.pcSublime;
          }),
            "object" == typeof exports && "object" == typeof module
              ? mod(
                  require("../lib/codemirror"),
                  require("../addon/search/searchcursor"),
                  require("../addon/edit/matchbrackets")
                )
              : mod(CodeMirror);
        },
        {
          "../addon/edit/matchbrackets": 56,
          "../addon/search/searchcursor": 64,
          "../lib/codemirror": 66
        }
      ],
      66: [
        function(require, module, exports) {
          var global, factory;
          (global = this),
            (factory = function() {
              "use strict";
              var userAgent = navigator.userAgent,
                platform = navigator.platform,
                gecko = /gecko\/\d/i.test(userAgent),
                ie_upto10 = /MSIE \d/.test(userAgent),
                ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(
                  userAgent
                ),
                edge = /Edge\/(\d+)/.exec(userAgent),
                ie = ie_upto10 || ie_11up || edge,
                ie_version =
                  ie &&
                  (ie_upto10
                    ? document.documentMode || 6
                    : +(edge || ie_11up)[1]),
                webkit = !edge && /WebKit\//.test(userAgent),
                qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent),
                chrome = !edge && /Chrome\//.test(userAgent),
                presto = /Opera\//.test(userAgent),
                safari = /Apple Computer/.test(navigator.vendor),
                mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(
                  userAgent
                ),
                phantom = /PhantomJS/.test(userAgent),
                ios =
                  !edge &&
                  /AppleWebKit/.test(userAgent) &&
                  /Mobile\/\w+/.test(userAgent),
                android = /Android/.test(userAgent),
                mobile =
                  ios ||
                  android ||
                  /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(
                    userAgent
                  ),
                mac = ios || /Mac/.test(platform),
                chromeOS = /\bCrOS\b/.test(userAgent),
                windows = /win/i.test(platform),
                presto_version =
                  presto && userAgent.match(/Version\/(\d*\.\d*)/);
              presto_version && (presto_version = Number(presto_version[1])),
                presto_version &&
                  15 <= presto_version &&
                  ((presto = !1), (webkit = !0));
              var flipCtrlCmd =
                  mac &&
                  (qtwebkit ||
                    (presto &&
                      (null == presto_version || presto_version < 12.11))),
                captureRightClick = gecko || (ie && 9 <= ie_version);
              function classTest(cls) {
                return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
              }
              var range,
                rmClass = function(node, cls) {
                  var current = node.className,
                    match = classTest(cls).exec(current);
                  if (match) {
                    var after = current.slice(match.index + match[0].length);
                    node.className =
                      current.slice(0, match.index) +
                      (after ? match[1] + after : "");
                  }
                };
              function removeChildren(e) {
                for (var count = e.childNodes.length; 0 < count; --count)
                  e.removeChild(e.firstChild);
                return e;
              }
              function removeChildrenAndAdd(parent, e) {
                return removeChildren(parent).appendChild(e);
              }
              function elt(tag, content, className, style) {
                var e = document.createElement(tag);
                if (
                  (className && (e.className = className),
                  style && (e.style.cssText = style),
                  "string" == typeof content)
                )
                  e.appendChild(document.createTextNode(content));
                else if (content)
                  for (var i = 0; i < content.length; ++i)
                    e.appendChild(content[i]);
                return e;
              }
              function eltP(tag, content, className, style) {
                var e = elt(tag, content, className, style);
                return e.setAttribute("role", "presentation"), e;
              }
              function contains(parent, child) {
                if (
                  (3 == child.nodeType && (child = child.parentNode),
                  parent.contains)
                )
                  return parent.contains(child);
                do {
                  if (
                    (11 == child.nodeType && (child = child.host),
                    child == parent)
                  )
                    return !0;
                } while ((child = child.parentNode));
              }
              function activeElt() {
                var activeElement;
                try {
                  activeElement = document.activeElement;
                } catch (e) {
                  activeElement = document.body || null;
                }
                for (
                  ;
                  activeElement &&
                  activeElement.shadowRoot &&
                  activeElement.shadowRoot.activeElement;

                )
                  activeElement = activeElement.shadowRoot.activeElement;
                return activeElement;
              }
              function addClass(node, cls) {
                var current = node.className;
                classTest(cls).test(current) ||
                  (node.className += (current ? " " : "") + cls);
              }
              function joinClasses(a, b) {
                for (var as = a.split(" "), i = 0; i < as.length; i++)
                  as[i] && !classTest(as[i]).test(b) && (b += " " + as[i]);
                return b;
              }
              range = document.createRange
                ? function(node, start, end, endNode) {
                    var r = document.createRange();
                    return (
                      r.setEnd(endNode || node, end), r.setStart(node, start), r
                    );
                  }
                : function(node, start, end) {
                    var r = document.body.createTextRange();
                    try {
                      r.moveToElementText(node.parentNode);
                    } catch (e) {
                      return r;
                    }
                    return (
                      r.collapse(!0),
                      r.moveEnd("character", end),
                      r.moveStart("character", start),
                      r
                    );
                  };
              var selectInput = function(node) {
                node.select();
              };
              function bind(f) {
                var args = Array.prototype.slice.call(arguments, 1);
                return function() {
                  return f.apply(null, args);
                };
              }
              function copyObj(obj, target, overwrite) {
                for (var prop in (target || (target = {}), obj))
                  !obj.hasOwnProperty(prop) ||
                    (!1 === overwrite && target.hasOwnProperty(prop)) ||
                    (target[prop] = obj[prop]);
                return target;
              }
              function countColumn(
                string,
                end,
                tabSize,
                startIndex,
                startValue
              ) {
                null == end &&
                  -1 == (end = string.search(/[^\s\u00a0]/)) &&
                  (end = string.length);
                for (var i = startIndex || 0, n = startValue || 0; ; ) {
                  var nextTab = string.indexOf("\t", i);
                  if (nextTab < 0 || end <= nextTab) return n + (end - i);
                  (n += nextTab - i),
                    (n += tabSize - n % tabSize),
                    (i = nextTab + 1);
                }
              }
              ios
                ? (selectInput = function(node) {
                    (node.selectionStart = 0),
                      (node.selectionEnd = node.value.length);
                  })
                : ie &&
                  (selectInput = function(node) {
                    try {
                      node.select();
                    } catch (_e) {}
                  });
              var Delayed = function() {
                this.id = null;
              };
              function indexOf(array, elt) {
                for (var i = 0; i < array.length; ++i)
                  if (array[i] == elt) return i;
                return -1;
              }
              Delayed.prototype.set = function(ms, f) {
                clearTimeout(this.id), (this.id = setTimeout(f, ms));
              };
              var scrollerGap = 30,
                Pass = {
                  toString: function() {
                    return "CodeMirror.Pass";
                  }
                },
                sel_dontScroll = { scroll: !1 },
                sel_mouse = { origin: "*mouse" },
                sel_move = { origin: "+move" };
              function findColumn(string, goal, tabSize) {
                for (var pos = 0, col = 0; ; ) {
                  var nextTab = string.indexOf("\t", pos);
                  -1 == nextTab && (nextTab = string.length);
                  var skipped = nextTab - pos;
                  if (nextTab == string.length || goal <= col + skipped)
                    return pos + Math.min(skipped, goal - col);
                  if (
                    ((col += nextTab - pos),
                    (pos = nextTab + 1),
                    goal <= (col += tabSize - col % tabSize))
                  )
                    return pos;
                }
              }
              var spaceStrs = [""];
              function spaceStr(n) {
                for (; spaceStrs.length <= n; )
                  spaceStrs.push(lst(spaceStrs) + " ");
                return spaceStrs[n];
              }
              function lst(arr) {
                return arr[arr.length - 1];
              }
              function map(array, f) {
                for (var out = [], i = 0; i < array.length; i++)
                  out[i] = f(array[i], i);
                return out;
              }
              function nothing() {}
              function createObj(base, props) {
                var inst;
                return (
                  Object.create
                    ? (inst = Object.create(base))
                    : ((nothing.prototype = base), (inst = new nothing())),
                  props && copyObj(props, inst),
                  inst
                );
              }
              var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
              function isWordCharBasic(ch) {
                return (
                  /\w/.test(ch) ||
                  ("" < ch &&
                    (ch.toUpperCase() != ch.toLowerCase() ||
                      nonASCIISingleCaseWordChar.test(ch)))
                );
              }
              function isWordChar(ch, helper) {
                return helper
                  ? !!(
                      -1 < helper.source.indexOf("\\w") && isWordCharBasic(ch)
                    ) || helper.test(ch)
                  : isWordCharBasic(ch);
              }
              function isEmpty(obj) {
                for (var n in obj)
                  if (obj.hasOwnProperty(n) && obj[n]) return !1;
                return !0;
              }
              var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
              function isExtendingChar(ch) {
                return 768 <= ch.charCodeAt(0) && extendingChars.test(ch);
              }
              function skipExtendingChars(str, pos, dir) {
                for (
                  ;
                  (dir < 0 ? 0 < pos : pos < str.length) &&
                  isExtendingChar(str.charAt(pos));

                )
                  pos += dir;
                return pos;
              }
              function findFirst(pred, from, to) {
                for (var dir = to < from ? -1 : 1; ; ) {
                  if (from == to) return from;
                  var midF = (from + to) / 2,
                    mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
                  if (mid == from) return pred(mid) ? from : to;
                  pred(mid) ? (to = mid) : (from = mid + dir);
                }
              }
              function getLine(doc, n) {
                if ((n -= doc.first) < 0 || n >= doc.size)
                  throw new Error(
                    "There is no line " + (n + doc.first) + " in the document."
                  );
                for (var chunk = doc; !chunk.lines; )
                  for (var i = 0; ; ++i) {
                    var child = chunk.children[i],
                      sz = child.chunkSize();
                    if (n < sz) {
                      chunk = child;
                      break;
                    }
                    n -= sz;
                  }
                return chunk.lines[n];
              }
              function getBetween(doc, start, end) {
                var out = [],
                  n = start.line;
                return (
                  doc.iter(start.line, end.line + 1, function(line) {
                    var text = line.text;
                    n == end.line && (text = text.slice(0, end.ch)),
                      n == start.line && (text = text.slice(start.ch)),
                      out.push(text),
                      ++n;
                  }),
                  out
                );
              }
              function getLines(doc, from, to) {
                var out = [];
                return (
                  doc.iter(from, to, function(line) {
                    out.push(line.text);
                  }),
                  out
                );
              }
              function updateLineHeight(line, height) {
                var diff = height - line.height;
                if (diff) for (var n = line; n; n = n.parent) n.height += diff;
              }
              function lineNo(line) {
                if (null == line.parent) return null;
                for (
                  var cur = line.parent,
                    no = indexOf(cur.lines, line),
                    chunk = cur.parent;
                  chunk;
                  chunk = (cur = chunk).parent
                )
                  for (var i = 0; chunk.children[i] != cur; ++i)
                    no += chunk.children[i].chunkSize();
                return no + cur.first;
              }
              function lineAtHeight(chunk, h) {
                var n = chunk.first;
                outer: do {
                  for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
                    var child = chunk.children[i$1],
                      ch = child.height;
                    if (h < ch) {
                      chunk = child;
                      continue outer;
                    }
                    (h -= ch), (n += child.chunkSize());
                  }
                  return n;
                } while (!chunk.lines);
                for (var i = 0; i < chunk.lines.length; ++i) {
                  var lh = chunk.lines[i].height;
                  if (h < lh) break;
                  h -= lh;
                }
                return n + i;
              }
              function isLine(doc, l) {
                return l >= doc.first && l < doc.first + doc.size;
              }
              function lineNumberFor(options, i) {
                return String(
                  options.lineNumberFormatter(i + options.firstLineNumber)
                );
              }
              function Pos(line, ch, sticky) {
                if (
                  (void 0 === sticky && (sticky = null), !(this instanceof Pos))
                )
                  return new Pos(line, ch, sticky);
                (this.line = line), (this.ch = ch), (this.sticky = sticky);
              }
              function cmp(a, b) {
                return a.line - b.line || a.ch - b.ch;
              }
              function equalCursorPos(a, b) {
                return a.sticky == b.sticky && 0 == cmp(a, b);
              }
              function copyPos(x) {
                return Pos(x.line, x.ch);
              }
              function maxPos(a, b) {
                return cmp(a, b) < 0 ? b : a;
              }
              function minPos(a, b) {
                return cmp(a, b) < 0 ? a : b;
              }
              function clipLine(doc, n) {
                return Math.max(
                  doc.first,
                  Math.min(n, doc.first + doc.size - 1)
                );
              }
              function clipPos(doc, pos) {
                if (pos.line < doc.first) return Pos(doc.first, 0);
                var last = doc.first + doc.size - 1;
                return pos.line > last
                  ? Pos(last, getLine(doc, last).text.length)
                  : (function(pos, linelen) {
                      var ch = pos.ch;
                      return null == ch || linelen < ch
                        ? Pos(pos.line, linelen)
                        : ch < 0 ? Pos(pos.line, 0) : pos;
                    })(pos, getLine(doc, pos.line).text.length);
              }
              function clipPosArray(doc, array) {
                for (var out = [], i = 0; i < array.length; i++)
                  out[i] = clipPos(doc, array[i]);
                return out;
              }
              var sawReadOnlySpans = !1,
                sawCollapsedSpans = !1;
              function MarkedSpan(marker, from, to) {
                (this.marker = marker), (this.from = from), (this.to = to);
              }
              function getMarkedSpanFor(spans, marker) {
                if (spans)
                  for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    if (span.marker == marker) return span;
                  }
              }
              function removeMarkedSpan(spans, span) {
                for (var r, i = 0; i < spans.length; ++i)
                  spans[i] != span && (r || (r = [])).push(spans[i]);
                return r;
              }
              function stretchSpansOverChange(doc, change) {
                if (change.full) return null;
                var oldFirst =
                    isLine(doc, change.from.line) &&
                    getLine(doc, change.from.line).markedSpans,
                  oldLast =
                    isLine(doc, change.to.line) &&
                    getLine(doc, change.to.line).markedSpans;
                if (!oldFirst && !oldLast) return null;
                var startCh = change.from.ch,
                  endCh = change.to.ch,
                  isInsert = 0 == cmp(change.from, change.to),
                  first = (function(old, startCh, isInsert) {
                    var nw;
                    if (old)
                      for (var i = 0; i < old.length; ++i) {
                        var span = old[i],
                          marker = span.marker;
                        if (
                          null == span.from ||
                          (marker.inclusiveLeft
                            ? span.from <= startCh
                            : span.from < startCh) ||
                          (span.from == startCh &&
                            "bookmark" == marker.type &&
                            (!isInsert || !span.marker.insertLeft))
                        ) {
                          var endsAfter =
                            null == span.to ||
                            (marker.inclusiveRight
                              ? span.to >= startCh
                              : span.to > startCh);
                          (nw || (nw = [])).push(
                            new MarkedSpan(
                              marker,
                              span.from,
                              endsAfter ? null : span.to
                            )
                          );
                        }
                      }
                    return nw;
                  })(oldFirst, startCh, isInsert),
                  last = (function(old, endCh, isInsert) {
                    var nw;
                    if (old)
                      for (var i = 0; i < old.length; ++i) {
                        var span = old[i],
                          marker = span.marker;
                        if (
                          null == span.to ||
                          (marker.inclusiveRight
                            ? span.to >= endCh
                            : span.to > endCh) ||
                          (span.from == endCh &&
                            "bookmark" == marker.type &&
                            (!isInsert || span.marker.insertLeft))
                        ) {
                          var startsBefore =
                            null == span.from ||
                            (marker.inclusiveLeft
                              ? span.from <= endCh
                              : span.from < endCh);
                          (nw || (nw = [])).push(
                            new MarkedSpan(
                              marker,
                              startsBefore ? null : span.from - endCh,
                              null == span.to ? null : span.to - endCh
                            )
                          );
                        }
                      }
                    return nw;
                  })(oldLast, endCh, isInsert),
                  sameLine = 1 == change.text.length,
                  offset = lst(change.text).length + (sameLine ? startCh : 0);
                if (first)
                  for (var i = 0; i < first.length; ++i) {
                    var span = first[i];
                    if (null == span.to) {
                      var found = getMarkedSpanFor(last, span.marker);
                      found
                        ? sameLine &&
                          (span.to =
                            null == found.to ? null : found.to + offset)
                        : (span.to = startCh);
                    }
                  }
                if (last)
                  for (var i$1 = 0; i$1 < last.length; ++i$1) {
                    var span$1 = last[i$1];
                    if (
                      (null != span$1.to && (span$1.to += offset),
                      null == span$1.from)
                    )
                      getMarkedSpanFor(first, span$1.marker) ||
                        ((span$1.from = offset),
                        sameLine && (first || (first = [])).push(span$1));
                    else
                      (span$1.from += offset),
                        sameLine && (first || (first = [])).push(span$1);
                  }
                first && (first = clearEmptySpans(first)),
                  last && last != first && (last = clearEmptySpans(last));
                var newMarkers = [first];
                if (!sameLine) {
                  var gapMarkers,
                    gap = change.text.length - 2;
                  if (0 < gap && first)
                    for (var i$2 = 0; i$2 < first.length; ++i$2)
                      null == first[i$2].to &&
                        (gapMarkers || (gapMarkers = [])).push(
                          new MarkedSpan(first[i$2].marker, null, null)
                        );
                  for (var i$3 = 0; i$3 < gap; ++i$3)
                    newMarkers.push(gapMarkers);
                  newMarkers.push(last);
                }
                return newMarkers;
              }
              function clearEmptySpans(spans) {
                for (var i = 0; i < spans.length; ++i) {
                  var span = spans[i];
                  null != span.from &&
                    span.from == span.to &&
                    !1 !== span.marker.clearWhenEmpty &&
                    spans.splice(i--, 1);
                }
                return spans.length ? spans : null;
              }
              function detachMarkedSpans(line) {
                var spans = line.markedSpans;
                if (spans) {
                  for (var i = 0; i < spans.length; ++i)
                    spans[i].marker.detachLine(line);
                  line.markedSpans = null;
                }
              }
              function attachMarkedSpans(line, spans) {
                if (spans) {
                  for (var i = 0; i < spans.length; ++i)
                    spans[i].marker.attachLine(line);
                  line.markedSpans = spans;
                }
              }
              function extraLeft(marker) {
                return marker.inclusiveLeft ? -1 : 0;
              }
              function extraRight(marker) {
                return marker.inclusiveRight ? 1 : 0;
              }
              function compareCollapsedMarkers(a, b) {
                var lenDiff = a.lines.length - b.lines.length;
                if (0 != lenDiff) return lenDiff;
                var aPos = a.find(),
                  bPos = b.find(),
                  fromCmp =
                    cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
                if (fromCmp) return -fromCmp;
                var toCmp =
                  cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
                return toCmp || b.id - a.id;
              }
              function collapsedSpanAtSide(line, start) {
                var found,
                  sps = sawCollapsedSpans && line.markedSpans;
                if (sps)
                  for (var sp = void 0, i = 0; i < sps.length; ++i)
                    (sp = sps[i]).marker.collapsed &&
                      null == (start ? sp.from : sp.to) &&
                      (!found ||
                        compareCollapsedMarkers(found, sp.marker) < 0) &&
                      (found = sp.marker);
                return found;
              }
              function collapsedSpanAtStart(line) {
                return collapsedSpanAtSide(line, !0);
              }
              function collapsedSpanAtEnd(line) {
                return collapsedSpanAtSide(line, !1);
              }
              function conflictingCollapsedRange(
                doc,
                lineNo$$1,
                from,
                to,
                marker
              ) {
                var line = getLine(doc, lineNo$$1),
                  sps = sawCollapsedSpans && line.markedSpans;
                if (sps)
                  for (var i = 0; i < sps.length; ++i) {
                    var sp = sps[i];
                    if (sp.marker.collapsed) {
                      var found = sp.marker.find(0),
                        fromCmp =
                          cmp(found.from, from) ||
                          extraLeft(sp.marker) - extraLeft(marker),
                        toCmp =
                          cmp(found.to, to) ||
                          extraRight(sp.marker) - extraRight(marker);
                      if (
                        !(
                          (0 <= fromCmp && toCmp <= 0) ||
                          (fromCmp <= 0 && 0 <= toCmp)
                        ) &&
                        ((fromCmp <= 0 &&
                          (sp.marker.inclusiveRight && marker.inclusiveLeft
                            ? 0 <= cmp(found.to, from)
                            : 0 < cmp(found.to, from))) ||
                          (0 <= fromCmp &&
                            (sp.marker.inclusiveRight && marker.inclusiveLeft
                              ? cmp(found.from, to) <= 0
                              : cmp(found.from, to) < 0)))
                      )
                        return !0;
                    }
                  }
              }
              function visualLine(line) {
                for (var merged; (merged = collapsedSpanAtStart(line)); )
                  line = merged.find(-1, !0).line;
                return line;
              }
              function visualLineNo(doc, lineN) {
                var line = getLine(doc, lineN),
                  vis = visualLine(line);
                return line == vis ? lineN : lineNo(vis);
              }
              function visualLineEndNo(doc, lineN) {
                if (lineN > doc.lastLine()) return lineN;
                var merged,
                  line = getLine(doc, lineN);
                if (!lineIsHidden(doc, line)) return lineN;
                for (; (merged = collapsedSpanAtEnd(line)); )
                  line = merged.find(1, !0).line;
                return lineNo(line) + 1;
              }
              function lineIsHidden(doc, line) {
                var sps = sawCollapsedSpans && line.markedSpans;
                if (sps)
                  for (var sp = void 0, i = 0; i < sps.length; ++i)
                    if ((sp = sps[i]).marker.collapsed) {
                      if (null == sp.from) return !0;
                      if (
                        !sp.marker.widgetNode &&
                        0 == sp.from &&
                        sp.marker.inclusiveLeft &&
                        lineIsHiddenInner(doc, line, sp)
                      )
                        return !0;
                    }
              }
              function lineIsHiddenInner(doc, line, span) {
                if (null == span.to) {
                  var end = span.marker.find(1, !0);
                  return lineIsHiddenInner(
                    doc,
                    end.line,
                    getMarkedSpanFor(end.line.markedSpans, span.marker)
                  );
                }
                if (span.marker.inclusiveRight && span.to == line.text.length)
                  return !0;
                for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i)
                  if (
                    (sp = line.markedSpans[i]).marker.collapsed &&
                    !sp.marker.widgetNode &&
                    sp.from == span.to &&
                    (null == sp.to || sp.to != span.from) &&
                    (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
                    lineIsHiddenInner(doc, line, sp)
                  )
                    return !0;
              }
              function heightAtLine(lineObj) {
                for (
                  var h = 0,
                    chunk = (lineObj = visualLine(lineObj)).parent,
                    i = 0;
                  i < chunk.lines.length;
                  ++i
                ) {
                  var line = chunk.lines[i];
                  if (line == lineObj) break;
                  h += line.height;
                }
                for (var p = chunk.parent; p; p = (chunk = p).parent)
                  for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
                    var cur = p.children[i$1];
                    if (cur == chunk) break;
                    h += cur.height;
                  }
                return h;
              }
              function lineLength(line) {
                if (0 == line.height) return 0;
                for (
                  var merged, len = line.text.length, cur = line;
                  (merged = collapsedSpanAtStart(cur));

                ) {
                  var found = merged.find(0, !0);
                  (cur = found.from.line), (len += found.from.ch - found.to.ch);
                }
                for (cur = line; (merged = collapsedSpanAtEnd(cur)); ) {
                  var found$1 = merged.find(0, !0);
                  (len -= cur.text.length - found$1.from.ch),
                    (len +=
                      (cur = found$1.to.line).text.length - found$1.to.ch);
                }
                return len;
              }
              function findMaxLine(cm) {
                var d = cm.display,
                  doc = cm.doc;
                (d.maxLine = getLine(doc, doc.first)),
                  (d.maxLineLength = lineLength(d.maxLine)),
                  (d.maxLineChanged = !0),
                  doc.iter(function(line) {
                    var len = lineLength(line);
                    len > d.maxLineLength &&
                      ((d.maxLineLength = len), (d.maxLine = line));
                  });
              }
              var bidiOther = null;
              function getBidiPartAt(order, ch, sticky) {
                var found;
                bidiOther = null;
                for (var i = 0; i < order.length; ++i) {
                  var cur = order[i];
                  if (cur.from < ch && cur.to > ch) return i;
                  cur.to == ch &&
                    (cur.from != cur.to && "before" == sticky
                      ? (found = i)
                      : (bidiOther = i)),
                    cur.from == ch &&
                      (cur.from != cur.to && "before" != sticky
                        ? (found = i)
                        : (bidiOther = i));
                }
                return null != found ? found : bidiOther;
              }
              var bidiOrdering = (function() {
                var lowTypes =
                    "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",
                  arabicTypes =
                    "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
                var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,
                  isNeutral = /[stwN]/,
                  isStrong = /[LRr]/,
                  countsAsLeft = /[Lb1n]/,
                  countsAsNum = /[1n]/;
                function BidiSpan(level, from, to) {
                  (this.level = level), (this.from = from), (this.to = to);
                }
                return function(str, direction) {
                  var outerType = "ltr" == direction ? "L" : "R";
                  if (
                    0 == str.length ||
                    ("ltr" == direction && !bidiRE.test(str))
                  )
                    return !1;
                  for (
                    var code, len = str.length, types = [], i = 0;
                    i < len;
                    ++i
                  )
                    types.push(
                      (code = str.charCodeAt(i)) <= 247
                        ? lowTypes.charAt(code)
                        : 1424 <= code && code <= 1524
                          ? "R"
                          : 1536 <= code && code <= 1785
                            ? arabicTypes.charAt(code - 1536)
                            : 1774 <= code && code <= 2220
                              ? "r"
                              : 8192 <= code && code <= 8203
                                ? "w"
                                : 8204 == code ? "b" : "L"
                    );
                  for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
                    var type = types[i$1];
                    "m" == type ? (types[i$1] = prev) : (prev = type);
                  }
                  for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
                    var type$1 = types[i$2];
                    "1" == type$1 && "r" == cur
                      ? (types[i$2] = "n")
                      : isStrong.test(type$1) &&
                        "r" == (cur = type$1) &&
                        (types[i$2] = "R");
                  }
                  for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
                    var type$2 = types[i$3];
                    "+" == type$2 && "1" == prev$1 && "1" == types[i$3 + 1]
                      ? (types[i$3] = "1")
                      : "," != type$2 ||
                        prev$1 != types[i$3 + 1] ||
                        ("1" != prev$1 && "n" != prev$1) ||
                        (types[i$3] = prev$1),
                      (prev$1 = type$2);
                  }
                  for (var i$4 = 0; i$4 < len; ++i$4) {
                    var type$3 = types[i$4];
                    if ("," == type$3) types[i$4] = "N";
                    else if ("%" == type$3) {
                      var end = void 0;
                      for (
                        end = i$4 + 1;
                        end < len && "%" == types[end];
                        ++end
                      );
                      for (
                        var replace =
                            (i$4 && "!" == types[i$4 - 1]) ||
                            (end < len && "1" == types[end])
                              ? "1"
                              : "N",
                          j = i$4;
                        j < end;
                        ++j
                      )
                        types[j] = replace;
                      i$4 = end - 1;
                    }
                  }
                  for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
                    var type$4 = types[i$5];
                    "L" == cur$1 && "1" == type$4
                      ? (types[i$5] = "L")
                      : isStrong.test(type$4) && (cur$1 = type$4);
                  }
                  for (var i$6 = 0; i$6 < len; ++i$6)
                    if (isNeutral.test(types[i$6])) {
                      var end$1 = void 0;
                      for (
                        end$1 = i$6 + 1;
                        end$1 < len && isNeutral.test(types[end$1]);
                        ++end$1
                      );
                      for (
                        var before = "L" == (i$6 ? types[i$6 - 1] : outerType),
                          replace$1 =
                            before ==
                            ("L" == (end$1 < len ? types[end$1] : outerType))
                              ? before ? "L" : "R"
                              : outerType,
                          j$1 = i$6;
                        j$1 < end$1;
                        ++j$1
                      )
                        types[j$1] = replace$1;
                      i$6 = end$1 - 1;
                    }
                  for (var m, order = [], i$7 = 0; i$7 < len; )
                    if (countsAsLeft.test(types[i$7])) {
                      var start = i$7;
                      for (
                        ++i$7;
                        i$7 < len && countsAsLeft.test(types[i$7]);
                        ++i$7
                      );
                      order.push(new BidiSpan(0, start, i$7));
                    } else {
                      var pos = i$7,
                        at = order.length;
                      for (++i$7; i$7 < len && "L" != types[i$7]; ++i$7);
                      for (var j$2 = pos; j$2 < i$7; )
                        if (countsAsNum.test(types[j$2])) {
                          pos < j$2 &&
                            order.splice(at, 0, new BidiSpan(1, pos, j$2));
                          var nstart = j$2;
                          for (
                            ++j$2;
                            j$2 < i$7 && countsAsNum.test(types[j$2]);
                            ++j$2
                          );
                          order.splice(at, 0, new BidiSpan(2, nstart, j$2)),
                            (pos = j$2);
                        } else ++j$2;
                      pos < i$7 &&
                        order.splice(at, 0, new BidiSpan(1, pos, i$7));
                    }
                  return (
                    "ltr" == direction &&
                      (1 == order[0].level &&
                        (m = str.match(/^\s+/)) &&
                        ((order[0].from = m[0].length),
                        order.unshift(new BidiSpan(0, 0, m[0].length))),
                      1 == lst(order).level &&
                        (m = str.match(/\s+$/)) &&
                        ((lst(order).to -= m[0].length),
                        order.push(new BidiSpan(0, len - m[0].length, len)))),
                    "rtl" == direction ? order.reverse() : order
                  );
                };
              })();
              function getOrder(line, direction) {
                var order = line.order;
                return (
                  null == order &&
                    (order = line.order = bidiOrdering(line.text, direction)),
                  order
                );
              }
              var noHandlers = [],
                on = function(emitter, type, f) {
                  if (emitter.addEventListener)
                    emitter.addEventListener(type, f, !1);
                  else if (emitter.attachEvent)
                    emitter.attachEvent("on" + type, f);
                  else {
                    var map$$1 = emitter._handlers || (emitter._handlers = {});
                    map$$1[type] = (map$$1[type] || noHandlers).concat(f);
                  }
                };
              function getHandlers(emitter, type) {
                return (
                  (emitter._handlers && emitter._handlers[type]) || noHandlers
                );
              }
              function off(emitter, type, f) {
                if (emitter.removeEventListener)
                  emitter.removeEventListener(type, f, !1);
                else if (emitter.detachEvent)
                  emitter.detachEvent("on" + type, f);
                else {
                  var map$$1 = emitter._handlers,
                    arr = map$$1 && map$$1[type];
                  if (arr) {
                    var index = indexOf(arr, f);
                    -1 < index &&
                      (map$$1[type] = arr
                        .slice(0, index)
                        .concat(arr.slice(index + 1)));
                  }
                }
              }
              function signal(emitter, type) {
                var handlers = getHandlers(emitter, type);
                if (handlers.length)
                  for (
                    var args = Array.prototype.slice.call(arguments, 2), i = 0;
                    i < handlers.length;
                    ++i
                  )
                    handlers[i].apply(null, args);
              }
              function signalDOMEvent(cm, e, override) {
                return (
                  "string" == typeof e &&
                    (e = {
                      type: e,
                      preventDefault: function() {
                        this.defaultPrevented = !0;
                      }
                    }),
                  signal(cm, override || e.type, cm, e),
                  e_defaultPrevented(e) || e.codemirrorIgnore
                );
              }
              function signalCursorActivity(cm) {
                var arr = cm._handlers && cm._handlers.cursorActivity;
                if (arr)
                  for (
                    var set =
                        cm.curOp.cursorActivityHandlers ||
                        (cm.curOp.cursorActivityHandlers = []),
                      i = 0;
                    i < arr.length;
                    ++i
                  )
                    -1 == indexOf(set, arr[i]) && set.push(arr[i]);
              }
              function hasHandler(emitter, type) {
                return 0 < getHandlers(emitter, type).length;
              }
              function eventMixin(ctor) {
                (ctor.prototype.on = function(type, f) {
                  on(this, type, f);
                }),
                  (ctor.prototype.off = function(type, f) {
                    off(this, type, f);
                  });
              }
              function e_preventDefault(e) {
                e.preventDefault ? e.preventDefault() : (e.returnValue = !1);
              }
              function e_stopPropagation(e) {
                e.stopPropagation ? e.stopPropagation() : (e.cancelBubble = !0);
              }
              function e_defaultPrevented(e) {
                return null != e.defaultPrevented
                  ? e.defaultPrevented
                  : 0 == e.returnValue;
              }
              function e_stop(e) {
                e_preventDefault(e), e_stopPropagation(e);
              }
              function e_target(e) {
                return e.target || e.srcElement;
              }
              function e_button(e) {
                var b = e.which;
                return (
                  null == b &&
                    (1 & e.button
                      ? (b = 1)
                      : 2 & e.button ? (b = 3) : 4 & e.button && (b = 2)),
                  mac && e.ctrlKey && 1 == b && (b = 3),
                  b
                );
              }
              var zwspSupported,
                badBidiRects,
                dragAndDrop = (function() {
                  if (ie && ie_version < 9) return !1;
                  var div = elt("div");
                  return "draggable" in div || "dragDrop" in div;
                })();
              function zeroWidthElement(measure) {
                if (null == zwspSupported) {
                  var test = elt("span", "​");
                  removeChildrenAndAdd(
                    measure,
                    elt("span", [test, document.createTextNode("x")])
                  ),
                    0 != measure.firstChild.offsetHeight &&
                      (zwspSupported =
                        test.offsetWidth <= 1 &&
                        2 < test.offsetHeight &&
                        !(ie && ie_version < 8));
                }
                var node = zwspSupported
                  ? elt("span", "​")
                  : elt(
                      "span",
                      " ",
                      null,
                      "display: inline-block; width: 1px; margin-right: -1px"
                    );
                return node.setAttribute("cm-text", ""), node;
              }
              function hasBadBidiRects(measure) {
                if (null != badBidiRects) return badBidiRects;
                var txt = removeChildrenAndAdd(
                    measure,
                    document.createTextNode("AخA")
                  ),
                  r0 = range(txt, 0, 1).getBoundingClientRect(),
                  r1 = range(txt, 1, 2).getBoundingClientRect();
                return (
                  removeChildren(measure),
                  !(!r0 || r0.left == r0.right) &&
                    (badBidiRects = r1.right - r0.right < 3)
                );
              }
              var e,
                splitLinesAuto =
                  3 != "\n\nb".split(/\n/).length
                    ? function(string) {
                        for (
                          var pos = 0, result = [], l = string.length;
                          pos <= l;

                        ) {
                          var nl = string.indexOf("\n", pos);
                          -1 == nl && (nl = string.length);
                          var line = string.slice(
                              pos,
                              "\r" == string.charAt(nl - 1) ? nl - 1 : nl
                            ),
                            rt = line.indexOf("\r");
                          -1 != rt
                            ? (result.push(line.slice(0, rt)), (pos += rt + 1))
                            : (result.push(line), (pos = nl + 1));
                        }
                        return result;
                      }
                    : function(string) {
                        return string.split(/\r\n?|\n/);
                      },
                hasSelection = window.getSelection
                  ? function(te) {
                      try {
                        return te.selectionStart != te.selectionEnd;
                      } catch (e) {
                        return !1;
                      }
                    }
                  : function(te) {
                      var range$$1;
                      try {
                        range$$1 = te.ownerDocument.selection.createRange();
                      } catch (e) {}
                      return (
                        !(!range$$1 || range$$1.parentElement() != te) &&
                        0 != range$$1.compareEndPoints("StartToEnd", range$$1)
                      );
                    },
                hasCopyEvent =
                  "oncopy" in (e = elt("div")) ||
                  (e.setAttribute("oncopy", "return;"),
                  "function" == typeof e.oncopy),
                badZoomedRects = null;
              var modes = {},
                mimeModes = {};
              function resolveMode(spec) {
                if ("string" == typeof spec && mimeModes.hasOwnProperty(spec))
                  spec = mimeModes[spec];
                else if (
                  spec &&
                  "string" == typeof spec.name &&
                  mimeModes.hasOwnProperty(spec.name)
                ) {
                  var found = mimeModes[spec.name];
                  "string" == typeof found && (found = { name: found }),
                    ((spec = createObj(found, spec)).name = found.name);
                } else {
                  if (
                    "string" == typeof spec &&
                    /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)
                  )
                    return resolveMode("application/xml");
                  if (
                    "string" == typeof spec &&
                    /^[\w\-]+\/[\w\-]+\+json$/.test(spec)
                  )
                    return resolveMode("application/json");
                }
                return "string" == typeof spec
                  ? { name: spec }
                  : spec || { name: "null" };
              }
              function getMode(options, spec) {
                spec = resolveMode(spec);
                var mfactory = modes[spec.name];
                if (!mfactory) return getMode(options, "text/plain");
                var modeObj = mfactory(options, spec);
                if (modeExtensions.hasOwnProperty(spec.name)) {
                  var exts = modeExtensions[spec.name];
                  for (var prop in exts)
                    exts.hasOwnProperty(prop) &&
                      (modeObj.hasOwnProperty(prop) &&
                        (modeObj["_" + prop] = modeObj[prop]),
                      (modeObj[prop] = exts[prop]));
                }
                if (
                  ((modeObj.name = spec.name),
                  spec.helperType && (modeObj.helperType = spec.helperType),
                  spec.modeProps)
                )
                  for (var prop$1 in spec.modeProps)
                    modeObj[prop$1] = spec.modeProps[prop$1];
                return modeObj;
              }
              var modeExtensions = {};
              function extendMode(mode, properties) {
                copyObj(
                  properties,
                  modeExtensions.hasOwnProperty(mode)
                    ? modeExtensions[mode]
                    : (modeExtensions[mode] = {})
                );
              }
              function copyState(mode, state) {
                if (!0 === state) return state;
                if (mode.copyState) return mode.copyState(state);
                var nstate = {};
                for (var n in state) {
                  var val = state[n];
                  val instanceof Array && (val = val.concat([])),
                    (nstate[n] = val);
                }
                return nstate;
              }
              function innerMode(mode, state) {
                for (
                  var info;
                  mode.innerMode &&
                  (info = mode.innerMode(state)) &&
                  info.mode != mode;

                )
                  (state = info.state), (mode = info.mode);
                return info || { mode: mode, state: state };
              }
              function startState(mode, a1, a2) {
                return !mode.startState || mode.startState(a1, a2);
              }
              var StringStream = function(string, tabSize, lineOracle) {
                (this.pos = this.start = 0),
                  (this.string = string),
                  (this.tabSize = tabSize || 8),
                  (this.lastColumnPos = this.lastColumnValue = 0),
                  (this.lineStart = 0),
                  (this.lineOracle = lineOracle);
              };
              (StringStream.prototype.eol = function() {
                return this.pos >= this.string.length;
              }),
                (StringStream.prototype.sol = function() {
                  return this.pos == this.lineStart;
                }),
                (StringStream.prototype.peek = function() {
                  return this.string.charAt(this.pos) || void 0;
                }),
                (StringStream.prototype.next = function() {
                  if (this.pos < this.string.length)
                    return this.string.charAt(this.pos++);
                }),
                (StringStream.prototype.eat = function(match) {
                  var ch = this.string.charAt(this.pos);
                  if (
                    "string" == typeof match
                      ? ch == match
                      : ch && (match.test ? match.test(ch) : match(ch))
                  )
                    return ++this.pos, ch;
                }),
                (StringStream.prototype.eatWhile = function(match) {
                  for (var start = this.pos; this.eat(match); );
                  return this.pos > start;
                }),
                (StringStream.prototype.eatSpace = function() {
                  for (
                    var start = this.pos;
                    /[\s\u00a0]/.test(this.string.charAt(this.pos));

                  )
                    ++this.pos;
                  return this.pos > start;
                }),
                (StringStream.prototype.skipToEnd = function() {
                  this.pos = this.string.length;
                }),
                (StringStream.prototype.skipTo = function(ch) {
                  var found = this.string.indexOf(ch, this.pos);
                  if (-1 < found) return (this.pos = found), !0;
                }),
                (StringStream.prototype.backUp = function(n) {
                  this.pos -= n;
                }),
                (StringStream.prototype.column = function() {
                  return (
                    this.lastColumnPos < this.start &&
                      ((this.lastColumnValue = countColumn(
                        this.string,
                        this.start,
                        this.tabSize,
                        this.lastColumnPos,
                        this.lastColumnValue
                      )),
                      (this.lastColumnPos = this.start)),
                    this.lastColumnValue -
                      (this.lineStart
                        ? countColumn(this.string, this.lineStart, this.tabSize)
                        : 0)
                  );
                }),
                (StringStream.prototype.indentation = function() {
                  return (
                    countColumn(this.string, null, this.tabSize) -
                    (this.lineStart
                      ? countColumn(this.string, this.lineStart, this.tabSize)
                      : 0)
                  );
                }),
                (StringStream.prototype.match = function(
                  pattern,
                  consume,
                  caseInsensitive
                ) {
                  if ("string" != typeof pattern) {
                    var match = this.string.slice(this.pos).match(pattern);
                    return match && 0 < match.index
                      ? null
                      : (match &&
                          !1 !== consume &&
                          (this.pos += match[0].length),
                        match);
                  }
                  var cased = function(str) {
                    return caseInsensitive ? str.toLowerCase() : str;
                  };
                  if (
                    cased(this.string.substr(this.pos, pattern.length)) ==
                    cased(pattern)
                  )
                    return !1 !== consume && (this.pos += pattern.length), !0;
                }),
                (StringStream.prototype.current = function() {
                  return this.string.slice(this.start, this.pos);
                }),
                (StringStream.prototype.hideFirstChars = function(n, inner) {
                  this.lineStart += n;
                  try {
                    return inner();
                  } finally {
                    this.lineStart -= n;
                  }
                }),
                (StringStream.prototype.lookAhead = function(n) {
                  var oracle = this.lineOracle;
                  return oracle && oracle.lookAhead(n);
                }),
                (StringStream.prototype.baseToken = function() {
                  var oracle = this.lineOracle;
                  return oracle && oracle.baseToken(this.pos);
                });
              var SavedContext = function(state, lookAhead) {
                  (this.state = state), (this.lookAhead = lookAhead);
                },
                Context = function(doc, state, line, lookAhead) {
                  (this.state = state),
                    (this.doc = doc),
                    (this.line = line),
                    (this.maxLookAhead = lookAhead || 0),
                    (this.baseTokens = null),
                    (this.baseTokenPos = 1);
                };
              function highlightLine(cm, line, context, forceToEnd) {
                var st = [cm.state.modeGen],
                  lineClasses = {};
                runMode(
                  cm,
                  line.text,
                  cm.doc.mode,
                  context,
                  function(end, style) {
                    return st.push(end, style);
                  },
                  lineClasses,
                  forceToEnd
                );
                for (
                  var state = context.state,
                    loop = function(o) {
                      context.baseTokens = st;
                      var overlay = cm.state.overlays[o],
                        i = 1,
                        at = 0;
                      (context.state = !0),
                        runMode(
                          cm,
                          line.text,
                          overlay.mode,
                          context,
                          function(end, style) {
                            for (var start = i; at < end; ) {
                              var i_end = st[i];
                              end < i_end &&
                                st.splice(i, 1, end, st[i + 1], i_end),
                                (i += 2),
                                (at = Math.min(end, i_end));
                            }
                            if (style)
                              if (overlay.opaque)
                                st.splice(
                                  start,
                                  i - start,
                                  end,
                                  "overlay " + style
                                ),
                                  (i = start + 2);
                              else
                                for (; start < i; start += 2) {
                                  var cur = st[start + 1];
                                  st[start + 1] =
                                    (cur ? cur + " " : "") + "overlay " + style;
                                }
                          },
                          lineClasses
                        ),
                        (context.state = state),
                        (context.baseTokens = null),
                        (context.baseTokenPos = 1);
                    },
                    o = 0;
                  o < cm.state.overlays.length;
                  ++o
                )
                  loop(o);
                return {
                  styles: st,
                  classes:
                    lineClasses.bgClass || lineClasses.textClass
                      ? lineClasses
                      : null
                };
              }
              function getLineStyles(cm, line, updateFrontier) {
                if (!line.styles || line.styles[0] != cm.state.modeGen) {
                  var context = getContextBefore(cm, lineNo(line)),
                    resetState =
                      line.text.length > cm.options.maxHighlightLength &&
                      copyState(cm.doc.mode, context.state),
                    result = highlightLine(cm, line, context);
                  resetState && (context.state = resetState),
                    (line.stateAfter = context.save(!resetState)),
                    (line.styles = result.styles),
                    result.classes
                      ? (line.styleClasses = result.classes)
                      : line.styleClasses && (line.styleClasses = null),
                    updateFrontier === cm.doc.highlightFrontier &&
                      (cm.doc.modeFrontier = Math.max(
                        cm.doc.modeFrontier,
                        ++cm.doc.highlightFrontier
                      ));
                }
                return line.styles;
              }
              function getContextBefore(cm, n, precise) {
                var doc = cm.doc,
                  display = cm.display;
                if (!doc.mode.startState) return new Context(doc, !0, n);
                var start = (function(cm, n, precise) {
                    for (
                      var minindent,
                        minline,
                        doc = cm.doc,
                        lim = precise
                          ? -1
                          : n - (cm.doc.mode.innerMode ? 1e3 : 100),
                        search = n;
                      lim < search;
                      --search
                    ) {
                      if (search <= doc.first) return doc.first;
                      var line = getLine(doc, search - 1),
                        after = line.stateAfter;
                      if (
                        after &&
                        (!precise ||
                          search +
                            (after instanceof SavedContext
                              ? after.lookAhead
                              : 0) <=
                            doc.modeFrontier)
                      )
                        return search;
                      var indented = countColumn(
                        line.text,
                        null,
                        cm.options.tabSize
                      );
                      (null == minline || indented < minindent) &&
                        ((minline = search - 1), (minindent = indented));
                    }
                    return minline;
                  })(cm, n, precise),
                  saved =
                    start > doc.first && getLine(doc, start - 1).stateAfter,
                  context = saved
                    ? Context.fromSaved(doc, saved, start)
                    : new Context(doc, startState(doc.mode), start);
                return (
                  doc.iter(start, n, function(line) {
                    processLine(cm, line.text, context);
                    var pos = context.line;
                    (line.stateAfter =
                      pos == n - 1 ||
                      pos % 5 == 0 ||
                      (pos >= display.viewFrom && pos < display.viewTo)
                        ? context.save()
                        : null),
                      context.nextLine();
                  }),
                  precise && (doc.modeFrontier = context.line),
                  context
                );
              }
              function processLine(cm, text, context, startAt) {
                var mode = cm.doc.mode,
                  stream = new StringStream(text, cm.options.tabSize, context);
                for (
                  stream.start = stream.pos = startAt || 0,
                    "" == text && callBlankLine(mode, context.state);
                  !stream.eol();

                )
                  readToken(mode, stream, context.state),
                    (stream.start = stream.pos);
              }
              function callBlankLine(mode, state) {
                if (mode.blankLine) return mode.blankLine(state);
                if (mode.innerMode) {
                  var inner = innerMode(mode, state);
                  return inner.mode.blankLine
                    ? inner.mode.blankLine(inner.state)
                    : void 0;
                }
              }
              function readToken(mode, stream, state, inner) {
                for (var i = 0; i < 10; i++) {
                  inner && (inner[0] = innerMode(mode, state).mode);
                  var style = mode.token(stream, state);
                  if (stream.pos > stream.start) return style;
                }
                throw new Error(
                  "Mode " + mode.name + " failed to advance stream."
                );
              }
              (Context.prototype.lookAhead = function(n) {
                var line = this.doc.getLine(this.line + n);
                return (
                  null != line &&
                    n > this.maxLookAhead &&
                    (this.maxLookAhead = n),
                  line
                );
              }),
                (Context.prototype.baseToken = function(n) {
                  if (!this.baseTokens) return null;
                  for (; this.baseTokens[this.baseTokenPos] <= n; )
                    this.baseTokenPos += 2;
                  var type = this.baseTokens[this.baseTokenPos + 1];
                  return {
                    type: type && type.replace(/( |^)overlay .*/, ""),
                    size: this.baseTokens[this.baseTokenPos] - n
                  };
                }),
                (Context.prototype.nextLine = function() {
                  this.line++, 0 < this.maxLookAhead && this.maxLookAhead--;
                }),
                (Context.fromSaved = function(doc, saved, line) {
                  return saved instanceof SavedContext
                    ? new Context(
                        doc,
                        copyState(doc.mode, saved.state),
                        line,
                        saved.lookAhead
                      )
                    : new Context(doc, copyState(doc.mode, saved), line);
                }),
                (Context.prototype.save = function(copy) {
                  var state =
                    !1 !== copy
                      ? copyState(this.doc.mode, this.state)
                      : this.state;
                  return 0 < this.maxLookAhead
                    ? new SavedContext(state, this.maxLookAhead)
                    : state;
                });
              var Token = function(stream, type, state) {
                (this.start = stream.start),
                  (this.end = stream.pos),
                  (this.string = stream.current()),
                  (this.type = type || null),
                  (this.state = state);
              };
              function takeToken(cm, pos, precise, asArray) {
                var style,
                  tokens,
                  doc = cm.doc,
                  mode = doc.mode,
                  line = getLine(doc, (pos = clipPos(doc, pos)).line),
                  context = getContextBefore(cm, pos.line, precise),
                  stream = new StringStream(
                    line.text,
                    cm.options.tabSize,
                    context
                  );
                for (
                  asArray && (tokens = []);
                  (asArray || stream.pos < pos.ch) && !stream.eol();

                )
                  (stream.start = stream.pos),
                    (style = readToken(mode, stream, context.state)),
                    asArray &&
                      tokens.push(
                        new Token(
                          stream,
                          style,
                          copyState(doc.mode, context.state)
                        )
                      );
                return asArray
                  ? tokens
                  : new Token(stream, style, context.state);
              }
              function extractLineClasses(type, output) {
                if (type)
                  for (;;) {
                    var lineClass = type.match(
                      /(?:^|\s+)line-(background-)?(\S+)/
                    );
                    if (!lineClass) break;
                    type =
                      type.slice(0, lineClass.index) +
                      type.slice(lineClass.index + lineClass[0].length);
                    var prop = lineClass[1] ? "bgClass" : "textClass";
                    null == output[prop]
                      ? (output[prop] = lineClass[2])
                      : new RegExp("(?:^|s)" + lineClass[2] + "(?:$|s)").test(
                          output[prop]
                        ) || (output[prop] += " " + lineClass[2]);
                  }
                return type;
              }
              function runMode(
                cm,
                text,
                mode,
                context,
                f,
                lineClasses,
                forceToEnd
              ) {
                var flattenSpans = mode.flattenSpans;
                null == flattenSpans &&
                  (flattenSpans = cm.options.flattenSpans);
                var style,
                  curStart = 0,
                  curStyle = null,
                  stream = new StringStream(text, cm.options.tabSize, context),
                  inner = cm.options.addModeClass && [null];
                for (
                  "" == text &&
                  extractLineClasses(
                    callBlankLine(mode, context.state),
                    lineClasses
                  );
                  !stream.eol();

                ) {
                  if (
                    (stream.pos > cm.options.maxHighlightLength
                      ? ((flattenSpans = !1),
                        forceToEnd &&
                          processLine(cm, text, context, stream.pos),
                        (stream.pos = text.length),
                        (style = null))
                      : (style = extractLineClasses(
                          readToken(mode, stream, context.state, inner),
                          lineClasses
                        )),
                    inner)
                  ) {
                    var mName = inner[0].name;
                    mName &&
                      (style = "m-" + (style ? mName + " " + style : mName));
                  }
                  if (!flattenSpans || curStyle != style) {
                    for (; curStart < stream.start; )
                      f(
                        (curStart = Math.min(stream.start, curStart + 5e3)),
                        curStyle
                      );
                    curStyle = style;
                  }
                  stream.start = stream.pos;
                }
                for (; curStart < stream.pos; ) {
                  var pos = Math.min(stream.pos, curStart + 5e3);
                  f(pos, curStyle), (curStart = pos);
                }
              }
              var Line = function(text, markedSpans, estimateHeight) {
                (this.text = text),
                  attachMarkedSpans(this, markedSpans),
                  (this.height = estimateHeight ? estimateHeight(this) : 1);
              };
              function cleanUpLine(line) {
                (line.parent = null), detachMarkedSpans(line);
              }
              (Line.prototype.lineNo = function() {
                return lineNo(this);
              }),
                eventMixin(Line);
              var styleToClassCache = {},
                styleToClassCacheWithMode = {};
              function interpretTokenStyle(style, options) {
                if (!style || /^\s*$/.test(style)) return null;
                var cache = options.addModeClass
                  ? styleToClassCacheWithMode
                  : styleToClassCache;
                return (
                  cache[style] ||
                  (cache[style] = style.replace(/\S+/g, "cm-$&"))
                );
              }
              function buildLineContent(cm, lineView) {
                var content = eltP(
                    "span",
                    null,
                    null,
                    webkit ? "padding-right: .1px" : null
                  ),
                  builder = {
                    pre: eltP("pre", [content], "CodeMirror-line"),
                    content: content,
                    col: 0,
                    pos: 0,
                    cm: cm,
                    trailingSpace: !1,
                    splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
                  };
                lineView.measure = {};
                for (
                  var i = 0;
                  i <= (lineView.rest ? lineView.rest.length : 0);
                  i++
                ) {
                  var line = i ? lineView.rest[i - 1] : lineView.line,
                    order = void 0;
                  (builder.pos = 0),
                    (builder.addToken = buildToken),
                    hasBadBidiRects(cm.display.measure) &&
                      (order = getOrder(line, cm.doc.direction)) &&
                      (builder.addToken = buildTokenBadBidi(
                        builder.addToken,
                        order
                      )),
                    (builder.map = []),
                    insertLineContent(
                      line,
                      builder,
                      getLineStyles(
                        cm,
                        line,
                        lineView != cm.display.externalMeasured && lineNo(line)
                      )
                    ),
                    line.styleClasses &&
                      (line.styleClasses.bgClass &&
                        (builder.bgClass = joinClasses(
                          line.styleClasses.bgClass,
                          builder.bgClass || ""
                        )),
                      line.styleClasses.textClass &&
                        (builder.textClass = joinClasses(
                          line.styleClasses.textClass,
                          builder.textClass || ""
                        ))),
                    0 == builder.map.length &&
                      builder.map.push(
                        0,
                        0,
                        builder.content.appendChild(
                          zeroWidthElement(cm.display.measure)
                        )
                      ),
                    0 == i
                      ? ((lineView.measure.map = builder.map),
                        (lineView.measure.cache = {}))
                      : ((
                          lineView.measure.maps || (lineView.measure.maps = [])
                        ).push(builder.map),
                        (
                          lineView.measure.caches ||
                          (lineView.measure.caches = [])
                        ).push({}));
                }
                if (webkit) {
                  var last = builder.content.lastChild;
                  (/\bcm-tab\b/.test(last.className) ||
                    (last.querySelector && last.querySelector(".cm-tab"))) &&
                    (builder.content.className = "cm-tab-wrap-hack");
                }
                return (
                  signal(cm, "renderLine", cm, lineView.line, builder.pre),
                  builder.pre.className &&
                    (builder.textClass = joinClasses(
                      builder.pre.className,
                      builder.textClass || ""
                    )),
                  builder
                );
              }
              function defaultSpecialCharPlaceholder(ch) {
                var token = elt("span", "•", "cm-invalidchar");
                return (
                  (token.title = "\\u" + ch.charCodeAt(0).toString(16)),
                  token.setAttribute("aria-label", token.title),
                  token
                );
              }
              function buildToken(
                builder,
                text,
                style,
                startStyle,
                endStyle,
                title,
                css
              ) {
                if (text) {
                  var content,
                    displayText = builder.splitSpaces
                      ? (function(text, trailingBefore) {
                          if (1 < text.length && !/  /.test(text)) return text;
                          for (
                            var spaceBefore = trailingBefore,
                              result = "",
                              i = 0;
                            i < text.length;
                            i++
                          ) {
                            var ch = text.charAt(i);
                            " " != ch ||
                              !spaceBefore ||
                              (i != text.length - 1 &&
                                32 != text.charCodeAt(i + 1)) ||
                              (ch = " "),
                              (result += ch),
                              (spaceBefore = " " == ch);
                          }
                          return result;
                        })(text, builder.trailingSpace)
                      : text,
                    special = builder.cm.state.specialChars,
                    mustWrap = !1;
                  if (special.test(text)) {
                    content = document.createDocumentFragment();
                    for (var pos = 0; ; ) {
                      special.lastIndex = pos;
                      var m = special.exec(text),
                        skipped = m ? m.index - pos : text.length - pos;
                      if (skipped) {
                        var txt = document.createTextNode(
                          displayText.slice(pos, pos + skipped)
                        );
                        ie && ie_version < 9
                          ? content.appendChild(elt("span", [txt]))
                          : content.appendChild(txt),
                          builder.map.push(
                            builder.pos,
                            builder.pos + skipped,
                            txt
                          ),
                          (builder.col += skipped),
                          (builder.pos += skipped);
                      }
                      if (!m) break;
                      pos += skipped + 1;
                      var txt$1 = void 0;
                      if ("\t" == m[0]) {
                        var tabSize = builder.cm.options.tabSize,
                          tabWidth = tabSize - builder.col % tabSize;
                        (txt$1 = content.appendChild(
                          elt("span", spaceStr(tabWidth), "cm-tab")
                        )).setAttribute("role", "presentation"),
                          txt$1.setAttribute("cm-text", "\t"),
                          (builder.col += tabWidth);
                      } else
                        "\r" == m[0] || "\n" == m[0]
                          ? (txt$1 = content.appendChild(
                              elt(
                                "span",
                                "\r" == m[0] ? "␍" : "␤",
                                "cm-invalidchar"
                              )
                            )).setAttribute("cm-text", m[0])
                          : ((txt$1 = builder.cm.options.specialCharPlaceholder(
                              m[0]
                            )).setAttribute("cm-text", m[0]),
                            ie && ie_version < 9
                              ? content.appendChild(elt("span", [txt$1]))
                              : content.appendChild(txt$1)),
                          (builder.col += 1);
                      builder.map.push(builder.pos, builder.pos + 1, txt$1),
                        builder.pos++;
                    }
                  } else
                    (builder.col += text.length),
                      (content = document.createTextNode(displayText)),
                      builder.map.push(
                        builder.pos,
                        builder.pos + text.length,
                        content
                      ),
                      ie && ie_version < 9 && (mustWrap = !0),
                      (builder.pos += text.length);
                  if (
                    ((builder.trailingSpace =
                      32 == displayText.charCodeAt(text.length - 1)),
                    style || startStyle || endStyle || mustWrap || css)
                  ) {
                    var fullStyle = style || "";
                    startStyle && (fullStyle += startStyle),
                      endStyle && (fullStyle += endStyle);
                    var token = elt("span", [content], fullStyle, css);
                    return (
                      title && (token.title = title),
                      builder.content.appendChild(token)
                    );
                  }
                  builder.content.appendChild(content);
                }
              }
              function buildTokenBadBidi(inner, order) {
                return function(
                  builder,
                  text,
                  style,
                  startStyle,
                  endStyle,
                  title,
                  css
                ) {
                  style = style
                    ? style + " cm-force-border"
                    : "cm-force-border";
                  for (var start = builder.pos, end = start + text.length; ; ) {
                    for (
                      var part = void 0, i = 0;
                      i < order.length &&
                      !((part = order[i]).to > start && part.from <= start);
                      i++
                    );
                    if (part.to >= end)
                      return inner(
                        builder,
                        text,
                        style,
                        startStyle,
                        endStyle,
                        title,
                        css
                      );
                    inner(
                      builder,
                      text.slice(0, part.to - start),
                      style,
                      startStyle,
                      null,
                      title,
                      css
                    ),
                      (startStyle = null),
                      (text = text.slice(part.to - start)),
                      (start = part.to);
                  }
                };
              }
              function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
                var widget = !ignoreWidget && marker.widgetNode;
                widget &&
                  builder.map.push(builder.pos, builder.pos + size, widget),
                  !ignoreWidget &&
                    builder.cm.display.input.needsContentAttribute &&
                    (widget ||
                      (widget = builder.content.appendChild(
                        document.createElement("span")
                      )),
                    widget.setAttribute("cm-marker", marker.id)),
                  widget &&
                    (builder.cm.display.input.setUneditable(widget),
                    builder.content.appendChild(widget)),
                  (builder.pos += size),
                  (builder.trailingSpace = !1);
              }
              function insertLineContent(line, builder, styles) {
                var spans = line.markedSpans,
                  allText = line.text,
                  at = 0;
                if (spans)
                  for (
                    var style,
                      css,
                      spanStyle,
                      spanEndStyle,
                      spanStartStyle,
                      title,
                      collapsed,
                      len = allText.length,
                      pos = 0,
                      i = 1,
                      text = "",
                      nextChange = 0;
                    ;

                  ) {
                    if (nextChange == pos) {
                      (spanStyle = spanEndStyle = spanStartStyle = title = css =
                        ""),
                        (collapsed = null),
                        (nextChange = 1 / 0);
                      for (
                        var foundBookmarks = [], endStyles = void 0, j = 0;
                        j < spans.length;
                        ++j
                      ) {
                        var sp = spans[j],
                          m = sp.marker;
                        "bookmark" == m.type && sp.from == pos && m.widgetNode
                          ? foundBookmarks.push(m)
                          : sp.from <= pos &&
                            (null == sp.to ||
                              sp.to > pos ||
                              (m.collapsed && sp.to == pos && sp.from == pos))
                            ? (null != sp.to &&
                                sp.to != pos &&
                                nextChange > sp.to &&
                                ((nextChange = sp.to), (spanEndStyle = "")),
                              m.className && (spanStyle += " " + m.className),
                              m.css && (css = (css ? css + ";" : "") + m.css),
                              m.startStyle &&
                                sp.from == pos &&
                                (spanStartStyle += " " + m.startStyle),
                              m.endStyle &&
                                sp.to == nextChange &&
                                (endStyles || (endStyles = [])).push(
                                  m.endStyle,
                                  sp.to
                                ),
                              m.title && !title && (title = m.title),
                              m.collapsed &&
                                (!collapsed ||
                                  compareCollapsedMarkers(collapsed.marker, m) <
                                    0) &&
                                (collapsed = sp))
                            : sp.from > pos &&
                              nextChange > sp.from &&
                              (nextChange = sp.from);
                      }
                      if (endStyles)
                        for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
                          endStyles[j$1 + 1] == nextChange &&
                            (spanEndStyle += " " + endStyles[j$1]);
                      if (!collapsed || collapsed.from == pos)
                        for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
                          buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                      if (collapsed && (collapsed.from || 0) == pos) {
                        if (
                          (buildCollapsedSpan(
                            builder,
                            (null == collapsed.to ? len + 1 : collapsed.to) -
                              pos,
                            collapsed.marker,
                            null == collapsed.from
                          ),
                          null == collapsed.to)
                        )
                          return;
                        collapsed.to == pos && (collapsed = !1);
                      }
                    }
                    if (len <= pos) break;
                    for (var upto = Math.min(len, nextChange); ; ) {
                      if (text) {
                        var end = pos + text.length;
                        if (!collapsed) {
                          var tokenText =
                            upto < end ? text.slice(0, upto - pos) : text;
                          builder.addToken(
                            builder,
                            tokenText,
                            style ? style + spanStyle : spanStyle,
                            spanStartStyle,
                            pos + tokenText.length == nextChange
                              ? spanEndStyle
                              : "",
                            title,
                            css
                          );
                        }
                        if (upto <= end) {
                          (text = text.slice(upto - pos)), (pos = upto);
                          break;
                        }
                        (pos = end), (spanStartStyle = "");
                      }
                      (text = allText.slice(at, (at = styles[i++]))),
                        (style = interpretTokenStyle(
                          styles[i++],
                          builder.cm.options
                        ));
                    }
                  }
                else
                  for (var i$1 = 1; i$1 < styles.length; i$1 += 2)
                    builder.addToken(
                      builder,
                      allText.slice(at, (at = styles[i$1])),
                      interpretTokenStyle(styles[i$1 + 1], builder.cm.options)
                    );
              }
              function LineView(doc, line, lineN) {
                (this.line = line),
                  (this.rest = (function(line) {
                    for (
                      var merged, lines;
                      (merged = collapsedSpanAtEnd(line));

                    )
                      (line = merged.find(1, !0).line),
                        (lines || (lines = [])).push(line);
                    return lines;
                  })(line)),
                  (this.size = this.rest
                    ? lineNo(lst(this.rest)) - lineN + 1
                    : 1),
                  (this.node = this.text = null),
                  (this.hidden = lineIsHidden(doc, line));
              }
              function buildViewArray(cm, from, to) {
                for (
                  var nextPos, array = [], pos = from;
                  pos < to;
                  pos = nextPos
                ) {
                  var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
                  (nextPos = pos + view.size), array.push(view);
                }
                return array;
              }
              var operationGroup = null;
              var orphanDelayedCallbacks = null;
              function signalLater(emitter, type) {
                var arr = getHandlers(emitter, type);
                if (arr.length) {
                  var list,
                    args = Array.prototype.slice.call(arguments, 2);
                  operationGroup
                    ? (list = operationGroup.delayedCallbacks)
                    : orphanDelayedCallbacks
                      ? (list = orphanDelayedCallbacks)
                      : ((list = orphanDelayedCallbacks = []),
                        setTimeout(fireOrphanDelayed, 0));
                  for (
                    var loop = function(i) {
                        list.push(function() {
                          return arr[i].apply(null, args);
                        });
                      },
                      i = 0;
                    i < arr.length;
                    ++i
                  )
                    loop(i);
                }
              }
              function fireOrphanDelayed() {
                var delayed = orphanDelayedCallbacks;
                orphanDelayedCallbacks = null;
                for (var i = 0; i < delayed.length; ++i) delayed[i]();
              }
              function updateLineForChanges(cm, lineView, lineN, dims) {
                for (var j = 0; j < lineView.changes.length; j++) {
                  var type = lineView.changes[j];
                  "text" == type
                    ? updateLineText(cm, lineView)
                    : "gutter" == type
                      ? updateLineGutter(cm, lineView, lineN, dims)
                      : "class" == type
                        ? updateLineClasses(cm, lineView)
                        : "widget" == type &&
                          updateLineWidgets(cm, lineView, dims);
                }
                lineView.changes = null;
              }
              function ensureLineWrapped(lineView) {
                return (
                  lineView.node == lineView.text &&
                    ((lineView.node = elt(
                      "div",
                      null,
                      null,
                      "position: relative"
                    )),
                    lineView.text.parentNode &&
                      lineView.text.parentNode.replaceChild(
                        lineView.node,
                        lineView.text
                      ),
                    lineView.node.appendChild(lineView.text),
                    ie && ie_version < 8 && (lineView.node.style.zIndex = 2)),
                  lineView.node
                );
              }
              function getLineContent(cm, lineView) {
                var ext = cm.display.externalMeasured;
                return ext && ext.line == lineView.line
                  ? ((cm.display.externalMeasured = null),
                    (lineView.measure = ext.measure),
                    ext.built)
                  : buildLineContent(cm, lineView);
              }
              function updateLineText(cm, lineView) {
                var cls = lineView.text.className,
                  built = getLineContent(cm, lineView);
                lineView.text == lineView.node && (lineView.node = built.pre),
                  lineView.text.parentNode.replaceChild(
                    built.pre,
                    lineView.text
                  ),
                  (lineView.text = built.pre),
                  built.bgClass != lineView.bgClass ||
                  built.textClass != lineView.textClass
                    ? ((lineView.bgClass = built.bgClass),
                      (lineView.textClass = built.textClass),
                      updateLineClasses(cm, lineView))
                    : cls && (lineView.text.className = cls);
              }
              function updateLineClasses(cm, lineView) {
                !(function(cm, lineView) {
                  var cls = lineView.bgClass
                    ? lineView.bgClass + " " + (lineView.line.bgClass || "")
                    : lineView.line.bgClass;
                  if (
                    (cls && (cls += " CodeMirror-linebackground"),
                    lineView.background)
                  )
                    cls
                      ? (lineView.background.className = cls)
                      : (lineView.background.parentNode.removeChild(
                          lineView.background
                        ),
                        (lineView.background = null));
                  else if (cls) {
                    var wrap = ensureLineWrapped(lineView);
                    (lineView.background = wrap.insertBefore(
                      elt("div", null, cls),
                      wrap.firstChild
                    )),
                      cm.display.input.setUneditable(lineView.background);
                  }
                })(cm, lineView),
                  lineView.line.wrapClass
                    ? (ensureLineWrapped(lineView).className =
                        lineView.line.wrapClass)
                    : lineView.node != lineView.text &&
                      (lineView.node.className = "");
                var textClass = lineView.textClass
                  ? lineView.textClass + " " + (lineView.line.textClass || "")
                  : lineView.line.textClass;
                lineView.text.className = textClass || "";
              }
              function updateLineGutter(cm, lineView, lineN, dims) {
                if (
                  (lineView.gutter &&
                    (lineView.node.removeChild(lineView.gutter),
                    (lineView.gutter = null)),
                  lineView.gutterBackground &&
                    (lineView.node.removeChild(lineView.gutterBackground),
                    (lineView.gutterBackground = null)),
                  lineView.line.gutterClass)
                ) {
                  var wrap = ensureLineWrapped(lineView);
                  (lineView.gutterBackground = elt(
                    "div",
                    null,
                    "CodeMirror-gutter-background " + lineView.line.gutterClass,
                    "left: " +
                      (cm.options.fixedGutter
                        ? dims.fixedPos
                        : -dims.gutterTotalWidth) +
                      "px; width: " +
                      dims.gutterTotalWidth +
                      "px"
                  )),
                    cm.display.input.setUneditable(lineView.gutterBackground),
                    wrap.insertBefore(lineView.gutterBackground, lineView.text);
                }
                var markers = lineView.line.gutterMarkers;
                if (cm.options.lineNumbers || markers) {
                  var wrap$1 = ensureLineWrapped(lineView),
                    gutterWrap = (lineView.gutter = elt(
                      "div",
                      null,
                      "CodeMirror-gutter-wrapper",
                      "left: " +
                        (cm.options.fixedGutter
                          ? dims.fixedPos
                          : -dims.gutterTotalWidth) +
                        "px"
                    ));
                  if (
                    (cm.display.input.setUneditable(gutterWrap),
                    wrap$1.insertBefore(gutterWrap, lineView.text),
                    lineView.line.gutterClass &&
                      (gutterWrap.className += " " + lineView.line.gutterClass),
                    !cm.options.lineNumbers ||
                      (markers && markers["CodeMirror-linenumbers"]) ||
                      (lineView.lineNumber = gutterWrap.appendChild(
                        elt(
                          "div",
                          lineNumberFor(cm.options, lineN),
                          "CodeMirror-linenumber CodeMirror-gutter-elt",
                          "left: " +
                            dims.gutterLeft["CodeMirror-linenumbers"] +
                            "px; width: " +
                            cm.display.lineNumInnerWidth +
                            "px"
                        )
                      )),
                    markers)
                  )
                    for (var k = 0; k < cm.options.gutters.length; ++k) {
                      var id = cm.options.gutters[k],
                        found = markers.hasOwnProperty(id) && markers[id];
                      found &&
                        gutterWrap.appendChild(
                          elt(
                            "div",
                            [found],
                            "CodeMirror-gutter-elt",
                            "left: " +
                              dims.gutterLeft[id] +
                              "px; width: " +
                              dims.gutterWidth[id] +
                              "px"
                          )
                        );
                    }
                }
              }
              function updateLineWidgets(cm, lineView, dims) {
                lineView.alignable && (lineView.alignable = null);
                for (
                  var node = lineView.node.firstChild, next = void 0;
                  node;
                  node = next
                )
                  (next = node.nextSibling),
                    "CodeMirror-linewidget" == node.className &&
                      lineView.node.removeChild(node);
                insertLineWidgets(cm, lineView, dims);
              }
              function buildLineElement(cm, lineView, lineN, dims) {
                var built = getLineContent(cm, lineView);
                return (
                  (lineView.text = lineView.node = built.pre),
                  built.bgClass && (lineView.bgClass = built.bgClass),
                  built.textClass && (lineView.textClass = built.textClass),
                  updateLineClasses(cm, lineView),
                  updateLineGutter(cm, lineView, lineN, dims),
                  insertLineWidgets(cm, lineView, dims),
                  lineView.node
                );
              }
              function insertLineWidgets(cm, lineView, dims) {
                if (
                  (insertLineWidgetsFor(cm, lineView.line, lineView, dims, !0),
                  lineView.rest)
                )
                  for (var i = 0; i < lineView.rest.length; i++)
                    insertLineWidgetsFor(
                      cm,
                      lineView.rest[i],
                      lineView,
                      dims,
                      !1
                    );
              }
              function insertLineWidgetsFor(
                cm,
                line,
                lineView,
                dims,
                allowAbove
              ) {
                if (line.widgets)
                  for (
                    var wrap = ensureLineWrapped(lineView),
                      i = 0,
                      ws = line.widgets;
                    i < ws.length;
                    ++i
                  ) {
                    var widget = ws[i],
                      node = elt("div", [widget.node], "CodeMirror-linewidget");
                    widget.handleMouseEvents ||
                      node.setAttribute("cm-ignore-events", "true"),
                      positionLineWidget(widget, node, lineView, dims),
                      cm.display.input.setUneditable(node),
                      allowAbove && widget.above
                        ? wrap.insertBefore(
                            node,
                            lineView.gutter || lineView.text
                          )
                        : wrap.appendChild(node),
                      signalLater(widget, "redraw");
                  }
              }
              function positionLineWidget(widget, node, lineView, dims) {
                if (widget.noHScroll) {
                  (lineView.alignable || (lineView.alignable = [])).push(node);
                  var width = dims.wrapperWidth;
                  (node.style.left = dims.fixedPos + "px"),
                    widget.coverGutter ||
                      ((width -= dims.gutterTotalWidth),
                      (node.style.paddingLeft = dims.gutterTotalWidth + "px")),
                    (node.style.width = width + "px");
                }
                widget.coverGutter &&
                  ((node.style.zIndex = 5),
                  (node.style.position = "relative"),
                  widget.noHScroll ||
                    (node.style.marginLeft = -dims.gutterTotalWidth + "px"));
              }
              function widgetHeight(widget) {
                if (null != widget.height) return widget.height;
                var cm = widget.doc.cm;
                if (!cm) return 0;
                if (!contains(document.body, widget.node)) {
                  var parentStyle = "position: relative;";
                  widget.coverGutter &&
                    (parentStyle +=
                      "margin-left: -" +
                      cm.display.gutters.offsetWidth +
                      "px;"),
                    widget.noHScroll &&
                      (parentStyle +=
                        "width: " + cm.display.wrapper.clientWidth + "px;"),
                    removeChildrenAndAdd(
                      cm.display.measure,
                      elt("div", [widget.node], null, parentStyle)
                    );
                }
                return (widget.height = widget.node.parentNode.offsetHeight);
              }
              function eventInWidget(display, e) {
                for (
                  var n = e_target(e);
                  n != display.wrapper;
                  n = n.parentNode
                )
                  if (
                    !n ||
                    (1 == n.nodeType &&
                      "true" == n.getAttribute("cm-ignore-events")) ||
                    (n.parentNode == display.sizer && n != display.mover)
                  )
                    return !0;
              }
              function paddingTop(display) {
                return display.lineSpace.offsetTop;
              }
              function paddingVert(display) {
                return (
                  display.mover.offsetHeight - display.lineSpace.offsetHeight
                );
              }
              function paddingH(display) {
                if (display.cachedPaddingH) return display.cachedPaddingH;
                var e = removeChildrenAndAdd(display.measure, elt("pre", "x")),
                  style = window.getComputedStyle
                    ? window.getComputedStyle(e)
                    : e.currentStyle,
                  data = {
                    left: parseInt(style.paddingLeft),
                    right: parseInt(style.paddingRight)
                  };
                return (
                  isNaN(data.left) ||
                    isNaN(data.right) ||
                    (display.cachedPaddingH = data),
                  data
                );
              }
              function scrollGap(cm) {
                return scrollerGap - cm.display.nativeBarWidth;
              }
              function displayWidth(cm) {
                return (
                  cm.display.scroller.clientWidth -
                  scrollGap(cm) -
                  cm.display.barWidth
                );
              }
              function displayHeight(cm) {
                return (
                  cm.display.scroller.clientHeight -
                  scrollGap(cm) -
                  cm.display.barHeight
                );
              }
              function mapFromLineView(lineView, line, lineN) {
                if (lineView.line == line)
                  return {
                    map: lineView.measure.map,
                    cache: lineView.measure.cache
                  };
                for (var i = 0; i < lineView.rest.length; i++)
                  if (lineView.rest[i] == line)
                    return {
                      map: lineView.measure.maps[i],
                      cache: lineView.measure.caches[i]
                    };
                for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
                  if (lineNo(lineView.rest[i$1]) > lineN)
                    return {
                      map: lineView.measure.maps[i$1],
                      cache: lineView.measure.caches[i$1],
                      before: !0
                    };
              }
              function measureChar(cm, line, ch, bias) {
                return measureCharPrepared(
                  cm,
                  prepareMeasureForLine(cm, line),
                  ch,
                  bias
                );
              }
              function findViewForLine(cm, lineN) {
                if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
                  return cm.display.view[findViewIndex(cm, lineN)];
                var ext = cm.display.externalMeasured;
                return ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size
                  ? ext
                  : void 0;
              }
              function prepareMeasureForLine(cm, line) {
                var lineN = lineNo(line),
                  view = findViewForLine(cm, lineN);
                view && !view.text
                  ? (view = null)
                  : view &&
                    view.changes &&
                    (updateLineForChanges(cm, view, lineN, getDimensions(cm)),
                    (cm.curOp.forceUpdate = !0)),
                  view ||
                    (view = (function(cm, line) {
                      var lineN = lineNo((line = visualLine(line))),
                        view = (cm.display.externalMeasured = new LineView(
                          cm.doc,
                          line,
                          lineN
                        ));
                      view.lineN = lineN;
                      var built = (view.built = buildLineContent(cm, view));
                      return (
                        (view.text = built.pre),
                        removeChildrenAndAdd(cm.display.lineMeasure, built.pre),
                        view
                      );
                    })(cm, line));
                var info = mapFromLineView(view, line, lineN);
                return {
                  line: line,
                  view: view,
                  rect: null,
                  map: info.map,
                  cache: info.cache,
                  before: info.before,
                  hasHeights: !1
                };
              }
              function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
                prepared.before && (ch = -1);
                var found,
                  key = ch + (bias || "");
                return (
                  prepared.cache.hasOwnProperty(key)
                    ? (found = prepared.cache[key])
                    : (prepared.rect ||
                        (prepared.rect = prepared.view.text.getBoundingClientRect()),
                      prepared.hasHeights ||
                        (!(function(cm, lineView, rect) {
                          var wrapping = cm.options.lineWrapping,
                            curWidth = wrapping && displayWidth(cm);
                          if (
                            !lineView.measure.heights ||
                            (wrapping && lineView.measure.width != curWidth)
                          ) {
                            var heights = (lineView.measure.heights = []);
                            if (wrapping) {
                              lineView.measure.width = curWidth;
                              for (
                                var rects = lineView.text.firstChild.getClientRects(),
                                  i = 0;
                                i < rects.length - 1;
                                i++
                              ) {
                                var cur = rects[i],
                                  next = rects[i + 1];
                                2 < Math.abs(cur.bottom - next.bottom) &&
                                  heights.push(
                                    (cur.bottom + next.top) / 2 - rect.top
                                  );
                              }
                            }
                            heights.push(rect.bottom - rect.top);
                          }
                        })(cm, prepared.view, prepared.rect),
                        (prepared.hasHeights = !0)),
                      (found = (function(cm, prepared, ch, bias) {
                        var rect,
                          place = nodeAndOffsetInLineMap(
                            prepared.map,
                            ch,
                            bias
                          ),
                          node = place.node,
                          start = place.start,
                          end = place.end,
                          collapse = place.collapse;
                        if (3 == node.nodeType) {
                          for (var i$1 = 0; i$1 < 4; i$1++) {
                            for (
                              ;
                              start &&
                              isExtendingChar(
                                prepared.line.text.charAt(
                                  place.coverStart + start
                                )
                              );

                            )
                              --start;
                            for (
                              ;
                              place.coverStart + end < place.coverEnd &&
                              isExtendingChar(
                                prepared.line.text.charAt(
                                  place.coverStart + end
                                )
                              );

                            )
                              ++end;
                            if (
                              (rect =
                                ie &&
                                ie_version < 9 &&
                                0 == start &&
                                end == place.coverEnd - place.coverStart
                                  ? node.parentNode.getBoundingClientRect()
                                  : getUsefulRect(
                                      range(node, start, end).getClientRects(),
                                      bias
                                    )).left ||
                              rect.right ||
                              0 == start
                            )
                              break;
                            (end = start), (start -= 1), (collapse = "right");
                          }
                          ie &&
                            ie_version < 11 &&
                            (rect = (function(measure, rect) {
                              if (
                                !window.screen ||
                                null == screen.logicalXDPI ||
                                screen.logicalXDPI == screen.deviceXDPI ||
                                !(function(measure) {
                                  if (null != badZoomedRects)
                                    return badZoomedRects;
                                  var node = removeChildrenAndAdd(
                                      measure,
                                      elt("span", "x")
                                    ),
                                    normal = node.getBoundingClientRect(),
                                    fromRange = range(
                                      node,
                                      0,
                                      1
                                    ).getBoundingClientRect();
                                  return (badZoomedRects =
                                    1 < Math.abs(normal.left - fromRange.left));
                                })(measure)
                              )
                                return rect;
                              var scaleX =
                                  screen.logicalXDPI / screen.deviceXDPI,
                                scaleY = screen.logicalYDPI / screen.deviceYDPI;
                              return {
                                left: rect.left * scaleX,
                                right: rect.right * scaleX,
                                top: rect.top * scaleY,
                                bottom: rect.bottom * scaleY
                              };
                            })(cm.display.measure, rect));
                        } else {
                          var rects;
                          0 < start && (collapse = bias = "right"),
                            (rect =
                              cm.options.lineWrapping &&
                              1 < (rects = node.getClientRects()).length
                                ? rects["right" == bias ? rects.length - 1 : 0]
                                : node.getBoundingClientRect());
                        }
                        if (
                          ie &&
                          ie_version < 9 &&
                          !start &&
                          (!rect || (!rect.left && !rect.right))
                        ) {
                          var rSpan = node.parentNode.getClientRects()[0];
                          rect = rSpan
                            ? {
                                left: rSpan.left,
                                right: rSpan.left + charWidth(cm.display),
                                top: rSpan.top,
                                bottom: rSpan.bottom
                              }
                            : nullRect;
                        }
                        for (
                          var rtop = rect.top - prepared.rect.top,
                            rbot = rect.bottom - prepared.rect.top,
                            mid = (rtop + rbot) / 2,
                            heights = prepared.view.measure.heights,
                            i = 0;
                          i < heights.length - 1 && !(mid < heights[i]);
                          i++
                        );
                        var top = i ? heights[i - 1] : 0,
                          bot = heights[i],
                          result = {
                            left:
                              ("right" == collapse ? rect.right : rect.left) -
                              prepared.rect.left,
                            right:
                              ("left" == collapse ? rect.left : rect.right) -
                              prepared.rect.left,
                            top: top,
                            bottom: bot
                          };
                        rect.left || rect.right || (result.bogus = !0);
                        cm.options.singleCursorHeightPerLine ||
                          ((result.rtop = rtop), (result.rbottom = rbot));
                        return result;
                      })(cm, prepared, ch, bias)).bogus ||
                        (prepared.cache[key] = found)),
                  {
                    left: found.left,
                    right: found.right,
                    top: varHeight ? found.rtop : found.top,
                    bottom: varHeight ? found.rbottom : found.bottom
                  }
                );
              }
              var measureText,
                nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
              function nodeAndOffsetInLineMap(map$$1, ch, bias) {
                for (
                  var node, start, end, collapse, mStart, mEnd, i = 0;
                  i < map$$1.length;
                  i += 3
                )
                  if (
                    ((mStart = map$$1[i]),
                    (mEnd = map$$1[i + 1]),
                    ch < mStart
                      ? ((start = 0), (end = 1), (collapse = "left"))
                      : ch < mEnd
                        ? (end = (start = ch - mStart) + 1)
                        : (i == map$$1.length - 3 ||
                            (ch == mEnd && map$$1[i + 3] > ch)) &&
                          ((start = (end = mEnd - mStart) - 1),
                          mEnd <= ch && (collapse = "right")),
                    null != start)
                  ) {
                    if (
                      ((node = map$$1[i + 2]),
                      mStart == mEnd &&
                        bias == (node.insertLeft ? "left" : "right") &&
                        (collapse = bias),
                      "left" == bias && 0 == start)
                    )
                      for (
                        ;
                        i &&
                        map$$1[i - 2] == map$$1[i - 3] &&
                        map$$1[i - 1].insertLeft;

                      )
                        (node = map$$1[2 + (i -= 3)]), (collapse = "left");
                    if ("right" == bias && start == mEnd - mStart)
                      for (
                        ;
                        i < map$$1.length - 3 &&
                        map$$1[i + 3] == map$$1[i + 4] &&
                        !map$$1[i + 5].insertLeft;

                      )
                        (node = map$$1[(i += 3) + 2]), (collapse = "right");
                    break;
                  }
                return {
                  node: node,
                  start: start,
                  end: end,
                  collapse: collapse,
                  coverStart: mStart,
                  coverEnd: mEnd
                };
              }
              function getUsefulRect(rects, bias) {
                var rect = nullRect;
                if ("left" == bias)
                  for (
                    var i = 0;
                    i < rects.length && (rect = rects[i]).left == rect.right;
                    i++
                  );
                else
                  for (
                    var i$1 = rects.length - 1;
                    0 <= i$1 && (rect = rects[i$1]).left == rect.right;
                    i$1--
                  );
                return rect;
              }
              function clearLineMeasurementCacheFor(lineView) {
                if (
                  lineView.measure &&
                  ((lineView.measure.cache = {}),
                  (lineView.measure.heights = null),
                  lineView.rest)
                )
                  for (var i = 0; i < lineView.rest.length; i++)
                    lineView.measure.caches[i] = {};
              }
              function clearLineMeasurementCache(cm) {
                (cm.display.externalMeasure = null),
                  removeChildren(cm.display.lineMeasure);
                for (var i = 0; i < cm.display.view.length; i++)
                  clearLineMeasurementCacheFor(cm.display.view[i]);
              }
              function clearCaches(cm) {
                clearLineMeasurementCache(cm),
                  (cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null),
                  cm.options.lineWrapping || (cm.display.maxLineChanged = !0),
                  (cm.display.lineNumChars = null);
              }
              function pageScrollX() {
                return chrome && android
                  ? -(
                      document.body.getBoundingClientRect().left -
                      parseInt(getComputedStyle(document.body).marginLeft)
                    )
                  : window.pageXOffset ||
                      (document.documentElement || document.body).scrollLeft;
              }
              function pageScrollY() {
                return chrome && android
                  ? -(
                      document.body.getBoundingClientRect().top -
                      parseInt(getComputedStyle(document.body).marginTop)
                    )
                  : window.pageYOffset ||
                      (document.documentElement || document.body).scrollTop;
              }
              function widgetTopHeight(lineObj) {
                var height = 0;
                if (lineObj.widgets)
                  for (var i = 0; i < lineObj.widgets.length; ++i)
                    lineObj.widgets[i].above &&
                      (height += widgetHeight(lineObj.widgets[i]));
                return height;
              }
              function intoCoordSystem(
                cm,
                lineObj,
                rect,
                context,
                includeWidgets
              ) {
                if (!includeWidgets) {
                  var height = widgetTopHeight(lineObj);
                  (rect.top += height), (rect.bottom += height);
                }
                if ("line" == context) return rect;
                context || (context = "local");
                var yOff = heightAtLine(lineObj);
                if (
                  ("local" == context
                    ? (yOff += paddingTop(cm.display))
                    : (yOff -= cm.display.viewOffset),
                  "page" == context || "window" == context)
                ) {
                  var lOff = cm.display.lineSpace.getBoundingClientRect();
                  yOff += lOff.top + ("window" == context ? 0 : pageScrollY());
                  var xOff =
                    lOff.left + ("window" == context ? 0 : pageScrollX());
                  (rect.left += xOff), (rect.right += xOff);
                }
                return (rect.top += yOff), (rect.bottom += yOff), rect;
              }
              function fromCoordSystem(cm, coords, context) {
                if ("div" == context) return coords;
                var left = coords.left,
                  top = coords.top;
                if ("page" == context)
                  (left -= pageScrollX()), (top -= pageScrollY());
                else if ("local" == context || !context) {
                  var localBox = cm.display.sizer.getBoundingClientRect();
                  (left += localBox.left), (top += localBox.top);
                }
                var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
                return {
                  left: left - lineSpaceBox.left,
                  top: top - lineSpaceBox.top
                };
              }
              function charCoords(cm, pos, context, lineObj, bias) {
                return (
                  lineObj || (lineObj = getLine(cm.doc, pos.line)),
                  intoCoordSystem(
                    cm,
                    lineObj,
                    measureChar(cm, lineObj, pos.ch, bias),
                    context
                  )
                );
              }
              function cursorCoords(
                cm,
                pos,
                context,
                lineObj,
                preparedMeasure,
                varHeight
              ) {
                function get(ch, right) {
                  var m = measureCharPrepared(
                    cm,
                    preparedMeasure,
                    ch,
                    right ? "right" : "left",
                    varHeight
                  );
                  return (
                    right ? (m.left = m.right) : (m.right = m.left),
                    intoCoordSystem(cm, lineObj, m, context)
                  );
                }
                (lineObj = lineObj || getLine(cm.doc, pos.line)),
                  preparedMeasure ||
                    (preparedMeasure = prepareMeasureForLine(cm, lineObj));
                var order = getOrder(lineObj, cm.doc.direction),
                  ch = pos.ch,
                  sticky = pos.sticky;
                if (
                  (ch >= lineObj.text.length
                    ? ((ch = lineObj.text.length), (sticky = "before"))
                    : ch <= 0 && ((ch = 0), (sticky = "after")),
                  !order)
                )
                  return get(
                    "before" == sticky ? ch - 1 : ch,
                    "before" == sticky
                  );
                function getBidi(ch, partPos, invert) {
                  return get(
                    invert ? ch - 1 : ch,
                    (1 == order[partPos].level) != invert
                  );
                }
                var partPos = getBidiPartAt(order, ch, sticky),
                  other = bidiOther,
                  val = getBidi(ch, partPos, "before" == sticky);
                return (
                  null != other &&
                    (val.other = getBidi(ch, other, "before" != sticky)),
                  val
                );
              }
              function estimateCoords(cm, pos) {
                var left = 0;
                (pos = clipPos(cm.doc, pos)),
                  cm.options.lineWrapping ||
                    (left = charWidth(cm.display) * pos.ch);
                var lineObj = getLine(cm.doc, pos.line),
                  top = heightAtLine(lineObj) + paddingTop(cm.display);
                return {
                  left: left,
                  right: left,
                  top: top,
                  bottom: top + lineObj.height
                };
              }
              function PosWithInfo(line, ch, sticky, outside, xRel) {
                var pos = Pos(line, ch, sticky);
                return (pos.xRel = xRel), outside && (pos.outside = !0), pos;
              }
              function coordsChar(cm, x, y) {
                var doc = cm.doc;
                if ((y += cm.display.viewOffset) < 0)
                  return PosWithInfo(doc.first, 0, null, !0, -1);
                var lineN = lineAtHeight(doc, y),
                  last = doc.first + doc.size - 1;
                if (last < lineN)
                  return PosWithInfo(
                    doc.first + doc.size - 1,
                    getLine(doc, last).text.length,
                    null,
                    !0,
                    1
                  );
                x < 0 && (x = 0);
                for (var lineObj = getLine(doc, lineN); ; ) {
                  var found = coordsCharInner(cm, lineObj, lineN, x, y),
                    merged = collapsedSpanAtEnd(lineObj),
                    mergedPos = merged && merged.find(0, !0);
                  if (
                    !merged ||
                    !(
                      found.ch > mergedPos.from.ch ||
                      (found.ch == mergedPos.from.ch && 0 < found.xRel)
                    )
                  )
                    return found;
                  lineN = lineNo((lineObj = mergedPos.to.line));
                }
              }
              function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
                y -= widgetTopHeight(lineObj);
                var end = lineObj.text.length,
                  begin = findFirst(
                    function(ch) {
                      return (
                        measureCharPrepared(cm, preparedMeasure, ch - 1)
                          .bottom <= y
                      );
                    },
                    end,
                    0
                  );
                return {
                  begin: begin,
                  end: (end = findFirst(
                    function(ch) {
                      return (
                        measureCharPrepared(cm, preparedMeasure, ch).top > y
                      );
                    },
                    begin,
                    end
                  ))
                };
              }
              function wrappedLineExtentChar(
                cm,
                lineObj,
                preparedMeasure,
                target
              ) {
                return (
                  preparedMeasure ||
                    (preparedMeasure = prepareMeasureForLine(cm, lineObj)),
                  wrappedLineExtent(
                    cm,
                    lineObj,
                    preparedMeasure,
                    intoCoordSystem(
                      cm,
                      lineObj,
                      measureCharPrepared(cm, preparedMeasure, target),
                      "line"
                    ).top
                  )
                );
              }
              function boxIsAfter(box, x, y, left) {
                return (
                  !(box.bottom <= y) &&
                  (box.top > y || (left ? box.left : box.right) > x)
                );
              }
              function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
                y -= heightAtLine(lineObj);
                var preparedMeasure = prepareMeasureForLine(cm, lineObj),
                  widgetHeight$$1 = widgetTopHeight(lineObj),
                  begin = 0,
                  end = lineObj.text.length,
                  ltr = !0,
                  order = getOrder(lineObj, cm.doc.direction);
                if (order) {
                  var part = (cm.options.lineWrapping
                    ? function(
                        cm,
                        lineObj,
                        _lineNo,
                        preparedMeasure,
                        order,
                        x,
                        y
                      ) {
                        var ref = wrappedLineExtent(
                            cm,
                            lineObj,
                            preparedMeasure,
                            y
                          ),
                          begin = ref.begin,
                          end = ref.end;
                        /\s/.test(lineObj.text.charAt(end - 1)) && end--;
                        for (
                          var part = null, closestDist = null, i = 0;
                          i < order.length;
                          i++
                        ) {
                          var p = order[i];
                          if (!(p.from >= end || p.to <= begin)) {
                            var ltr = 1 != p.level,
                              endX = measureCharPrepared(
                                cm,
                                preparedMeasure,
                                ltr
                                  ? Math.min(end, p.to) - 1
                                  : Math.max(begin, p.from)
                              ).right,
                              dist = endX < x ? x - endX + 1e9 : endX - x;
                            (!part || dist < closestDist) &&
                              ((part = p), (closestDist = dist));
                          }
                        }
                        part || (part = order[order.length - 1]);
                        part.from < begin &&
                          (part = {
                            from: begin,
                            to: part.to,
                            level: part.level
                          });
                        part.to > end &&
                          (part = {
                            from: part.from,
                            to: end,
                            level: part.level
                          });
                        return part;
                      }
                    : function(
                        cm,
                        lineObj,
                        lineNo$$1,
                        preparedMeasure,
                        order,
                        x,
                        y
                      ) {
                        var index = findFirst(
                            function(i) {
                              var part = order[i],
                                ltr = 1 != part.level;
                              return boxIsAfter(
                                cursorCoords(
                                  cm,
                                  Pos(
                                    lineNo$$1,
                                    ltr ? part.to : part.from,
                                    ltr ? "before" : "after"
                                  ),
                                  "line",
                                  lineObj,
                                  preparedMeasure
                                ),
                                x,
                                y,
                                !0
                              );
                            },
                            0,
                            order.length - 1
                          ),
                          part = order[index];
                        if (0 < index) {
                          var ltr = 1 != part.level,
                            start = cursorCoords(
                              cm,
                              Pos(
                                lineNo$$1,
                                ltr ? part.from : part.to,
                                ltr ? "after" : "before"
                              ),
                              "line",
                              lineObj,
                              preparedMeasure
                            );
                          boxIsAfter(start, x, y, !0) &&
                            start.top > y &&
                            (part = order[index - 1]);
                        }
                        return part;
                      })(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
                  (begin = (ltr = 1 != part.level) ? part.from : part.to - 1),
                    (end = ltr ? part.to : part.from - 1);
                }
                var baseX,
                  sticky,
                  chAround = null,
                  boxAround = null,
                  ch = findFirst(
                    function(ch) {
                      var box = measureCharPrepared(cm, preparedMeasure, ch);
                      return (
                        (box.top += widgetHeight$$1),
                        (box.bottom += widgetHeight$$1),
                        !!boxIsAfter(box, x, y, !1) &&
                          (box.top <= y &&
                            box.left <= x &&
                            ((chAround = ch), (boxAround = box)),
                          !0)
                      );
                    },
                    begin,
                    end
                  ),
                  outside = !1;
                if (boxAround) {
                  var atLeft = x - boxAround.left < boxAround.right - x,
                    atStart = atLeft == ltr;
                  (ch = chAround + (atStart ? 0 : 1)),
                    (sticky = atStart ? "after" : "before"),
                    (baseX = atLeft ? boxAround.left : boxAround.right);
                } else {
                  ltr || (ch != end && ch != begin) || ch++,
                    (sticky =
                      0 == ch
                        ? "after"
                        : ch == lineObj.text.length
                          ? "before"
                          : measureCharPrepared(
                              cm,
                              preparedMeasure,
                              ch - (ltr ? 1 : 0)
                            ).bottom +
                              widgetHeight$$1 <=
                              y ==
                            ltr
                            ? "after"
                            : "before");
                  var coords = cursorCoords(
                    cm,
                    Pos(lineNo$$1, ch, sticky),
                    "line",
                    lineObj,
                    preparedMeasure
                  );
                  (baseX = coords.left),
                    (outside = y < coords.top || y >= coords.bottom);
                }
                return PosWithInfo(
                  lineNo$$1,
                  (ch = skipExtendingChars(lineObj.text, ch, 1)),
                  sticky,
                  outside,
                  x - baseX
                );
              }
              function textHeight(display) {
                if (null != display.cachedTextHeight)
                  return display.cachedTextHeight;
                if (null == measureText) {
                  measureText = elt("pre");
                  for (var i = 0; i < 49; ++i)
                    measureText.appendChild(document.createTextNode("x")),
                      measureText.appendChild(elt("br"));
                  measureText.appendChild(document.createTextNode("x"));
                }
                removeChildrenAndAdd(display.measure, measureText);
                var height = measureText.offsetHeight / 50;
                return (
                  3 < height && (display.cachedTextHeight = height),
                  removeChildren(display.measure),
                  height || 1
                );
              }
              function charWidth(display) {
                if (null != display.cachedCharWidth)
                  return display.cachedCharWidth;
                var anchor = elt("span", "xxxxxxxxxx"),
                  pre = elt("pre", [anchor]);
                removeChildrenAndAdd(display.measure, pre);
                var rect = anchor.getBoundingClientRect(),
                  width = (rect.right - rect.left) / 10;
                return (
                  2 < width && (display.cachedCharWidth = width), width || 10
                );
              }
              function getDimensions(cm) {
                for (
                  var d = cm.display,
                    left = {},
                    width = {},
                    gutterLeft = d.gutters.clientLeft,
                    n = d.gutters.firstChild,
                    i = 0;
                  n;
                  n = n.nextSibling, ++i
                )
                  (left[cm.options.gutters[i]] =
                    n.offsetLeft + n.clientLeft + gutterLeft),
                    (width[cm.options.gutters[i]] = n.clientWidth);
                return {
                  fixedPos: compensateForHScroll(d),
                  gutterTotalWidth: d.gutters.offsetWidth,
                  gutterLeft: left,
                  gutterWidth: width,
                  wrapperWidth: d.wrapper.clientWidth
                };
              }
              function compensateForHScroll(display) {
                return (
                  display.scroller.getBoundingClientRect().left -
                  display.sizer.getBoundingClientRect().left
                );
              }
              function estimateHeight(cm) {
                var th = textHeight(cm.display),
                  wrapping = cm.options.lineWrapping,
                  perLine =
                    wrapping &&
                    Math.max(
                      5,
                      cm.display.scroller.clientWidth / charWidth(cm.display) -
                        3
                    );
                return function(line) {
                  if (lineIsHidden(cm.doc, line)) return 0;
                  var widgetsHeight = 0;
                  if (line.widgets)
                    for (var i = 0; i < line.widgets.length; i++)
                      line.widgets[i].height &&
                        (widgetsHeight += line.widgets[i].height);
                  return wrapping
                    ? widgetsHeight +
                        (Math.ceil(line.text.length / perLine) || 1) * th
                    : widgetsHeight + th;
                };
              }
              function estimateLineHeights(cm) {
                var doc = cm.doc,
                  est = estimateHeight(cm);
                doc.iter(function(line) {
                  var estHeight = est(line);
                  estHeight != line.height && updateLineHeight(line, estHeight);
                });
              }
              function posFromMouse(cm, e, liberal, forRect) {
                var display = cm.display;
                if (
                  !liberal &&
                  "true" == e_target(e).getAttribute("cm-not-content")
                )
                  return null;
                var x,
                  y,
                  space = display.lineSpace.getBoundingClientRect();
                try {
                  (x = e.clientX - space.left), (y = e.clientY - space.top);
                } catch (e) {
                  return null;
                }
                var line,
                  coords = coordsChar(cm, x, y);
                if (
                  forRect &&
                  1 == coords.xRel &&
                  (line = getLine(cm.doc, coords.line).text).length == coords.ch
                ) {
                  var colDiff =
                    countColumn(line, line.length, cm.options.tabSize) -
                    line.length;
                  coords = Pos(
                    coords.line,
                    Math.max(
                      0,
                      Math.round(
                        (x - paddingH(cm.display).left) / charWidth(cm.display)
                      ) - colDiff
                    )
                  );
                }
                return coords;
              }
              function findViewIndex(cm, n) {
                if (n >= cm.display.viewTo) return null;
                if ((n -= cm.display.viewFrom) < 0) return null;
                for (var view = cm.display.view, i = 0; i < view.length; i++)
                  if ((n -= view[i].size) < 0) return i;
              }
              function updateSelection(cm) {
                cm.display.input.showSelection(
                  cm.display.input.prepareSelection()
                );
              }
              function prepareSelection(cm, primary) {
                void 0 === primary && (primary = !0);
                for (
                  var doc = cm.doc,
                    result = {},
                    curFragment = (result.cursors = document.createDocumentFragment()),
                    selFragment = (result.selection = document.createDocumentFragment()),
                    i = 0;
                  i < doc.sel.ranges.length;
                  i++
                )
                  if (primary || i != doc.sel.primIndex) {
                    var range$$1 = doc.sel.ranges[i];
                    if (
                      !(
                        range$$1.from().line >= cm.display.viewTo ||
                        range$$1.to().line < cm.display.viewFrom
                      )
                    ) {
                      var collapsed = range$$1.empty();
                      (collapsed || cm.options.showCursorWhenSelecting) &&
                        drawSelectionCursor(cm, range$$1.head, curFragment),
                        collapsed ||
                          drawSelectionRange(cm, range$$1, selFragment);
                    }
                  }
                return result;
              }
              function drawSelectionCursor(cm, head, output) {
                var pos = cursorCoords(
                    cm,
                    head,
                    "div",
                    null,
                    null,
                    !cm.options.singleCursorHeightPerLine
                  ),
                  cursor = output.appendChild(
                    elt("div", " ", "CodeMirror-cursor")
                  );
                if (
                  ((cursor.style.left = pos.left + "px"),
                  (cursor.style.top = pos.top + "px"),
                  (cursor.style.height =
                    Math.max(0, pos.bottom - pos.top) *
                      cm.options.cursorHeight +
                    "px"),
                  pos.other)
                ) {
                  var otherCursor = output.appendChild(
                    elt(
                      "div",
                      " ",
                      "CodeMirror-cursor CodeMirror-secondarycursor"
                    )
                  );
                  (otherCursor.style.display = ""),
                    (otherCursor.style.left = pos.other.left + "px"),
                    (otherCursor.style.top = pos.other.top + "px"),
                    (otherCursor.style.height =
                      0.85 * (pos.other.bottom - pos.other.top) + "px");
                }
              }
              function cmpCoords(a, b) {
                return a.top - b.top || a.left - b.left;
              }
              function drawSelectionRange(cm, range$$1, output) {
                var display = cm.display,
                  doc = cm.doc,
                  fragment = document.createDocumentFragment(),
                  padding = paddingH(cm.display),
                  leftSide = padding.left,
                  rightSide =
                    Math.max(
                      display.sizerWidth,
                      displayWidth(cm) - display.sizer.offsetLeft
                    ) - padding.right,
                  docLTR = "ltr" == doc.direction;
                function add(left, top, width, bottom) {
                  top < 0 && (top = 0),
                    (top = Math.round(top)),
                    (bottom = Math.round(bottom)),
                    fragment.appendChild(
                      elt(
                        "div",
                        null,
                        "CodeMirror-selected",
                        "position: absolute; left: " +
                          left +
                          "px;\n                             top: " +
                          top +
                          "px; width: " +
                          (null == width ? rightSide - left : width) +
                          "px;\n                             height: " +
                          (bottom - top) +
                          "px"
                      )
                    );
                }
                function drawForLine(line, fromArg, toArg) {
                  var start,
                    end,
                    lineObj = getLine(doc, line),
                    lineLen = lineObj.text.length;
                  function coords(ch, bias) {
                    return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
                  }
                  function wrapX(pos, dir, side) {
                    var extent = wrappedLineExtentChar(cm, lineObj, null, pos),
                      prop =
                        ("ltr" == dir) == ("after" == side) ? "left" : "right";
                    return coords(
                      "after" == side
                        ? extent.begin
                        : extent.end -
                          (/\s/.test(lineObj.text.charAt(extent.end - 1))
                            ? 2
                            : 1),
                      prop
                    )[prop];
                  }
                  var order = getOrder(lineObj, doc.direction);
                  return (
                    (function(order, from, to, f) {
                      if (!order) return f(from, to, "ltr", 0);
                      for (var found = !1, i = 0; i < order.length; ++i) {
                        var part = order[i];
                        ((part.from < to && part.to > from) ||
                          (from == to && part.to == from)) &&
                          (f(
                            Math.max(part.from, from),
                            Math.min(part.to, to),
                            1 == part.level ? "rtl" : "ltr",
                            i
                          ),
                          (found = !0));
                      }
                      found || f(from, to, "ltr");
                    })(
                      order,
                      fromArg || 0,
                      null == toArg ? lineLen : toArg,
                      function(from, to, dir, i) {
                        var ltr = "ltr" == dir,
                          fromPos = coords(from, ltr ? "left" : "right"),
                          toPos = coords(to - 1, ltr ? "right" : "left"),
                          openStart = null == fromArg && 0 == from,
                          openEnd = null == toArg && to == lineLen,
                          first = 0 == i,
                          last = !order || i == order.length - 1;
                        if (toPos.top - fromPos.top <= 3) {
                          var openRight =
                              (docLTR ? openEnd : openStart) && last,
                            left =
                              (docLTR ? openStart : openEnd) && first
                                ? leftSide
                                : (ltr ? fromPos : toPos).left,
                            right = openRight
                              ? rightSide
                              : (ltr ? toPos : fromPos).right;
                          add(left, fromPos.top, right - left, fromPos.bottom);
                        } else {
                          var topLeft, topRight, botLeft, botRight;
                          ltr
                            ? ((topLeft =
                                docLTR && openStart && first
                                  ? leftSide
                                  : fromPos.left),
                              (topRight = docLTR
                                ? rightSide
                                : wrapX(from, dir, "before")),
                              (botLeft = docLTR
                                ? leftSide
                                : wrapX(to, dir, "after")),
                              (botRight =
                                docLTR && openEnd && last
                                  ? rightSide
                                  : toPos.right))
                            : ((topLeft = docLTR
                                ? wrapX(from, dir, "before")
                                : leftSide),
                              (topRight =
                                !docLTR && openStart && first
                                  ? rightSide
                                  : fromPos.right),
                              (botLeft =
                                !docLTR && openEnd && last
                                  ? leftSide
                                  : toPos.left),
                              (botRight = docLTR
                                ? wrapX(to, dir, "after")
                                : rightSide)),
                            add(
                              topLeft,
                              fromPos.top,
                              topRight - topLeft,
                              fromPos.bottom
                            ),
                            fromPos.bottom < toPos.top &&
                              add(leftSide, fromPos.bottom, null, toPos.top),
                            add(
                              botLeft,
                              toPos.top,
                              botRight - botLeft,
                              toPos.bottom
                            );
                        }
                        (!start || cmpCoords(fromPos, start) < 0) &&
                          (start = fromPos),
                          cmpCoords(toPos, start) < 0 && (start = toPos),
                          (!end || cmpCoords(fromPos, end) < 0) &&
                            (end = fromPos),
                          cmpCoords(toPos, end) < 0 && (end = toPos);
                      }
                    ),
                    { start: start, end: end }
                  );
                }
                var sFrom = range$$1.from(),
                  sTo = range$$1.to();
                if (sFrom.line == sTo.line)
                  drawForLine(sFrom.line, sFrom.ch, sTo.ch);
                else {
                  var fromLine = getLine(doc, sFrom.line),
                    toLine = getLine(doc, sTo.line),
                    singleVLine = visualLine(fromLine) == visualLine(toLine),
                    leftEnd = drawForLine(
                      sFrom.line,
                      sFrom.ch,
                      singleVLine ? fromLine.text.length + 1 : null
                    ).end,
                    rightStart = drawForLine(
                      sTo.line,
                      singleVLine ? 0 : null,
                      sTo.ch
                    ).start;
                  singleVLine &&
                    (leftEnd.top < rightStart.top - 2
                      ? (add(leftEnd.right, leftEnd.top, null, leftEnd.bottom),
                        add(
                          leftSide,
                          rightStart.top,
                          rightStart.left,
                          rightStart.bottom
                        ))
                      : add(
                          leftEnd.right,
                          leftEnd.top,
                          rightStart.left - leftEnd.right,
                          leftEnd.bottom
                        )),
                    leftEnd.bottom < rightStart.top &&
                      add(leftSide, leftEnd.bottom, null, rightStart.top);
                }
                output.appendChild(fragment);
              }
              function restartBlink(cm) {
                if (cm.state.focused) {
                  var display = cm.display;
                  clearInterval(display.blinker);
                  var on = !0;
                  (display.cursorDiv.style.visibility = ""),
                    0 < cm.options.cursorBlinkRate
                      ? (display.blinker = setInterval(function() {
                          return (display.cursorDiv.style.visibility = (on = !on)
                            ? ""
                            : "hidden");
                        }, cm.options.cursorBlinkRate))
                      : cm.options.cursorBlinkRate < 0 &&
                        (display.cursorDiv.style.visibility = "hidden");
                }
              }
              function ensureFocus(cm) {
                cm.state.focused || (cm.display.input.focus(), onFocus(cm));
              }
              function delayBlurEvent(cm) {
                (cm.state.delayingBlurEvent = !0),
                  setTimeout(function() {
                    cm.state.delayingBlurEvent &&
                      ((cm.state.delayingBlurEvent = !1), onBlur(cm));
                  }, 100);
              }
              function onFocus(cm, e) {
                cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1),
                  "nocursor" != cm.options.readOnly &&
                    (cm.state.focused ||
                      (signal(cm, "focus", cm, e),
                      (cm.state.focused = !0),
                      addClass(cm.display.wrapper, "CodeMirror-focused"),
                      cm.curOp ||
                        cm.display.selForContextMenu == cm.doc.sel ||
                        (cm.display.input.reset(),
                        webkit &&
                          setTimeout(function() {
                            return cm.display.input.reset(!0);
                          }, 20)),
                      cm.display.input.receivedFocus()),
                    restartBlink(cm));
              }
              function onBlur(cm, e) {
                cm.state.delayingBlurEvent ||
                  (cm.state.focused &&
                    (signal(cm, "blur", cm, e),
                    (cm.state.focused = !1),
                    rmClass(cm.display.wrapper, "CodeMirror-focused")),
                  clearInterval(cm.display.blinker),
                  setTimeout(function() {
                    cm.state.focused || (cm.display.shift = !1);
                  }, 150));
              }
              function updateHeightsInViewport(cm) {
                for (
                  var display = cm.display,
                    prevBottom = display.lineDiv.offsetTop,
                    i = 0;
                  i < display.view.length;
                  i++
                ) {
                  var cur = display.view[i],
                    height = void 0;
                  if (!cur.hidden) {
                    if (ie && ie_version < 8) {
                      var bot = cur.node.offsetTop + cur.node.offsetHeight;
                      (height = bot - prevBottom), (prevBottom = bot);
                    } else {
                      var box = cur.node.getBoundingClientRect();
                      height = box.bottom - box.top;
                    }
                    var diff = cur.line.height - height;
                    if (
                      (height < 2 && (height = textHeight(display)),
                      (0.005 < diff || diff < -0.005) &&
                        (updateLineHeight(cur.line, height),
                        updateWidgetHeight(cur.line),
                        cur.rest))
                    )
                      for (var j = 0; j < cur.rest.length; j++)
                        updateWidgetHeight(cur.rest[j]);
                  }
                }
              }
              function updateWidgetHeight(line) {
                if (line.widgets)
                  for (var i = 0; i < line.widgets.length; ++i) {
                    var w = line.widgets[i],
                      parent = w.node.parentNode;
                    parent && (w.height = parent.offsetHeight);
                  }
              }
              function visibleLines(display, doc, viewport) {
                var top =
                  viewport && null != viewport.top
                    ? Math.max(0, viewport.top)
                    : display.scroller.scrollTop;
                top = Math.floor(top - paddingTop(display));
                var bottom =
                    viewport && null != viewport.bottom
                      ? viewport.bottom
                      : top + display.wrapper.clientHeight,
                  from = lineAtHeight(doc, top),
                  to = lineAtHeight(doc, bottom);
                if (viewport && viewport.ensure) {
                  var ensureFrom = viewport.ensure.from.line,
                    ensureTo = viewport.ensure.to.line;
                  ensureFrom < from
                    ? (to = lineAtHeight(
                        doc,
                        heightAtLine(getLine(doc, (from = ensureFrom))) +
                          display.wrapper.clientHeight
                      ))
                    : Math.min(ensureTo, doc.lastLine()) >= to &&
                      ((from = lineAtHeight(
                        doc,
                        heightAtLine(getLine(doc, ensureTo)) -
                          display.wrapper.clientHeight
                      )),
                      (to = ensureTo));
                }
                return { from: from, to: Math.max(to, from + 1) };
              }
              function alignHorizontally(cm) {
                var display = cm.display,
                  view = display.view;
                if (
                  display.alignWidgets ||
                  (display.gutters.firstChild && cm.options.fixedGutter)
                ) {
                  for (
                    var comp =
                        compensateForHScroll(display) -
                        display.scroller.scrollLeft +
                        cm.doc.scrollLeft,
                      gutterW = display.gutters.offsetWidth,
                      left = comp + "px",
                      i = 0;
                    i < view.length;
                    i++
                  )
                    if (!view[i].hidden) {
                      cm.options.fixedGutter &&
                        (view[i].gutter && (view[i].gutter.style.left = left),
                        view[i].gutterBackground &&
                          (view[i].gutterBackground.style.left = left));
                      var align = view[i].alignable;
                      if (align)
                        for (var j = 0; j < align.length; j++)
                          align[j].style.left = left;
                    }
                  cm.options.fixedGutter &&
                    (display.gutters.style.left = comp + gutterW + "px");
                }
              }
              function maybeUpdateLineNumberWidth(cm) {
                if (!cm.options.lineNumbers) return !1;
                var doc = cm.doc,
                  last = lineNumberFor(cm.options, doc.first + doc.size - 1),
                  display = cm.display;
                if (last.length != display.lineNumChars) {
                  var test = display.measure.appendChild(
                      elt(
                        "div",
                        [elt("div", last)],
                        "CodeMirror-linenumber CodeMirror-gutter-elt"
                      )
                    ),
                    innerW = test.firstChild.offsetWidth,
                    padding = test.offsetWidth - innerW;
                  return (
                    (display.lineGutter.style.width = ""),
                    (display.lineNumInnerWidth =
                      Math.max(
                        innerW,
                        display.lineGutter.offsetWidth - padding
                      ) + 1),
                    (display.lineNumWidth =
                      display.lineNumInnerWidth + padding),
                    (display.lineNumChars = display.lineNumInnerWidth
                      ? last.length
                      : -1),
                    (display.lineGutter.style.width =
                      display.lineNumWidth + "px"),
                    updateGutterSpace(cm),
                    !0
                  );
                }
                return !1;
              }
              function calculateScrollPos(cm, rect) {
                var display = cm.display,
                  snapMargin = textHeight(cm.display);
                rect.top < 0 && (rect.top = 0);
                var screentop =
                    cm.curOp && null != cm.curOp.scrollTop
                      ? cm.curOp.scrollTop
                      : display.scroller.scrollTop,
                  screen = displayHeight(cm),
                  result = {};
                rect.bottom - rect.top > screen &&
                  (rect.bottom = rect.top + screen);
                var docBottom = cm.doc.height + paddingVert(display),
                  atTop = rect.top < snapMargin,
                  atBottom = rect.bottom > docBottom - snapMargin;
                if (rect.top < screentop)
                  result.scrollTop = atTop ? 0 : rect.top;
                else if (rect.bottom > screentop + screen) {
                  var newTop = Math.min(
                    rect.top,
                    (atBottom ? docBottom : rect.bottom) - screen
                  );
                  newTop != screentop && (result.scrollTop = newTop);
                }
                var screenleft =
                    cm.curOp && null != cm.curOp.scrollLeft
                      ? cm.curOp.scrollLeft
                      : display.scroller.scrollLeft,
                  screenw =
                    displayWidth(cm) -
                    (cm.options.fixedGutter ? display.gutters.offsetWidth : 0),
                  tooWide = rect.right - rect.left > screenw;
                return (
                  tooWide && (rect.right = rect.left + screenw),
                  rect.left < 10
                    ? (result.scrollLeft = 0)
                    : rect.left < screenleft
                      ? (result.scrollLeft = Math.max(
                          0,
                          rect.left - (tooWide ? 0 : 10)
                        ))
                      : rect.right > screenw + screenleft - 3 &&
                        (result.scrollLeft =
                          rect.right + (tooWide ? 0 : 10) - screenw),
                  result
                );
              }
              function addToScrollTop(cm, top) {
                null != top &&
                  (resolveScrollToPos(cm),
                  (cm.curOp.scrollTop =
                    (null == cm.curOp.scrollTop
                      ? cm.doc.scrollTop
                      : cm.curOp.scrollTop) + top));
              }
              function ensureCursorVisible(cm) {
                resolveScrollToPos(cm);
                var cur = cm.getCursor();
                cm.curOp.scrollToPos = {
                  from: cur,
                  to: cur,
                  margin: cm.options.cursorScrollMargin
                };
              }
              function scrollToCoords(cm, x, y) {
                (null == x && null == y) || resolveScrollToPos(cm),
                  null != x && (cm.curOp.scrollLeft = x),
                  null != y && (cm.curOp.scrollTop = y);
              }
              function resolveScrollToPos(cm) {
                var range$$1 = cm.curOp.scrollToPos;
                range$$1 &&
                  ((cm.curOp.scrollToPos = null),
                  scrollToCoordsRange(
                    cm,
                    estimateCoords(cm, range$$1.from),
                    estimateCoords(cm, range$$1.to),
                    range$$1.margin
                  ));
              }
              function scrollToCoordsRange(cm, from, to, margin) {
                var sPos = calculateScrollPos(cm, {
                  left: Math.min(from.left, to.left),
                  top: Math.min(from.top, to.top) - margin,
                  right: Math.max(from.right, to.right),
                  bottom: Math.max(from.bottom, to.bottom) + margin
                });
                scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
              }
              function updateScrollTop(cm, val) {
                Math.abs(cm.doc.scrollTop - val) < 2 ||
                  (gecko || updateDisplaySimple(cm, { top: val }),
                  setScrollTop(cm, val, !0),
                  gecko && updateDisplaySimple(cm),
                  startWorker(cm, 100));
              }
              function setScrollTop(cm, val, forceScroll) {
                (val = Math.min(
                  cm.display.scroller.scrollHeight -
                    cm.display.scroller.clientHeight,
                  val
                )),
                  (cm.display.scroller.scrollTop != val || forceScroll) &&
                    ((cm.doc.scrollTop = val),
                    cm.display.scrollbars.setScrollTop(val),
                    cm.display.scroller.scrollTop != val &&
                      (cm.display.scroller.scrollTop = val));
              }
              function setScrollLeft(cm, val, isScroller, forceScroll) {
                (val = Math.min(
                  val,
                  cm.display.scroller.scrollWidth -
                    cm.display.scroller.clientWidth
                )),
                  ((isScroller
                    ? val == cm.doc.scrollLeft
                    : Math.abs(cm.doc.scrollLeft - val) < 2) &&
                    !forceScroll) ||
                    ((cm.doc.scrollLeft = val),
                    alignHorizontally(cm),
                    cm.display.scroller.scrollLeft != val &&
                      (cm.display.scroller.scrollLeft = val),
                    cm.display.scrollbars.setScrollLeft(val));
              }
              function measureForScrollbars(cm) {
                var d = cm.display,
                  gutterW = d.gutters.offsetWidth,
                  docH = Math.round(cm.doc.height + paddingVert(cm.display));
                return {
                  clientHeight: d.scroller.clientHeight,
                  viewHeight: d.wrapper.clientHeight,
                  scrollWidth: d.scroller.scrollWidth,
                  clientWidth: d.scroller.clientWidth,
                  viewWidth: d.wrapper.clientWidth,
                  barLeft: cm.options.fixedGutter ? gutterW : 0,
                  docHeight: docH,
                  scrollHeight: docH + scrollGap(cm) + d.barHeight,
                  nativeBarWidth: d.nativeBarWidth,
                  gutterWidth: gutterW
                };
              }
              var NativeScrollbars = function(place, scroll, cm) {
                this.cm = cm;
                var vert = (this.vert = elt(
                    "div",
                    [elt("div", null, null, "min-width: 1px")],
                    "CodeMirror-vscrollbar"
                  )),
                  horiz = (this.horiz = elt(
                    "div",
                    [elt("div", null, null, "height: 100%; min-height: 1px")],
                    "CodeMirror-hscrollbar"
                  ));
                place(vert),
                  place(horiz),
                  on(vert, "scroll", function() {
                    vert.clientHeight && scroll(vert.scrollTop, "vertical");
                  }),
                  on(horiz, "scroll", function() {
                    horiz.clientWidth && scroll(horiz.scrollLeft, "horizontal");
                  }),
                  (this.checkedZeroWidth = !1),
                  ie &&
                    ie_version < 8 &&
                    (this.horiz.style.minHeight = this.vert.style.minWidth =
                      "18px");
              };
              (NativeScrollbars.prototype.update = function(measure) {
                var needsH = measure.scrollWidth > measure.clientWidth + 1,
                  needsV = measure.scrollHeight > measure.clientHeight + 1,
                  sWidth = measure.nativeBarWidth;
                if (needsV) {
                  (this.vert.style.display = "block"),
                    (this.vert.style.bottom = needsH ? sWidth + "px" : "0");
                  var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
                  this.vert.firstChild.style.height =
                    Math.max(
                      0,
                      measure.scrollHeight - measure.clientHeight + totalHeight
                    ) + "px";
                } else
                  (this.vert.style.display = ""),
                    (this.vert.firstChild.style.height = "0");
                if (needsH) {
                  (this.horiz.style.display = "block"),
                    (this.horiz.style.right = needsV ? sWidth + "px" : "0"),
                    (this.horiz.style.left = measure.barLeft + "px");
                  var totalWidth =
                    measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
                  this.horiz.firstChild.style.width =
                    Math.max(
                      0,
                      measure.scrollWidth - measure.clientWidth + totalWidth
                    ) + "px";
                } else
                  (this.horiz.style.display = ""),
                    (this.horiz.firstChild.style.width = "0");
                return (
                  !this.checkedZeroWidth &&
                    0 < measure.clientHeight &&
                    (0 == sWidth && this.zeroWidthHack(),
                    (this.checkedZeroWidth = !0)),
                  { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 }
                );
              }),
                (NativeScrollbars.prototype.setScrollLeft = function(pos) {
                  this.horiz.scrollLeft != pos && (this.horiz.scrollLeft = pos),
                    this.disableHoriz &&
                      this.enableZeroWidthBar(
                        this.horiz,
                        this.disableHoriz,
                        "horiz"
                      );
                }),
                (NativeScrollbars.prototype.setScrollTop = function(pos) {
                  this.vert.scrollTop != pos && (this.vert.scrollTop = pos),
                    this.disableVert &&
                      this.enableZeroWidthBar(
                        this.vert,
                        this.disableVert,
                        "vert"
                      );
                }),
                (NativeScrollbars.prototype.zeroWidthHack = function() {
                  var w = mac && !mac_geMountainLion ? "12px" : "18px";
                  (this.horiz.style.height = this.vert.style.width = w),
                    (this.horiz.style.pointerEvents = this.vert.style.pointerEvents =
                      "none"),
                    (this.disableHoriz = new Delayed()),
                    (this.disableVert = new Delayed());
                }),
                (NativeScrollbars.prototype.enableZeroWidthBar = function(
                  bar,
                  delay,
                  type
                ) {
                  (bar.style.pointerEvents = "auto"),
                    delay.set(1e3, function maybeDisable() {
                      var box = bar.getBoundingClientRect();
                      ("vert" == type
                        ? document.elementFromPoint(
                            box.right - 1,
                            (box.top + box.bottom) / 2
                          )
                        : document.elementFromPoint(
                            (box.right + box.left) / 2,
                            box.bottom - 1
                          )) != bar
                        ? (bar.style.pointerEvents = "none")
                        : delay.set(1e3, maybeDisable);
                    });
                }),
                (NativeScrollbars.prototype.clear = function() {
                  var parent = this.horiz.parentNode;
                  parent.removeChild(this.horiz), parent.removeChild(this.vert);
                });
              var NullScrollbars = function() {};
              function updateScrollbars(cm, measure) {
                measure || (measure = measureForScrollbars(cm));
                var startWidth = cm.display.barWidth,
                  startHeight = cm.display.barHeight;
                updateScrollbarsInner(cm, measure);
                for (
                  var i = 0;
                  (i < 4 && startWidth != cm.display.barWidth) ||
                  startHeight != cm.display.barHeight;
                  i++
                )
                  startWidth != cm.display.barWidth &&
                    cm.options.lineWrapping &&
                    updateHeightsInViewport(cm),
                    updateScrollbarsInner(cm, measureForScrollbars(cm)),
                    (startWidth = cm.display.barWidth),
                    (startHeight = cm.display.barHeight);
              }
              function updateScrollbarsInner(cm, measure) {
                var d = cm.display,
                  sizes = d.scrollbars.update(measure);
                (d.sizer.style.paddingRight =
                  (d.barWidth = sizes.right) + "px"),
                  (d.sizer.style.paddingBottom =
                    (d.barHeight = sizes.bottom) + "px"),
                  (d.heightForcer.style.borderBottom =
                    sizes.bottom + "px solid transparent"),
                  sizes.right && sizes.bottom
                    ? ((d.scrollbarFiller.style.display = "block"),
                      (d.scrollbarFiller.style.height = sizes.bottom + "px"),
                      (d.scrollbarFiller.style.width = sizes.right + "px"))
                    : (d.scrollbarFiller.style.display = ""),
                  sizes.bottom &&
                  cm.options.coverGutterNextToScrollbar &&
                  cm.options.fixedGutter
                    ? ((d.gutterFiller.style.display = "block"),
                      (d.gutterFiller.style.height = sizes.bottom + "px"),
                      (d.gutterFiller.style.width = measure.gutterWidth + "px"))
                    : (d.gutterFiller.style.display = "");
              }
              (NullScrollbars.prototype.update = function() {
                return { bottom: 0, right: 0 };
              }),
                (NullScrollbars.prototype.setScrollLeft = function() {}),
                (NullScrollbars.prototype.setScrollTop = function() {}),
                (NullScrollbars.prototype.clear = function() {});
              var scrollbarModel = {
                native: NativeScrollbars,
                null: NullScrollbars
              };
              function initScrollbars(cm) {
                cm.display.scrollbars &&
                  (cm.display.scrollbars.clear(),
                  cm.display.scrollbars.addClass &&
                    rmClass(
                      cm.display.wrapper,
                      cm.display.scrollbars.addClass
                    )),
                  (cm.display.scrollbars = new scrollbarModel[
                    cm.options.scrollbarStyle
                  ](
                    function(node) {
                      cm.display.wrapper.insertBefore(
                        node,
                        cm.display.scrollbarFiller
                      ),
                        on(node, "mousedown", function() {
                          cm.state.focused &&
                            setTimeout(function() {
                              return cm.display.input.focus();
                            }, 0);
                        }),
                        node.setAttribute("cm-not-content", "true");
                    },
                    function(pos, axis) {
                      "horizontal" == axis
                        ? setScrollLeft(cm, pos)
                        : updateScrollTop(cm, pos);
                    },
                    cm
                  )),
                  cm.display.scrollbars.addClass &&
                    addClass(
                      cm.display.wrapper,
                      cm.display.scrollbars.addClass
                    );
              }
              var nextOpId = 0;
              function startOperation(cm) {
                var op;
                (cm.curOp = {
                  cm: cm,
                  viewChanged: !1,
                  startHeight: cm.doc.height,
                  forceUpdate: !1,
                  updateInput: null,
                  typing: !1,
                  changeObjs: null,
                  cursorActivityHandlers: null,
                  cursorActivityCalled: 0,
                  selectionChanged: !1,
                  updateMaxLine: !1,
                  scrollLeft: null,
                  scrollTop: null,
                  scrollToPos: null,
                  focus: !1,
                  id: ++nextOpId
                }),
                  (op = cm.curOp),
                  operationGroup
                    ? operationGroup.ops.push(op)
                    : (op.ownsGroup = operationGroup = {
                        ops: [op],
                        delayedCallbacks: []
                      });
              }
              function endOperation(cm) {
                !(function(op, endCb) {
                  var group = op.ownsGroup;
                  if (group)
                    try {
                      !(function(group) {
                        var callbacks = group.delayedCallbacks,
                          i = 0;
                        do {
                          for (; i < callbacks.length; i++)
                            callbacks[i].call(null);
                          for (var j = 0; j < group.ops.length; j++) {
                            var op = group.ops[j];
                            if (op.cursorActivityHandlers)
                              for (
                                ;
                                op.cursorActivityCalled <
                                op.cursorActivityHandlers.length;

                              )
                                op.cursorActivityHandlers[
                                  op.cursorActivityCalled++
                                ].call(null, op.cm);
                          }
                        } while (i < callbacks.length);
                      })(group);
                    } finally {
                      (operationGroup = null), endCb(group);
                    }
                })(cm.curOp, function(group) {
                  for (var i = 0; i < group.ops.length; i++)
                    group.ops[i].cm.curOp = null;
                  !(function(group) {
                    for (var ops = group.ops, i = 0; i < ops.length; i++)
                      endOperation_R1(ops[i]);
                    for (var i$1 = 0; i$1 < ops.length; i$1++)
                      (op = ops[i$1]).updatedDisplay =
                        op.mustUpdate &&
                        updateDisplayIfNeeded(op.cm, op.update);
                    var op;
                    for (var i$2 = 0; i$2 < ops.length; i$2++)
                      endOperation_R2(ops[i$2]);
                    for (var i$3 = 0; i$3 < ops.length; i$3++)
                      endOperation_W2(ops[i$3]);
                    for (var i$4 = 0; i$4 < ops.length; i$4++)
                      endOperation_finish(ops[i$4]);
                  })(group);
                });
              }
              function endOperation_R1(op) {
                var cm = op.cm,
                  display = cm.display;
                !(function(cm) {
                  var display = cm.display;
                  !display.scrollbarsClipped &&
                    display.scroller.offsetWidth &&
                    ((display.nativeBarWidth =
                      display.scroller.offsetWidth -
                      display.scroller.clientWidth),
                    (display.heightForcer.style.height = scrollGap(cm) + "px"),
                    (display.sizer.style.marginBottom =
                      -display.nativeBarWidth + "px"),
                    (display.sizer.style.borderRightWidth =
                      scrollGap(cm) + "px"),
                    (display.scrollbarsClipped = !0));
                })(cm),
                  op.updateMaxLine && findMaxLine(cm),
                  (op.mustUpdate =
                    op.viewChanged ||
                    op.forceUpdate ||
                    null != op.scrollTop ||
                    (op.scrollToPos &&
                      (op.scrollToPos.from.line < display.viewFrom ||
                        op.scrollToPos.to.line >= display.viewTo)) ||
                    (display.maxLineChanged && cm.options.lineWrapping)),
                  (op.update =
                    op.mustUpdate &&
                    new DisplayUpdate(
                      cm,
                      op.mustUpdate && {
                        top: op.scrollTop,
                        ensure: op.scrollToPos
                      },
                      op.forceUpdate
                    ));
              }
              function endOperation_R2(op) {
                var cm = op.cm,
                  display = cm.display;
                op.updatedDisplay && updateHeightsInViewport(cm),
                  (op.barMeasure = measureForScrollbars(cm)),
                  display.maxLineChanged &&
                    !cm.options.lineWrapping &&
                    ((op.adjustWidthTo =
                      measureChar(
                        cm,
                        display.maxLine,
                        display.maxLine.text.length
                      ).left + 3),
                    (cm.display.sizerWidth = op.adjustWidthTo),
                    (op.barMeasure.scrollWidth = Math.max(
                      display.scroller.clientWidth,
                      display.sizer.offsetLeft +
                        op.adjustWidthTo +
                        scrollGap(cm) +
                        cm.display.barWidth
                    )),
                    (op.maxScrollLeft = Math.max(
                      0,
                      display.sizer.offsetLeft +
                        op.adjustWidthTo -
                        displayWidth(cm)
                    ))),
                  (op.updatedDisplay || op.selectionChanged) &&
                    (op.preparedSelection = display.input.prepareSelection());
              }
              function endOperation_W2(op) {
                var cm = op.cm;
                null != op.adjustWidthTo &&
                  ((cm.display.sizer.style.minWidth = op.adjustWidthTo + "px"),
                  op.maxScrollLeft < cm.doc.scrollLeft &&
                    setScrollLeft(
                      cm,
                      Math.min(
                        cm.display.scroller.scrollLeft,
                        op.maxScrollLeft
                      ),
                      !0
                    ),
                  (cm.display.maxLineChanged = !1));
                var takeFocus = op.focus && op.focus == activeElt();
                op.preparedSelection &&
                  cm.display.input.showSelection(
                    op.preparedSelection,
                    takeFocus
                  ),
                  (op.updatedDisplay || op.startHeight != cm.doc.height) &&
                    updateScrollbars(cm, op.barMeasure),
                  op.updatedDisplay && setDocumentHeight(cm, op.barMeasure),
                  op.selectionChanged && restartBlink(cm),
                  cm.state.focused &&
                    op.updateInput &&
                    cm.display.input.reset(op.typing),
                  takeFocus && ensureFocus(op.cm);
              }
              function endOperation_finish(op) {
                var cm = op.cm,
                  display = cm.display,
                  doc = cm.doc;
                (op.updatedDisplay && postUpdateDisplay(cm, op.update),
                null == display.wheelStartX ||
                  (null == op.scrollTop &&
                    null == op.scrollLeft &&
                    !op.scrollToPos) ||
                  (display.wheelStartX = display.wheelStartY = null),
                null != op.scrollTop &&
                  setScrollTop(cm, op.scrollTop, op.forceScroll),
                null != op.scrollLeft &&
                  setScrollLeft(cm, op.scrollLeft, !0, !0),
                op.scrollToPos) &&
                  (function(cm, rect) {
                    if (!signalDOMEvent(cm, "scrollCursorIntoView")) {
                      var display = cm.display,
                        box = display.sizer.getBoundingClientRect(),
                        doScroll = null;
                      if (
                        (rect.top + box.top < 0
                          ? (doScroll = !0)
                          : rect.bottom + box.top >
                              (window.innerHeight ||
                                document.documentElement.clientHeight) &&
                            (doScroll = !1),
                        null != doScroll && !phantom)
                      ) {
                        var scrollNode = elt(
                          "div",
                          "​",
                          null,
                          "position: absolute;\n                         top: " +
                            (rect.top -
                              display.viewOffset -
                              paddingTop(cm.display)) +
                            "px;\n                         height: " +
                            (rect.bottom -
                              rect.top +
                              scrollGap(cm) +
                              display.barHeight) +
                            "px;\n                         left: " +
                            rect.left +
                            "px; width: " +
                            Math.max(2, rect.right - rect.left) +
                            "px;"
                        );
                        cm.display.lineSpace.appendChild(scrollNode),
                          scrollNode.scrollIntoView(doScroll),
                          cm.display.lineSpace.removeChild(scrollNode);
                      }
                    }
                  })(
                    cm,
                    (function(cm, pos, end, margin) {
                      var rect;
                      null == margin && (margin = 0),
                        cm.options.lineWrapping ||
                          pos != end ||
                          (end =
                            "before" ==
                            (pos = pos.ch
                              ? Pos(
                                  pos.line,
                                  "before" == pos.sticky ? pos.ch - 1 : pos.ch,
                                  "after"
                                )
                              : pos).sticky
                              ? Pos(pos.line, pos.ch + 1, "before")
                              : pos);
                      for (var limit = 0; limit < 5; limit++) {
                        var changed = !1,
                          coords = cursorCoords(cm, pos),
                          endCoords =
                            end && end != pos ? cursorCoords(cm, end) : coords,
                          scrollPos = calculateScrollPos(
                            cm,
                            (rect = {
                              left: Math.min(coords.left, endCoords.left),
                              top: Math.min(coords.top, endCoords.top) - margin,
                              right: Math.max(coords.left, endCoords.left),
                              bottom:
                                Math.max(coords.bottom, endCoords.bottom) +
                                margin
                            })
                          ),
                          startTop = cm.doc.scrollTop,
                          startLeft = cm.doc.scrollLeft;
                        if (
                          (null != scrollPos.scrollTop &&
                            (updateScrollTop(cm, scrollPos.scrollTop),
                            1 < Math.abs(cm.doc.scrollTop - startTop) &&
                              (changed = !0)),
                          null != scrollPos.scrollLeft &&
                            (setScrollLeft(cm, scrollPos.scrollLeft),
                            1 < Math.abs(cm.doc.scrollLeft - startLeft) &&
                              (changed = !0)),
                          !changed)
                        )
                          break;
                      }
                      return rect;
                    })(
                      cm,
                      clipPos(doc, op.scrollToPos.from),
                      clipPos(doc, op.scrollToPos.to),
                      op.scrollToPos.margin
                    )
                  );
                var hidden = op.maybeHiddenMarkers,
                  unhidden = op.maybeUnhiddenMarkers;
                if (hidden)
                  for (var i = 0; i < hidden.length; ++i)
                    hidden[i].lines.length || signal(hidden[i], "hide");
                if (unhidden)
                  for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
                    unhidden[i$1].lines.length &&
                      signal(unhidden[i$1], "unhide");
                display.wrapper.offsetHeight &&
                  (doc.scrollTop = cm.display.scroller.scrollTop),
                  op.changeObjs && signal(cm, "changes", cm, op.changeObjs),
                  op.update && op.update.finish();
              }
              function runInOp(cm, f) {
                if (cm.curOp) return f();
                startOperation(cm);
                try {
                  return f();
                } finally {
                  endOperation(cm);
                }
              }
              function operation(cm, f) {
                return function() {
                  if (cm.curOp) return f.apply(cm, arguments);
                  startOperation(cm);
                  try {
                    return f.apply(cm, arguments);
                  } finally {
                    endOperation(cm);
                  }
                };
              }
              function methodOp(f) {
                return function() {
                  if (this.curOp) return f.apply(this, arguments);
                  startOperation(this);
                  try {
                    return f.apply(this, arguments);
                  } finally {
                    endOperation(this);
                  }
                };
              }
              function docMethodOp(f) {
                return function() {
                  var cm = this.cm;
                  if (!cm || cm.curOp) return f.apply(this, arguments);
                  startOperation(cm);
                  try {
                    return f.apply(this, arguments);
                  } finally {
                    endOperation(cm);
                  }
                };
              }
              function regChange(cm, from, to, lendiff) {
                null == from && (from = cm.doc.first),
                  null == to && (to = cm.doc.first + cm.doc.size),
                  lendiff || (lendiff = 0);
                var display = cm.display;
                if (
                  (lendiff &&
                    to < display.viewTo &&
                    (null == display.updateLineNumbers ||
                      display.updateLineNumbers > from) &&
                    (display.updateLineNumbers = from),
                  (cm.curOp.viewChanged = !0),
                  from >= display.viewTo)
                )
                  sawCollapsedSpans &&
                    visualLineNo(cm.doc, from) < display.viewTo &&
                    resetView(cm);
                else if (to <= display.viewFrom)
                  sawCollapsedSpans &&
                  visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom
                    ? resetView(cm)
                    : ((display.viewFrom += lendiff),
                      (display.viewTo += lendiff));
                else if (from <= display.viewFrom && to >= display.viewTo)
                  resetView(cm);
                else if (from <= display.viewFrom) {
                  var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
                  cut
                    ? ((display.view = display.view.slice(cut.index)),
                      (display.viewFrom = cut.lineN),
                      (display.viewTo += lendiff))
                    : resetView(cm);
                } else if (to >= display.viewTo) {
                  var cut$1 = viewCuttingPoint(cm, from, from, -1);
                  cut$1
                    ? ((display.view = display.view.slice(0, cut$1.index)),
                      (display.viewTo = cut$1.lineN))
                    : resetView(cm);
                } else {
                  var cutTop = viewCuttingPoint(cm, from, from, -1),
                    cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
                  cutTop && cutBot
                    ? ((display.view = display.view
                        .slice(0, cutTop.index)
                        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
                        .concat(display.view.slice(cutBot.index))),
                      (display.viewTo += lendiff))
                    : resetView(cm);
                }
                var ext = display.externalMeasured;
                ext &&
                  (to < ext.lineN
                    ? (ext.lineN += lendiff)
                    : from < ext.lineN + ext.size &&
                      (display.externalMeasured = null));
              }
              function regLineChange(cm, line, type) {
                cm.curOp.viewChanged = !0;
                var display = cm.display,
                  ext = cm.display.externalMeasured;
                if (
                  (ext &&
                    line >= ext.lineN &&
                    line < ext.lineN + ext.size &&
                    (display.externalMeasured = null),
                  !(line < display.viewFrom || line >= display.viewTo))
                ) {
                  var lineView = display.view[findViewIndex(cm, line)];
                  if (null != lineView.node) {
                    var arr = lineView.changes || (lineView.changes = []);
                    -1 == indexOf(arr, type) && arr.push(type);
                  }
                }
              }
              function resetView(cm) {
                (cm.display.viewFrom = cm.display.viewTo = cm.doc.first),
                  (cm.display.view = []),
                  (cm.display.viewOffset = 0);
              }
              function viewCuttingPoint(cm, oldN, newN, dir) {
                var diff,
                  index = findViewIndex(cm, oldN),
                  view = cm.display.view;
                if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
                  return { index: index, lineN: newN };
                for (var n = cm.display.viewFrom, i = 0; i < index; i++)
                  n += view[i].size;
                if (n != oldN) {
                  if (0 < dir) {
                    if (index == view.length - 1) return null;
                    (diff = n + view[index].size - oldN), index++;
                  } else diff = n - oldN;
                  (oldN += diff), (newN += diff);
                }
                for (; visualLineNo(cm.doc, newN) != newN; ) {
                  if (index == (dir < 0 ? 0 : view.length - 1)) return null;
                  (newN += dir * view[index - (dir < 0 ? 1 : 0)].size),
                    (index += dir);
                }
                return { index: index, lineN: newN };
              }
              function countDirtyView(cm) {
                for (
                  var view = cm.display.view, dirty = 0, i = 0;
                  i < view.length;
                  i++
                ) {
                  var lineView = view[i];
                  lineView.hidden ||
                    (lineView.node && !lineView.changes) ||
                    ++dirty;
                }
                return dirty;
              }
              function startWorker(cm, time) {
                cm.doc.highlightFrontier < cm.display.viewTo &&
                  cm.state.highlight.set(time, bind(highlightWorker, cm));
              }
              function highlightWorker(cm) {
                var doc = cm.doc;
                if (!(doc.highlightFrontier >= cm.display.viewTo)) {
                  var end = +new Date() + cm.options.workTime,
                    context = getContextBefore(cm, doc.highlightFrontier),
                    changedLines = [];
                  doc.iter(
                    context.line,
                    Math.min(doc.first + doc.size, cm.display.viewTo + 500),
                    function(line) {
                      if (context.line >= cm.display.viewFrom) {
                        var oldStyles = line.styles,
                          resetState =
                            line.text.length > cm.options.maxHighlightLength
                              ? copyState(doc.mode, context.state)
                              : null,
                          highlighted = highlightLine(cm, line, context, !0);
                        resetState && (context.state = resetState),
                          (line.styles = highlighted.styles);
                        var oldCls = line.styleClasses,
                          newCls = highlighted.classes;
                        newCls
                          ? (line.styleClasses = newCls)
                          : oldCls && (line.styleClasses = null);
                        for (
                          var ischange =
                              !oldStyles ||
                              oldStyles.length != line.styles.length ||
                              (oldCls != newCls &&
                                (!oldCls ||
                                  !newCls ||
                                  oldCls.bgClass != newCls.bgClass ||
                                  oldCls.textClass != newCls.textClass)),
                            i = 0;
                          !ischange && i < oldStyles.length;
                          ++i
                        )
                          ischange = oldStyles[i] != line.styles[i];
                        ischange && changedLines.push(context.line),
                          (line.stateAfter = context.save()),
                          context.nextLine();
                      } else
                        line.text.length <= cm.options.maxHighlightLength &&
                          processLine(cm, line.text, context),
                          (line.stateAfter =
                            context.line % 5 == 0 ? context.save() : null),
                          context.nextLine();
                      if (+new Date() > end)
                        return startWorker(cm, cm.options.workDelay), !0;
                    }
                  ),
                    (doc.highlightFrontier = context.line),
                    (doc.modeFrontier = Math.max(
                      doc.modeFrontier,
                      context.line
                    )),
                    changedLines.length &&
                      runInOp(cm, function() {
                        for (var i = 0; i < changedLines.length; i++)
                          regLineChange(cm, changedLines[i], "text");
                      });
                }
              }
              var DisplayUpdate = function(cm, viewport, force) {
                var display = cm.display;
                (this.viewport = viewport),
                  (this.visible = visibleLines(display, cm.doc, viewport)),
                  (this.editorIsHidden = !display.wrapper.offsetWidth),
                  (this.wrapperHeight = display.wrapper.clientHeight),
                  (this.wrapperWidth = display.wrapper.clientWidth),
                  (this.oldDisplayWidth = displayWidth(cm)),
                  (this.force = force),
                  (this.dims = getDimensions(cm)),
                  (this.events = []);
              };
              function updateDisplayIfNeeded(cm, update) {
                var display = cm.display,
                  doc = cm.doc;
                if (update.editorIsHidden) return resetView(cm), !1;
                if (
                  !update.force &&
                  update.visible.from >= display.viewFrom &&
                  update.visible.to <= display.viewTo &&
                  (null == display.updateLineNumbers ||
                    display.updateLineNumbers >= display.viewTo) &&
                  display.renderedView == display.view &&
                  0 == countDirtyView(cm)
                )
                  return !1;
                maybeUpdateLineNumberWidth(cm) &&
                  (resetView(cm), (update.dims = getDimensions(cm)));
                var end = doc.first + doc.size,
                  from = Math.max(
                    update.visible.from - cm.options.viewportMargin,
                    doc.first
                  ),
                  to = Math.min(
                    end,
                    update.visible.to + cm.options.viewportMargin
                  );
                display.viewFrom < from &&
                  from - display.viewFrom < 20 &&
                  (from = Math.max(doc.first, display.viewFrom)),
                  display.viewTo > to &&
                    display.viewTo - to < 20 &&
                    (to = Math.min(end, display.viewTo)),
                  sawCollapsedSpans &&
                    ((from = visualLineNo(cm.doc, from)),
                    (to = visualLineEndNo(cm.doc, to)));
                var different =
                  from != display.viewFrom ||
                  to != display.viewTo ||
                  display.lastWrapHeight != update.wrapperHeight ||
                  display.lastWrapWidth != update.wrapperWidth;
                !(function(cm, from, to) {
                  var display = cm.display;
                  0 == display.view.length ||
                  from >= display.viewTo ||
                  to <= display.viewFrom
                    ? ((display.view = buildViewArray(cm, from, to)),
                      (display.viewFrom = from))
                    : (display.viewFrom > from
                        ? (display.view = buildViewArray(
                            cm,
                            from,
                            display.viewFrom
                          ).concat(display.view))
                        : display.viewFrom < from &&
                          (display.view = display.view.slice(
                            findViewIndex(cm, from)
                          )),
                      (display.viewFrom = from),
                      display.viewTo < to
                        ? (display.view = display.view.concat(
                            buildViewArray(cm, display.viewTo, to)
                          ))
                        : display.viewTo > to &&
                          (display.view = display.view.slice(
                            0,
                            findViewIndex(cm, to)
                          ))),
                    (display.viewTo = to);
                })(cm, from, to),
                  (display.viewOffset = heightAtLine(
                    getLine(cm.doc, display.viewFrom)
                  )),
                  (cm.display.mover.style.top = display.viewOffset + "px");
                var toUpdate = countDirtyView(cm);
                if (
                  !different &&
                  0 == toUpdate &&
                  !update.force &&
                  display.renderedView == display.view &&
                  (null == display.updateLineNumbers ||
                    display.updateLineNumbers >= display.viewTo)
                )
                  return !1;
                var selSnapshot = (function(cm) {
                  if (cm.hasFocus()) return null;
                  var active = activeElt();
                  if (!active || !contains(cm.display.lineDiv, active))
                    return null;
                  var result = { activeElt: active };
                  if (window.getSelection) {
                    var sel = window.getSelection();
                    sel.anchorNode &&
                      sel.extend &&
                      contains(cm.display.lineDiv, sel.anchorNode) &&
                      ((result.anchorNode = sel.anchorNode),
                      (result.anchorOffset = sel.anchorOffset),
                      (result.focusNode = sel.focusNode),
                      (result.focusOffset = sel.focusOffset));
                  }
                  return result;
                })(cm);
                return (
                  4 < toUpdate && (display.lineDiv.style.display = "none"),
                  (function(cm, updateNumbersFrom, dims) {
                    var display = cm.display,
                      lineNumbers = cm.options.lineNumbers,
                      container = display.lineDiv,
                      cur = container.firstChild;
                    function rm(node) {
                      var next = node.nextSibling;
                      return (
                        webkit && mac && cm.display.currentWheelTarget == node
                          ? (node.style.display = "none")
                          : node.parentNode.removeChild(node),
                        next
                      );
                    }
                    for (
                      var view = display.view, lineN = display.viewFrom, i = 0;
                      i < view.length;
                      i++
                    ) {
                      var lineView = view[i];
                      if (lineView.hidden);
                      else if (
                        lineView.node &&
                        lineView.node.parentNode == container
                      ) {
                        for (; cur != lineView.node; ) cur = rm(cur);
                        var updateNumber =
                          lineNumbers &&
                          null != updateNumbersFrom &&
                          updateNumbersFrom <= lineN &&
                          lineView.lineNumber;
                        lineView.changes &&
                          (-1 < indexOf(lineView.changes, "gutter") &&
                            (updateNumber = !1),
                          updateLineForChanges(cm, lineView, lineN, dims)),
                          updateNumber &&
                            (removeChildren(lineView.lineNumber),
                            lineView.lineNumber.appendChild(
                              document.createTextNode(
                                lineNumberFor(cm.options, lineN)
                              )
                            )),
                          (cur = lineView.node.nextSibling);
                      } else {
                        var node = buildLineElement(cm, lineView, lineN, dims);
                        container.insertBefore(node, cur);
                      }
                      lineN += lineView.size;
                    }
                    for (; cur; ) cur = rm(cur);
                  })(cm, display.updateLineNumbers, update.dims),
                  4 < toUpdate && (display.lineDiv.style.display = ""),
                  (display.renderedView = display.view),
                  (function(snapshot) {
                    if (
                      snapshot &&
                      snapshot.activeElt &&
                      snapshot.activeElt != activeElt() &&
                      (snapshot.activeElt.focus(),
                      snapshot.anchorNode &&
                        contains(document.body, snapshot.anchorNode) &&
                        contains(document.body, snapshot.focusNode))
                    ) {
                      var sel = window.getSelection(),
                        range$$1 = document.createRange();
                      range$$1.setEnd(
                        snapshot.anchorNode,
                        snapshot.anchorOffset
                      ),
                        range$$1.collapse(!1),
                        sel.removeAllRanges(),
                        sel.addRange(range$$1),
                        sel.extend(snapshot.focusNode, snapshot.focusOffset);
                    }
                  })(selSnapshot),
                  removeChildren(display.cursorDiv),
                  removeChildren(display.selectionDiv),
                  (display.gutters.style.height = display.sizer.style.minHeight = 0),
                  different &&
                    ((display.lastWrapHeight = update.wrapperHeight),
                    (display.lastWrapWidth = update.wrapperWidth),
                    startWorker(cm, 400)),
                  (display.updateLineNumbers = null),
                  !0
                );
              }
              function postUpdateDisplay(cm, update) {
                for (
                  var viewport = update.viewport, first = !0;
                  ((first &&
                    cm.options.lineWrapping &&
                    update.oldDisplayWidth != displayWidth(cm)) ||
                    (viewport &&
                      null != viewport.top &&
                      (viewport = {
                        top: Math.min(
                          cm.doc.height +
                            paddingVert(cm.display) -
                            displayHeight(cm),
                          viewport.top
                        )
                      }),
                    (update.visible = visibleLines(
                      cm.display,
                      cm.doc,
                      viewport
                    )),
                    !(
                      update.visible.from >= cm.display.viewFrom &&
                      update.visible.to <= cm.display.viewTo
                    ))) &&
                  updateDisplayIfNeeded(cm, update);
                  first = !1
                ) {
                  updateHeightsInViewport(cm);
                  var barMeasure = measureForScrollbars(cm);
                  updateSelection(cm),
                    updateScrollbars(cm, barMeasure),
                    setDocumentHeight(cm, barMeasure),
                    (update.force = !1);
                }
                update.signal(cm, "update", cm),
                  (cm.display.viewFrom == cm.display.reportedViewFrom &&
                    cm.display.viewTo == cm.display.reportedViewTo) ||
                    (update.signal(
                      cm,
                      "viewportChange",
                      cm,
                      cm.display.viewFrom,
                      cm.display.viewTo
                    ),
                    (cm.display.reportedViewFrom = cm.display.viewFrom),
                    (cm.display.reportedViewTo = cm.display.viewTo));
              }
              function updateDisplaySimple(cm, viewport) {
                var update = new DisplayUpdate(cm, viewport);
                if (updateDisplayIfNeeded(cm, update)) {
                  updateHeightsInViewport(cm), postUpdateDisplay(cm, update);
                  var barMeasure = measureForScrollbars(cm);
                  updateSelection(cm),
                    updateScrollbars(cm, barMeasure),
                    setDocumentHeight(cm, barMeasure),
                    update.finish();
                }
              }
              function updateGutterSpace(cm) {
                var width = cm.display.gutters.offsetWidth;
                cm.display.sizer.style.marginLeft = width + "px";
              }
              function setDocumentHeight(cm, measure) {
                (cm.display.sizer.style.minHeight = measure.docHeight + "px"),
                  (cm.display.heightForcer.style.top =
                    measure.docHeight + "px"),
                  (cm.display.gutters.style.height =
                    measure.docHeight +
                    cm.display.barHeight +
                    scrollGap(cm) +
                    "px");
              }
              function updateGutters(cm) {
                var gutters = cm.display.gutters,
                  specs = cm.options.gutters;
                removeChildren(gutters);
                for (var i = 0; i < specs.length; ++i) {
                  var gutterClass = specs[i],
                    gElt = gutters.appendChild(
                      elt("div", null, "CodeMirror-gutter " + gutterClass)
                    );
                  "CodeMirror-linenumbers" == gutterClass &&
                    ((cm.display.lineGutter = gElt).style.width =
                      (cm.display.lineNumWidth || 1) + "px");
                }
                (gutters.style.display = i ? "" : "none"),
                  updateGutterSpace(cm);
              }
              function setGuttersForLineNumbers(options) {
                var found = indexOf(options.gutters, "CodeMirror-linenumbers");
                -1 == found && options.lineNumbers
                  ? (options.gutters = options.gutters.concat([
                      "CodeMirror-linenumbers"
                    ]))
                  : -1 < found &&
                    !options.lineNumbers &&
                    ((options.gutters = options.gutters.slice(0)),
                    options.gutters.splice(found, 1));
              }
              (DisplayUpdate.prototype.signal = function(emitter, type) {
                hasHandler(emitter, type) && this.events.push(arguments);
              }),
                (DisplayUpdate.prototype.finish = function() {
                  for (var i = 0; i < this.events.length; i++)
                    signal.apply(null, this.events[i]);
                });
              var wheelSamples = 0,
                wheelPixelsPerUnit = null;
              function wheelEventDelta(e) {
                var dx = e.wheelDeltaX,
                  dy = e.wheelDeltaY;
                return (
                  null == dx &&
                    e.detail &&
                    e.axis == e.HORIZONTAL_AXIS &&
                    (dx = e.detail),
                  null == dy && e.detail && e.axis == e.VERTICAL_AXIS
                    ? (dy = e.detail)
                    : null == dy && (dy = e.wheelDelta),
                  { x: dx, y: dy }
                );
              }
              function wheelEventPixels(e) {
                var delta = wheelEventDelta(e);
                return (
                  (delta.x *= wheelPixelsPerUnit),
                  (delta.y *= wheelPixelsPerUnit),
                  delta
                );
              }
              function onScrollWheel(cm, e) {
                var delta = wheelEventDelta(e),
                  dx = delta.x,
                  dy = delta.y,
                  display = cm.display,
                  scroll = display.scroller,
                  canScrollX = scroll.scrollWidth > scroll.clientWidth,
                  canScrollY = scroll.scrollHeight > scroll.clientHeight;
                if ((dx && canScrollX) || (dy && canScrollY)) {
                  if (dy && mac && webkit)
                    outer: for (
                      var cur = e.target, view = display.view;
                      cur != scroll;
                      cur = cur.parentNode
                    )
                      for (var i = 0; i < view.length; i++)
                        if (view[i].node == cur) {
                          cm.display.currentWheelTarget = cur;
                          break outer;
                        }
                  if (dx && !gecko && !presto && null != wheelPixelsPerUnit)
                    return (
                      dy &&
                        canScrollY &&
                        updateScrollTop(
                          cm,
                          Math.max(
                            0,
                            scroll.scrollTop + dy * wheelPixelsPerUnit
                          )
                        ),
                      setScrollLeft(
                        cm,
                        Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit)
                      ),
                      (!dy || (dy && canScrollY)) && e_preventDefault(e),
                      void (display.wheelStartX = null)
                    );
                  if (dy && null != wheelPixelsPerUnit) {
                    var pixels = dy * wheelPixelsPerUnit,
                      top = cm.doc.scrollTop,
                      bot = top + display.wrapper.clientHeight;
                    pixels < 0
                      ? (top = Math.max(0, top + pixels - 50))
                      : (bot = Math.min(cm.doc.height, bot + pixels + 50)),
                      updateDisplaySimple(cm, { top: top, bottom: bot });
                  }
                  wheelSamples < 20 &&
                    (null == display.wheelStartX
                      ? ((display.wheelStartX = scroll.scrollLeft),
                        (display.wheelStartY = scroll.scrollTop),
                        (display.wheelDX = dx),
                        (display.wheelDY = dy),
                        setTimeout(function() {
                          if (null != display.wheelStartX) {
                            var movedX =
                                scroll.scrollLeft - display.wheelStartX,
                              movedY = scroll.scrollTop - display.wheelStartY,
                              sample =
                                (movedY &&
                                  display.wheelDY &&
                                  movedY / display.wheelDY) ||
                                (movedX &&
                                  display.wheelDX &&
                                  movedX / display.wheelDX);
                            (display.wheelStartX = display.wheelStartY = null),
                              sample &&
                                ((wheelPixelsPerUnit =
                                  (wheelPixelsPerUnit * wheelSamples + sample) /
                                  (wheelSamples + 1)),
                                ++wheelSamples);
                          }
                        }, 200))
                      : ((display.wheelDX += dx), (display.wheelDY += dy)));
                }
              }
              ie
                ? (wheelPixelsPerUnit = -0.53)
                : gecko
                  ? (wheelPixelsPerUnit = 15)
                  : chrome
                    ? (wheelPixelsPerUnit = -0.7)
                    : safari && (wheelPixelsPerUnit = -1 / 3);
              var Selection = function(ranges, primIndex) {
                (this.ranges = ranges), (this.primIndex = primIndex);
              };
              (Selection.prototype.primary = function() {
                return this.ranges[this.primIndex];
              }),
                (Selection.prototype.equals = function(other) {
                  if (other == this) return !0;
                  if (
                    other.primIndex != this.primIndex ||
                    other.ranges.length != this.ranges.length
                  )
                    return !1;
                  for (var i = 0; i < this.ranges.length; i++) {
                    var here = this.ranges[i],
                      there = other.ranges[i];
                    if (
                      !equalCursorPos(here.anchor, there.anchor) ||
                      !equalCursorPos(here.head, there.head)
                    )
                      return !1;
                  }
                  return !0;
                }),
                (Selection.prototype.deepCopy = function() {
                  for (var out = [], i = 0; i < this.ranges.length; i++)
                    out[i] = new Range(
                      copyPos(this.ranges[i].anchor),
                      copyPos(this.ranges[i].head)
                    );
                  return new Selection(out, this.primIndex);
                }),
                (Selection.prototype.somethingSelected = function() {
                  for (var i = 0; i < this.ranges.length; i++)
                    if (!this.ranges[i].empty()) return !0;
                  return !1;
                }),
                (Selection.prototype.contains = function(pos, end) {
                  end || (end = pos);
                  for (var i = 0; i < this.ranges.length; i++) {
                    var range = this.ranges[i];
                    if (
                      0 <= cmp(end, range.from()) &&
                      cmp(pos, range.to()) <= 0
                    )
                      return i;
                  }
                  return -1;
                });
              var Range = function(anchor, head) {
                (this.anchor = anchor), (this.head = head);
              };
              function normalizeSelection(ranges, primIndex) {
                var prim = ranges[primIndex];
                ranges.sort(function(a, b) {
                  return cmp(a.from(), b.from());
                }),
                  (primIndex = indexOf(ranges, prim));
                for (var i = 1; i < ranges.length; i++) {
                  var cur = ranges[i],
                    prev = ranges[i - 1];
                  if (0 <= cmp(prev.to(), cur.from())) {
                    var from = minPos(prev.from(), cur.from()),
                      to = maxPos(prev.to(), cur.to()),
                      inv = prev.empty()
                        ? cur.from() == cur.head
                        : prev.from() == prev.head;
                    i <= primIndex && --primIndex,
                      ranges.splice(
                        --i,
                        2,
                        new Range(inv ? to : from, inv ? from : to)
                      );
                  }
                }
                return new Selection(ranges, primIndex);
              }
              function simpleSelection(anchor, head) {
                return new Selection([new Range(anchor, head || anchor)], 0);
              }
              function changeEnd(change) {
                return change.text
                  ? Pos(
                      change.from.line + change.text.length - 1,
                      lst(change.text).length +
                        (1 == change.text.length ? change.from.ch : 0)
                    )
                  : change.to;
              }
              function adjustForChange(pos, change) {
                if (cmp(pos, change.from) < 0) return pos;
                if (cmp(pos, change.to) <= 0) return changeEnd(change);
                var line =
                    pos.line +
                    change.text.length -
                    (change.to.line - change.from.line) -
                    1,
                  ch = pos.ch;
                return (
                  pos.line == change.to.line &&
                    (ch += changeEnd(change).ch - change.to.ch),
                  Pos(line, ch)
                );
              }
              function computeSelAfterChange(doc, change) {
                for (var out = [], i = 0; i < doc.sel.ranges.length; i++) {
                  var range = doc.sel.ranges[i];
                  out.push(
                    new Range(
                      adjustForChange(range.anchor, change),
                      adjustForChange(range.head, change)
                    )
                  );
                }
                return normalizeSelection(out, doc.sel.primIndex);
              }
              function offsetPos(pos, old, nw) {
                return pos.line == old.line
                  ? Pos(nw.line, pos.ch - old.ch + nw.ch)
                  : Pos(nw.line + (pos.line - old.line), pos.ch);
              }
              function loadMode(cm) {
                (cm.doc.mode = getMode(cm.options, cm.doc.modeOption)),
                  resetModeState(cm);
              }
              function resetModeState(cm) {
                cm.doc.iter(function(line) {
                  line.stateAfter && (line.stateAfter = null),
                    line.styles && (line.styles = null);
                }),
                  (cm.doc.modeFrontier = cm.doc.highlightFrontier =
                    cm.doc.first),
                  startWorker(cm, 100),
                  cm.state.modeGen++,
                  cm.curOp && regChange(cm);
              }
              function isWholeLineUpdate(doc, change) {
                return (
                  0 == change.from.ch &&
                  0 == change.to.ch &&
                  "" == lst(change.text) &&
                  (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
                );
              }
              function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
                function spansFor(n) {
                  return markedSpans ? markedSpans[n] : null;
                }
                function update(line, text, spans) {
                  !(function(line, text, markedSpans, estimateHeight) {
                    (line.text = text),
                      line.stateAfter && (line.stateAfter = null),
                      line.styles && (line.styles = null),
                      null != line.order && (line.order = null),
                      detachMarkedSpans(line),
                      attachMarkedSpans(line, markedSpans);
                    var estHeight = estimateHeight ? estimateHeight(line) : 1;
                    estHeight != line.height &&
                      updateLineHeight(line, estHeight);
                  })(line, text, spans, estimateHeight$$1),
                    signalLater(line, "change", line, change);
                }
                function linesFor(start, end) {
                  for (var result = [], i = start; i < end; ++i)
                    result.push(
                      new Line(text[i], spansFor(i), estimateHeight$$1)
                    );
                  return result;
                }
                var from = change.from,
                  to = change.to,
                  text = change.text,
                  firstLine = getLine(doc, from.line),
                  lastLine = getLine(doc, to.line),
                  lastText = lst(text),
                  lastSpans = spansFor(text.length - 1),
                  nlines = to.line - from.line;
                if (change.full)
                  doc.insert(0, linesFor(0, text.length)),
                    doc.remove(text.length, doc.size - text.length);
                else if (isWholeLineUpdate(doc, change)) {
                  var added = linesFor(0, text.length - 1);
                  update(lastLine, lastLine.text, lastSpans),
                    nlines && doc.remove(from.line, nlines),
                    added.length && doc.insert(from.line, added);
                } else if (firstLine == lastLine)
                  if (1 == text.length)
                    update(
                      firstLine,
                      firstLine.text.slice(0, from.ch) +
                        lastText +
                        firstLine.text.slice(to.ch),
                      lastSpans
                    );
                  else {
                    var added$1 = linesFor(1, text.length - 1);
                    added$1.push(
                      new Line(
                        lastText + firstLine.text.slice(to.ch),
                        lastSpans,
                        estimateHeight$$1
                      )
                    ),
                      update(
                        firstLine,
                        firstLine.text.slice(0, from.ch) + text[0],
                        spansFor(0)
                      ),
                      doc.insert(from.line + 1, added$1);
                  }
                else if (1 == text.length)
                  update(
                    firstLine,
                    firstLine.text.slice(0, from.ch) +
                      text[0] +
                      lastLine.text.slice(to.ch),
                    spansFor(0)
                  ),
                    doc.remove(from.line + 1, nlines);
                else {
                  update(
                    firstLine,
                    firstLine.text.slice(0, from.ch) + text[0],
                    spansFor(0)
                  ),
                    update(
                      lastLine,
                      lastText + lastLine.text.slice(to.ch),
                      lastSpans
                    );
                  var added$2 = linesFor(1, text.length - 1);
                  1 < nlines && doc.remove(from.line + 1, nlines - 1),
                    doc.insert(from.line + 1, added$2);
                }
                signalLater(doc, "change", doc, change);
              }
              function linkedDocs(doc, f, sharedHistOnly) {
                !(function propagate(doc, skip, sharedHist) {
                  if (doc.linked)
                    for (var i = 0; i < doc.linked.length; ++i) {
                      var rel = doc.linked[i];
                      if (rel.doc != skip) {
                        var shared = sharedHist && rel.sharedHist;
                        (sharedHistOnly && !shared) ||
                          (f(rel.doc, shared), propagate(rel.doc, doc, shared));
                      }
                    }
                })(doc, null, !0);
              }
              function attachDoc(cm, doc) {
                if (doc.cm) throw new Error("This document is already in use.");
                estimateLineHeights(((cm.doc = doc).cm = cm)),
                  loadMode(cm),
                  setDirectionClass(cm),
                  cm.options.lineWrapping || findMaxLine(cm),
                  (cm.options.mode = doc.modeOption),
                  regChange(cm);
              }
              function setDirectionClass(cm) {
                ("rtl" == cm.doc.direction ? addClass : rmClass)(
                  cm.display.lineDiv,
                  "CodeMirror-rtl"
                );
              }
              function History(startGen) {
                (this.done = []),
                  (this.undone = []),
                  (this.undoDepth = 1 / 0),
                  (this.lastModTime = this.lastSelTime = 0),
                  (this.lastOp = this.lastSelOp = null),
                  (this.lastOrigin = this.lastSelOrigin = null),
                  (this.generation = this.maxGeneration = startGen || 1);
              }
              function historyChangeFromChange(doc, change) {
                var histChange = {
                  from: copyPos(change.from),
                  to: changeEnd(change),
                  text: getBetween(doc, change.from, change.to)
                };
                return (
                  attachLocalSpans(
                    doc,
                    histChange,
                    change.from.line,
                    change.to.line + 1
                  ),
                  linkedDocs(
                    doc,
                    function(doc) {
                      return attachLocalSpans(
                        doc,
                        histChange,
                        change.from.line,
                        change.to.line + 1
                      );
                    },
                    !0
                  ),
                  histChange
                );
              }
              function clearSelectionEvents(array) {
                for (; array.length; ) {
                  if (!lst(array).ranges) break;
                  array.pop();
                }
              }
              function addChangeToHistory(doc, change, selAfter, opId) {
                var hist = doc.history;
                hist.undone.length = 0;
                var cur,
                  last,
                  time = +new Date();
                if (
                  (hist.lastOp == opId ||
                    (hist.lastOrigin == change.origin &&
                      change.origin &&
                      (("+" == change.origin.charAt(0) &&
                        doc.cm &&
                        hist.lastModTime >
                          time - doc.cm.options.historyEventDelay) ||
                        "*" == change.origin.charAt(0)))) &&
                  (cur = (function(hist, force) {
                    return force
                      ? (clearSelectionEvents(hist.done), lst(hist.done))
                      : hist.done.length && !lst(hist.done).ranges
                        ? lst(hist.done)
                        : 1 < hist.done.length &&
                          !hist.done[hist.done.length - 2].ranges
                          ? (hist.done.pop(), lst(hist.done))
                          : void 0;
                  })(hist, hist.lastOp == opId))
                )
                  (last = lst(cur.changes)),
                    0 == cmp(change.from, change.to) &&
                    0 == cmp(change.from, last.to)
                      ? (last.to = changeEnd(change))
                      : cur.changes.push(historyChangeFromChange(doc, change));
                else {
                  var before = lst(hist.done);
                  for (
                    (before && before.ranges) ||
                      pushSelectionToHistory(doc.sel, hist.done),
                      cur = {
                        changes: [historyChangeFromChange(doc, change)],
                        generation: hist.generation
                      },
                      hist.done.push(cur);
                    hist.done.length > hist.undoDepth;

                  )
                    hist.done.shift(), hist.done[0].ranges || hist.done.shift();
                }
                hist.done.push(selAfter),
                  (hist.generation = ++hist.maxGeneration),
                  (hist.lastModTime = hist.lastSelTime = time),
                  (hist.lastOp = hist.lastSelOp = opId),
                  (hist.lastOrigin = hist.lastSelOrigin = change.origin),
                  last || signal(doc, "historyAdded");
              }
              function addSelectionToHistory(doc, sel, opId, options) {
                var hist = doc.history,
                  origin = options && options.origin;
                opId == hist.lastSelOp ||
                (origin &&
                  hist.lastSelOrigin == origin &&
                  ((hist.lastModTime == hist.lastSelTime &&
                    hist.lastOrigin == origin) ||
                    (function(doc, origin, prev, sel) {
                      var ch = origin.charAt(0);
                      return (
                        "*" == ch ||
                        ("+" == ch &&
                          prev.ranges.length == sel.ranges.length &&
                          prev.somethingSelected() == sel.somethingSelected() &&
                          new Date() - doc.history.lastSelTime <=
                            (doc.cm ? doc.cm.options.historyEventDelay : 500))
                      );
                    })(doc, origin, lst(hist.done), sel)))
                  ? (hist.done[hist.done.length - 1] = sel)
                  : pushSelectionToHistory(sel, hist.done),
                  (hist.lastSelTime = +new Date()),
                  (hist.lastSelOrigin = origin),
                  (hist.lastSelOp = opId),
                  options &&
                    !1 !== options.clearRedo &&
                    clearSelectionEvents(hist.undone);
              }
              function pushSelectionToHistory(sel, dest) {
                var top = lst(dest);
                (top && top.ranges && top.equals(sel)) || dest.push(sel);
              }
              function attachLocalSpans(doc, change, from, to) {
                var existing = change["spans_" + doc.id],
                  n = 0;
                doc.iter(
                  Math.max(doc.first, from),
                  Math.min(doc.first + doc.size, to),
                  function(line) {
                    line.markedSpans &&
                      ((existing ||
                        (existing = change["spans_" + doc.id] = {}))[n] =
                        line.markedSpans),
                      ++n;
                  }
                );
              }
              function removeClearedSpans(spans) {
                if (!spans) return null;
                for (var out, i = 0; i < spans.length; ++i)
                  spans[i].marker.explicitlyCleared
                    ? out || (out = spans.slice(0, i))
                    : out && out.push(spans[i]);
                return out ? (out.length ? out : null) : spans;
              }
              function mergeOldSpans(doc, change) {
                var old = (function(doc, change) {
                    var found = change["spans_" + doc.id];
                    if (!found) return null;
                    for (var nw = [], i = 0; i < change.text.length; ++i)
                      nw.push(removeClearedSpans(found[i]));
                    return nw;
                  })(doc, change),
                  stretched = stretchSpansOverChange(doc, change);
                if (!old) return stretched;
                if (!stretched) return old;
                for (var i = 0; i < old.length; ++i) {
                  var oldCur = old[i],
                    stretchCur = stretched[i];
                  if (oldCur && stretchCur)
                    spans: for (var j = 0; j < stretchCur.length; ++j) {
                      for (
                        var span = stretchCur[j], k = 0;
                        k < oldCur.length;
                        ++k
                      )
                        if (oldCur[k].marker == span.marker) continue spans;
                      oldCur.push(span);
                    }
                  else stretchCur && (old[i] = stretchCur);
                }
                return old;
              }
              function copyHistoryArray(events, newGroup, instantiateSel) {
                for (var copy = [], i = 0; i < events.length; ++i) {
                  var event = events[i];
                  if (event.ranges)
                    copy.push(
                      instantiateSel
                        ? Selection.prototype.deepCopy.call(event)
                        : event
                    );
                  else {
                    var changes = event.changes,
                      newChanges = [];
                    copy.push({ changes: newChanges });
                    for (var j = 0; j < changes.length; ++j) {
                      var change = changes[j],
                        m = void 0;
                      if (
                        (newChanges.push({
                          from: change.from,
                          to: change.to,
                          text: change.text
                        }),
                        newGroup)
                      )
                        for (var prop in change)
                          (m = prop.match(/^spans_(\d+)$/)) &&
                            -1 < indexOf(newGroup, Number(m[1])) &&
                            ((lst(newChanges)[prop] = change[prop]),
                            delete change[prop]);
                    }
                  }
                }
                return copy;
              }
              function extendRange(range, head, other, extend) {
                if (extend) {
                  var anchor = range.anchor;
                  if (other) {
                    var posBefore = cmp(head, anchor) < 0;
                    posBefore != cmp(other, anchor) < 0
                      ? ((anchor = head), (head = other))
                      : posBefore != cmp(head, other) < 0 && (head = other);
                  }
                  return new Range(anchor, head);
                }
                return new Range(other || head, head);
              }
              function extendSelection(doc, head, other, options, extend) {
                null == extend &&
                  (extend = doc.cm && (doc.cm.display.shift || doc.extend)),
                  setSelection(
                    doc,
                    new Selection(
                      [extendRange(doc.sel.primary(), head, other, extend)],
                      0
                    ),
                    options
                  );
              }
              function extendSelections(doc, heads, options) {
                for (
                  var out = [],
                    extend = doc.cm && (doc.cm.display.shift || doc.extend),
                    i = 0;
                  i < doc.sel.ranges.length;
                  i++
                )
                  out[i] = extendRange(
                    doc.sel.ranges[i],
                    heads[i],
                    null,
                    extend
                  );
                setSelection(
                  doc,
                  normalizeSelection(out, doc.sel.primIndex),
                  options
                );
              }
              function replaceOneSelection(doc, i, range, options) {
                var ranges = doc.sel.ranges.slice(0);
                (ranges[i] = range),
                  setSelection(
                    doc,
                    normalizeSelection(ranges, doc.sel.primIndex),
                    options
                  );
              }
              function setSimpleSelection(doc, anchor, head, options) {
                setSelection(doc, simpleSelection(anchor, head), options);
              }
              function setSelectionReplaceHistory(doc, sel, options) {
                var done = doc.history.done,
                  last = lst(done);
                last && last.ranges
                  ? setSelectionNoUndo(
                      doc,
                      (done[done.length - 1] = sel),
                      options
                    )
                  : setSelection(doc, sel, options);
              }
              function setSelection(doc, sel, options) {
                setSelectionNoUndo(doc, sel, options),
                  addSelectionToHistory(
                    doc,
                    doc.sel,
                    doc.cm ? doc.cm.curOp.id : NaN,
                    options
                  );
              }
              function setSelectionNoUndo(doc, sel, options) {
                (hasHandler(doc, "beforeSelectionChange") ||
                  (doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))) &&
                  (sel = (function(doc, sel, options) {
                    var obj = {
                      ranges: sel.ranges,
                      update: function(ranges) {
                        this.ranges = [];
                        for (var i = 0; i < ranges.length; i++)
                          this.ranges[i] = new Range(
                            clipPos(doc, ranges[i].anchor),
                            clipPos(doc, ranges[i].head)
                          );
                      },
                      origin: options && options.origin
                    };
                    return (
                      signal(doc, "beforeSelectionChange", doc, obj),
                      doc.cm &&
                        signal(doc.cm, "beforeSelectionChange", doc.cm, obj),
                      obj.ranges != sel.ranges
                        ? normalizeSelection(obj.ranges, obj.ranges.length - 1)
                        : sel
                    );
                  })(doc, sel, options)),
                  setSelectionInner(
                    doc,
                    skipAtomicInSelection(
                      doc,
                      sel,
                      (options && options.bias) ||
                        (cmp(sel.primary().head, doc.sel.primary().head) < 0
                          ? -1
                          : 1),
                      !0
                    )
                  ),
                  (options && !1 === options.scroll) ||
                    !doc.cm ||
                    ensureCursorVisible(doc.cm);
              }
              function setSelectionInner(doc, sel) {
                sel.equals(doc.sel) ||
                  ((doc.sel = sel),
                  doc.cm &&
                    ((doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = !0),
                    signalCursorActivity(doc.cm)),
                  signalLater(doc, "cursorActivity", doc));
              }
              function reCheckSelection(doc) {
                setSelectionInner(
                  doc,
                  skipAtomicInSelection(doc, doc.sel, null, !1)
                );
              }
              function skipAtomicInSelection(doc, sel, bias, mayClear) {
                for (var out, i = 0; i < sel.ranges.length; i++) {
                  var range = sel.ranges[i],
                    old =
                      sel.ranges.length == doc.sel.ranges.length &&
                      doc.sel.ranges[i],
                    newAnchor = skipAtomic(
                      doc,
                      range.anchor,
                      old && old.anchor,
                      bias,
                      mayClear
                    ),
                    newHead = skipAtomic(
                      doc,
                      range.head,
                      old && old.head,
                      bias,
                      mayClear
                    );
                  (out || newAnchor != range.anchor || newHead != range.head) &&
                    (out || (out = sel.ranges.slice(0, i)),
                    (out[i] = new Range(newAnchor, newHead)));
                }
                return out ? normalizeSelection(out, sel.primIndex) : sel;
              }
              function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
                var line = getLine(doc, pos.line);
                if (line.markedSpans)
                  for (var i = 0; i < line.markedSpans.length; ++i) {
                    var sp = line.markedSpans[i],
                      m = sp.marker;
                    if (
                      (null == sp.from ||
                        (m.inclusiveLeft
                          ? sp.from <= pos.ch
                          : sp.from < pos.ch)) &&
                      (null == sp.to ||
                        (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))
                    ) {
                      if (
                        mayClear &&
                        (signal(m, "beforeCursorEnter"), m.explicitlyCleared)
                      ) {
                        if (line.markedSpans) {
                          --i;
                          continue;
                        }
                        break;
                      }
                      if (!m.atomic) continue;
                      if (oldPos) {
                        var near = m.find(dir < 0 ? 1 : -1),
                          diff = void 0;
                        if (
                          ((dir < 0 ? m.inclusiveRight : m.inclusiveLeft) &&
                            (near = movePos(
                              doc,
                              near,
                              -dir,
                              near && near.line == pos.line ? line : null
                            )),
                          near &&
                            near.line == pos.line &&
                            (diff = cmp(near, oldPos)) &&
                            (dir < 0 ? diff < 0 : 0 < diff))
                        )
                          return skipAtomicInner(doc, near, pos, dir, mayClear);
                      }
                      var far = m.find(dir < 0 ? -1 : 1);
                      return (
                        (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) &&
                          (far = movePos(
                            doc,
                            far,
                            dir,
                            far.line == pos.line ? line : null
                          )),
                        far
                          ? skipAtomicInner(doc, far, pos, dir, mayClear)
                          : null
                      );
                    }
                  }
                return pos;
              }
              function skipAtomic(doc, pos, oldPos, bias, mayClear) {
                var dir = bias || 1,
                  found =
                    skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
                    (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, !0)) ||
                    skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
                    (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, !0));
                return found || ((doc.cantEdit = !0), Pos(doc.first, 0));
              }
              function movePos(doc, pos, dir, line) {
                return dir < 0 && 0 == pos.ch
                  ? pos.line > doc.first
                    ? clipPos(doc, Pos(pos.line - 1))
                    : null
                  : 0 < dir &&
                    pos.ch == (line || getLine(doc, pos.line)).text.length
                    ? pos.line < doc.first + doc.size - 1
                      ? Pos(pos.line + 1, 0)
                      : null
                    : new Pos(pos.line, pos.ch + dir);
              }
              function selectAll(cm) {
                cm.setSelection(
                  Pos(cm.firstLine(), 0),
                  Pos(cm.lastLine()),
                  sel_dontScroll
                );
              }
              function filterChange(doc, change, update) {
                var obj = {
                  canceled: !1,
                  from: change.from,
                  to: change.to,
                  text: change.text,
                  origin: change.origin,
                  cancel: function() {
                    return (obj.canceled = !0);
                  }
                };
                return (
                  update &&
                    (obj.update = function(from, to, text, origin) {
                      from && (obj.from = clipPos(doc, from)),
                        to && (obj.to = clipPos(doc, to)),
                        text && (obj.text = text),
                        void 0 !== origin && (obj.origin = origin);
                    }),
                  signal(doc, "beforeChange", doc, obj),
                  doc.cm && signal(doc.cm, "beforeChange", doc.cm, obj),
                  obj.canceled
                    ? null
                    : {
                        from: obj.from,
                        to: obj.to,
                        text: obj.text,
                        origin: obj.origin
                      }
                );
              }
              function makeChange(doc, change, ignoreReadOnly) {
                if (doc.cm) {
                  if (!doc.cm.curOp)
                    return operation(doc.cm, makeChange)(
                      doc,
                      change,
                      ignoreReadOnly
                    );
                  if (doc.cm.state.suppressEdits) return;
                }
                if (
                  !(
                    hasHandler(doc, "beforeChange") ||
                    (doc.cm && hasHandler(doc.cm, "beforeChange"))
                  ) ||
                  (change = filterChange(doc, change, !0))
                ) {
                  var split =
                    sawReadOnlySpans &&
                    !ignoreReadOnly &&
                    (function(doc, from, to) {
                      var markers = null;
                      if (
                        (doc.iter(from.line, to.line + 1, function(line) {
                          if (line.markedSpans)
                            for (var i = 0; i < line.markedSpans.length; ++i) {
                              var mark = line.markedSpans[i].marker;
                              !mark.readOnly ||
                                (markers && -1 != indexOf(markers, mark)) ||
                                (markers || (markers = [])).push(mark);
                            }
                        }),
                        !markers)
                      )
                        return null;
                      for (
                        var parts = [{ from: from, to: to }], i = 0;
                        i < markers.length;
                        ++i
                      )
                        for (
                          var mk = markers[i], m = mk.find(0), j = 0;
                          j < parts.length;
                          ++j
                        ) {
                          var p = parts[j];
                          if (
                            !(cmp(p.to, m.from) < 0 || 0 < cmp(p.from, m.to))
                          ) {
                            var newParts = [j, 1],
                              dfrom = cmp(p.from, m.from),
                              dto = cmp(p.to, m.to);
                            (dfrom < 0 || (!mk.inclusiveLeft && !dfrom)) &&
                              newParts.push({ from: p.from, to: m.from }),
                              (0 < dto || (!mk.inclusiveRight && !dto)) &&
                                newParts.push({ from: m.to, to: p.to }),
                              parts.splice.apply(parts, newParts),
                              (j += newParts.length - 3);
                          }
                        }
                      return parts;
                    })(doc, change.from, change.to);
                  if (split)
                    for (var i = split.length - 1; 0 <= i; --i)
                      makeChangeInner(doc, {
                        from: split[i].from,
                        to: split[i].to,
                        text: i ? [""] : change.text,
                        origin: change.origin
                      });
                  else makeChangeInner(doc, change);
                }
              }
              function makeChangeInner(doc, change) {
                if (
                  1 != change.text.length ||
                  "" != change.text[0] ||
                  0 != cmp(change.from, change.to)
                ) {
                  var selAfter = computeSelAfterChange(doc, change);
                  addChangeToHistory(
                    doc,
                    change,
                    selAfter,
                    doc.cm ? doc.cm.curOp.id : NaN
                  ),
                    makeChangeSingleDoc(
                      doc,
                      change,
                      selAfter,
                      stretchSpansOverChange(doc, change)
                    );
                  var rebased = [];
                  linkedDocs(doc, function(doc, sharedHist) {
                    sharedHist ||
                      -1 != indexOf(rebased, doc.history) ||
                      (rebaseHist(doc.history, change),
                      rebased.push(doc.history)),
                      makeChangeSingleDoc(
                        doc,
                        change,
                        null,
                        stretchSpansOverChange(doc, change)
                      );
                  });
                }
              }
              function makeChangeFromHistory(doc, type, allowSelectionOnly) {
                var suppress = doc.cm && doc.cm.state.suppressEdits;
                if (!suppress || allowSelectionOnly) {
                  for (
                    var event,
                      hist = doc.history,
                      selAfter = doc.sel,
                      source = "undo" == type ? hist.done : hist.undone,
                      dest = "undo" == type ? hist.undone : hist.done,
                      i = 0;
                    i < source.length &&
                    ((event = source[i]),
                    allowSelectionOnly
                      ? !event.ranges || event.equals(doc.sel)
                      : event.ranges);
                    i++
                  );
                  if (i != source.length) {
                    for (hist.lastOrigin = hist.lastSelOrigin = null; ; ) {
                      if (!(event = source.pop()).ranges) {
                        if (suppress) return void source.push(event);
                        break;
                      }
                      if (
                        (pushSelectionToHistory(event, dest),
                        allowSelectionOnly && !event.equals(doc.sel))
                      )
                        return void setSelection(doc, event, { clearRedo: !1 });
                      selAfter = event;
                    }
                    var antiChanges = [];
                    pushSelectionToHistory(selAfter, dest),
                      dest.push({
                        changes: antiChanges,
                        generation: hist.generation
                      }),
                      (hist.generation =
                        event.generation || ++hist.maxGeneration);
                    for (
                      var filter =
                          hasHandler(doc, "beforeChange") ||
                          (doc.cm && hasHandler(doc.cm, "beforeChange")),
                        loop = function(i) {
                          var change = event.changes[i];
                          if (
                            ((change.origin = type),
                            filter && !filterChange(doc, change, !1))
                          )
                            return (source.length = 0), {};
                          antiChanges.push(
                            historyChangeFromChange(doc, change)
                          );
                          var after = i
                            ? computeSelAfterChange(doc, change)
                            : lst(source);
                          makeChangeSingleDoc(
                            doc,
                            change,
                            after,
                            mergeOldSpans(doc, change)
                          ),
                            !i &&
                              doc.cm &&
                              doc.cm.scrollIntoView({
                                from: change.from,
                                to: changeEnd(change)
                              });
                          var rebased = [];
                          linkedDocs(doc, function(doc, sharedHist) {
                            sharedHist ||
                              -1 != indexOf(rebased, doc.history) ||
                              (rebaseHist(doc.history, change),
                              rebased.push(doc.history)),
                              makeChangeSingleDoc(
                                doc,
                                change,
                                null,
                                mergeOldSpans(doc, change)
                              );
                          });
                        },
                        i$1 = event.changes.length - 1;
                      0 <= i$1;
                      --i$1
                    ) {
                      var returned = loop(i$1);
                      if (returned) return returned.v;
                    }
                  }
                }
              }
              function shiftDoc(doc, distance) {
                if (
                  0 != distance &&
                  ((doc.first += distance),
                  (doc.sel = new Selection(
                    map(doc.sel.ranges, function(range) {
                      return new Range(
                        Pos(range.anchor.line + distance, range.anchor.ch),
                        Pos(range.head.line + distance, range.head.ch)
                      );
                    }),
                    doc.sel.primIndex
                  )),
                  doc.cm)
                ) {
                  regChange(doc.cm, doc.first, doc.first - distance, distance);
                  for (
                    var d = doc.cm.display, l = d.viewFrom;
                    l < d.viewTo;
                    l++
                  )
                    regLineChange(doc.cm, l, "gutter");
                }
              }
              function makeChangeSingleDoc(doc, change, selAfter, spans) {
                if (doc.cm && !doc.cm.curOp)
                  return operation(doc.cm, makeChangeSingleDoc)(
                    doc,
                    change,
                    selAfter,
                    spans
                  );
                if (change.to.line < doc.first)
                  shiftDoc(
                    doc,
                    change.text.length - 1 - (change.to.line - change.from.line)
                  );
                else if (!(change.from.line > doc.lastLine())) {
                  if (change.from.line < doc.first) {
                    var shift =
                      change.text.length - 1 - (doc.first - change.from.line);
                    shiftDoc(doc, shift),
                      (change = {
                        from: Pos(doc.first, 0),
                        to: Pos(change.to.line + shift, change.to.ch),
                        text: [lst(change.text)],
                        origin: change.origin
                      });
                  }
                  var last = doc.lastLine();
                  change.to.line > last &&
                    (change = {
                      from: change.from,
                      to: Pos(last, getLine(doc, last).text.length),
                      text: [change.text[0]],
                      origin: change.origin
                    }),
                    (change.removed = getBetween(doc, change.from, change.to)),
                    selAfter || (selAfter = computeSelAfterChange(doc, change)),
                    doc.cm
                      ? (function(cm, change, spans) {
                          var doc = cm.doc,
                            display = cm.display,
                            from = change.from,
                            to = change.to,
                            recomputeMaxLength = !1,
                            checkWidthStart = from.line;
                          cm.options.lineWrapping ||
                            ((checkWidthStart = lineNo(
                              visualLine(getLine(doc, from.line))
                            )),
                            doc.iter(checkWidthStart, to.line + 1, function(
                              line
                            ) {
                              if (line == display.maxLine)
                                return (recomputeMaxLength = !0);
                            }));
                          -1 < doc.sel.contains(change.from, change.to) &&
                            signalCursorActivity(cm);
                          updateDoc(doc, change, spans, estimateHeight(cm)),
                            cm.options.lineWrapping ||
                              (doc.iter(
                                checkWidthStart,
                                from.line + change.text.length,
                                function(line) {
                                  var len = lineLength(line);
                                  len > display.maxLineLength &&
                                    ((display.maxLine = line),
                                    (display.maxLineLength = len),
                                    (display.maxLineChanged = !0),
                                    (recomputeMaxLength = !1));
                                }
                              ),
                              recomputeMaxLength &&
                                (cm.curOp.updateMaxLine = !0));
                          (function(doc, n) {
                            if (
                              ((doc.modeFrontier = Math.min(
                                doc.modeFrontier,
                                n
                              )),
                              !(doc.highlightFrontier < n - 10))
                            ) {
                              for (
                                var start = doc.first, line = n - 1;
                                start < line;
                                line--
                              ) {
                                var saved = getLine(doc, line).stateAfter;
                                if (
                                  saved &&
                                  (!(saved instanceof SavedContext) ||
                                    line + saved.lookAhead < n)
                                ) {
                                  start = line + 1;
                                  break;
                                }
                              }
                              doc.highlightFrontier = Math.min(
                                doc.highlightFrontier,
                                start
                              );
                            }
                          })(doc, from.line),
                            startWorker(cm, 400);
                          var lendiff =
                            change.text.length - (to.line - from.line) - 1;
                          change.full
                            ? regChange(cm)
                            : from.line != to.line ||
                              1 != change.text.length ||
                              isWholeLineUpdate(cm.doc, change)
                              ? regChange(cm, from.line, to.line + 1, lendiff)
                              : regLineChange(cm, from.line, "text");
                          var changesHandler = hasHandler(cm, "changes"),
                            changeHandler = hasHandler(cm, "change");
                          if (changeHandler || changesHandler) {
                            var obj = {
                              from: from,
                              to: to,
                              text: change.text,
                              removed: change.removed,
                              origin: change.origin
                            };
                            changeHandler && signalLater(cm, "change", cm, obj),
                              changesHandler &&
                                (
                                  cm.curOp.changeObjs ||
                                  (cm.curOp.changeObjs = [])
                                ).push(obj);
                          }
                          cm.display.selForContextMenu = null;
                        })(doc.cm, change, spans)
                      : updateDoc(doc, change, spans),
                    setSelectionNoUndo(doc, selAfter, sel_dontScroll);
                }
              }
              function replaceRange(doc, code, from, to, origin) {
                var assign;
                (to || (to = from), cmp(to, from) < 0) &&
                  ((from = (assign = [to, from])[0]), (to = assign[1]));
                "string" == typeof code && (code = doc.splitLines(code)),
                  makeChange(doc, {
                    from: from,
                    to: to,
                    text: code,
                    origin: origin
                  });
              }
              function rebaseHistSelSingle(pos, from, to, diff) {
                to < pos.line
                  ? (pos.line += diff)
                  : from < pos.line && ((pos.line = from), (pos.ch = 0));
              }
              function rebaseHistArray(array, from, to, diff) {
                for (var i = 0; i < array.length; ++i) {
                  var sub = array[i],
                    ok = !0;
                  if (sub.ranges) {
                    sub.copied ||
                      ((sub = array[i] = sub.deepCopy()).copied = !0);
                    for (var j = 0; j < sub.ranges.length; j++)
                      rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff),
                        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
                  } else {
                    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
                      var cur = sub.changes[j$1];
                      if (to < cur.from.line)
                        (cur.from = Pos(cur.from.line + diff, cur.from.ch)),
                          (cur.to = Pos(cur.to.line + diff, cur.to.ch));
                      else if (from <= cur.to.line) {
                        ok = !1;
                        break;
                      }
                    }
                    ok || (array.splice(0, i + 1), (i = 0));
                  }
                }
              }
              function rebaseHist(hist, change) {
                var from = change.from.line,
                  to = change.to.line,
                  diff = change.text.length - (to - from) - 1;
                rebaseHistArray(hist.done, from, to, diff),
                  rebaseHistArray(hist.undone, from, to, diff);
              }
              function changeLine(doc, handle, changeType, op) {
                var no = handle,
                  line = handle;
                return (
                  "number" == typeof handle
                    ? (line = getLine(doc, clipLine(doc, handle)))
                    : (no = lineNo(handle)),
                  null == no
                    ? null
                    : (op(line, no) &&
                        doc.cm &&
                        regLineChange(doc.cm, no, changeType),
                      line)
                );
              }
              function LeafChunk(lines) {
                (this.lines = lines), (this.parent = null);
                for (var height = 0, i = 0; i < lines.length; ++i)
                  (lines[i].parent = this), (height += lines[i].height);
                this.height = height;
              }
              function BranchChunk(children) {
                this.children = children;
                for (
                  var size = 0, height = 0, i = 0;
                  i < children.length;
                  ++i
                ) {
                  var ch = children[i];
                  (size += ch.chunkSize()),
                    (height += ch.height),
                    (ch.parent = this);
                }
                (this.size = size),
                  (this.height = height),
                  (this.parent = null);
              }
              (Range.prototype.from = function() {
                return minPos(this.anchor, this.head);
              }),
                (Range.prototype.to = function() {
                  return maxPos(this.anchor, this.head);
                }),
                (Range.prototype.empty = function() {
                  return (
                    this.head.line == this.anchor.line &&
                    this.head.ch == this.anchor.ch
                  );
                }),
                (LeafChunk.prototype = {
                  chunkSize: function() {
                    return this.lines.length;
                  },
                  removeInner: function(at, n) {
                    for (var i = at, e = at + n; i < e; ++i) {
                      var line = this.lines[i];
                      (this.height -= line.height),
                        cleanUpLine(line),
                        signalLater(line, "delete");
                    }
                    this.lines.splice(at, n);
                  },
                  collapse: function(lines) {
                    lines.push.apply(lines, this.lines);
                  },
                  insertInner: function(at, lines, height) {
                    (this.height += height),
                      (this.lines = this.lines
                        .slice(0, at)
                        .concat(lines)
                        .concat(this.lines.slice(at)));
                    for (var i = 0; i < lines.length; ++i)
                      lines[i].parent = this;
                  },
                  iterN: function(at, n, op) {
                    for (var e = at + n; at < e; ++at)
                      if (op(this.lines[at])) return !0;
                  }
                }),
                (BranchChunk.prototype = {
                  chunkSize: function() {
                    return this.size;
                  },
                  removeInner: function(at, n) {
                    this.size -= n;
                    for (var i = 0; i < this.children.length; ++i) {
                      var child = this.children[i],
                        sz = child.chunkSize();
                      if (at < sz) {
                        var rm = Math.min(n, sz - at),
                          oldHeight = child.height;
                        if (
                          (child.removeInner(at, rm),
                          (this.height -= oldHeight - child.height),
                          sz == rm &&
                            (this.children.splice(i--, 1),
                            (child.parent = null)),
                          0 == (n -= rm))
                        )
                          break;
                        at = 0;
                      } else at -= sz;
                    }
                    if (
                      this.size - n < 25 &&
                      (1 < this.children.length ||
                        !(this.children[0] instanceof LeafChunk))
                    ) {
                      var lines = [];
                      this.collapse(lines),
                        (this.children = [new LeafChunk(lines)]),
                        (this.children[0].parent = this);
                    }
                  },
                  collapse: function(lines) {
                    for (var i = 0; i < this.children.length; ++i)
                      this.children[i].collapse(lines);
                  },
                  insertInner: function(at, lines, height) {
                    (this.size += lines.length), (this.height += height);
                    for (var i = 0; i < this.children.length; ++i) {
                      var child = this.children[i],
                        sz = child.chunkSize();
                      if (at <= sz) {
                        if (
                          (child.insertInner(at, lines, height),
                          child.lines && 50 < child.lines.length)
                        ) {
                          for (
                            var remaining = child.lines.length % 25 + 25,
                              pos = remaining;
                            pos < child.lines.length;

                          ) {
                            var leaf = new LeafChunk(
                              child.lines.slice(pos, (pos += 25))
                            );
                            (child.height -= leaf.height),
                              this.children.splice(++i, 0, leaf),
                              (leaf.parent = this);
                          }
                          (child.lines = child.lines.slice(0, remaining)),
                            this.maybeSpill();
                        }
                        break;
                      }
                      at -= sz;
                    }
                  },
                  maybeSpill: function() {
                    if (!(this.children.length <= 10)) {
                      var me = this;
                      do {
                        var sibling = new BranchChunk(
                          me.children.splice(me.children.length - 5, 5)
                        );
                        if (me.parent) {
                          (me.size -= sibling.size),
                            (me.height -= sibling.height);
                          var myIndex = indexOf(me.parent.children, me);
                          me.parent.children.splice(myIndex + 1, 0, sibling);
                        } else {
                          var copy = new BranchChunk(me.children);
                          ((copy.parent = me).children = [copy, sibling]),
                            (me = copy);
                        }
                        sibling.parent = me.parent;
                      } while (10 < me.children.length);
                      me.parent.maybeSpill();
                    }
                  },
                  iterN: function(at, n, op) {
                    for (var i = 0; i < this.children.length; ++i) {
                      var child = this.children[i],
                        sz = child.chunkSize();
                      if (at < sz) {
                        var used = Math.min(n, sz - at);
                        if (child.iterN(at, used, op)) return !0;
                        if (0 == (n -= used)) break;
                        at = 0;
                      } else at -= sz;
                    }
                  }
                });
              var LineWidget = function(doc, node, options) {
                if (options)
                  for (var opt in options)
                    options.hasOwnProperty(opt) && (this[opt] = options[opt]);
                (this.doc = doc), (this.node = node);
              };
              function adjustScrollWhenAboveVisible(cm, line, diff) {
                heightAtLine(line) <
                  ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop) &&
                  addToScrollTop(cm, diff);
              }
              (LineWidget.prototype.clear = function() {
                var cm = this.doc.cm,
                  ws = this.line.widgets,
                  line = this.line,
                  no = lineNo(line);
                if (null != no && ws) {
                  for (var i = 0; i < ws.length; ++i)
                    ws[i] == this && ws.splice(i--, 1);
                  ws.length || (line.widgets = null);
                  var height = widgetHeight(this);
                  updateLineHeight(line, Math.max(0, line.height - height)),
                    cm &&
                      (runInOp(cm, function() {
                        adjustScrollWhenAboveVisible(cm, line, -height),
                          regLineChange(cm, no, "widget");
                      }),
                      signalLater(cm, "lineWidgetCleared", cm, this, no));
                }
              }),
                (LineWidget.prototype.changed = function() {
                  var this$1 = this,
                    oldH = this.height,
                    cm = this.doc.cm,
                    line = this.line;
                  this.height = null;
                  var diff = widgetHeight(this) - oldH;
                  diff &&
                    (updateLineHeight(line, line.height + diff),
                    cm &&
                      runInOp(cm, function() {
                        (cm.curOp.forceUpdate = !0),
                          adjustScrollWhenAboveVisible(cm, line, diff),
                          signalLater(
                            cm,
                            "lineWidgetChanged",
                            cm,
                            this$1,
                            lineNo(line)
                          );
                      }));
                }),
                eventMixin(LineWidget);
              var nextMarkerId = 0,
                TextMarker = function(doc, type) {
                  (this.lines = []),
                    (this.type = type),
                    (this.doc = doc),
                    (this.id = ++nextMarkerId);
                };
              function markText(doc, from, to, options, type) {
                if (options && options.shared)
                  return (function(doc, from, to, options, type) {
                    (options = copyObj(options)).shared = !1;
                    var markers = [markText(doc, from, to, options, type)],
                      primary = markers[0],
                      widget = options.widgetNode;
                    return (
                      linkedDocs(doc, function(doc) {
                        widget && (options.widgetNode = widget.cloneNode(!0)),
                          markers.push(
                            markText(
                              doc,
                              clipPos(doc, from),
                              clipPos(doc, to),
                              options,
                              type
                            )
                          );
                        for (var i = 0; i < doc.linked.length; ++i)
                          if (doc.linked[i].isParent) return;
                        primary = lst(markers);
                      }),
                      new SharedTextMarker(markers, primary)
                    );
                  })(doc, from, to, options, type);
                if (doc.cm && !doc.cm.curOp)
                  return operation(doc.cm, markText)(
                    doc,
                    from,
                    to,
                    options,
                    type
                  );
                var marker = new TextMarker(doc, type),
                  diff = cmp(from, to);
                if (
                  (options && copyObj(options, marker, !1),
                  0 < diff || (0 == diff && !1 !== marker.clearWhenEmpty))
                )
                  return marker;
                if (
                  (marker.replacedWith &&
                    ((marker.collapsed = !0),
                    (marker.widgetNode = eltP(
                      "span",
                      [marker.replacedWith],
                      "CodeMirror-widget"
                    )),
                    options.handleMouseEvents ||
                      marker.widgetNode.setAttribute(
                        "cm-ignore-events",
                        "true"
                      ),
                    options.insertLeft && (marker.widgetNode.insertLeft = !0)),
                  marker.collapsed)
                ) {
                  if (
                    conflictingCollapsedRange(
                      doc,
                      from.line,
                      from,
                      to,
                      marker
                    ) ||
                    (from.line != to.line &&
                      conflictingCollapsedRange(doc, to.line, from, to, marker))
                  )
                    throw new Error(
                      "Inserting collapsed marker partially overlapping an existing one"
                    );
                  sawCollapsedSpans = !0;
                }
                marker.addToHistory &&
                  addChangeToHistory(
                    doc,
                    { from: from, to: to, origin: "markText" },
                    doc.sel,
                    NaN
                  );
                var updateMaxLine,
                  curLine = from.line,
                  cm = doc.cm;
                if (
                  (doc.iter(curLine, to.line + 1, function(line) {
                    cm &&
                      marker.collapsed &&
                      !cm.options.lineWrapping &&
                      visualLine(line) == cm.display.maxLine &&
                      (updateMaxLine = !0),
                      marker.collapsed &&
                        curLine != from.line &&
                        updateLineHeight(line, 0),
                      (function(line, span) {
                        (line.markedSpans = line.markedSpans
                          ? line.markedSpans.concat([span])
                          : [span]),
                          span.marker.attachLine(line);
                      })(
                        line,
                        new MarkedSpan(
                          marker,
                          curLine == from.line ? from.ch : null,
                          curLine == to.line ? to.ch : null
                        )
                      ),
                      ++curLine;
                  }),
                  marker.collapsed &&
                    doc.iter(from.line, to.line + 1, function(line) {
                      lineIsHidden(doc, line) && updateLineHeight(line, 0);
                    }),
                  marker.clearOnEnter &&
                    on(marker, "beforeCursorEnter", function() {
                      return marker.clear();
                    }),
                  marker.readOnly &&
                    ((sawReadOnlySpans = !0),
                    (doc.history.done.length || doc.history.undone.length) &&
                      doc.clearHistory()),
                  marker.collapsed &&
                    ((marker.id = ++nextMarkerId), (marker.atomic = !0)),
                  cm)
                ) {
                  if (
                    (updateMaxLine && (cm.curOp.updateMaxLine = !0),
                    marker.collapsed)
                  )
                    regChange(cm, from.line, to.line + 1);
                  else if (
                    marker.className ||
                    marker.title ||
                    marker.startStyle ||
                    marker.endStyle ||
                    marker.css
                  )
                    for (var i = from.line; i <= to.line; i++)
                      regLineChange(cm, i, "text");
                  marker.atomic && reCheckSelection(cm.doc),
                    signalLater(cm, "markerAdded", cm, marker);
                }
                return marker;
              }
              (TextMarker.prototype.clear = function() {
                if (!this.explicitlyCleared) {
                  var cm = this.doc.cm,
                    withOp = cm && !cm.curOp;
                  if (
                    (withOp && startOperation(cm), hasHandler(this, "clear"))
                  ) {
                    var found = this.find();
                    found && signalLater(this, "clear", found.from, found.to);
                  }
                  for (
                    var min = null, max = null, i = 0;
                    i < this.lines.length;
                    ++i
                  ) {
                    var line = this.lines[i],
                      span = getMarkedSpanFor(line.markedSpans, this);
                    cm && !this.collapsed
                      ? regLineChange(cm, lineNo(line), "text")
                      : cm &&
                        (null != span.to && (max = lineNo(line)),
                        null != span.from && (min = lineNo(line))),
                      (line.markedSpans = removeMarkedSpan(
                        line.markedSpans,
                        span
                      )),
                      null == span.from &&
                        this.collapsed &&
                        !lineIsHidden(this.doc, line) &&
                        cm &&
                        updateLineHeight(line, textHeight(cm.display));
                  }
                  if (cm && this.collapsed && !cm.options.lineWrapping)
                    for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
                      var visual = visualLine(this.lines[i$1]),
                        len = lineLength(visual);
                      len > cm.display.maxLineLength &&
                        ((cm.display.maxLine = visual),
                        (cm.display.maxLineLength = len),
                        (cm.display.maxLineChanged = !0));
                    }
                  null != min &&
                    cm &&
                    this.collapsed &&
                    regChange(cm, min, max + 1),
                    (this.lines.length = 0),
                    (this.explicitlyCleared = !0),
                    this.atomic &&
                      this.doc.cantEdit &&
                      ((this.doc.cantEdit = !1),
                      cm && reCheckSelection(cm.doc)),
                    cm && signalLater(cm, "markerCleared", cm, this, min, max),
                    withOp && endOperation(cm),
                    this.parent && this.parent.clear();
                }
              }),
                (TextMarker.prototype.find = function(side, lineObj) {
                  var from, to;
                  null == side && "bookmark" == this.type && (side = 1);
                  for (var i = 0; i < this.lines.length; ++i) {
                    var line = this.lines[i],
                      span = getMarkedSpanFor(line.markedSpans, this);
                    if (
                      null != span.from &&
                      ((from = Pos(lineObj ? line : lineNo(line), span.from)),
                      -1 == side)
                    )
                      return from;
                    if (
                      null != span.to &&
                      ((to = Pos(lineObj ? line : lineNo(line), span.to)),
                      1 == side)
                    )
                      return to;
                  }
                  return from && { from: from, to: to };
                }),
                (TextMarker.prototype.changed = function() {
                  var this$1 = this,
                    pos = this.find(-1, !0),
                    widget = this,
                    cm = this.doc.cm;
                  pos &&
                    cm &&
                    runInOp(cm, function() {
                      var line = pos.line,
                        lineN = lineNo(pos.line),
                        view = findViewForLine(cm, lineN);
                      if (
                        (view &&
                          (clearLineMeasurementCacheFor(view),
                          (cm.curOp.selectionChanged = cm.curOp.forceUpdate = !0)),
                        (cm.curOp.updateMaxLine = !0),
                        !lineIsHidden(widget.doc, line) &&
                          null != widget.height)
                      ) {
                        var oldHeight = widget.height;
                        widget.height = null;
                        var dHeight = widgetHeight(widget) - oldHeight;
                        dHeight &&
                          updateLineHeight(line, line.height + dHeight);
                      }
                      signalLater(cm, "markerChanged", cm, this$1);
                    });
                }),
                (TextMarker.prototype.attachLine = function(line) {
                  if (!this.lines.length && this.doc.cm) {
                    var op = this.doc.cm.curOp;
                    (op.maybeHiddenMarkers &&
                      -1 != indexOf(op.maybeHiddenMarkers, this)) ||
                      (
                        op.maybeUnhiddenMarkers ||
                        (op.maybeUnhiddenMarkers = [])
                      ).push(this);
                  }
                  this.lines.push(line);
                }),
                (TextMarker.prototype.detachLine = function(line) {
                  if (
                    (this.lines.splice(indexOf(this.lines, line), 1),
                    !this.lines.length && this.doc.cm)
                  ) {
                    var op = this.doc.cm.curOp;
                    (
                      op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])
                    ).push(this);
                  }
                }),
                eventMixin(TextMarker);
              var SharedTextMarker = function(markers, primary) {
                (this.markers = markers), (this.primary = primary);
                for (var i = 0; i < markers.length; ++i)
                  markers[i].parent = this;
              };
              function findSharedMarkers(doc) {
                return doc.findMarks(
                  Pos(doc.first, 0),
                  doc.clipPos(Pos(doc.lastLine())),
                  function(m) {
                    return m.parent;
                  }
                );
              }
              function detachSharedMarkers(markers) {
                for (
                  var loop = function(i) {
                      var marker = markers[i],
                        linked = [marker.primary.doc];
                      linkedDocs(marker.primary.doc, function(d) {
                        return linked.push(d);
                      });
                      for (var j = 0; j < marker.markers.length; j++) {
                        var subMarker = marker.markers[j];
                        -1 == indexOf(linked, subMarker.doc) &&
                          ((subMarker.parent = null),
                          marker.markers.splice(j--, 1));
                      }
                    },
                    i = 0;
                  i < markers.length;
                  i++
                )
                  loop(i);
              }
              (SharedTextMarker.prototype.clear = function() {
                if (!this.explicitlyCleared) {
                  this.explicitlyCleared = !0;
                  for (var i = 0; i < this.markers.length; ++i)
                    this.markers[i].clear();
                  signalLater(this, "clear");
                }
              }),
                (SharedTextMarker.prototype.find = function(side, lineObj) {
                  return this.primary.find(side, lineObj);
                }),
                eventMixin(SharedTextMarker);
              var nextDocId = 0,
                Doc = function(text, mode, firstLine, lineSep, direction) {
                  if (!(this instanceof Doc))
                    return new Doc(text, mode, firstLine, lineSep, direction);
                  null == firstLine && (firstLine = 0),
                    BranchChunk.call(this, [
                      new LeafChunk([new Line("", null)])
                    ]),
                    (this.first = firstLine),
                    (this.scrollTop = this.scrollLeft = 0),
                    (this.cantEdit = !1),
                    (this.cleanGeneration = 1),
                    (this.modeFrontier = this.highlightFrontier = firstLine);
                  var start = Pos(firstLine, 0);
                  (this.sel = simpleSelection(start)),
                    (this.history = new History(null)),
                    (this.id = ++nextDocId),
                    (this.modeOption = mode),
                    (this.lineSep = lineSep),
                    (this.direction = "rtl" == direction ? "rtl" : "ltr"),
                    (this.extend = !1),
                    "string" == typeof text && (text = this.splitLines(text)),
                    updateDoc(this, { from: start, to: start, text: text }),
                    setSelection(this, simpleSelection(start), sel_dontScroll);
                };
              (Doc.prototype = createObj(BranchChunk.prototype, {
                constructor: Doc,
                iter: function(from, to, op) {
                  op
                    ? this.iterN(from - this.first, to - from, op)
                    : this.iterN(this.first, this.first + this.size, from);
                },
                insert: function(at, lines) {
                  for (var height = 0, i = 0; i < lines.length; ++i)
                    height += lines[i].height;
                  this.insertInner(at - this.first, lines, height);
                },
                remove: function(at, n) {
                  this.removeInner(at - this.first, n);
                },
                getValue: function(lineSep) {
                  var lines = getLines(
                    this,
                    this.first,
                    this.first + this.size
                  );
                  return !1 === lineSep
                    ? lines
                    : lines.join(lineSep || this.lineSeparator());
                },
                setValue: docMethodOp(function(code) {
                  var top = Pos(this.first, 0),
                    last = this.first + this.size - 1;
                  makeChange(
                    this,
                    {
                      from: top,
                      to: Pos(last, getLine(this, last).text.length),
                      text: this.splitLines(code),
                      origin: "setValue",
                      full: !0
                    },
                    !0
                  ),
                    this.cm && scrollToCoords(this.cm, 0, 0),
                    setSelection(this, simpleSelection(top), sel_dontScroll);
                }),
                replaceRange: function(code, from, to, origin) {
                  replaceRange(
                    this,
                    code,
                    (from = clipPos(this, from)),
                    (to = to ? clipPos(this, to) : from),
                    origin
                  );
                },
                getRange: function(from, to, lineSep) {
                  var lines = getBetween(
                    this,
                    clipPos(this, from),
                    clipPos(this, to)
                  );
                  return !1 === lineSep
                    ? lines
                    : lines.join(lineSep || this.lineSeparator());
                },
                getLine: function(line) {
                  var l = this.getLineHandle(line);
                  return l && l.text;
                },
                getLineHandle: function(line) {
                  if (isLine(this, line)) return getLine(this, line);
                },
                getLineNumber: function(line) {
                  return lineNo(line);
                },
                getLineHandleVisualStart: function(line) {
                  return (
                    "number" == typeof line && (line = getLine(this, line)),
                    visualLine(line)
                  );
                },
                lineCount: function() {
                  return this.size;
                },
                firstLine: function() {
                  return this.first;
                },
                lastLine: function() {
                  return this.first + this.size - 1;
                },
                clipPos: function(pos) {
                  return clipPos(this, pos);
                },
                getCursor: function(start) {
                  var range$$1 = this.sel.primary();
                  return null == start || "head" == start
                    ? range$$1.head
                    : "anchor" == start
                      ? range$$1.anchor
                      : "end" == start || "to" == start || !1 === start
                        ? range$$1.to()
                        : range$$1.from();
                },
                listSelections: function() {
                  return this.sel.ranges;
                },
                somethingSelected: function() {
                  return this.sel.somethingSelected();
                },
                setCursor: docMethodOp(function(line, ch, options) {
                  setSimpleSelection(
                    this,
                    clipPos(
                      this,
                      "number" == typeof line ? Pos(line, ch || 0) : line
                    ),
                    null,
                    options
                  );
                }),
                setSelection: docMethodOp(function(anchor, head, options) {
                  setSimpleSelection(
                    this,
                    clipPos(this, anchor),
                    clipPos(this, head || anchor),
                    options
                  );
                }),
                extendSelection: docMethodOp(function(head, other, options) {
                  extendSelection(
                    this,
                    clipPos(this, head),
                    other && clipPos(this, other),
                    options
                  );
                }),
                extendSelections: docMethodOp(function(heads, options) {
                  extendSelections(this, clipPosArray(this, heads), options);
                }),
                extendSelectionsBy: docMethodOp(function(f, options) {
                  extendSelections(
                    this,
                    clipPosArray(this, map(this.sel.ranges, f)),
                    options
                  );
                }),
                setSelections: docMethodOp(function(ranges, primary, options) {
                  if (ranges.length) {
                    for (var out = [], i = 0; i < ranges.length; i++)
                      out[i] = new Range(
                        clipPos(this, ranges[i].anchor),
                        clipPos(this, ranges[i].head)
                      );
                    null == primary &&
                      (primary = Math.min(
                        ranges.length - 1,
                        this.sel.primIndex
                      )),
                      setSelection(
                        this,
                        normalizeSelection(out, primary),
                        options
                      );
                  }
                }),
                addSelection: docMethodOp(function(anchor, head, options) {
                  var ranges = this.sel.ranges.slice(0);
                  ranges.push(
                    new Range(
                      clipPos(this, anchor),
                      clipPos(this, head || anchor)
                    )
                  ),
                    setSelection(
                      this,
                      normalizeSelection(ranges, ranges.length - 1),
                      options
                    );
                }),
                getSelection: function(lineSep) {
                  for (
                    var lines, ranges = this.sel.ranges, i = 0;
                    i < ranges.length;
                    i++
                  ) {
                    var sel = getBetween(
                      this,
                      ranges[i].from(),
                      ranges[i].to()
                    );
                    lines = lines ? lines.concat(sel) : sel;
                  }
                  return !1 === lineSep
                    ? lines
                    : lines.join(lineSep || this.lineSeparator());
                },
                getSelections: function(lineSep) {
                  for (
                    var parts = [], ranges = this.sel.ranges, i = 0;
                    i < ranges.length;
                    i++
                  ) {
                    var sel = getBetween(
                      this,
                      ranges[i].from(),
                      ranges[i].to()
                    );
                    !1 !== lineSep &&
                      (sel = sel.join(lineSep || this.lineSeparator())),
                      (parts[i] = sel);
                  }
                  return parts;
                },
                replaceSelection: function(code, collapse, origin) {
                  for (var dup = [], i = 0; i < this.sel.ranges.length; i++)
                    dup[i] = code;
                  this.replaceSelections(dup, collapse, origin || "+input");
                },
                replaceSelections: docMethodOp(function(
                  code,
                  collapse,
                  origin
                ) {
                  for (
                    var changes = [], sel = this.sel, i = 0;
                    i < sel.ranges.length;
                    i++
                  ) {
                    var range$$1 = sel.ranges[i];
                    changes[i] = {
                      from: range$$1.from(),
                      to: range$$1.to(),
                      text: this.splitLines(code[i]),
                      origin: origin
                    };
                  }
                  for (
                    var newSel =
                        collapse &&
                        "end" != collapse &&
                        (function(doc, changes, hint) {
                          for (
                            var out = [],
                              oldPrev = Pos(doc.first, 0),
                              newPrev = oldPrev,
                              i = 0;
                            i < changes.length;
                            i++
                          ) {
                            var change = changes[i],
                              from = offsetPos(change.from, oldPrev, newPrev),
                              to = offsetPos(
                                changeEnd(change),
                                oldPrev,
                                newPrev
                              );
                            if (
                              ((oldPrev = change.to),
                              (newPrev = to),
                              "around" == hint)
                            ) {
                              var range = doc.sel.ranges[i],
                                inv = cmp(range.head, range.anchor) < 0;
                              out[i] = new Range(
                                inv ? to : from,
                                inv ? from : to
                              );
                            } else out[i] = new Range(from, from);
                          }
                          return new Selection(out, doc.sel.primIndex);
                        })(this, changes, collapse),
                      i$1 = changes.length - 1;
                    0 <= i$1;
                    i$1--
                  )
                    makeChange(this, changes[i$1]);
                  newSel
                    ? setSelectionReplaceHistory(this, newSel)
                    : this.cm && ensureCursorVisible(this.cm);
                }),
                undo: docMethodOp(function() {
                  makeChangeFromHistory(this, "undo");
                }),
                redo: docMethodOp(function() {
                  makeChangeFromHistory(this, "redo");
                }),
                undoSelection: docMethodOp(function() {
                  makeChangeFromHistory(this, "undo", !0);
                }),
                redoSelection: docMethodOp(function() {
                  makeChangeFromHistory(this, "redo", !0);
                }),
                setExtending: function(val) {
                  this.extend = val;
                },
                getExtending: function() {
                  return this.extend;
                },
                historySize: function() {
                  for (
                    var hist = this.history, done = 0, undone = 0, i = 0;
                    i < hist.done.length;
                    i++
                  )
                    hist.done[i].ranges || ++done;
                  for (var i$1 = 0; i$1 < hist.undone.length; i$1++)
                    hist.undone[i$1].ranges || ++undone;
                  return { undo: done, redo: undone };
                },
                clearHistory: function() {
                  this.history = new History(this.history.maxGeneration);
                },
                markClean: function() {
                  this.cleanGeneration = this.changeGeneration(!0);
                },
                changeGeneration: function(forceSplit) {
                  return (
                    forceSplit &&
                      (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null),
                    this.history.generation
                  );
                },
                isClean: function(gen) {
                  return (
                    this.history.generation == (gen || this.cleanGeneration)
                  );
                },
                getHistory: function() {
                  return {
                    done: copyHistoryArray(this.history.done),
                    undone: copyHistoryArray(this.history.undone)
                  };
                },
                setHistory: function(histData) {
                  var hist = (this.history = new History(
                    this.history.maxGeneration
                  ));
                  (hist.done = copyHistoryArray(
                    histData.done.slice(0),
                    null,
                    !0
                  )),
                    (hist.undone = copyHistoryArray(
                      histData.undone.slice(0),
                      null,
                      !0
                    ));
                },
                setGutterMarker: docMethodOp(function(line, gutterID, value) {
                  return changeLine(this, line, "gutter", function(line) {
                    var markers =
                      line.gutterMarkers || (line.gutterMarkers = {});
                    return (
                      !(markers[gutterID] = value) &&
                        isEmpty(markers) &&
                        (line.gutterMarkers = null),
                      !0
                    );
                  });
                }),
                clearGutter: docMethodOp(function(gutterID) {
                  var this$1 = this;
                  this.iter(function(line) {
                    line.gutterMarkers &&
                      line.gutterMarkers[gutterID] &&
                      changeLine(this$1, line, "gutter", function() {
                        return (
                          (line.gutterMarkers[gutterID] = null),
                          isEmpty(line.gutterMarkers) &&
                            (line.gutterMarkers = null),
                          !0
                        );
                      });
                  });
                }),
                lineInfo: function(line) {
                  var n;
                  if ("number" == typeof line) {
                    if (!isLine(this, line)) return null;
                    if (!(line = getLine(this, (n = line)))) return null;
                  } else if (null == (n = lineNo(line))) return null;
                  return {
                    line: n,
                    handle: line,
                    text: line.text,
                    gutterMarkers: line.gutterMarkers,
                    textClass: line.textClass,
                    bgClass: line.bgClass,
                    wrapClass: line.wrapClass,
                    widgets: line.widgets
                  };
                },
                addLineClass: docMethodOp(function(handle, where, cls) {
                  return changeLine(
                    this,
                    handle,
                    "gutter" == where ? "gutter" : "class",
                    function(line) {
                      var prop =
                        "text" == where
                          ? "textClass"
                          : "background" == where
                            ? "bgClass"
                            : "gutter" == where ? "gutterClass" : "wrapClass";
                      if (line[prop]) {
                        if (classTest(cls).test(line[prop])) return !1;
                        line[prop] += " " + cls;
                      } else line[prop] = cls;
                      return !0;
                    }
                  );
                }),
                removeLineClass: docMethodOp(function(handle, where, cls) {
                  return changeLine(
                    this,
                    handle,
                    "gutter" == where ? "gutter" : "class",
                    function(line) {
                      var prop =
                          "text" == where
                            ? "textClass"
                            : "background" == where
                              ? "bgClass"
                              : "gutter" == where ? "gutterClass" : "wrapClass",
                        cur = line[prop];
                      if (!cur) return !1;
                      if (null == cls) line[prop] = null;
                      else {
                        var found = cur.match(classTest(cls));
                        if (!found) return !1;
                        var end = found.index + found[0].length;
                        line[prop] =
                          cur.slice(0, found.index) +
                            (found.index && end != cur.length ? " " : "") +
                            cur.slice(end) || null;
                      }
                      return !0;
                    }
                  );
                }),
                addLineWidget: docMethodOp(function(handle, node, options) {
                  return (function(doc, handle, node, options) {
                    var widget = new LineWidget(doc, node, options),
                      cm = doc.cm;
                    return (
                      cm && widget.noHScroll && (cm.display.alignWidgets = !0),
                      changeLine(doc, handle, "widget", function(line) {
                        var widgets = line.widgets || (line.widgets = []);
                        if (
                          (null == widget.insertAt
                            ? widgets.push(widget)
                            : widgets.splice(
                                Math.min(
                                  widgets.length - 1,
                                  Math.max(0, widget.insertAt)
                                ),
                                0,
                                widget
                              ),
                          (widget.line = line),
                          cm && !lineIsHidden(doc, line))
                        ) {
                          var aboveVisible = heightAtLine(line) < doc.scrollTop;
                          updateLineHeight(
                            line,
                            line.height + widgetHeight(widget)
                          ),
                            aboveVisible && addToScrollTop(cm, widget.height),
                            (cm.curOp.forceUpdate = !0);
                        }
                        return !0;
                      }),
                      cm &&
                        signalLater(
                          cm,
                          "lineWidgetAdded",
                          cm,
                          widget,
                          "number" == typeof handle ? handle : lineNo(handle)
                        ),
                      widget
                    );
                  })(this, handle, node, options);
                }),
                removeLineWidget: function(widget) {
                  widget.clear();
                },
                markText: function(from, to, options) {
                  return markText(
                    this,
                    clipPos(this, from),
                    clipPos(this, to),
                    options,
                    (options && options.type) || "range"
                  );
                },
                setBookmark: function(pos, options) {
                  var realOpts = {
                    replacedWith:
                      options &&
                      (null == options.nodeType ? options.widget : options),
                    insertLeft: options && options.insertLeft,
                    clearWhenEmpty: !1,
                    shared: options && options.shared,
                    handleMouseEvents: options && options.handleMouseEvents
                  };
                  return markText(
                    this,
                    (pos = clipPos(this, pos)),
                    pos,
                    realOpts,
                    "bookmark"
                  );
                },
                findMarksAt: function(pos) {
                  var markers = [],
                    spans = getLine(this, (pos = clipPos(this, pos)).line)
                      .markedSpans;
                  if (spans)
                    for (var i = 0; i < spans.length; ++i) {
                      var span = spans[i];
                      (null == span.from || span.from <= pos.ch) &&
                        (null == span.to || span.to >= pos.ch) &&
                        markers.push(span.marker.parent || span.marker);
                    }
                  return markers;
                },
                findMarks: function(from, to, filter) {
                  (from = clipPos(this, from)), (to = clipPos(this, to));
                  var found = [],
                    lineNo$$1 = from.line;
                  return (
                    this.iter(from.line, to.line + 1, function(line) {
                      var spans = line.markedSpans;
                      if (spans)
                        for (var i = 0; i < spans.length; i++) {
                          var span = spans[i];
                          (null != span.to &&
                            lineNo$$1 == from.line &&
                            from.ch >= span.to) ||
                            (null == span.from && lineNo$$1 != from.line) ||
                            (null != span.from &&
                              lineNo$$1 == to.line &&
                              span.from >= to.ch) ||
                            (filter && !filter(span.marker)) ||
                            found.push(span.marker.parent || span.marker);
                        }
                      ++lineNo$$1;
                    }),
                    found
                  );
                },
                getAllMarks: function() {
                  var markers = [];
                  return (
                    this.iter(function(line) {
                      var sps = line.markedSpans;
                      if (sps)
                        for (var i = 0; i < sps.length; ++i)
                          null != sps[i].from && markers.push(sps[i].marker);
                    }),
                    markers
                  );
                },
                posFromIndex: function(off) {
                  var ch,
                    lineNo$$1 = this.first,
                    sepSize = this.lineSeparator().length;
                  return (
                    this.iter(function(line) {
                      var sz = line.text.length + sepSize;
                      if (off < sz) return (ch = off), !0;
                      (off -= sz), ++lineNo$$1;
                    }),
                    clipPos(this, Pos(lineNo$$1, ch))
                  );
                },
                indexFromPos: function(coords) {
                  var index = (coords = clipPos(this, coords)).ch;
                  if (coords.line < this.first || coords.ch < 0) return 0;
                  var sepSize = this.lineSeparator().length;
                  return (
                    this.iter(this.first, coords.line, function(line) {
                      index += line.text.length + sepSize;
                    }),
                    index
                  );
                },
                copy: function(copyHistory) {
                  var doc = new Doc(
                    getLines(this, this.first, this.first + this.size),
                    this.modeOption,
                    this.first,
                    this.lineSep,
                    this.direction
                  );
                  return (
                    (doc.scrollTop = this.scrollTop),
                    (doc.scrollLeft = this.scrollLeft),
                    (doc.sel = this.sel),
                    (doc.extend = !1),
                    copyHistory &&
                      ((doc.history.undoDepth = this.history.undoDepth),
                      doc.setHistory(this.getHistory())),
                    doc
                  );
                },
                linkedDoc: function(options) {
                  options || (options = {});
                  var from = this.first,
                    to = this.first + this.size;
                  null != options.from &&
                    options.from > from &&
                    (from = options.from),
                    null != options.to && options.to < to && (to = options.to);
                  var copy = new Doc(
                    getLines(this, from, to),
                    options.mode || this.modeOption,
                    from,
                    this.lineSep,
                    this.direction
                  );
                  return (
                    options.sharedHist && (copy.history = this.history),
                    (this.linked || (this.linked = [])).push({
                      doc: copy,
                      sharedHist: options.sharedHist
                    }),
                    (copy.linked = [
                      {
                        doc: this,
                        isParent: !0,
                        sharedHist: options.sharedHist
                      }
                    ]),
                    (function(doc, markers) {
                      for (var i = 0; i < markers.length; i++) {
                        var marker = markers[i],
                          pos = marker.find(),
                          mFrom = doc.clipPos(pos.from),
                          mTo = doc.clipPos(pos.to);
                        if (cmp(mFrom, mTo)) {
                          var subMark = markText(
                            doc,
                            mFrom,
                            mTo,
                            marker.primary,
                            marker.primary.type
                          );
                          marker.markers.push(subMark),
                            (subMark.parent = marker);
                        }
                      }
                    })(copy, findSharedMarkers(this)),
                    copy
                  );
                },
                unlinkDoc: function(other) {
                  if (
                    (other instanceof CodeMirror$1 && (other = other.doc),
                    this.linked)
                  )
                    for (var i = 0; i < this.linked.length; ++i) {
                      if (this.linked[i].doc == other) {
                        this.linked.splice(i, 1),
                          other.unlinkDoc(this),
                          detachSharedMarkers(findSharedMarkers(this));
                        break;
                      }
                    }
                  if (other.history == this.history) {
                    var splitIds = [other.id];
                    linkedDocs(
                      other,
                      function(doc) {
                        return splitIds.push(doc.id);
                      },
                      !0
                    ),
                      (other.history = new History(null)),
                      (other.history.done = copyHistoryArray(
                        this.history.done,
                        splitIds
                      )),
                      (other.history.undone = copyHistoryArray(
                        this.history.undone,
                        splitIds
                      ));
                  }
                },
                iterLinkedDocs: function(f) {
                  linkedDocs(this, f);
                },
                getMode: function() {
                  return this.mode;
                },
                getEditor: function() {
                  return this.cm;
                },
                splitLines: function(str) {
                  return this.lineSep
                    ? str.split(this.lineSep)
                    : splitLinesAuto(str);
                },
                lineSeparator: function() {
                  return this.lineSep || "\n";
                },
                setDirection: docMethodOp(function(dir) {
                  var cm;
                  ("rtl" != dir && (dir = "ltr"), dir != this.direction) &&
                    ((this.direction = dir),
                    this.iter(function(line) {
                      return (line.order = null);
                    }),
                    this.cm &&
                      runInOp((cm = this.cm), function() {
                        setDirectionClass(cm), regChange(cm);
                      }));
                })
              })),
                (Doc.prototype.eachLine = Doc.prototype.iter);
              var lastDrop = 0;
              function onDrop(e) {
                var cm = this;
                if (
                  (clearDragCursor(cm),
                  !signalDOMEvent(cm, e) && !eventInWidget(cm.display, e))
                ) {
                  e_preventDefault(e), ie && (lastDrop = +new Date());
                  var pos = posFromMouse(cm, e, !0),
                    files = e.dataTransfer.files;
                  if (pos && !cm.isReadOnly())
                    if (
                      files &&
                      files.length &&
                      window.FileReader &&
                      window.File
                    )
                      for (
                        var n = files.length,
                          text = Array(n),
                          read = 0,
                          loadFile = function(file, i) {
                            if (
                              !cm.options.allowDropFileTypes ||
                              -1 !=
                                indexOf(
                                  cm.options.allowDropFileTypes,
                                  file.type
                                )
                            ) {
                              var reader = new FileReader();
                              (reader.onload = operation(cm, function() {
                                var content = reader.result;
                                if (
                                  (/[\x00-\x08\x0e-\x1f]{2}/.test(content) &&
                                    (content = ""),
                                  (text[i] = content),
                                  ++read == n)
                                ) {
                                  var change = {
                                    from: (pos = clipPos(cm.doc, pos)),
                                    to: pos,
                                    text: cm.doc.splitLines(
                                      text.join(cm.doc.lineSeparator())
                                    ),
                                    origin: "paste"
                                  };
                                  makeChange(cm.doc, change),
                                    setSelectionReplaceHistory(
                                      cm.doc,
                                      simpleSelection(pos, changeEnd(change))
                                    );
                                }
                              })),
                                reader.readAsText(file);
                            }
                          },
                          i = 0;
                        i < n;
                        ++i
                      )
                        loadFile(files[i], i);
                    else {
                      if (
                        cm.state.draggingText &&
                        -1 < cm.doc.sel.contains(pos)
                      )
                        return (
                          cm.state.draggingText(e),
                          void setTimeout(function() {
                            return cm.display.input.focus();
                          }, 20)
                        );
                      try {
                        var text$1 = e.dataTransfer.getData("Text");
                        if (text$1) {
                          var selected;
                          if (
                            (cm.state.draggingText &&
                              !cm.state.draggingText.copy &&
                              (selected = cm.listSelections()),
                            setSelectionNoUndo(
                              cm.doc,
                              simpleSelection(pos, pos)
                            ),
                            selected)
                          )
                            for (var i$1 = 0; i$1 < selected.length; ++i$1)
                              replaceRange(
                                cm.doc,
                                "",
                                selected[i$1].anchor,
                                selected[i$1].head,
                                "drag"
                              );
                          cm.replaceSelection(text$1, "around", "paste"),
                            cm.display.input.focus();
                        }
                      } catch (e) {}
                    }
                }
              }
              function clearDragCursor(cm) {
                cm.display.dragCursor &&
                  (cm.display.lineSpace.removeChild(cm.display.dragCursor),
                  (cm.display.dragCursor = null));
              }
              function forEachCodeMirror(f) {
                if (document.getElementsByClassName)
                  for (
                    var byClass = document.getElementsByClassName("CodeMirror"),
                      i = 0;
                    i < byClass.length;
                    i++
                  ) {
                    var cm = byClass[i].CodeMirror;
                    cm && f(cm);
                  }
              }
              var globalsRegistered = !1;
              function ensureGlobalHandlers() {
                var resizeTimer;
                globalsRegistered ||
                  (on(window, "resize", function() {
                    null == resizeTimer &&
                      (resizeTimer = setTimeout(function() {
                        (resizeTimer = null), forEachCodeMirror(onResize);
                      }, 100));
                  }),
                  on(window, "blur", function() {
                    return forEachCodeMirror(onBlur);
                  }),
                  (globalsRegistered = !0));
              }
              function onResize(cm) {
                var d = cm.display;
                (d.lastWrapHeight == d.wrapper.clientHeight &&
                  d.lastWrapWidth == d.wrapper.clientWidth) ||
                  ((d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null),
                  (d.scrollbarsClipped = !1),
                  cm.setSize());
              }
              for (
                var keyNames = {
                    3: "Pause",
                    8: "Backspace",
                    9: "Tab",
                    13: "Enter",
                    16: "Shift",
                    17: "Ctrl",
                    18: "Alt",
                    19: "Pause",
                    20: "CapsLock",
                    27: "Esc",
                    32: "Space",
                    33: "PageUp",
                    34: "PageDown",
                    35: "End",
                    36: "Home",
                    37: "Left",
                    38: "Up",
                    39: "Right",
                    40: "Down",
                    44: "PrintScrn",
                    45: "Insert",
                    46: "Delete",
                    59: ";",
                    61: "=",
                    91: "Mod",
                    92: "Mod",
                    93: "Mod",
                    106: "*",
                    107: "=",
                    109: "-",
                    110: ".",
                    111: "/",
                    127: "Delete",
                    145: "ScrollLock",
                    173: "-",
                    186: ";",
                    187: "=",
                    188: ",",
                    189: "-",
                    190: ".",
                    191: "/",
                    192: "`",
                    219: "[",
                    220: "\\",
                    221: "]",
                    222: "'",
                    63232: "Up",
                    63233: "Down",
                    63234: "Left",
                    63235: "Right",
                    63272: "Delete",
                    63273: "Home",
                    63275: "End",
                    63276: "PageUp",
                    63277: "PageDown",
                    63302: "Insert"
                  },
                  i = 0;
                i < 10;
                i++
              )
                keyNames[i + 48] = keyNames[i + 96] = String(i);
              for (var i$1 = 65; i$1 <= 90; i$1++)
                keyNames[i$1] = String.fromCharCode(i$1);
              for (var i$2 = 1; i$2 <= 12; i$2++)
                keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
              var keyMap = {};
              function normalizeKeyName(name) {
                var alt,
                  ctrl,
                  shift,
                  cmd,
                  parts = name.split(/-(?!$)/);
                name = parts[parts.length - 1];
                for (var i = 0; i < parts.length - 1; i++) {
                  var mod = parts[i];
                  if (/^(cmd|meta|m)$/i.test(mod)) cmd = !0;
                  else if (/^a(lt)?$/i.test(mod)) alt = !0;
                  else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = !0;
                  else {
                    if (!/^s(hift)?$/i.test(mod))
                      throw new Error("Unrecognized modifier name: " + mod);
                    shift = !0;
                  }
                }
                return (
                  alt && (name = "Alt-" + name),
                  ctrl && (name = "Ctrl-" + name),
                  cmd && (name = "Cmd-" + name),
                  shift && (name = "Shift-" + name),
                  name
                );
              }
              function normalizeKeyMap(keymap) {
                var copy = {};
                for (var keyname in keymap)
                  if (keymap.hasOwnProperty(keyname)) {
                    var value = keymap[keyname];
                    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname))
                      continue;
                    if ("..." == value) {
                      delete keymap[keyname];
                      continue;
                    }
                    for (
                      var keys = map(keyname.split(" "), normalizeKeyName),
                        i = 0;
                      i < keys.length;
                      i++
                    ) {
                      var val = void 0,
                        name = void 0;
                      i == keys.length - 1
                        ? ((name = keys.join(" ")), (val = value))
                        : ((name = keys.slice(0, i + 1).join(" ")),
                          (val = "..."));
                      var prev = copy[name];
                      if (prev) {
                        if (prev != val)
                          throw new Error("Inconsistent bindings for " + name);
                      } else copy[name] = val;
                    }
                    delete keymap[keyname];
                  }
                for (var prop in copy) keymap[prop] = copy[prop];
                return keymap;
              }
              function lookupKey(key, map$$1, handle, context) {
                var found = (map$$1 = getKeyMap(map$$1)).call
                  ? map$$1.call(key, context)
                  : map$$1[key];
                if (!1 === found) return "nothing";
                if ("..." === found) return "multi";
                if (null != found && handle(found)) return "handled";
                if (map$$1.fallthrough) {
                  if (
                    "[object Array]" !=
                    Object.prototype.toString.call(map$$1.fallthrough)
                  )
                    return lookupKey(key, map$$1.fallthrough, handle, context);
                  for (var i = 0; i < map$$1.fallthrough.length; i++) {
                    var result = lookupKey(
                      key,
                      map$$1.fallthrough[i],
                      handle,
                      context
                    );
                    if (result) return result;
                  }
                }
              }
              function isModifierKey(value) {
                var name =
                  "string" == typeof value ? value : keyNames[value.keyCode];
                return (
                  "Ctrl" == name ||
                  "Alt" == name ||
                  "Shift" == name ||
                  "Mod" == name
                );
              }
              function addModifierNames(name, event, noShift) {
                var base = name;
                return (
                  event.altKey && "Alt" != base && (name = "Alt-" + name),
                  (flipCtrlCmd ? event.metaKey : event.ctrlKey) &&
                    "Ctrl" != base &&
                    (name = "Ctrl-" + name),
                  (flipCtrlCmd ? event.ctrlKey : event.metaKey) &&
                    "Cmd" != base &&
                    (name = "Cmd-" + name),
                  !noShift &&
                    event.shiftKey &&
                    "Shift" != base &&
                    (name = "Shift-" + name),
                  name
                );
              }
              function keyName(event, noShift) {
                if (presto && 34 == event.keyCode && event.char) return !1;
                var name = keyNames[event.keyCode];
                return (
                  null != name &&
                  !event.altGraphKey &&
                  (3 == event.keyCode && event.code && (name = event.code),
                  addModifierNames(name, event, noShift))
                );
              }
              function getKeyMap(val) {
                return "string" == typeof val ? keyMap[val] : val;
              }
              function deleteNearSelection(cm, compute) {
                for (
                  var ranges = cm.doc.sel.ranges, kill = [], i = 0;
                  i < ranges.length;
                  i++
                ) {
                  for (
                    var toKill = compute(ranges[i]);
                    kill.length && cmp(toKill.from, lst(kill).to) <= 0;

                  ) {
                    var replaced = kill.pop();
                    if (cmp(replaced.from, toKill.from) < 0) {
                      toKill.from = replaced.from;
                      break;
                    }
                  }
                  kill.push(toKill);
                }
                runInOp(cm, function() {
                  for (var i = kill.length - 1; 0 <= i; i--)
                    replaceRange(
                      cm.doc,
                      "",
                      kill[i].from,
                      kill[i].to,
                      "+delete"
                    );
                  ensureCursorVisible(cm);
                });
              }
              function moveCharLogically(line, ch, dir) {
                var target = skipExtendingChars(line.text, ch + dir, dir);
                return target < 0 || target > line.text.length ? null : target;
              }
              function moveLogically(line, start, dir) {
                var ch = moveCharLogically(line, start.ch, dir);
                return null == ch
                  ? null
                  : new Pos(start.line, ch, dir < 0 ? "after" : "before");
              }
              function endOfLine(visually, cm, lineObj, lineNo, dir) {
                if (visually) {
                  var order = getOrder(lineObj, cm.doc.direction);
                  if (order) {
                    var ch,
                      part = dir < 0 ? lst(order) : order[0],
                      sticky =
                        dir < 0 == (1 == part.level) ? "after" : "before";
                    if (0 < part.level || "rtl" == cm.doc.direction) {
                      var prep = prepareMeasureForLine(cm, lineObj);
                      ch = dir < 0 ? lineObj.text.length - 1 : 0;
                      var targetTop = measureCharPrepared(cm, prep, ch).top;
                      (ch = findFirst(
                        function(ch) {
                          return (
                            measureCharPrepared(cm, prep, ch).top == targetTop
                          );
                        },
                        dir < 0 == (1 == part.level) ? part.from : part.to - 1,
                        ch
                      )),
                        "before" == sticky &&
                          (ch = moveCharLogically(lineObj, ch, 1));
                    } else ch = dir < 0 ? part.to : part.from;
                    return new Pos(lineNo, ch, sticky);
                  }
                }
                return new Pos(
                  lineNo,
                  dir < 0 ? lineObj.text.length : 0,
                  dir < 0 ? "before" : "after"
                );
              }
              (keyMap.basic = {
                Left: "goCharLeft",
                Right: "goCharRight",
                Up: "goLineUp",
                Down: "goLineDown",
                End: "goLineEnd",
                Home: "goLineStartSmart",
                PageUp: "goPageUp",
                PageDown: "goPageDown",
                Delete: "delCharAfter",
                Backspace: "delCharBefore",
                "Shift-Backspace": "delCharBefore",
                Tab: "defaultTab",
                "Shift-Tab": "indentAuto",
                Enter: "newlineAndIndent",
                Insert: "toggleOverwrite",
                Esc: "singleSelection"
              }),
                (keyMap.pcDefault = {
                  "Ctrl-A": "selectAll",
                  "Ctrl-D": "deleteLine",
                  "Ctrl-Z": "undo",
                  "Shift-Ctrl-Z": "redo",
                  "Ctrl-Y": "redo",
                  "Ctrl-Home": "goDocStart",
                  "Ctrl-End": "goDocEnd",
                  "Ctrl-Up": "goLineUp",
                  "Ctrl-Down": "goLineDown",
                  "Ctrl-Left": "goGroupLeft",
                  "Ctrl-Right": "goGroupRight",
                  "Alt-Left": "goLineStart",
                  "Alt-Right": "goLineEnd",
                  "Ctrl-Backspace": "delGroupBefore",
                  "Ctrl-Delete": "delGroupAfter",
                  "Ctrl-S": "save",
                  "Ctrl-F": "find",
                  "Ctrl-G": "findNext",
                  "Shift-Ctrl-G": "findPrev",
                  "Shift-Ctrl-F": "replace",
                  "Shift-Ctrl-R": "replaceAll",
                  "Ctrl-[": "indentLess",
                  "Ctrl-]": "indentMore",
                  "Ctrl-U": "undoSelection",
                  "Shift-Ctrl-U": "redoSelection",
                  "Alt-U": "redoSelection",
                  fallthrough: "basic"
                }),
                (keyMap.emacsy = {
                  "Ctrl-F": "goCharRight",
                  "Ctrl-B": "goCharLeft",
                  "Ctrl-P": "goLineUp",
                  "Ctrl-N": "goLineDown",
                  "Alt-F": "goWordRight",
                  "Alt-B": "goWordLeft",
                  "Ctrl-A": "goLineStart",
                  "Ctrl-E": "goLineEnd",
                  "Ctrl-V": "goPageDown",
                  "Shift-Ctrl-V": "goPageUp",
                  "Ctrl-D": "delCharAfter",
                  "Ctrl-H": "delCharBefore",
                  "Alt-D": "delWordAfter",
                  "Alt-Backspace": "delWordBefore",
                  "Ctrl-K": "killLine",
                  "Ctrl-T": "transposeChars",
                  "Ctrl-O": "openLine"
                }),
                (keyMap.macDefault = {
                  "Cmd-A": "selectAll",
                  "Cmd-D": "deleteLine",
                  "Cmd-Z": "undo",
                  "Shift-Cmd-Z": "redo",
                  "Cmd-Y": "redo",
                  "Cmd-Home": "goDocStart",
                  "Cmd-Up": "goDocStart",
                  "Cmd-End": "goDocEnd",
                  "Cmd-Down": "goDocEnd",
                  "Alt-Left": "goGroupLeft",
                  "Alt-Right": "goGroupRight",
                  "Cmd-Left": "goLineLeft",
                  "Cmd-Right": "goLineRight",
                  "Alt-Backspace": "delGroupBefore",
                  "Ctrl-Alt-Backspace": "delGroupAfter",
                  "Alt-Delete": "delGroupAfter",
                  "Cmd-S": "save",
                  "Cmd-F": "find",
                  "Cmd-G": "findNext",
                  "Shift-Cmd-G": "findPrev",
                  "Cmd-Alt-F": "replace",
                  "Shift-Cmd-Alt-F": "replaceAll",
                  "Cmd-[": "indentLess",
                  "Cmd-]": "indentMore",
                  "Cmd-Backspace": "delWrappedLineLeft",
                  "Cmd-Delete": "delWrappedLineRight",
                  "Cmd-U": "undoSelection",
                  "Shift-Cmd-U": "redoSelection",
                  "Ctrl-Up": "goDocStart",
                  "Ctrl-Down": "goDocEnd",
                  fallthrough: ["basic", "emacsy"]
                }),
                (keyMap.default = mac ? keyMap.macDefault : keyMap.pcDefault);
              var commands = {
                selectAll: selectAll,
                singleSelection: function(cm) {
                  return cm.setSelection(
                    cm.getCursor("anchor"),
                    cm.getCursor("head"),
                    sel_dontScroll
                  );
                },
                killLine: function(cm) {
                  return deleteNearSelection(cm, function(range) {
                    if (range.empty()) {
                      var len = getLine(cm.doc, range.head.line).text.length;
                      return range.head.ch == len &&
                        range.head.line < cm.lastLine()
                        ? { from: range.head, to: Pos(range.head.line + 1, 0) }
                        : { from: range.head, to: Pos(range.head.line, len) };
                    }
                    return { from: range.from(), to: range.to() };
                  });
                },
                deleteLine: function(cm) {
                  return deleteNearSelection(cm, function(range) {
                    return {
                      from: Pos(range.from().line, 0),
                      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
                    };
                  });
                },
                delLineLeft: function(cm) {
                  return deleteNearSelection(cm, function(range) {
                    return {
                      from: Pos(range.from().line, 0),
                      to: range.from()
                    };
                  });
                },
                delWrappedLineLeft: function(cm) {
                  return deleteNearSelection(cm, function(range) {
                    var top = cm.charCoords(range.head, "div").top + 5;
                    return {
                      from: cm.coordsChar({ left: 0, top: top }, "div"),
                      to: range.from()
                    };
                  });
                },
                delWrappedLineRight: function(cm) {
                  return deleteNearSelection(cm, function(range) {
                    var top = cm.charCoords(range.head, "div").top + 5,
                      rightPos = cm.coordsChar(
                        {
                          left: cm.display.lineDiv.offsetWidth + 100,
                          top: top
                        },
                        "div"
                      );
                    return { from: range.from(), to: rightPos };
                  });
                },
                undo: function(cm) {
                  return cm.undo();
                },
                redo: function(cm) {
                  return cm.redo();
                },
                undoSelection: function(cm) {
                  return cm.undoSelection();
                },
                redoSelection: function(cm) {
                  return cm.redoSelection();
                },
                goDocStart: function(cm) {
                  return cm.extendSelection(Pos(cm.firstLine(), 0));
                },
                goDocEnd: function(cm) {
                  return cm.extendSelection(Pos(cm.lastLine()));
                },
                goLineStart: function(cm) {
                  return cm.extendSelectionsBy(
                    function(range) {
                      return lineStart(cm, range.head.line);
                    },
                    { origin: "+move", bias: 1 }
                  );
                },
                goLineStartSmart: function(cm) {
                  return cm.extendSelectionsBy(
                    function(range) {
                      return lineStartSmart(cm, range.head);
                    },
                    { origin: "+move", bias: 1 }
                  );
                },
                goLineEnd: function(cm) {
                  return cm.extendSelectionsBy(
                    function(range) {
                      return (function(cm, lineN) {
                        var line = getLine(cm.doc, lineN),
                          visual = (function(line) {
                            for (
                              var merged;
                              (merged = collapsedSpanAtEnd(line));

                            )
                              line = merged.find(1, !0).line;
                            return line;
                          })(line);
                        visual != line && (lineN = lineNo(visual));
                        return endOfLine(!0, cm, line, lineN, -1);
                      })(cm, range.head.line);
                    },
                    { origin: "+move", bias: -1 }
                  );
                },
                goLineRight: function(cm) {
                  return cm.extendSelectionsBy(function(range) {
                    var top = cm.cursorCoords(range.head, "div").top + 5;
                    return cm.coordsChar(
                      { left: cm.display.lineDiv.offsetWidth + 100, top: top },
                      "div"
                    );
                  }, sel_move);
                },
                goLineLeft: function(cm) {
                  return cm.extendSelectionsBy(function(range) {
                    var top = cm.cursorCoords(range.head, "div").top + 5;
                    return cm.coordsChar({ left: 0, top: top }, "div");
                  }, sel_move);
                },
                goLineLeftSmart: function(cm) {
                  return cm.extendSelectionsBy(function(range) {
                    var top = cm.cursorCoords(range.head, "div").top + 5,
                      pos = cm.coordsChar({ left: 0, top: top }, "div");
                    return pos.ch < cm.getLine(pos.line).search(/\S/)
                      ? lineStartSmart(cm, range.head)
                      : pos;
                  }, sel_move);
                },
                goLineUp: function(cm) {
                  return cm.moveV(-1, "line");
                },
                goLineDown: function(cm) {
                  return cm.moveV(1, "line");
                },
                goPageUp: function(cm) {
                  return cm.moveV(-1, "page");
                },
                goPageDown: function(cm) {
                  return cm.moveV(1, "page");
                },
                goCharLeft: function(cm) {
                  return cm.moveH(-1, "char");
                },
                goCharRight: function(cm) {
                  return cm.moveH(1, "char");
                },
                goColumnLeft: function(cm) {
                  return cm.moveH(-1, "column");
                },
                goColumnRight: function(cm) {
                  return cm.moveH(1, "column");
                },
                goWordLeft: function(cm) {
                  return cm.moveH(-1, "word");
                },
                goGroupRight: function(cm) {
                  return cm.moveH(1, "group");
                },
                goGroupLeft: function(cm) {
                  return cm.moveH(-1, "group");
                },
                goWordRight: function(cm) {
                  return cm.moveH(1, "word");
                },
                delCharBefore: function(cm) {
                  return cm.deleteH(-1, "char");
                },
                delCharAfter: function(cm) {
                  return cm.deleteH(1, "char");
                },
                delWordBefore: function(cm) {
                  return cm.deleteH(-1, "word");
                },
                delWordAfter: function(cm) {
                  return cm.deleteH(1, "word");
                },
                delGroupBefore: function(cm) {
                  return cm.deleteH(-1, "group");
                },
                delGroupAfter: function(cm) {
                  return cm.deleteH(1, "group");
                },
                indentAuto: function(cm) {
                  return cm.indentSelection("smart");
                },
                indentMore: function(cm) {
                  return cm.indentSelection("add");
                },
                indentLess: function(cm) {
                  return cm.indentSelection("subtract");
                },
                insertTab: function(cm) {
                  return cm.replaceSelection("\t");
                },
                insertSoftTab: function(cm) {
                  for (
                    var spaces = [],
                      ranges = cm.listSelections(),
                      tabSize = cm.options.tabSize,
                      i = 0;
                    i < ranges.length;
                    i++
                  ) {
                    var pos = ranges[i].from(),
                      col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                    spaces.push(spaceStr(tabSize - col % tabSize));
                  }
                  cm.replaceSelections(spaces);
                },
                defaultTab: function(cm) {
                  cm.somethingSelected()
                    ? cm.indentSelection("add")
                    : cm.execCommand("insertTab");
                },
                transposeChars: function(cm) {
                  return runInOp(cm, function() {
                    for (
                      var ranges = cm.listSelections(), newSel = [], i = 0;
                      i < ranges.length;
                      i++
                    )
                      if (ranges[i].empty()) {
                        var cur = ranges[i].head,
                          line = getLine(cm.doc, cur.line).text;
                        if (line)
                          if (
                            (cur.ch == line.length &&
                              (cur = new Pos(cur.line, cur.ch - 1)),
                            0 < cur.ch)
                          )
                            (cur = new Pos(cur.line, cur.ch + 1)),
                              cm.replaceRange(
                                line.charAt(cur.ch - 1) +
                                  line.charAt(cur.ch - 2),
                                Pos(cur.line, cur.ch - 2),
                                cur,
                                "+transpose"
                              );
                          else if (cur.line > cm.doc.first) {
                            var prev = getLine(cm.doc, cur.line - 1).text;
                            prev &&
                              ((cur = new Pos(cur.line, 1)),
                              cm.replaceRange(
                                line.charAt(0) +
                                  cm.doc.lineSeparator() +
                                  prev.charAt(prev.length - 1),
                                Pos(cur.line - 1, prev.length - 1),
                                cur,
                                "+transpose"
                              ));
                          }
                        newSel.push(new Range(cur, cur));
                      }
                    cm.setSelections(newSel);
                  });
                },
                newlineAndIndent: function(cm) {
                  return runInOp(cm, function() {
                    for (
                      var sels = cm.listSelections(), i = sels.length - 1;
                      0 <= i;
                      i--
                    )
                      cm.replaceRange(
                        cm.doc.lineSeparator(),
                        sels[i].anchor,
                        sels[i].head,
                        "+input"
                      );
                    sels = cm.listSelections();
                    for (var i$1 = 0; i$1 < sels.length; i$1++)
                      cm.indentLine(sels[i$1].from().line, null, !0);
                    ensureCursorVisible(cm);
                  });
                },
                openLine: function(cm) {
                  return cm.replaceSelection("\n", "start");
                },
                toggleOverwrite: function(cm) {
                  return cm.toggleOverwrite();
                }
              };
              function lineStart(cm, lineN) {
                var line = getLine(cm.doc, lineN),
                  visual = visualLine(line);
                return (
                  visual != line && (lineN = lineNo(visual)),
                  endOfLine(!0, cm, visual, lineN, 1)
                );
              }
              function lineStartSmart(cm, pos) {
                var start = lineStart(cm, pos.line),
                  line = getLine(cm.doc, start.line),
                  order = getOrder(line, cm.doc.direction);
                if (!order || 0 == order[0].level) {
                  var firstNonWS = Math.max(0, line.text.search(/\S/)),
                    inWS =
                      pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
                  return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
                }
                return start;
              }
              function doHandleBinding(cm, bound, dropShift) {
                if ("string" == typeof bound && !(bound = commands[bound]))
                  return !1;
                cm.display.input.ensurePolled();
                var prevShift = cm.display.shift,
                  done = !1;
                try {
                  cm.isReadOnly() && (cm.state.suppressEdits = !0),
                    dropShift && (cm.display.shift = !1),
                    (done = bound(cm) != Pass);
                } finally {
                  (cm.display.shift = prevShift), (cm.state.suppressEdits = !1);
                }
                return done;
              }
              var stopSeq = new Delayed();
              function dispatchKey(cm, name, e, handle) {
                var seq = cm.state.keySeq;
                if (seq) {
                  if (isModifierKey(name)) return "handled";
                  if (
                    (/\'$/.test(name)
                      ? (cm.state.keySeq = null)
                      : stopSeq.set(50, function() {
                          cm.state.keySeq == seq &&
                            ((cm.state.keySeq = null),
                            cm.display.input.reset());
                        }),
                    dispatchKeyInner(cm, seq + " " + name, e, handle))
                  )
                    return !0;
                }
                return dispatchKeyInner(cm, name, e, handle);
              }
              function dispatchKeyInner(cm, name, e, handle) {
                var result = (function(cm, name, handle) {
                  for (var i = 0; i < cm.state.keyMaps.length; i++) {
                    var result = lookupKey(
                      name,
                      cm.state.keyMaps[i],
                      handle,
                      cm
                    );
                    if (result) return result;
                  }
                  return (
                    (cm.options.extraKeys &&
                      lookupKey(name, cm.options.extraKeys, handle, cm)) ||
                    lookupKey(name, cm.options.keyMap, handle, cm)
                  );
                })(cm, name, handle);
                return (
                  "multi" == result && (cm.state.keySeq = name),
                  "handled" == result &&
                    signalLater(cm, "keyHandled", cm, name, e),
                  ("handled" != result && "multi" != result) ||
                    (e_preventDefault(e), restartBlink(cm)),
                  !!result
                );
              }
              function handleKeyBinding(cm, e) {
                var name = keyName(e, !0);
                return (
                  !!name &&
                  (e.shiftKey && !cm.state.keySeq
                    ? dispatchKey(cm, "Shift-" + name, e, function(b) {
                        return doHandleBinding(cm, b, !0);
                      }) ||
                      dispatchKey(cm, name, e, function(b) {
                        if (
                          "string" == typeof b ? /^go[A-Z]/.test(b) : b.motion
                        )
                          return doHandleBinding(cm, b);
                      })
                    : dispatchKey(cm, name, e, function(b) {
                        return doHandleBinding(cm, b);
                      }))
                );
              }
              var lastStoppedKey = null;
              function onKeyDown(e) {
                var cm = this;
                if (((cm.curOp.focus = activeElt()), !signalDOMEvent(cm, e))) {
                  ie &&
                    ie_version < 11 &&
                    27 == e.keyCode &&
                    (e.returnValue = !1);
                  var code = e.keyCode;
                  cm.display.shift = 16 == code || e.shiftKey;
                  var handled = handleKeyBinding(cm, e);
                  presto &&
                    ((lastStoppedKey = handled ? code : null),
                    !handled &&
                      88 == code &&
                      !hasCopyEvent &&
                      (mac ? e.metaKey : e.ctrlKey) &&
                      cm.replaceSelection("", null, "cut")),
                    18 != code ||
                      /\bCodeMirror-crosshair\b/.test(
                        cm.display.lineDiv.className
                      ) ||
                      (function(cm) {
                        var lineDiv = cm.display.lineDiv;
                        function up(e) {
                          (18 != e.keyCode && e.altKey) ||
                            (rmClass(lineDiv, "CodeMirror-crosshair"),
                            off(document, "keyup", up),
                            off(document, "mouseover", up));
                        }
                        addClass(lineDiv, "CodeMirror-crosshair"),
                          on(document, "keyup", up),
                          on(document, "mouseover", up);
                      })(cm);
                }
              }
              function onKeyUp(e) {
                16 == e.keyCode && (this.doc.sel.shift = !1),
                  signalDOMEvent(this, e);
              }
              function onKeyPress(e) {
                var cm = this;
                if (
                  !(
                    eventInWidget(cm.display, e) ||
                    signalDOMEvent(cm, e) ||
                    (e.ctrlKey && !e.altKey) ||
                    (mac && e.metaKey)
                  )
                ) {
                  var keyCode = e.keyCode,
                    charCode = e.charCode;
                  if (presto && keyCode == lastStoppedKey)
                    return (lastStoppedKey = null), void e_preventDefault(e);
                  if (
                    !presto ||
                    (e.which && !(e.which < 10)) ||
                    !handleKeyBinding(cm, e)
                  ) {
                    var ch = String.fromCharCode(
                      null == charCode ? keyCode : charCode
                    );
                    "\b" != ch &&
                      ((function(cm, e, ch) {
                        return dispatchKey(cm, "'" + ch + "'", e, function(b) {
                          return doHandleBinding(cm, b, !0);
                        });
                      })(cm, e, ch) ||
                        cm.display.input.onKeyPress(e));
                  }
                }
              }
              var lastClick,
                lastDoubleClick,
                PastClick = function(time, pos, button) {
                  (this.time = time), (this.pos = pos), (this.button = button);
                };
              function onMouseDown(e) {
                var cm = this,
                  display = cm.display;
                if (
                  !(
                    signalDOMEvent(cm, e) ||
                    (display.activeTouch && display.input.supportsTouch())
                  )
                )
                  if (
                    (display.input.ensurePolled(),
                    (display.shift = e.shiftKey),
                    eventInWidget(display, e))
                  )
                    webkit ||
                      ((display.scroller.draggable = !1),
                      setTimeout(function() {
                        return (display.scroller.draggable = !0);
                      }, 100));
                  else if (!clickInGutter(cm, e)) {
                    var pos = posFromMouse(cm, e),
                      button = e_button(e),
                      repeat = pos
                        ? (function(pos, button) {
                            var now = +new Date();
                            return lastDoubleClick &&
                              lastDoubleClick.compare(now, pos, button)
                              ? ((lastClick = lastDoubleClick = null), "triple")
                              : lastClick && lastClick.compare(now, pos, button)
                                ? ((lastDoubleClick = new PastClick(
                                    now,
                                    pos,
                                    button
                                  )),
                                  (lastClick = null),
                                  "double")
                                : ((lastClick = new PastClick(
                                    now,
                                    pos,
                                    button
                                  )),
                                  (lastDoubleClick = null),
                                  "single");
                          })(pos, button)
                        : "single";
                    window.focus(),
                      1 == button &&
                        cm.state.selectingText &&
                        cm.state.selectingText(e),
                      (pos &&
                        (function(cm, button, pos, repeat, event) {
                          var name = "Click";
                          "double" == repeat
                            ? (name = "Double" + name)
                            : "triple" == repeat && (name = "Triple" + name);
                          return dispatchKey(
                            cm,
                            addModifierNames(
                              (name =
                                (1 == button
                                  ? "Left"
                                  : 2 == button ? "Middle" : "Right") + name),
                              event
                            ),
                            event,
                            function(bound) {
                              if (
                                ("string" == typeof bound &&
                                  (bound = commands[bound]),
                                !bound)
                              )
                                return !1;
                              var done = !1;
                              try {
                                cm.isReadOnly() &&
                                  (cm.state.suppressEdits = !0),
                                  (done = bound(cm, pos) != Pass);
                              } finally {
                                cm.state.suppressEdits = !1;
                              }
                              return done;
                            }
                          );
                        })(cm, button, pos, repeat, e)) ||
                        (1 == button
                          ? pos
                            ? (function(cm, pos, repeat, event) {
                                ie
                                  ? setTimeout(bind(ensureFocus, cm), 0)
                                  : (cm.curOp.focus = activeElt());
                                var contained,
                                  behavior = (function(cm, repeat, event) {
                                    var option = cm.getOption("configureMouse"),
                                      value = option
                                        ? option(cm, repeat, event)
                                        : {};
                                    if (null == value.unit) {
                                      var rect = chromeOS
                                        ? event.shiftKey && event.metaKey
                                        : event.altKey;
                                      value.unit = rect
                                        ? "rectangle"
                                        : "single" == repeat
                                          ? "char"
                                          : "double" == repeat
                                            ? "word"
                                            : "line";
                                    }
                                    (null == value.extend || cm.doc.extend) &&
                                      (value.extend =
                                        cm.doc.extend || event.shiftKey);
                                    null == value.addNew &&
                                      (value.addNew = mac
                                        ? event.metaKey
                                        : event.ctrlKey);
                                    null == value.moveOnDrag &&
                                      (value.moveOnDrag = !(mac
                                        ? event.altKey
                                        : event.ctrlKey));
                                    return value;
                                  })(cm, repeat, event),
                                  sel = cm.doc.sel;
                                cm.options.dragDrop &&
                                dragAndDrop &&
                                !cm.isReadOnly() &&
                                "single" == repeat &&
                                -1 < (contained = sel.contains(pos)) &&
                                (cmp(
                                  (contained = sel.ranges[contained]).from(),
                                  pos
                                ) < 0 ||
                                  0 < pos.xRel) &&
                                (0 < cmp(contained.to(), pos) || pos.xRel < 0)
                                  ? (function(cm, event, pos, behavior) {
                                      var display = cm.display,
                                        moved = !1,
                                        dragEnd = operation(cm, function(e) {
                                          webkit &&
                                            (display.scroller.draggable = !1),
                                            (cm.state.draggingText = !1),
                                            off(document, "mouseup", dragEnd),
                                            off(
                                              document,
                                              "mousemove",
                                              mouseMove
                                            ),
                                            off(
                                              display.scroller,
                                              "dragstart",
                                              dragStart
                                            ),
                                            off(
                                              display.scroller,
                                              "drop",
                                              dragEnd
                                            ),
                                            moved ||
                                              (e_preventDefault(e),
                                              behavior.addNew ||
                                                extendSelection(
                                                  cm.doc,
                                                  pos,
                                                  null,
                                                  null,
                                                  behavior.extend
                                                ),
                                              webkit || (ie && 9 == ie_version)
                                                ? setTimeout(function() {
                                                    document.body.focus(),
                                                      display.input.focus();
                                                  }, 20)
                                                : display.input.focus());
                                        }),
                                        mouseMove = function(e2) {
                                          moved =
                                            moved ||
                                            10 <=
                                              Math.abs(
                                                event.clientX - e2.clientX
                                              ) +
                                                Math.abs(
                                                  event.clientY - e2.clientY
                                                );
                                        },
                                        dragStart = function() {
                                          return (moved = !0);
                                        };
                                      webkit &&
                                        (display.scroller.draggable = !0);
                                      ((cm.state.draggingText = dragEnd).copy = !behavior.moveOnDrag),
                                        display.scroller.dragDrop &&
                                          display.scroller.dragDrop();
                                      on(document, "mouseup", dragEnd),
                                        on(document, "mousemove", mouseMove),
                                        on(
                                          display.scroller,
                                          "dragstart",
                                          dragStart
                                        ),
                                        on(display.scroller, "drop", dragEnd),
                                        delayBlurEvent(cm),
                                        setTimeout(function() {
                                          return display.input.focus();
                                        }, 20);
                                    })(cm, event, pos, behavior)
                                  : (function(cm, event, start, behavior) {
                                      var display = cm.display,
                                        doc = cm.doc;
                                      e_preventDefault(event);
                                      var ourRange,
                                        ourIndex,
                                        startSel = doc.sel,
                                        ranges = startSel.ranges;
                                      behavior.addNew && !behavior.extend
                                        ? ((ourIndex = doc.sel.contains(start)),
                                          (ourRange =
                                            -1 < ourIndex
                                              ? ranges[ourIndex]
                                              : new Range(start, start)))
                                        : ((ourRange = doc.sel.primary()),
                                          (ourIndex = doc.sel.primIndex));
                                      if ("rectangle" == behavior.unit)
                                        behavior.addNew ||
                                          (ourRange = new Range(start, start)),
                                          (start = posFromMouse(
                                            cm,
                                            event,
                                            !0,
                                            !0
                                          )),
                                          (ourIndex = -1);
                                      else {
                                        var range$$1 = rangeForUnit(
                                          cm,
                                          start,
                                          behavior.unit
                                        );
                                        ourRange = behavior.extend
                                          ? extendRange(
                                              ourRange,
                                              range$$1.anchor,
                                              range$$1.head,
                                              behavior.extend
                                            )
                                          : range$$1;
                                      }
                                      behavior.addNew
                                        ? -1 == ourIndex
                                          ? ((ourIndex = ranges.length),
                                            setSelection(
                                              doc,
                                              normalizeSelection(
                                                ranges.concat([ourRange]),
                                                ourIndex
                                              ),
                                              { scroll: !1, origin: "*mouse" }
                                            ))
                                          : 1 < ranges.length &&
                                            ranges[ourIndex].empty() &&
                                            "char" == behavior.unit &&
                                            !behavior.extend
                                            ? (setSelection(
                                                doc,
                                                normalizeSelection(
                                                  ranges
                                                    .slice(0, ourIndex)
                                                    .concat(
                                                      ranges.slice(ourIndex + 1)
                                                    ),
                                                  0
                                                ),
                                                { scroll: !1, origin: "*mouse" }
                                              ),
                                              (startSel = doc.sel))
                                            : replaceOneSelection(
                                                doc,
                                                ourIndex,
                                                ourRange,
                                                sel_mouse
                                              )
                                        : (setSelection(
                                            doc,
                                            new Selection(
                                              [ourRange],
                                              (ourIndex = 0)
                                            ),
                                            sel_mouse
                                          ),
                                          (startSel = doc.sel));
                                      var lastPos = start;
                                      function extendTo(pos) {
                                        if (0 != cmp(lastPos, pos))
                                          if (
                                            ((lastPos = pos),
                                            "rectangle" == behavior.unit)
                                          ) {
                                            for (
                                              var ranges = [],
                                                tabSize = cm.options.tabSize,
                                                startCol = countColumn(
                                                  getLine(doc, start.line).text,
                                                  start.ch,
                                                  tabSize
                                                ),
                                                posCol = countColumn(
                                                  getLine(doc, pos.line).text,
                                                  pos.ch,
                                                  tabSize
                                                ),
                                                left = Math.min(
                                                  startCol,
                                                  posCol
                                                ),
                                                right = Math.max(
                                                  startCol,
                                                  posCol
                                                ),
                                                line = Math.min(
                                                  start.line,
                                                  pos.line
                                                ),
                                                end = Math.min(
                                                  cm.lastLine(),
                                                  Math.max(start.line, pos.line)
                                                );
                                              line <= end;
                                              line++
                                            ) {
                                              var text = getLine(doc, line)
                                                  .text,
                                                leftPos = findColumn(
                                                  text,
                                                  left,
                                                  tabSize
                                                );
                                              left == right
                                                ? ranges.push(
                                                    new Range(
                                                      Pos(line, leftPos),
                                                      Pos(line, leftPos)
                                                    )
                                                  )
                                                : text.length > leftPos &&
                                                  ranges.push(
                                                    new Range(
                                                      Pos(line, leftPos),
                                                      Pos(
                                                        line,
                                                        findColumn(
                                                          text,
                                                          right,
                                                          tabSize
                                                        )
                                                      )
                                                    )
                                                  );
                                            }
                                            ranges.length ||
                                              ranges.push(
                                                new Range(start, start)
                                              ),
                                              setSelection(
                                                doc,
                                                normalizeSelection(
                                                  startSel.ranges
                                                    .slice(0, ourIndex)
                                                    .concat(ranges),
                                                  ourIndex
                                                ),
                                                { origin: "*mouse", scroll: !1 }
                                              ),
                                              cm.scrollIntoView(pos);
                                          } else {
                                            var head,
                                              oldRange = ourRange,
                                              range$$1 = rangeForUnit(
                                                cm,
                                                pos,
                                                behavior.unit
                                              ),
                                              anchor = oldRange.anchor;
                                            0 < cmp(range$$1.anchor, anchor)
                                              ? ((head = range$$1.head),
                                                (anchor = minPos(
                                                  oldRange.from(),
                                                  range$$1.anchor
                                                )))
                                              : ((head = range$$1.anchor),
                                                (anchor = maxPos(
                                                  oldRange.to(),
                                                  range$$1.head
                                                )));
                                            var ranges$1 = startSel.ranges.slice(
                                              0
                                            );
                                            (ranges$1[ourIndex] = (function(
                                              cm,
                                              range$$1
                                            ) {
                                              var anchor = range$$1.anchor,
                                                head = range$$1.head,
                                                anchorLine = getLine(
                                                  cm.doc,
                                                  anchor.line
                                                );
                                              if (
                                                0 == cmp(anchor, head) &&
                                                anchor.sticky == head.sticky
                                              )
                                                return range$$1;
                                              var order = getOrder(anchorLine);
                                              if (!order) return range$$1;
                                              var index = getBidiPartAt(
                                                  order,
                                                  anchor.ch,
                                                  anchor.sticky
                                                ),
                                                part = order[index];
                                              if (
                                                part.from != anchor.ch &&
                                                part.to != anchor.ch
                                              )
                                                return range$$1;
                                              var leftSide,
                                                boundary =
                                                  index +
                                                  ((part.from == anchor.ch) ==
                                                  (1 != part.level)
                                                    ? 0
                                                    : 1);
                                              if (
                                                0 == boundary ||
                                                boundary == order.length
                                              )
                                                return range$$1;
                                              if (head.line != anchor.line)
                                                leftSide =
                                                  0 <
                                                  (head.line - anchor.line) *
                                                    ("ltr" == cm.doc.direction
                                                      ? 1
                                                      : -1);
                                              else {
                                                var headIndex = getBidiPartAt(
                                                    order,
                                                    head.ch,
                                                    head.sticky
                                                  ),
                                                  dir =
                                                    headIndex - index ||
                                                    (head.ch - anchor.ch) *
                                                      (1 == part.level
                                                        ? -1
                                                        : 1);
                                                leftSide =
                                                  headIndex == boundary - 1 ||
                                                  headIndex == boundary
                                                    ? dir < 0
                                                    : 0 < dir;
                                              }
                                              var usePart =
                                                  order[
                                                    boundary +
                                                      (leftSide ? -1 : 0)
                                                  ],
                                                from =
                                                  leftSide ==
                                                  (1 == usePart.level),
                                                ch = from
                                                  ? usePart.from
                                                  : usePart.to,
                                                sticky = from
                                                  ? "after"
                                                  : "before";
                                              return anchor.ch == ch &&
                                                anchor.sticky == sticky
                                                ? range$$1
                                                : new Range(
                                                    new Pos(
                                                      anchor.line,
                                                      ch,
                                                      sticky
                                                    ),
                                                    head
                                                  );
                                            })(
                                              cm,
                                              new Range(
                                                clipPos(doc, anchor),
                                                head
                                              )
                                            )),
                                              setSelection(
                                                doc,
                                                normalizeSelection(
                                                  ranges$1,
                                                  ourIndex
                                                ),
                                                sel_mouse
                                              );
                                          }
                                      }
                                      var editorSize = display.wrapper.getBoundingClientRect(),
                                        counter = 0;
                                      function done(e) {
                                        (cm.state.selectingText = !1),
                                          (counter = 1 / 0),
                                          e_preventDefault(e),
                                          display.input.focus(),
                                          off(document, "mousemove", move),
                                          off(document, "mouseup", up),
                                          (doc.history.lastSelOrigin = null);
                                      }
                                      var move = operation(cm, function(e) {
                                          e_button(e)
                                            ? (function extend(e) {
                                                var curCount = ++counter;
                                                var cur = posFromMouse(
                                                  cm,
                                                  e,
                                                  !0,
                                                  "rectangle" == behavior.unit
                                                );
                                                if (!cur) return;
                                                if (0 != cmp(cur, lastPos)) {
                                                  (cm.curOp.focus = activeElt()),
                                                    extendTo(cur);
                                                  var visible = visibleLines(
                                                    display,
                                                    doc
                                                  );
                                                  (cur.line >= visible.to ||
                                                    cur.line < visible.from) &&
                                                    setTimeout(
                                                      operation(cm, function() {
                                                        counter == curCount &&
                                                          extend(e);
                                                      }),
                                                      150
                                                    );
                                                } else {
                                                  var outside =
                                                    e.clientY < editorSize.top
                                                      ? -20
                                                      : e.clientY >
                                                        editorSize.bottom
                                                        ? 20
                                                        : 0;
                                                  outside &&
                                                    setTimeout(
                                                      operation(cm, function() {
                                                        counter == curCount &&
                                                          ((display.scroller.scrollTop += outside),
                                                          extend(e));
                                                      }),
                                                      50
                                                    );
                                                }
                                              })(e)
                                            : done(e);
                                        }),
                                        up = operation(cm, done);
                                      (cm.state.selectingText = up),
                                        on(document, "mousemove", move),
                                        on(document, "mouseup", up);
                                    })(cm, event, pos, behavior);
                              })(cm, pos, repeat, e)
                            : e_target(e) == display.scroller &&
                              e_preventDefault(e)
                          : 2 == button
                            ? (pos && extendSelection(cm.doc, pos),
                              setTimeout(function() {
                                return display.input.focus();
                              }, 20))
                            : 3 == button &&
                              (captureRightClick
                                ? onContextMenu(cm, e)
                                : delayBlurEvent(cm)));
                  }
              }
              function rangeForUnit(cm, pos, unit) {
                if ("char" == unit) return new Range(pos, pos);
                if ("word" == unit) return cm.findWordAt(pos);
                if ("line" == unit)
                  return new Range(
                    Pos(pos.line, 0),
                    clipPos(cm.doc, Pos(pos.line + 1, 0))
                  );
                var result = unit(cm, pos);
                return new Range(result.from, result.to);
              }
              function gutterEvent(cm, e, type, prevent) {
                var mX, mY;
                if (e.touches)
                  (mX = e.touches[0].clientX), (mY = e.touches[0].clientY);
                else
                  try {
                    (mX = e.clientX), (mY = e.clientY);
                  } catch (e) {
                    return !1;
                  }
                if (
                  mX >=
                  Math.floor(cm.display.gutters.getBoundingClientRect().right)
                )
                  return !1;
                prevent && e_preventDefault(e);
                var display = cm.display,
                  lineBox = display.lineDiv.getBoundingClientRect();
                if (mY > lineBox.bottom || !hasHandler(cm, type))
                  return e_defaultPrevented(e);
                mY -= lineBox.top - display.viewOffset;
                for (var i = 0; i < cm.options.gutters.length; ++i) {
                  var g = display.gutters.childNodes[i];
                  if (g && g.getBoundingClientRect().right >= mX)
                    return (
                      signal(
                        cm,
                        type,
                        cm,
                        lineAtHeight(cm.doc, mY),
                        cm.options.gutters[i],
                        e
                      ),
                      e_defaultPrevented(e)
                    );
                }
              }
              function clickInGutter(cm, e) {
                return gutterEvent(cm, e, "gutterClick", !0);
              }
              function onContextMenu(cm, e) {
                eventInWidget(cm.display, e) ||
                  (function(cm, e) {
                    if (!hasHandler(cm, "gutterContextMenu")) return !1;
                    return gutterEvent(cm, e, "gutterContextMenu", !1);
                  })(cm, e) ||
                  signalDOMEvent(cm, e, "contextmenu") ||
                  cm.display.input.onContextMenu(e);
              }
              function themeChanged(cm) {
                (cm.display.wrapper.className =
                  cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
                  cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-")),
                  clearCaches(cm);
              }
              PastClick.prototype.compare = function(time, pos, button) {
                return (
                  this.time + 400 > time &&
                  0 == cmp(pos, this.pos) &&
                  button == this.button
                );
              };
              var Init = {
                  toString: function() {
                    return "CodeMirror.Init";
                  }
                },
                defaults = {},
                optionHandlers = {};
              function guttersChanged(cm) {
                updateGutters(cm), regChange(cm), alignHorizontally(cm);
              }
              function dragDropChanged(cm, value, old) {
                if (!value != !(old && old != Init)) {
                  var funcs = cm.display.dragFunctions,
                    toggle = value ? on : off;
                  toggle(cm.display.scroller, "dragstart", funcs.start),
                    toggle(cm.display.scroller, "dragenter", funcs.enter),
                    toggle(cm.display.scroller, "dragover", funcs.over),
                    toggle(cm.display.scroller, "dragleave", funcs.leave),
                    toggle(cm.display.scroller, "drop", funcs.drop);
                }
              }
              function wrappingChanged(cm) {
                cm.options.lineWrapping
                  ? (addClass(cm.display.wrapper, "CodeMirror-wrap"),
                    (cm.display.sizer.style.minWidth = ""),
                    (cm.display.sizerWidth = null))
                  : (rmClass(cm.display.wrapper, "CodeMirror-wrap"),
                    findMaxLine(cm)),
                  estimateLineHeights(cm),
                  regChange(cm),
                  clearCaches(cm),
                  setTimeout(function() {
                    return updateScrollbars(cm);
                  }, 100);
              }
              function CodeMirror$1(place, options) {
                var this$1 = this;
                if (!(this instanceof CodeMirror$1))
                  return new CodeMirror$1(place, options);
                (this.options = options = options ? copyObj(options) : {}),
                  copyObj(defaults, options, !1),
                  setGuttersForLineNumbers(options);
                var doc = options.value;
                "string" == typeof doc &&
                  (doc = new Doc(
                    doc,
                    options.mode,
                    null,
                    options.lineSeparator,
                    options.direction
                  )),
                  (this.doc = doc);
                var input = new CodeMirror$1.inputStyles[options.inputStyle](
                    this
                  ),
                  display = (this.display = new function(place, doc, input) {
                    var d = this;
                    (this.input = input),
                      (d.scrollbarFiller = elt(
                        "div",
                        null,
                        "CodeMirror-scrollbar-filler"
                      )),
                      d.scrollbarFiller.setAttribute("cm-not-content", "true"),
                      (d.gutterFiller = elt(
                        "div",
                        null,
                        "CodeMirror-gutter-filler"
                      )),
                      d.gutterFiller.setAttribute("cm-not-content", "true"),
                      (d.lineDiv = eltP("div", null, "CodeMirror-code")),
                      (d.selectionDiv = elt(
                        "div",
                        null,
                        null,
                        "position: relative; z-index: 1"
                      )),
                      (d.cursorDiv = elt("div", null, "CodeMirror-cursors")),
                      (d.measure = elt("div", null, "CodeMirror-measure")),
                      (d.lineMeasure = elt("div", null, "CodeMirror-measure")),
                      (d.lineSpace = eltP(
                        "div",
                        [
                          d.measure,
                          d.lineMeasure,
                          d.selectionDiv,
                          d.cursorDiv,
                          d.lineDiv
                        ],
                        null,
                        "position: relative; outline: none"
                      ));
                    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
                    (d.mover = elt("div", [lines], null, "position: relative")),
                      (d.sizer = elt("div", [d.mover], "CodeMirror-sizer")),
                      (d.sizerWidth = null),
                      (d.heightForcer = elt(
                        "div",
                        null,
                        null,
                        "position: absolute; height: " +
                          scrollerGap +
                          "px; width: 1px;"
                      )),
                      (d.gutters = elt("div", null, "CodeMirror-gutters")),
                      (d.lineGutter = null),
                      (d.scroller = elt(
                        "div",
                        [d.sizer, d.heightForcer, d.gutters],
                        "CodeMirror-scroll"
                      )),
                      d.scroller.setAttribute("tabIndex", "-1"),
                      (d.wrapper = elt(
                        "div",
                        [d.scrollbarFiller, d.gutterFiller, d.scroller],
                        "CodeMirror"
                      )),
                      ie &&
                        ie_version < 8 &&
                        ((d.gutters.style.zIndex = -1),
                        (d.scroller.style.paddingRight = 0)),
                      webkit ||
                        (gecko && mobile) ||
                        (d.scroller.draggable = !0),
                      place &&
                        (place.appendChild
                          ? place.appendChild(d.wrapper)
                          : place(d.wrapper)),
                      (d.viewFrom = d.viewTo = doc.first),
                      (d.reportedViewFrom = d.reportedViewTo = doc.first),
                      (d.view = []),
                      (d.renderedView = null),
                      (d.externalMeasured = null),
                      (d.viewOffset = 0),
                      (d.lastWrapHeight = d.lastWrapWidth = 0),
                      (d.updateLineNumbers = null),
                      (d.nativeBarWidth = d.barHeight = d.barWidth = 0),
                      (d.scrollbarsClipped = !1),
                      (d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null),
                      (d.alignWidgets = !1),
                      (d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null),
                      (d.maxLine = null),
                      (d.maxLineLength = 0),
                      (d.maxLineChanged = !1),
                      (d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null),
                      (d.shift = !1),
                      (d.selForContextMenu = null),
                      (d.activeTouch = null),
                      input.init(d);
                  }(place, doc, input));
                for (var opt in (updateGutters(
                  (display.wrapper.CodeMirror = this)
                ),
                themeChanged(this),
                options.lineWrapping &&
                  (this.display.wrapper.className += " CodeMirror-wrap"),
                initScrollbars(this),
                (this.state = {
                  keyMaps: [],
                  overlays: [],
                  modeGen: 0,
                  overwrite: !1,
                  delayingBlurEvent: !1,
                  focused: !1,
                  suppressEdits: !1,
                  pasteIncoming: !1,
                  cutIncoming: !1,
                  selectingText: !1,
                  draggingText: !1,
                  highlight: new Delayed(),
                  keySeq: null,
                  specialChars: null
                }),
                options.autofocus && !mobile && display.input.focus(),
                ie &&
                  ie_version < 11 &&
                  setTimeout(function() {
                    return this$1.display.input.reset(!0);
                  }, 20),
                (function(cm) {
                  var d = cm.display;
                  on(d.scroller, "mousedown", operation(cm, onMouseDown)),
                    on(
                      d.scroller,
                      "dblclick",
                      ie && ie_version < 11
                        ? operation(cm, function(e) {
                            if (!signalDOMEvent(cm, e)) {
                              var pos = posFromMouse(cm, e);
                              if (
                                pos &&
                                !clickInGutter(cm, e) &&
                                !eventInWidget(cm.display, e)
                              ) {
                                e_preventDefault(e);
                                var word = cm.findWordAt(pos);
                                extendSelection(cm.doc, word.anchor, word.head);
                              }
                            }
                          })
                        : function(e) {
                            return signalDOMEvent(cm, e) || e_preventDefault(e);
                          }
                    );
                  captureRightClick ||
                    on(d.scroller, "contextmenu", function(e) {
                      return onContextMenu(cm, e);
                    });
                  var touchFinished,
                    prevTouch = { end: 0 };
                  function finishTouch() {
                    d.activeTouch &&
                      ((touchFinished = setTimeout(function() {
                        return (d.activeTouch = null);
                      }, 1e3)),
                      ((prevTouch = d.activeTouch).end = +new Date()));
                  }
                  function farAway(touch, other) {
                    if (null == other.left) return !0;
                    var dx = other.left - touch.left,
                      dy = other.top - touch.top;
                    return 400 < dx * dx + dy * dy;
                  }
                  on(d.scroller, "touchstart", function(e) {
                    if (
                      !signalDOMEvent(cm, e) &&
                      !(function(e) {
                        if (1 != e.touches.length) return !1;
                        var touch = e.touches[0];
                        return touch.radiusX <= 1 && touch.radiusY <= 1;
                      })(e) &&
                      !clickInGutter(cm, e)
                    ) {
                      d.input.ensurePolled(), clearTimeout(touchFinished);
                      var now = +new Date();
                      (d.activeTouch = {
                        start: now,
                        moved: !1,
                        prev: now - prevTouch.end <= 300 ? prevTouch : null
                      }),
                        1 == e.touches.length &&
                          ((d.activeTouch.left = e.touches[0].pageX),
                          (d.activeTouch.top = e.touches[0].pageY));
                    }
                  }),
                    on(d.scroller, "touchmove", function() {
                      d.activeTouch && (d.activeTouch.moved = !0);
                    }),
                    on(d.scroller, "touchend", function(e) {
                      var touch = d.activeTouch;
                      if (
                        touch &&
                        !eventInWidget(d, e) &&
                        null != touch.left &&
                        !touch.moved &&
                        new Date() - touch.start < 300
                      ) {
                        var range,
                          pos = cm.coordsChar(d.activeTouch, "page");
                        (range =
                          !touch.prev || farAway(touch, touch.prev)
                            ? new Range(pos, pos)
                            : !touch.prev.prev ||
                              farAway(touch, touch.prev.prev)
                              ? cm.findWordAt(pos)
                              : new Range(
                                  Pos(pos.line, 0),
                                  clipPos(cm.doc, Pos(pos.line + 1, 0))
                                )),
                          cm.setSelection(range.anchor, range.head),
                          cm.focus(),
                          e_preventDefault(e);
                      }
                      finishTouch();
                    }),
                    on(d.scroller, "touchcancel", finishTouch),
                    on(d.scroller, "scroll", function() {
                      d.scroller.clientHeight &&
                        (updateScrollTop(cm, d.scroller.scrollTop),
                        setScrollLeft(cm, d.scroller.scrollLeft, !0),
                        signal(cm, "scroll", cm));
                    }),
                    on(d.scroller, "mousewheel", function(e) {
                      return onScrollWheel(cm, e);
                    }),
                    on(d.scroller, "DOMMouseScroll", function(e) {
                      return onScrollWheel(cm, e);
                    }),
                    on(d.wrapper, "scroll", function() {
                      return (d.wrapper.scrollTop = d.wrapper.scrollLeft = 0);
                    }),
                    (d.dragFunctions = {
                      enter: function(e) {
                        signalDOMEvent(cm, e) || e_stop(e);
                      },
                      over: function(e) {
                        signalDOMEvent(cm, e) ||
                          (!(function(cm, e) {
                            var pos = posFromMouse(cm, e);
                            if (pos) {
                              var frag = document.createDocumentFragment();
                              drawSelectionCursor(cm, pos, frag),
                                cm.display.dragCursor ||
                                  ((cm.display.dragCursor = elt(
                                    "div",
                                    null,
                                    "CodeMirror-cursors CodeMirror-dragcursors"
                                  )),
                                  cm.display.lineSpace.insertBefore(
                                    cm.display.dragCursor,
                                    cm.display.cursorDiv
                                  )),
                                removeChildrenAndAdd(
                                  cm.display.dragCursor,
                                  frag
                                );
                            }
                          })(cm, e),
                          e_stop(e));
                      },
                      start: function(e) {
                        return (function(cm, e) {
                          if (
                            ie &&
                            (!cm.state.draggingText ||
                              +new Date() - lastDrop < 100)
                          )
                            e_stop(e);
                          else if (
                            !signalDOMEvent(cm, e) &&
                            !eventInWidget(cm.display, e) &&
                            (e.dataTransfer.setData("Text", cm.getSelection()),
                            (e.dataTransfer.effectAllowed = "copyMove"),
                            e.dataTransfer.setDragImage && !safari)
                          ) {
                            var img = elt(
                              "img",
                              null,
                              null,
                              "position: fixed; left: 0; top: 0;"
                            );
                            (img.src =
                              "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="),
                              presto &&
                                ((img.width = img.height = 1),
                                cm.display.wrapper.appendChild(img),
                                (img._top = img.offsetTop)),
                              e.dataTransfer.setDragImage(img, 0, 0),
                              presto && img.parentNode.removeChild(img);
                          }
                        })(cm, e);
                      },
                      drop: operation(cm, onDrop),
                      leave: function(e) {
                        signalDOMEvent(cm, e) || clearDragCursor(cm);
                      }
                    });
                  var inp = d.input.getField();
                  on(inp, "keyup", function(e) {
                    return onKeyUp.call(cm, e);
                  }),
                    on(inp, "keydown", operation(cm, onKeyDown)),
                    on(inp, "keypress", operation(cm, onKeyPress)),
                    on(inp, "focus", function(e) {
                      return onFocus(cm, e);
                    }),
                    on(inp, "blur", function(e) {
                      return onBlur(cm, e);
                    });
                })(this),
                ensureGlobalHandlers(),
                startOperation(this),
                (this.curOp.forceUpdate = !0),
                attachDoc(this, doc),
                (options.autofocus && !mobile) || this.hasFocus()
                  ? setTimeout(bind(onFocus, this), 20)
                  : onBlur(this),
                optionHandlers))
                  optionHandlers.hasOwnProperty(opt) &&
                    optionHandlers[opt](this$1, options[opt], Init);
                maybeUpdateLineNumberWidth(this),
                  options.finishInit && options.finishInit(this);
                for (var i = 0; i < initHooks.length; ++i) initHooks[i](this$1);
                endOperation(this),
                  webkit &&
                    options.lineWrapping &&
                    "optimizelegibility" ==
                      getComputedStyle(display.lineDiv).textRendering &&
                    (display.lineDiv.style.textRendering = "auto");
              }
              (CodeMirror$1.defaults = defaults),
                (CodeMirror$1.optionHandlers = optionHandlers);
              var initHooks = [];
              function indentLine(cm, n, how, aggressive) {
                var state,
                  doc = cm.doc;
                null == how && (how = "add"),
                  "smart" == how &&
                    (doc.mode.indent
                      ? (state = getContextBefore(cm, n).state)
                      : (how = "prev"));
                var tabSize = cm.options.tabSize,
                  line = getLine(doc, n),
                  curSpace = countColumn(line.text, null, tabSize);
                line.stateAfter && (line.stateAfter = null);
                var indentation,
                  curSpaceString = line.text.match(/^\s*/)[0];
                if (aggressive || /\S/.test(line.text)) {
                  if (
                    "smart" == how &&
                    ((indentation = doc.mode.indent(
                      state,
                      line.text.slice(curSpaceString.length),
                      line.text
                    )) == Pass ||
                      150 < indentation)
                  ) {
                    if (!aggressive) return;
                    how = "prev";
                  }
                } else (indentation = 0), (how = "not");
                "prev" == how
                  ? (indentation =
                      n > doc.first
                        ? countColumn(getLine(doc, n - 1).text, null, tabSize)
                        : 0)
                  : "add" == how
                    ? (indentation = curSpace + cm.options.indentUnit)
                    : "subtract" == how
                      ? (indentation = curSpace - cm.options.indentUnit)
                      : "number" == typeof how &&
                        (indentation = curSpace + how),
                  (indentation = Math.max(0, indentation));
                var indentString = "",
                  pos = 0;
                if (cm.options.indentWithTabs)
                  for (var i = Math.floor(indentation / tabSize); i; --i)
                    (pos += tabSize), (indentString += "\t");
                if (
                  (pos < indentation &&
                    (indentString += spaceStr(indentation - pos)),
                  indentString != curSpaceString)
                )
                  return (
                    replaceRange(
                      doc,
                      indentString,
                      Pos(n, 0),
                      Pos(n, curSpaceString.length),
                      "+input"
                    ),
                    (line.stateAfter = null),
                    !0
                  );
                for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
                  var range = doc.sel.ranges[i$1];
                  if (
                    range.head.line == n &&
                    range.head.ch < curSpaceString.length
                  ) {
                    var pos$1 = Pos(n, curSpaceString.length);
                    replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
                    break;
                  }
                }
              }
              CodeMirror$1.defineInitHook = function(f) {
                return initHooks.push(f);
              };
              var lastCopied = null;
              function setLastCopied(newLastCopied) {
                lastCopied = newLastCopied;
              }
              function applyTextInput(cm, inserted, deleted, sel, origin) {
                var doc = cm.doc;
                (cm.display.shift = !1), sel || (sel = doc.sel);
                var updateInput,
                  paste = cm.state.pasteIncoming || "paste" == origin,
                  textLines = splitLinesAuto(inserted),
                  multiPaste = null;
                if (paste && 1 < sel.ranges.length)
                  if (lastCopied && lastCopied.text.join("\n") == inserted) {
                    if (sel.ranges.length % lastCopied.text.length == 0) {
                      multiPaste = [];
                      for (var i = 0; i < lastCopied.text.length; i++)
                        multiPaste.push(doc.splitLines(lastCopied.text[i]));
                    }
                  } else
                    textLines.length == sel.ranges.length &&
                      cm.options.pasteLinesPerSelection &&
                      (multiPaste = map(textLines, function(l) {
                        return [l];
                      }));
                for (var i$1 = sel.ranges.length - 1; 0 <= i$1; i$1--) {
                  var range$$1 = sel.ranges[i$1],
                    from = range$$1.from(),
                    to = range$$1.to();
                  range$$1.empty() &&
                    (deleted && 0 < deleted
                      ? (from = Pos(from.line, from.ch - deleted))
                      : cm.state.overwrite && !paste
                        ? (to = Pos(
                            to.line,
                            Math.min(
                              getLine(doc, to.line).text.length,
                              to.ch + lst(textLines).length
                            )
                          ))
                        : lastCopied &&
                          lastCopied.lineWise &&
                          lastCopied.text.join("\n") == inserted &&
                          (from = to = Pos(from.line, 0))),
                    (updateInput = cm.curOp.updateInput);
                  var changeEvent = {
                    from: from,
                    to: to,
                    text: multiPaste
                      ? multiPaste[i$1 % multiPaste.length]
                      : textLines,
                    origin:
                      origin ||
                      (paste
                        ? "paste"
                        : cm.state.cutIncoming ? "cut" : "+input")
                  };
                  makeChange(cm.doc, changeEvent),
                    signalLater(cm, "inputRead", cm, changeEvent);
                }
                inserted && !paste && triggerElectric(cm, inserted),
                  ensureCursorVisible(cm),
                  (cm.curOp.updateInput = updateInput),
                  (cm.curOp.typing = !0),
                  (cm.state.pasteIncoming = cm.state.cutIncoming = !1);
              }
              function handlePaste(e, cm) {
                var pasted = e.clipboardData && e.clipboardData.getData("Text");
                if (pasted)
                  return (
                    e.preventDefault(),
                    cm.isReadOnly() ||
                      cm.options.disableInput ||
                      runInOp(cm, function() {
                        return applyTextInput(cm, pasted, 0, null, "paste");
                      }),
                    !0
                  );
              }
              function triggerElectric(cm, inserted) {
                if (cm.options.electricChars && cm.options.smartIndent)
                  for (
                    var sel = cm.doc.sel, i = sel.ranges.length - 1;
                    0 <= i;
                    i--
                  ) {
                    var range$$1 = sel.ranges[i];
                    if (
                      !(
                        100 < range$$1.head.ch ||
                        (i && sel.ranges[i - 1].head.line == range$$1.head.line)
                      )
                    ) {
                      var mode = cm.getModeAt(range$$1.head),
                        indented = !1;
                      if (mode.electricChars) {
                        for (var j = 0; j < mode.electricChars.length; j++)
                          if (
                            -1 < inserted.indexOf(mode.electricChars.charAt(j))
                          ) {
                            indented = indentLine(
                              cm,
                              range$$1.head.line,
                              "smart"
                            );
                            break;
                          }
                      } else
                        mode.electricInput &&
                          mode.electricInput.test(
                            getLine(cm.doc, range$$1.head.line).text.slice(
                              0,
                              range$$1.head.ch
                            )
                          ) &&
                          (indented = indentLine(
                            cm,
                            range$$1.head.line,
                            "smart"
                          ));
                      indented &&
                        signalLater(
                          cm,
                          "electricInput",
                          cm,
                          range$$1.head.line
                        );
                    }
                  }
              }
              function copyableRanges(cm) {
                for (
                  var text = [], ranges = [], i = 0;
                  i < cm.doc.sel.ranges.length;
                  i++
                ) {
                  var line = cm.doc.sel.ranges[i].head.line,
                    lineRange = {
                      anchor: Pos(line, 0),
                      head: Pos(line + 1, 0)
                    };
                  ranges.push(lineRange),
                    text.push(cm.getRange(lineRange.anchor, lineRange.head));
                }
                return { text: text, ranges: ranges };
              }
              function disableBrowserMagic(field, spellcheck) {
                field.setAttribute("autocorrect", "off"),
                  field.setAttribute("autocapitalize", "off"),
                  field.setAttribute("spellcheck", !!spellcheck);
              }
              function hiddenTextarea() {
                var te = elt(
                    "textarea",
                    null,
                    null,
                    "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"
                  ),
                  div = elt(
                    "div",
                    [te],
                    null,
                    "overflow: hidden; position: relative; width: 3px; height: 0px;"
                  );
                return (
                  webkit
                    ? (te.style.width = "1000px")
                    : te.setAttribute("wrap", "off"),
                  ios && (te.style.border = "1px solid black"),
                  disableBrowserMagic(te),
                  div
                );
              }
              function findPosH(doc, pos, dir, unit, visually) {
                var oldPos = pos,
                  origDir = dir,
                  lineObj = getLine(doc, pos.line);
                function moveOnce(boundToLine) {
                  var next, l;
                  if (
                    null ==
                    (next = visually
                      ? (function(cm, line, start, dir) {
                          var bidi = getOrder(line, cm.doc.direction);
                          if (!bidi) return moveLogically(line, start, dir);
                          start.ch >= line.text.length
                            ? ((start.ch = line.text.length),
                              (start.sticky = "before"))
                            : start.ch <= 0 &&
                              ((start.ch = 0), (start.sticky = "after"));
                          var partPos = getBidiPartAt(
                              bidi,
                              start.ch,
                              start.sticky
                            ),
                            part = bidi[partPos];
                          if (
                            "ltr" == cm.doc.direction &&
                            part.level % 2 == 0 &&
                            (0 < dir
                              ? part.to > start.ch
                              : part.from < start.ch)
                          )
                            return moveLogically(line, start, dir);
                          var prep,
                            mv = function(pos, dir) {
                              return moveCharLogically(
                                line,
                                pos instanceof Pos ? pos.ch : pos,
                                dir
                              );
                            },
                            getWrappedLineExtent = function(ch) {
                              return cm.options.lineWrapping
                                ? ((prep =
                                    prep || prepareMeasureForLine(cm, line)),
                                  wrappedLineExtentChar(cm, line, prep, ch))
                                : { begin: 0, end: line.text.length };
                            },
                            wrappedLineExtent = getWrappedLineExtent(
                              "before" == start.sticky
                                ? mv(start, -1)
                                : start.ch
                            );
                          if ("rtl" == cm.doc.direction || 1 == part.level) {
                            var moveInStorageOrder =
                                (1 == part.level) == dir < 0,
                              ch = mv(start, moveInStorageOrder ? 1 : -1);
                            if (
                              null != ch &&
                              (moveInStorageOrder
                                ? ch <= part.to && ch <= wrappedLineExtent.end
                                : ch >= part.from &&
                                  ch >= wrappedLineExtent.begin)
                            ) {
                              var sticky = moveInStorageOrder
                                ? "before"
                                : "after";
                              return new Pos(start.line, ch, sticky);
                            }
                          }
                          var searchInVisualLine = function(
                              partPos,
                              dir,
                              wrappedLineExtent
                            ) {
                              for (
                                var getRes = function(ch, moveInStorageOrder) {
                                  return moveInStorageOrder
                                    ? new Pos(start.line, mv(ch, 1), "before")
                                    : new Pos(start.line, ch, "after");
                                };
                                0 <= partPos && partPos < bidi.length;
                                partPos += dir
                              ) {
                                var part = bidi[partPos],
                                  moveInStorageOrder =
                                    0 < dir == (1 != part.level),
                                  ch = moveInStorageOrder
                                    ? wrappedLineExtent.begin
                                    : mv(wrappedLineExtent.end, -1);
                                if (part.from <= ch && ch < part.to)
                                  return getRes(ch, moveInStorageOrder);
                                if (
                                  ((ch = moveInStorageOrder
                                    ? part.from
                                    : mv(part.to, -1)),
                                  wrappedLineExtent.begin <= ch &&
                                    ch < wrappedLineExtent.end)
                                )
                                  return getRes(ch, moveInStorageOrder);
                              }
                            },
                            res = searchInVisualLine(
                              partPos + dir,
                              dir,
                              wrappedLineExtent
                            );
                          if (res) return res;
                          var nextCh =
                            0 < dir
                              ? wrappedLineExtent.end
                              : mv(wrappedLineExtent.begin, -1);
                          return null == nextCh ||
                            (0 < dir && nextCh == line.text.length) ||
                            !(res = searchInVisualLine(
                              0 < dir ? 0 : bidi.length - 1,
                              dir,
                              getWrappedLineExtent(nextCh)
                            ))
                            ? null
                            : res;
                        })(doc.cm, lineObj, pos, dir)
                      : moveLogically(lineObj, pos, dir))
                  ) {
                    if (
                      boundToLine ||
                      (l = pos.line + dir) < doc.first ||
                      l >= doc.first + doc.size ||
                      ((pos = new Pos(l, pos.ch, pos.sticky)),
                      !(lineObj = getLine(doc, l)))
                    )
                      return !1;
                    pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir);
                  } else pos = next;
                  return !0;
                }
                if ("char" == unit) moveOnce();
                else if ("column" == unit) moveOnce(!0);
                else if ("word" == unit || "group" == unit)
                  for (
                    var sawType = null,
                      group = "group" == unit,
                      helper = doc.cm && doc.cm.getHelper(pos, "wordChars"),
                      first = !0;
                    !(dir < 0) || moveOnce(!first);
                    first = !1
                  ) {
                    var cur = lineObj.text.charAt(pos.ch) || "\n",
                      type = isWordChar(cur, helper)
                        ? "w"
                        : group && "\n" == cur
                          ? "n"
                          : !group || /\s/.test(cur) ? null : "p";
                    if (
                      (!group || first || type || (type = "s"),
                      sawType && sawType != type)
                    ) {
                      dir < 0 &&
                        ((dir = 1), moveOnce(), (pos.sticky = "after"));
                      break;
                    }
                    if (
                      (type && (sawType = type), 0 < dir && !moveOnce(!first))
                    )
                      break;
                  }
                var result = skipAtomic(doc, pos, oldPos, origDir, !0);
                return (
                  equalCursorPos(oldPos, result) && (result.hitSide = !0),
                  result
                );
              }
              function findPosV(cm, pos, dir, unit) {
                var y,
                  target,
                  doc = cm.doc,
                  x = pos.left;
                if ("page" == unit) {
                  var pageSize = Math.min(
                      cm.display.wrapper.clientHeight,
                      window.innerHeight ||
                        document.documentElement.clientHeight
                    ),
                    moveAmount = Math.max(
                      pageSize - 0.5 * textHeight(cm.display),
                      3
                    );
                  y = (0 < dir ? pos.bottom : pos.top) + dir * moveAmount;
                } else
                  "line" == unit &&
                    (y = 0 < dir ? pos.bottom + 3 : pos.top - 3);
                for (; (target = coordsChar(cm, x, y)).outside; ) {
                  if (dir < 0 ? y <= 0 : y >= doc.height) {
                    target.hitSide = !0;
                    break;
                  }
                  y += 5 * dir;
                }
                return target;
              }
              var ContentEditableInput = function(cm) {
                (this.cm = cm),
                  (this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null),
                  (this.polling = new Delayed()),
                  (this.composing = null),
                  (this.gracePeriod = !1),
                  (this.readDOMTimeout = null);
              };
              function posToDOM(cm, pos) {
                var view = findViewForLine(cm, pos.line);
                if (!view || view.hidden) return null;
                var line = getLine(cm.doc, pos.line),
                  info = mapFromLineView(view, line, pos.line),
                  order = getOrder(line, cm.doc.direction),
                  side = "left";
                order &&
                  (side = getBidiPartAt(order, pos.ch) % 2 ? "right" : "left");
                var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
                return (
                  (result.offset =
                    "right" == result.collapse ? result.end : result.start),
                  result
                );
              }
              function badPos(pos, bad) {
                return bad && (pos.bad = !0), pos;
              }
              function domToPos(cm, node, offset) {
                var lineNode;
                if (node == cm.display.lineDiv) {
                  if (!(lineNode = cm.display.lineDiv.childNodes[offset]))
                    return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), !0);
                  (node = null), (offset = 0);
                } else
                  for (lineNode = node; ; lineNode = lineNode.parentNode) {
                    if (!lineNode || lineNode == cm.display.lineDiv)
                      return null;
                    if (
                      lineNode.parentNode &&
                      lineNode.parentNode == cm.display.lineDiv
                    )
                      break;
                  }
                for (var i = 0; i < cm.display.view.length; i++) {
                  var lineView = cm.display.view[i];
                  if (lineView.node == lineNode)
                    return locateNodeInLineView(lineView, node, offset);
                }
              }
              function locateNodeInLineView(lineView, node, offset) {
                var wrapper = lineView.text.firstChild,
                  bad = !1;
                if (!node || !contains(wrapper, node))
                  return badPos(Pos(lineNo(lineView.line), 0), !0);
                if (
                  node == wrapper &&
                  ((bad = !0),
                  (node = wrapper.childNodes[offset]),
                  (offset = 0),
                  !node)
                ) {
                  var line = lineView.rest ? lst(lineView.rest) : lineView.line;
                  return badPos(Pos(lineNo(line), line.text.length), bad);
                }
                var textNode = 3 == node.nodeType ? node : null,
                  topNode = node;
                for (
                  textNode ||
                  1 != node.childNodes.length ||
                  3 != node.firstChild.nodeType ||
                  ((textNode = node.firstChild),
                  offset && (offset = textNode.nodeValue.length));
                  topNode.parentNode != wrapper;

                )
                  topNode = topNode.parentNode;
                var measure = lineView.measure,
                  maps = measure.maps;
                function find(textNode, topNode, offset) {
                  for (var i = -1; i < (maps ? maps.length : 0); i++)
                    for (
                      var map$$1 = i < 0 ? measure.map : maps[i], j = 0;
                      j < map$$1.length;
                      j += 3
                    ) {
                      var curNode = map$$1[j + 2];
                      if (curNode == textNode || curNode == topNode) {
                        var line = lineNo(
                            i < 0 ? lineView.line : lineView.rest[i]
                          ),
                          ch = map$$1[j] + offset;
                        return (
                          (offset < 0 || curNode != textNode) &&
                            (ch = map$$1[j + (offset ? 1 : 0)]),
                          Pos(line, ch)
                        );
                      }
                    }
                }
                var found = find(textNode, topNode, offset);
                if (found) return badPos(found, bad);
                for (
                  var after = topNode.nextSibling,
                    dist = textNode ? textNode.nodeValue.length - offset : 0;
                  after;
                  after = after.nextSibling
                ) {
                  if ((found = find(after, after.firstChild, 0)))
                    return badPos(Pos(found.line, found.ch - dist), bad);
                  dist += after.textContent.length;
                }
                for (
                  var before = topNode.previousSibling, dist$1 = offset;
                  before;
                  before = before.previousSibling
                ) {
                  if ((found = find(before, before.firstChild, -1)))
                    return badPos(Pos(found.line, found.ch + dist$1), bad);
                  dist$1 += before.textContent.length;
                }
              }
              (ContentEditableInput.prototype.init = function(display) {
                var this$1 = this,
                  input = this,
                  cm = input.cm,
                  div = (input.div = display.lineDiv);
                function onCopyCut(e) {
                  if (!signalDOMEvent(cm, e)) {
                    if (cm.somethingSelected())
                      setLastCopied({ lineWise: !1, text: cm.getSelections() }),
                        "cut" == e.type && cm.replaceSelection("", null, "cut");
                    else {
                      if (!cm.options.lineWiseCopyCut) return;
                      var ranges = copyableRanges(cm);
                      setLastCopied({ lineWise: !0, text: ranges.text }),
                        "cut" == e.type &&
                          cm.operation(function() {
                            cm.setSelections(ranges.ranges, 0, sel_dontScroll),
                              cm.replaceSelection("", null, "cut");
                          });
                    }
                    if (e.clipboardData) {
                      e.clipboardData.clearData();
                      var content = lastCopied.text.join("\n");
                      if (
                        (e.clipboardData.setData("Text", content),
                        e.clipboardData.getData("Text") == content)
                      )
                        return void e.preventDefault();
                    }
                    var kludge = hiddenTextarea(),
                      te = kludge.firstChild;
                    cm.display.lineSpace.insertBefore(
                      kludge,
                      cm.display.lineSpace.firstChild
                    ),
                      (te.value = lastCopied.text.join("\n"));
                    var hadFocus = document.activeElement;
                    selectInput(te),
                      setTimeout(function() {
                        cm.display.lineSpace.removeChild(kludge),
                          hadFocus.focus(),
                          hadFocus == div && input.showPrimarySelection();
                      }, 50);
                  }
                }
                disableBrowserMagic(div, cm.options.spellcheck),
                  on(div, "paste", function(e) {
                    signalDOMEvent(cm, e) ||
                      handlePaste(e, cm) ||
                      (ie_version <= 11 &&
                        setTimeout(
                          operation(cm, function() {
                            return this$1.updateFromDOM();
                          }),
                          20
                        ));
                  }),
                  on(div, "compositionstart", function(e) {
                    this$1.composing = { data: e.data, done: !1 };
                  }),
                  on(div, "compositionupdate", function(e) {
                    this$1.composing ||
                      (this$1.composing = { data: e.data, done: !1 });
                  }),
                  on(div, "compositionend", function(e) {
                    this$1.composing &&
                      (e.data != this$1.composing.data &&
                        this$1.readFromDOMSoon(),
                      (this$1.composing.done = !0));
                  }),
                  on(div, "touchstart", function() {
                    return input.forceCompositionEnd();
                  }),
                  on(div, "input", function() {
                    this$1.composing || this$1.readFromDOMSoon();
                  }),
                  on(div, "copy", onCopyCut),
                  on(div, "cut", onCopyCut);
              }),
                (ContentEditableInput.prototype.prepareSelection = function() {
                  var result = prepareSelection(this.cm, !1);
                  return (result.focus = this.cm.state.focused), result;
                }),
                (ContentEditableInput.prototype.showSelection = function(
                  info,
                  takeFocus
                ) {
                  info &&
                    this.cm.display.view.length &&
                    ((info.focus || takeFocus) && this.showPrimarySelection(),
                    this.showMultipleSelections(info));
                }),
                (ContentEditableInput.prototype.showPrimarySelection = function() {
                  var sel = window.getSelection(),
                    cm = this.cm,
                    prim = cm.doc.sel.primary(),
                    from = prim.from(),
                    to = prim.to();
                  if (
                    cm.display.viewTo == cm.display.viewFrom ||
                    from.line >= cm.display.viewTo ||
                    to.line < cm.display.viewFrom
                  )
                    sel.removeAllRanges();
                  else {
                    var curAnchor = domToPos(
                        cm,
                        sel.anchorNode,
                        sel.anchorOffset
                      ),
                      curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
                    if (
                      !curAnchor ||
                      curAnchor.bad ||
                      !curFocus ||
                      curFocus.bad ||
                      0 != cmp(minPos(curAnchor, curFocus), from) ||
                      0 != cmp(maxPos(curAnchor, curFocus), to)
                    ) {
                      var view = cm.display.view,
                        start = (from.line >= cm.display.viewFrom &&
                          posToDOM(cm, from)) || {
                          node: view[0].measure.map[2],
                          offset: 0
                        },
                        end = to.line < cm.display.viewTo && posToDOM(cm, to);
                      if (!end) {
                        var measure = view[view.length - 1].measure,
                          map$$1 = measure.maps
                            ? measure.maps[measure.maps.length - 1]
                            : measure.map;
                        end = {
                          node: map$$1[map$$1.length - 1],
                          offset:
                            map$$1[map$$1.length - 2] -
                            map$$1[map$$1.length - 3]
                        };
                      }
                      if (start && end) {
                        var rng,
                          old = sel.rangeCount && sel.getRangeAt(0);
                        try {
                          rng = range(
                            start.node,
                            start.offset,
                            end.offset,
                            end.node
                          );
                        } catch (e) {}
                        rng &&
                          (!gecko && cm.state.focused
                            ? (sel.collapse(start.node, start.offset),
                              rng.collapsed ||
                                (sel.removeAllRanges(), sel.addRange(rng)))
                            : (sel.removeAllRanges(), sel.addRange(rng)),
                          old && null == sel.anchorNode
                            ? sel.addRange(old)
                            : gecko && this.startGracePeriod()),
                          this.rememberSelection();
                      } else sel.removeAllRanges();
                    }
                  }
                }),
                (ContentEditableInput.prototype.startGracePeriod = function() {
                  var this$1 = this;
                  clearTimeout(this.gracePeriod),
                    (this.gracePeriod = setTimeout(function() {
                      (this$1.gracePeriod = !1),
                        this$1.selectionChanged() &&
                          this$1.cm.operation(function() {
                            return (this$1.cm.curOp.selectionChanged = !0);
                          });
                    }, 20));
                }),
                (ContentEditableInput.prototype.showMultipleSelections = function(
                  info
                ) {
                  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors),
                    removeChildrenAndAdd(
                      this.cm.display.selectionDiv,
                      info.selection
                    );
                }),
                (ContentEditableInput.prototype.rememberSelection = function() {
                  var sel = window.getSelection();
                  (this.lastAnchorNode = sel.anchorNode),
                    (this.lastAnchorOffset = sel.anchorOffset),
                    (this.lastFocusNode = sel.focusNode),
                    (this.lastFocusOffset = sel.focusOffset);
                }),
                (ContentEditableInput.prototype.selectionInEditor = function() {
                  var sel = window.getSelection();
                  if (!sel.rangeCount) return !1;
                  var node = sel.getRangeAt(0).commonAncestorContainer;
                  return contains(this.div, node);
                }),
                (ContentEditableInput.prototype.focus = function() {
                  "nocursor" != this.cm.options.readOnly &&
                    (this.selectionInEditor() ||
                      this.showSelection(this.prepareSelection(), !0),
                    this.div.focus());
                }),
                (ContentEditableInput.prototype.blur = function() {
                  this.div.blur();
                }),
                (ContentEditableInput.prototype.getField = function() {
                  return this.div;
                }),
                (ContentEditableInput.prototype.supportsTouch = function() {
                  return !0;
                }),
                (ContentEditableInput.prototype.receivedFocus = function() {
                  var input = this;
                  this.selectionInEditor()
                    ? this.pollSelection()
                    : runInOp(this.cm, function() {
                        return (input.cm.curOp.selectionChanged = !0);
                      }),
                    this.polling.set(
                      this.cm.options.pollInterval,
                      function poll() {
                        input.cm.state.focused &&
                          (input.pollSelection(),
                          input.polling.set(
                            input.cm.options.pollInterval,
                            poll
                          ));
                      }
                    );
                }),
                (ContentEditableInput.prototype.selectionChanged = function() {
                  var sel = window.getSelection();
                  return (
                    sel.anchorNode != this.lastAnchorNode ||
                    sel.anchorOffset != this.lastAnchorOffset ||
                    sel.focusNode != this.lastFocusNode ||
                    sel.focusOffset != this.lastFocusOffset
                  );
                }),
                (ContentEditableInput.prototype.pollSelection = function() {
                  if (
                    null == this.readDOMTimeout &&
                    !this.gracePeriod &&
                    this.selectionChanged()
                  ) {
                    var sel = window.getSelection(),
                      cm = this.cm;
                    if (
                      android &&
                      chrome &&
                      this.cm.options.gutters.length &&
                      (function(node) {
                        for (var scan = node; scan; scan = scan.parentNode)
                          if (/CodeMirror-gutter-wrapper/.test(scan.className))
                            return !0;
                        return !1;
                      })(sel.anchorNode)
                    )
                      return (
                        this.cm.triggerOnKeyDown({
                          type: "keydown",
                          keyCode: 8,
                          preventDefault: Math.abs
                        }),
                        this.blur(),
                        void this.focus()
                      );
                    if (!this.composing) {
                      this.rememberSelection();
                      var anchor = domToPos(
                          cm,
                          sel.anchorNode,
                          sel.anchorOffset
                        ),
                        head = domToPos(cm, sel.focusNode, sel.focusOffset);
                      anchor &&
                        head &&
                        runInOp(cm, function() {
                          setSelection(
                            cm.doc,
                            simpleSelection(anchor, head),
                            sel_dontScroll
                          ),
                            (anchor.bad || head.bad) &&
                              (cm.curOp.selectionChanged = !0);
                        });
                    }
                  }
                }),
                (ContentEditableInput.prototype.pollContent = function() {
                  null != this.readDOMTimeout &&
                    (clearTimeout(this.readDOMTimeout),
                    (this.readDOMTimeout = null));
                  var fromIndex,
                    fromLine,
                    fromNode,
                    cm = this.cm,
                    display = cm.display,
                    sel = cm.doc.sel.primary(),
                    from = sel.from(),
                    to = sel.to();
                  if (
                    (0 == from.ch &&
                      from.line > cm.firstLine() &&
                      (from = Pos(
                        from.line - 1,
                        getLine(cm.doc, from.line - 1).length
                      )),
                    to.ch == getLine(cm.doc, to.line).text.length &&
                      to.line < cm.lastLine() &&
                      (to = Pos(to.line + 1, 0)),
                    from.line < display.viewFrom ||
                      to.line > display.viewTo - 1)
                  )
                    return !1;
                  from.line == display.viewFrom ||
                  0 == (fromIndex = findViewIndex(cm, from.line))
                    ? ((fromLine = lineNo(display.view[0].line)),
                      (fromNode = display.view[0].node))
                    : ((fromLine = lineNo(display.view[fromIndex].line)),
                      (fromNode =
                        display.view[fromIndex - 1].node.nextSibling));
                  var toLine,
                    toNode,
                    toIndex = findViewIndex(cm, to.line);
                  if (
                    (toIndex == display.view.length - 1
                      ? ((toLine = display.viewTo - 1),
                        (toNode = display.lineDiv.lastChild))
                      : ((toLine = lineNo(display.view[toIndex + 1].line) - 1),
                        (toNode =
                          display.view[toIndex + 1].node.previousSibling)),
                    !fromNode)
                  )
                    return !1;
                  for (
                    var newText = cm.doc.splitLines(
                        (function(cm, from, to, fromLine, toLine) {
                          var text = "",
                            closing = !1,
                            lineSep = cm.doc.lineSeparator();
                          function close() {
                            closing && ((text += lineSep), (closing = !1));
                          }
                          function addText(str) {
                            str && (close(), (text += str));
                          }
                          function walk(node) {
                            if (1 == node.nodeType) {
                              var cmText = node.getAttribute("cm-text");
                              if (null != cmText)
                                return void addText(
                                  cmText ||
                                    node.textContent.replace(/\u200b/g, "")
                                );
                              var range$$1,
                                markerID = node.getAttribute("cm-marker");
                              if (markerID) {
                                var found = cm.findMarks(
                                  Pos(fromLine, 0),
                                  Pos(toLine + 1, 0),
                                  ((id = +markerID),
                                  function(marker) {
                                    return marker.id == id;
                                  })
                                );
                                return void (
                                  found.length &&
                                  (range$$1 = found[0].find(0)) &&
                                  addText(
                                    getBetween(
                                      cm.doc,
                                      range$$1.from,
                                      range$$1.to
                                    ).join(lineSep)
                                  )
                                );
                              }
                              if (
                                "false" == node.getAttribute("contenteditable")
                              )
                                return;
                              var isBlock = /^(pre|div|p)$/i.test(
                                node.nodeName
                              );
                              isBlock && close();
                              for (var i = 0; i < node.childNodes.length; i++)
                                walk(node.childNodes[i]);
                              isBlock && (closing = !0);
                            } else
                              3 == node.nodeType && addText(node.nodeValue);
                            var id;
                          }
                          for (; walk(from), from != to; )
                            from = from.nextSibling;
                          return text;
                        })(cm, fromNode, toNode, fromLine, toLine)
                      ),
                      oldText = getBetween(
                        cm.doc,
                        Pos(fromLine, 0),
                        Pos(toLine, getLine(cm.doc, toLine).text.length)
                      );
                    1 < newText.length && 1 < oldText.length;

                  )
                    if (lst(newText) == lst(oldText))
                      newText.pop(), oldText.pop(), toLine--;
                    else {
                      if (newText[0] != oldText[0]) break;
                      newText.shift(), oldText.shift(), fromLine++;
                    }
                  for (
                    var cutFront = 0,
                      cutEnd = 0,
                      newTop = newText[0],
                      oldTop = oldText[0],
                      maxCutFront = Math.min(newTop.length, oldTop.length);
                    cutFront < maxCutFront &&
                    newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront);

                  )
                    ++cutFront;
                  for (
                    var newBot = lst(newText),
                      oldBot = lst(oldText),
                      maxCutEnd = Math.min(
                        newBot.length - (1 == newText.length ? cutFront : 0),
                        oldBot.length - (1 == oldText.length ? cutFront : 0)
                      );
                    cutEnd < maxCutEnd &&
                    newBot.charCodeAt(newBot.length - cutEnd - 1) ==
                      oldBot.charCodeAt(oldBot.length - cutEnd - 1);

                  )
                    ++cutEnd;
                  if (
                    1 == newText.length &&
                    1 == oldText.length &&
                    fromLine == from.line
                  )
                    for (
                      ;
                      cutFront &&
                      cutFront > from.ch &&
                      newBot.charCodeAt(newBot.length - cutEnd - 1) ==
                        oldBot.charCodeAt(oldBot.length - cutEnd - 1);

                    )
                      cutFront--, cutEnd++;
                  (newText[newText.length - 1] = newBot
                    .slice(0, newBot.length - cutEnd)
                    .replace(/^\u200b+/, "")),
                    (newText[0] = newText[0]
                      .slice(cutFront)
                      .replace(/\u200b+$/, ""));
                  var chFrom = Pos(fromLine, cutFront),
                    chTo = Pos(
                      toLine,
                      oldText.length ? lst(oldText).length - cutEnd : 0
                    );
                  return 1 < newText.length || newText[0] || cmp(chFrom, chTo)
                    ? (replaceRange(cm.doc, newText, chFrom, chTo, "+input"),
                      !0)
                    : void 0;
                }),
                (ContentEditableInput.prototype.ensurePolled = function() {
                  this.forceCompositionEnd();
                }),
                (ContentEditableInput.prototype.reset = function() {
                  this.forceCompositionEnd();
                }),
                (ContentEditableInput.prototype.forceCompositionEnd = function() {
                  this.composing &&
                    (clearTimeout(this.readDOMTimeout),
                    (this.composing = null),
                    this.updateFromDOM(),
                    this.div.blur(),
                    this.div.focus());
                }),
                (ContentEditableInput.prototype.readFromDOMSoon = function() {
                  var this$1 = this;
                  null == this.readDOMTimeout &&
                    (this.readDOMTimeout = setTimeout(function() {
                      if (((this$1.readDOMTimeout = null), this$1.composing)) {
                        if (!this$1.composing.done) return;
                        this$1.composing = null;
                      }
                      this$1.updateFromDOM();
                    }, 80));
                }),
                (ContentEditableInput.prototype.updateFromDOM = function() {
                  var this$1 = this;
                  (!this.cm.isReadOnly() && this.pollContent()) ||
                    runInOp(this.cm, function() {
                      return regChange(this$1.cm);
                    });
                }),
                (ContentEditableInput.prototype.setUneditable = function(node) {
                  node.contentEditable = "false";
                }),
                (ContentEditableInput.prototype.onKeyPress = function(e) {
                  0 != e.charCode &&
                    (e.preventDefault(),
                    this.cm.isReadOnly() ||
                      operation(this.cm, applyTextInput)(
                        this.cm,
                        String.fromCharCode(
                          null == e.charCode ? e.keyCode : e.charCode
                        ),
                        0
                      ));
                }),
                (ContentEditableInput.prototype.readOnlyChanged = function(
                  val
                ) {
                  this.div.contentEditable = String("nocursor" != val);
                }),
                (ContentEditableInput.prototype.onContextMenu = function() {}),
                (ContentEditableInput.prototype.resetPosition = function() {}),
                (ContentEditableInput.prototype.needsContentAttribute = !0);
              var TextareaInput = function(cm) {
                (this.cm = cm),
                  (this.prevInput = ""),
                  (this.pollingFast = !1),
                  (this.polling = new Delayed()),
                  (this.hasSelection = !1),
                  (this.composing = null);
              };
              (TextareaInput.prototype.init = function(display) {
                var this$1 = this,
                  input = this,
                  cm = this.cm,
                  div = (this.wrapper = hiddenTextarea()),
                  te = (this.textarea = div.firstChild);
                function prepareCopyCut(e) {
                  if (!signalDOMEvent(cm, e)) {
                    if (cm.somethingSelected())
                      setLastCopied({ lineWise: !1, text: cm.getSelections() });
                    else {
                      if (!cm.options.lineWiseCopyCut) return;
                      var ranges = copyableRanges(cm);
                      setLastCopied({ lineWise: !0, text: ranges.text }),
                        "cut" == e.type
                          ? cm.setSelections(
                              ranges.ranges,
                              null,
                              sel_dontScroll
                            )
                          : ((input.prevInput = ""),
                            (te.value = ranges.text.join("\n")),
                            selectInput(te));
                    }
                    "cut" == e.type && (cm.state.cutIncoming = !0);
                  }
                }
                display.wrapper.insertBefore(div, display.wrapper.firstChild),
                  ios && (te.style.width = "0px"),
                  on(te, "input", function() {
                    ie &&
                      9 <= ie_version &&
                      this$1.hasSelection &&
                      (this$1.hasSelection = null),
                      input.poll();
                  }),
                  on(te, "paste", function(e) {
                    signalDOMEvent(cm, e) ||
                      handlePaste(e, cm) ||
                      ((cm.state.pasteIncoming = !0), input.fastPoll());
                  }),
                  on(te, "cut", prepareCopyCut),
                  on(te, "copy", prepareCopyCut),
                  on(display.scroller, "paste", function(e) {
                    eventInWidget(display, e) ||
                      signalDOMEvent(cm, e) ||
                      ((cm.state.pasteIncoming = !0), input.focus());
                  }),
                  on(display.lineSpace, "selectstart", function(e) {
                    eventInWidget(display, e) || e_preventDefault(e);
                  }),
                  on(te, "compositionstart", function() {
                    var start = cm.getCursor("from");
                    input.composing && input.composing.range.clear(),
                      (input.composing = {
                        start: start,
                        range: cm.markText(start, cm.getCursor("to"), {
                          className: "CodeMirror-composing"
                        })
                      });
                  }),
                  on(te, "compositionend", function() {
                    input.composing &&
                      (input.poll(),
                      input.composing.range.clear(),
                      (input.composing = null));
                  });
              }),
                (TextareaInput.prototype.prepareSelection = function() {
                  var cm = this.cm,
                    display = cm.display,
                    doc = cm.doc,
                    result = prepareSelection(cm);
                  if (cm.options.moveInputWithCursor) {
                    var headPos = cursorCoords(
                        cm,
                        doc.sel.primary().head,
                        "div"
                      ),
                      wrapOff = display.wrapper.getBoundingClientRect(),
                      lineOff = display.lineDiv.getBoundingClientRect();
                    (result.teTop = Math.max(
                      0,
                      Math.min(
                        display.wrapper.clientHeight - 10,
                        headPos.top + lineOff.top - wrapOff.top
                      )
                    )),
                      (result.teLeft = Math.max(
                        0,
                        Math.min(
                          display.wrapper.clientWidth - 10,
                          headPos.left + lineOff.left - wrapOff.left
                        )
                      ));
                  }
                  return result;
                }),
                (TextareaInput.prototype.showSelection = function(drawn) {
                  var display = this.cm.display;
                  removeChildrenAndAdd(display.cursorDiv, drawn.cursors),
                    removeChildrenAndAdd(display.selectionDiv, drawn.selection),
                    null != drawn.teTop &&
                      ((this.wrapper.style.top = drawn.teTop + "px"),
                      (this.wrapper.style.left = drawn.teLeft + "px"));
                }),
                (TextareaInput.prototype.reset = function(typing) {
                  if (!this.contextMenuPending && !this.composing) {
                    var cm = this.cm;
                    if (cm.somethingSelected()) {
                      this.prevInput = "";
                      var content = cm.getSelection();
                      (this.textarea.value = content),
                        cm.state.focused && selectInput(this.textarea),
                        ie && 9 <= ie_version && (this.hasSelection = content);
                    } else
                      typing ||
                        ((this.prevInput = this.textarea.value = ""),
                        ie && 9 <= ie_version && (this.hasSelection = null));
                  }
                }),
                (TextareaInput.prototype.getField = function() {
                  return this.textarea;
                }),
                (TextareaInput.prototype.supportsTouch = function() {
                  return !1;
                }),
                (TextareaInput.prototype.focus = function() {
                  if (
                    "nocursor" != this.cm.options.readOnly &&
                    (!mobile || activeElt() != this.textarea)
                  )
                    try {
                      this.textarea.focus();
                    } catch (e) {}
                }),
                (TextareaInput.prototype.blur = function() {
                  this.textarea.blur();
                }),
                (TextareaInput.prototype.resetPosition = function() {
                  this.wrapper.style.top = this.wrapper.style.left = 0;
                }),
                (TextareaInput.prototype.receivedFocus = function() {
                  this.slowPoll();
                }),
                (TextareaInput.prototype.slowPoll = function() {
                  var this$1 = this;
                  this.pollingFast ||
                    this.polling.set(this.cm.options.pollInterval, function() {
                      this$1.poll(),
                        this$1.cm.state.focused && this$1.slowPoll();
                    });
                }),
                (TextareaInput.prototype.fastPoll = function() {
                  var missed = !1,
                    input = this;
                  (input.pollingFast = !0),
                    input.polling.set(20, function p() {
                      input.poll() || missed
                        ? ((input.pollingFast = !1), input.slowPoll())
                        : ((missed = !0), input.polling.set(60, p));
                    });
                }),
                (TextareaInput.prototype.poll = function() {
                  var this$1 = this,
                    cm = this.cm,
                    input = this.textarea,
                    prevInput = this.prevInput;
                  if (
                    this.contextMenuPending ||
                    !cm.state.focused ||
                    (hasSelection(input) && !prevInput && !this.composing) ||
                    cm.isReadOnly() ||
                    cm.options.disableInput ||
                    cm.state.keySeq
                  )
                    return !1;
                  var text = input.value;
                  if (text == prevInput && !cm.somethingSelected()) return !1;
                  if (
                    (ie && 9 <= ie_version && this.hasSelection === text) ||
                    (mac && /[\uf700-\uf7ff]/.test(text))
                  )
                    return cm.display.input.reset(), !1;
                  if (cm.doc.sel == cm.display.selForContextMenu) {
                    var first = text.charCodeAt(0);
                    if (
                      (8203 != first || prevInput || (prevInput = "​"),
                      8666 == first)
                    )
                      return this.reset(), this.cm.execCommand("undo");
                  }
                  for (
                    var same = 0, l = Math.min(prevInput.length, text.length);
                    same < l &&
                    prevInput.charCodeAt(same) == text.charCodeAt(same);

                  )
                    ++same;
                  return (
                    runInOp(cm, function() {
                      applyTextInput(
                        cm,
                        text.slice(same),
                        prevInput.length - same,
                        null,
                        this$1.composing ? "*compose" : null
                      ),
                        1e3 < text.length || -1 < text.indexOf("\n")
                          ? (input.value = this$1.prevInput = "")
                          : (this$1.prevInput = text),
                        this$1.composing &&
                          (this$1.composing.range.clear(),
                          (this$1.composing.range = cm.markText(
                            this$1.composing.start,
                            cm.getCursor("to"),
                            { className: "CodeMirror-composing" }
                          )));
                    }),
                    !0
                  );
                }),
                (TextareaInput.prototype.ensurePolled = function() {
                  this.pollingFast && this.poll() && (this.pollingFast = !1);
                }),
                (TextareaInput.prototype.onKeyPress = function() {
                  ie && 9 <= ie_version && (this.hasSelection = null),
                    this.fastPoll();
                }),
                (TextareaInput.prototype.onContextMenu = function(e) {
                  var input = this,
                    cm = input.cm,
                    display = cm.display,
                    te = input.textarea,
                    pos = posFromMouse(cm, e),
                    scrollPos = display.scroller.scrollTop;
                  if (pos && !presto) {
                    cm.options.resetSelectionOnContextMenu &&
                      -1 == cm.doc.sel.contains(pos) &&
                      operation(cm, setSelection)(
                        cm.doc,
                        simpleSelection(pos),
                        sel_dontScroll
                      );
                    var oldCSS = te.style.cssText,
                      oldWrapperCSS = input.wrapper.style.cssText;
                    input.wrapper.style.cssText = "position: absolute";
                    var oldScrollY,
                      wrapperBox = input.wrapper.getBoundingClientRect();
                    if (
                      ((te.style.cssText =
                        "position: absolute; width: 30px; height: 30px;\n      top: " +
                        (e.clientY - wrapperBox.top - 5) +
                        "px; left: " +
                        (e.clientX - wrapperBox.left - 5) +
                        "px;\n      z-index: 1000; background: " +
                        (ie ? "rgba(255, 255, 255, .05)" : "transparent") +
                        ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);"),
                      webkit && (oldScrollY = window.scrollY),
                      display.input.focus(),
                      webkit && window.scrollTo(null, oldScrollY),
                      display.input.reset(),
                      cm.somethingSelected() ||
                        (te.value = input.prevInput = " "),
                      (input.contextMenuPending = !0),
                      (display.selForContextMenu = cm.doc.sel),
                      clearTimeout(display.detectingSelectAll),
                      ie && 9 <= ie_version && prepareSelectAllHack(),
                      captureRightClick)
                    ) {
                      e_stop(e);
                      var mouseup = function() {
                        off(window, "mouseup", mouseup), setTimeout(rehide, 20);
                      };
                      on(window, "mouseup", mouseup);
                    } else setTimeout(rehide, 50);
                  }
                  function prepareSelectAllHack() {
                    if (null != te.selectionStart) {
                      var selected = cm.somethingSelected(),
                        extval = "​" + (selected ? te.value : "");
                      (te.value = "⇚"),
                        (te.value = extval),
                        (input.prevInput = selected ? "" : "​"),
                        (te.selectionStart = 1),
                        (te.selectionEnd = extval.length),
                        (display.selForContextMenu = cm.doc.sel);
                    }
                  }
                  function rehide() {
                    if (
                      ((input.contextMenuPending = !1),
                      (input.wrapper.style.cssText = oldWrapperCSS),
                      (te.style.cssText = oldCSS),
                      ie &&
                        ie_version < 9 &&
                        display.scrollbars.setScrollTop(
                          (display.scroller.scrollTop = scrollPos)
                        ),
                      null != te.selectionStart)
                    ) {
                      (!ie || (ie && ie_version < 9)) && prepareSelectAllHack();
                      var i = 0,
                        poll = function() {
                          display.selForContextMenu == cm.doc.sel &&
                          0 == te.selectionStart &&
                          0 < te.selectionEnd &&
                          "​" == input.prevInput
                            ? operation(cm, selectAll)(cm)
                            : i++ < 10
                              ? (display.detectingSelectAll = setTimeout(
                                  poll,
                                  500
                                ))
                              : ((display.selForContextMenu = null),
                                display.input.reset());
                        };
                      display.detectingSelectAll = setTimeout(poll, 200);
                    }
                  }
                }),
                (TextareaInput.prototype.readOnlyChanged = function(val) {
                  val || this.reset(),
                    (this.textarea.disabled = "nocursor" == val);
                }),
                (TextareaInput.prototype.setUneditable = function() {}),
                (TextareaInput.prototype.needsContentAttribute = !1),
                (function(CodeMirror) {
                  var optionHandlers = CodeMirror.optionHandlers;
                  function option(name, deflt, handle, notOnInit) {
                    (CodeMirror.defaults[name] = deflt),
                      handle &&
                        (optionHandlers[name] = notOnInit
                          ? function(cm, val, old) {
                              old != Init && handle(cm, val, old);
                            }
                          : handle);
                  }
                  (CodeMirror.defineOption = option),
                    (CodeMirror.Init = Init),
                    option(
                      "value",
                      "",
                      function(cm, val) {
                        return cm.setValue(val);
                      },
                      !0
                    ),
                    option(
                      "mode",
                      null,
                      function(cm, val) {
                        (cm.doc.modeOption = val), loadMode(cm);
                      },
                      !0
                    ),
                    option("indentUnit", 2, loadMode, !0),
                    option("indentWithTabs", !1),
                    option("smartIndent", !0),
                    option(
                      "tabSize",
                      4,
                      function(cm) {
                        resetModeState(cm), clearCaches(cm), regChange(cm);
                      },
                      !0
                    ),
                    option("lineSeparator", null, function(cm, val) {
                      if ((cm.doc.lineSep = val)) {
                        var newBreaks = [],
                          lineNo = cm.doc.first;
                        cm.doc.iter(function(line) {
                          for (var pos = 0; ; ) {
                            var found = line.text.indexOf(val, pos);
                            if (-1 == found) break;
                            (pos = found + val.length),
                              newBreaks.push(Pos(lineNo, found));
                          }
                          lineNo++;
                        });
                        for (var i = newBreaks.length - 1; 0 <= i; i--)
                          replaceRange(
                            cm.doc,
                            val,
                            newBreaks[i],
                            Pos(newBreaks[i].line, newBreaks[i].ch + val.length)
                          );
                      }
                    }),
                    option(
                      "specialChars",
                      /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,
                      function(cm, val, old) {
                        (cm.state.specialChars = new RegExp(
                          val.source + (val.test("\t") ? "" : "|\t"),
                          "g"
                        )),
                          old != Init && cm.refresh();
                      }
                    ),
                    option(
                      "specialCharPlaceholder",
                      defaultSpecialCharPlaceholder,
                      function(cm) {
                        return cm.refresh();
                      },
                      !0
                    ),
                    option("electricChars", !0),
                    option(
                      "inputStyle",
                      mobile ? "contenteditable" : "textarea",
                      function() {
                        throw new Error(
                          "inputStyle can not (yet) be changed in a running editor"
                        );
                      },
                      !0
                    ),
                    option(
                      "spellcheck",
                      !1,
                      function(cm, val) {
                        return (cm.getInputField().spellcheck = val);
                      },
                      !0
                    ),
                    option("rtlMoveVisually", !windows),
                    option("wholeLineUpdateBefore", !0),
                    option(
                      "theme",
                      "default",
                      function(cm) {
                        themeChanged(cm), guttersChanged(cm);
                      },
                      !0
                    ),
                    option("keyMap", "default", function(cm, val, old) {
                      var next = getKeyMap(val),
                        prev = old != Init && getKeyMap(old);
                      prev && prev.detach && prev.detach(cm, next),
                        next.attach && next.attach(cm, prev || null);
                    }),
                    option("extraKeys", null),
                    option("configureMouse", null),
                    option("lineWrapping", !1, wrappingChanged, !0),
                    option(
                      "gutters",
                      [],
                      function(cm) {
                        setGuttersForLineNumbers(cm.options),
                          guttersChanged(cm);
                      },
                      !0
                    ),
                    option(
                      "fixedGutter",
                      !0,
                      function(cm, val) {
                        (cm.display.gutters.style.left = val
                          ? compensateForHScroll(cm.display) + "px"
                          : "0"),
                          cm.refresh();
                      },
                      !0
                    ),
                    option(
                      "coverGutterNextToScrollbar",
                      !1,
                      function(cm) {
                        return updateScrollbars(cm);
                      },
                      !0
                    ),
                    option(
                      "scrollbarStyle",
                      "native",
                      function(cm) {
                        initScrollbars(cm),
                          updateScrollbars(cm),
                          cm.display.scrollbars.setScrollTop(cm.doc.scrollTop),
                          cm.display.scrollbars.setScrollLeft(
                            cm.doc.scrollLeft
                          );
                      },
                      !0
                    ),
                    option(
                      "lineNumbers",
                      !1,
                      function(cm) {
                        setGuttersForLineNumbers(cm.options),
                          guttersChanged(cm);
                      },
                      !0
                    ),
                    option("firstLineNumber", 1, guttersChanged, !0),
                    option(
                      "lineNumberFormatter",
                      function(integer) {
                        return integer;
                      },
                      guttersChanged,
                      !0
                    ),
                    option("showCursorWhenSelecting", !1, updateSelection, !0),
                    option("resetSelectionOnContextMenu", !0),
                    option("lineWiseCopyCut", !0),
                    option("pasteLinesPerSelection", !0),
                    option("readOnly", !1, function(cm, val) {
                      "nocursor" == val &&
                        (onBlur(cm), cm.display.input.blur()),
                        cm.display.input.readOnlyChanged(val);
                    }),
                    option(
                      "disableInput",
                      !1,
                      function(cm, val) {
                        val || cm.display.input.reset();
                      },
                      !0
                    ),
                    option("dragDrop", !0, dragDropChanged),
                    option("allowDropFileTypes", null),
                    option("cursorBlinkRate", 530),
                    option("cursorScrollMargin", 0),
                    option("cursorHeight", 1, updateSelection, !0),
                    option(
                      "singleCursorHeightPerLine",
                      !0,
                      updateSelection,
                      !0
                    ),
                    option("workTime", 100),
                    option("workDelay", 100),
                    option("flattenSpans", !0, resetModeState, !0),
                    option("addModeClass", !1, resetModeState, !0),
                    option("pollInterval", 100),
                    option("undoDepth", 200, function(cm, val) {
                      return (cm.doc.history.undoDepth = val);
                    }),
                    option("historyEventDelay", 1250),
                    option(
                      "viewportMargin",
                      10,
                      function(cm) {
                        return cm.refresh();
                      },
                      !0
                    ),
                    option("maxHighlightLength", 1e4, resetModeState, !0),
                    option("moveInputWithCursor", !0, function(cm, val) {
                      val || cm.display.input.resetPosition();
                    }),
                    option("tabindex", null, function(cm, val) {
                      return (cm.display.input.getField().tabIndex = val || "");
                    }),
                    option("autofocus", null),
                    option(
                      "direction",
                      "ltr",
                      function(cm, val) {
                        return cm.doc.setDirection(val);
                      },
                      !0
                    );
                })(CodeMirror$1),
                (function(CodeMirror) {
                  var optionHandlers = CodeMirror.optionHandlers,
                    helpers = (CodeMirror.helpers = {});
                  (CodeMirror.prototype = {
                    constructor: CodeMirror,
                    focus: function() {
                      window.focus(), this.display.input.focus();
                    },
                    setOption: function(option, value) {
                      var options = this.options,
                        old = options[option];
                      (options[option] == value && "mode" != option) ||
                        ((options[option] = value),
                        optionHandlers.hasOwnProperty(option) &&
                          operation(this, optionHandlers[option])(
                            this,
                            value,
                            old
                          ),
                        signal(this, "optionChange", this, option));
                    },
                    getOption: function(option) {
                      return this.options[option];
                    },
                    getDoc: function() {
                      return this.doc;
                    },
                    addKeyMap: function(map$$1, bottom) {
                      this.state.keyMaps[bottom ? "push" : "unshift"](
                        getKeyMap(map$$1)
                      );
                    },
                    removeKeyMap: function(map$$1) {
                      for (
                        var maps = this.state.keyMaps, i = 0;
                        i < maps.length;
                        ++i
                      )
                        if (maps[i] == map$$1 || maps[i].name == map$$1)
                          return maps.splice(i, 1), !0;
                    },
                    addOverlay: methodOp(function(spec, options) {
                      var mode = spec.token
                        ? spec
                        : CodeMirror.getMode(this.options, spec);
                      if (mode.startState)
                        throw new Error("Overlays may not be stateful.");
                      !(function(array, value, score) {
                        for (
                          var pos = 0, priority = score(value);
                          pos < array.length && score(array[pos]) <= priority;

                        )
                          pos++;
                        array.splice(pos, 0, value);
                      })(
                        this.state.overlays,
                        {
                          mode: mode,
                          modeSpec: spec,
                          opaque: options && options.opaque,
                          priority: (options && options.priority) || 0
                        },
                        function(overlay) {
                          return overlay.priority;
                        }
                      ),
                        this.state.modeGen++,
                        regChange(this);
                    }),
                    removeOverlay: methodOp(function(spec) {
                      for (
                        var overlays = this.state.overlays, i = 0;
                        i < overlays.length;
                        ++i
                      ) {
                        var cur = overlays[i].modeSpec;
                        if (
                          cur == spec ||
                          ("string" == typeof spec && cur.name == spec)
                        )
                          return (
                            overlays.splice(i, 1),
                            this.state.modeGen++,
                            void regChange(this)
                          );
                      }
                    }),
                    indentLine: methodOp(function(n, dir, aggressive) {
                      "string" != typeof dir &&
                        "number" != typeof dir &&
                        (dir =
                          null == dir
                            ? this.options.smartIndent ? "smart" : "prev"
                            : dir ? "add" : "subtract"),
                        isLine(this.doc, n) &&
                          indentLine(this, n, dir, aggressive);
                    }),
                    indentSelection: methodOp(function(how) {
                      for (
                        var ranges = this.doc.sel.ranges, end = -1, i = 0;
                        i < ranges.length;
                        i++
                      ) {
                        var range$$1 = ranges[i];
                        if (range$$1.empty())
                          range$$1.head.line > end &&
                            (indentLine(this, range$$1.head.line, how, !0),
                            (end = range$$1.head.line),
                            i == this.doc.sel.primIndex &&
                              ensureCursorVisible(this));
                        else {
                          var from = range$$1.from(),
                            to = range$$1.to(),
                            start = Math.max(end, from.line);
                          end =
                            Math.min(
                              this.lastLine(),
                              to.line - (to.ch ? 0 : 1)
                            ) + 1;
                          for (var j = start; j < end; ++j)
                            indentLine(this, j, how);
                          var newRanges = this.doc.sel.ranges;
                          0 == from.ch &&
                            ranges.length == newRanges.length &&
                            0 < newRanges[i].from().ch &&
                            replaceOneSelection(
                              this.doc,
                              i,
                              new Range(from, newRanges[i].to()),
                              sel_dontScroll
                            );
                        }
                      }
                    }),
                    getTokenAt: function(pos, precise) {
                      return takeToken(this, pos, precise);
                    },
                    getLineTokens: function(line, precise) {
                      return takeToken(this, Pos(line), precise, !0);
                    },
                    getTokenTypeAt: function(pos) {
                      pos = clipPos(this.doc, pos);
                      var type,
                        styles = getLineStyles(
                          this,
                          getLine(this.doc, pos.line)
                        ),
                        before = 0,
                        after = (styles.length - 1) / 2,
                        ch = pos.ch;
                      if (0 == ch) type = styles[2];
                      else
                        for (;;) {
                          var mid = (before + after) >> 1;
                          if ((mid ? styles[2 * mid - 1] : 0) >= ch)
                            after = mid;
                          else {
                            if (!(styles[2 * mid + 1] < ch)) {
                              type = styles[2 * mid + 2];
                              break;
                            }
                            before = mid + 1;
                          }
                        }
                      var cut = type ? type.indexOf("overlay ") : -1;
                      return cut < 0
                        ? type
                        : 0 == cut ? null : type.slice(0, cut - 1);
                    },
                    getModeAt: function(pos) {
                      var mode = this.doc.mode;
                      return mode.innerMode
                        ? CodeMirror.innerMode(mode, this.getTokenAt(pos).state)
                            .mode
                        : mode;
                    },
                    getHelper: function(pos, type) {
                      return this.getHelpers(pos, type)[0];
                    },
                    getHelpers: function(pos, type) {
                      var found = [];
                      if (!helpers.hasOwnProperty(type)) return found;
                      var help = helpers[type],
                        mode = this.getModeAt(pos);
                      if ("string" == typeof mode[type])
                        help[mode[type]] && found.push(help[mode[type]]);
                      else if (mode[type])
                        for (var i = 0; i < mode[type].length; i++) {
                          var val = help[mode[type][i]];
                          val && found.push(val);
                        }
                      else
                        mode.helperType && help[mode.helperType]
                          ? found.push(help[mode.helperType])
                          : help[mode.name] && found.push(help[mode.name]);
                      for (var i$1 = 0; i$1 < help._global.length; i$1++) {
                        var cur = help._global[i$1];
                        cur.pred(mode, this) &&
                          -1 == indexOf(found, cur.val) &&
                          found.push(cur.val);
                      }
                      return found;
                    },
                    getStateAfter: function(line, precise) {
                      var doc = this.doc;
                      return getContextBefore(
                        this,
                        (line = clipLine(
                          doc,
                          null == line ? doc.first + doc.size - 1 : line
                        )) + 1,
                        precise
                      ).state;
                    },
                    cursorCoords: function(start, mode) {
                      var range$$1 = this.doc.sel.primary();
                      return cursorCoords(
                        this,
                        null == start
                          ? range$$1.head
                          : "object" == typeof start
                            ? clipPos(this.doc, start)
                            : start ? range$$1.from() : range$$1.to(),
                        mode || "page"
                      );
                    },
                    charCoords: function(pos, mode) {
                      return charCoords(
                        this,
                        clipPos(this.doc, pos),
                        mode || "page"
                      );
                    },
                    coordsChar: function(coords, mode) {
                      return coordsChar(
                        this,
                        (coords = fromCoordSystem(this, coords, mode || "page"))
                          .left,
                        coords.top
                      );
                    },
                    lineAtHeight: function(height, mode) {
                      return (
                        (height = fromCoordSystem(
                          this,
                          { top: height, left: 0 },
                          mode || "page"
                        ).top),
                        lineAtHeight(this.doc, height + this.display.viewOffset)
                      );
                    },
                    heightAtLine: function(line, mode, includeWidgets) {
                      var lineObj,
                        end = !1;
                      if ("number" == typeof line) {
                        var last = this.doc.first + this.doc.size - 1;
                        line < this.doc.first
                          ? (line = this.doc.first)
                          : last < line && ((line = last), (end = !0)),
                          (lineObj = getLine(this.doc, line));
                      } else lineObj = line;
                      return (
                        intoCoordSystem(
                          this,
                          lineObj,
                          { top: 0, left: 0 },
                          mode || "page",
                          includeWidgets || end
                        ).top +
                        (end ? this.doc.height - heightAtLine(lineObj) : 0)
                      );
                    },
                    defaultTextHeight: function() {
                      return textHeight(this.display);
                    },
                    defaultCharWidth: function() {
                      return charWidth(this.display);
                    },
                    getViewport: function() {
                      return {
                        from: this.display.viewFrom,
                        to: this.display.viewTo
                      };
                    },
                    addWidget: function(pos, node, scroll, vert, horiz) {
                      var cm,
                        rect,
                        scrollPos,
                        display = this.display,
                        top = (pos = cursorCoords(this, clipPos(this.doc, pos)))
                          .bottom,
                        left = pos.left;
                      if (
                        ((node.style.position = "absolute"),
                        node.setAttribute("cm-ignore-events", "true"),
                        this.display.input.setUneditable(node),
                        display.sizer.appendChild(node),
                        "over" == vert)
                      )
                        top = pos.top;
                      else if ("above" == vert || "near" == vert) {
                        var vspace = Math.max(
                            display.wrapper.clientHeight,
                            this.doc.height
                          ),
                          hspace = Math.max(
                            display.sizer.clientWidth,
                            display.lineSpace.clientWidth
                          );
                        ("above" == vert ||
                          pos.bottom + node.offsetHeight > vspace) &&
                        pos.top > node.offsetHeight
                          ? (top = pos.top - node.offsetHeight)
                          : pos.bottom + node.offsetHeight <= vspace &&
                            (top = pos.bottom),
                          left + node.offsetWidth > hspace &&
                            (left = hspace - node.offsetWidth);
                      }
                      (node.style.top = top + "px"),
                        (node.style.left = node.style.right = ""),
                        "right" == horiz
                          ? ((left =
                              display.sizer.clientWidth - node.offsetWidth),
                            (node.style.right = "0px"))
                          : ("left" == horiz
                              ? (left = 0)
                              : "middle" == horiz &&
                                (left =
                                  (display.sizer.clientWidth -
                                    node.offsetWidth) /
                                  2),
                            (node.style.left = left + "px")),
                        scroll &&
                          ((cm = this),
                          (rect = {
                            left: left,
                            top: top,
                            right: left + node.offsetWidth,
                            bottom: top + node.offsetHeight
                          }),
                          null !=
                            (scrollPos = calculateScrollPos(cm, rect))
                              .scrollTop &&
                            updateScrollTop(cm, scrollPos.scrollTop),
                          null != scrollPos.scrollLeft &&
                            setScrollLeft(cm, scrollPos.scrollLeft));
                    },
                    triggerOnKeyDown: methodOp(onKeyDown),
                    triggerOnKeyPress: methodOp(onKeyPress),
                    triggerOnKeyUp: onKeyUp,
                    triggerOnMouseDown: methodOp(onMouseDown),
                    execCommand: function(cmd) {
                      if (commands.hasOwnProperty(cmd))
                        return commands[cmd].call(null, this);
                    },
                    triggerElectric: methodOp(function(text) {
                      triggerElectric(this, text);
                    }),
                    findPosH: function(from, amount, unit, visually) {
                      var dir = 1;
                      amount < 0 && ((dir = -1), (amount = -amount));
                      for (
                        var cur = clipPos(this.doc, from), i = 0;
                        i < amount &&
                        !(cur = findPosH(this.doc, cur, dir, unit, visually))
                          .hitSide;
                        ++i
                      );
                      return cur;
                    },
                    moveH: methodOp(function(dir, unit) {
                      var this$1 = this;
                      this.extendSelectionsBy(function(range$$1) {
                        return this$1.display.shift ||
                          this$1.doc.extend ||
                          range$$1.empty()
                          ? findPosH(
                              this$1.doc,
                              range$$1.head,
                              dir,
                              unit,
                              this$1.options.rtlMoveVisually
                            )
                          : dir < 0 ? range$$1.from() : range$$1.to();
                      }, sel_move);
                    }),
                    deleteH: methodOp(function(dir, unit) {
                      var sel = this.doc.sel,
                        doc = this.doc;
                      sel.somethingSelected()
                        ? doc.replaceSelection("", null, "+delete")
                        : deleteNearSelection(this, function(range$$1) {
                            var other = findPosH(
                              doc,
                              range$$1.head,
                              dir,
                              unit,
                              !1
                            );
                            return dir < 0
                              ? { from: other, to: range$$1.head }
                              : { from: range$$1.head, to: other };
                          });
                    }),
                    findPosV: function(from, amount, unit, goalColumn) {
                      var dir = 1,
                        x = goalColumn;
                      amount < 0 && ((dir = -1), (amount = -amount));
                      for (
                        var cur = clipPos(this.doc, from), i = 0;
                        i < amount;
                        ++i
                      ) {
                        var coords = cursorCoords(this, cur, "div");
                        if (
                          (null == x ? (x = coords.left) : (coords.left = x),
                          (cur = findPosV(this, coords, dir, unit)).hitSide)
                        )
                          break;
                      }
                      return cur;
                    },
                    moveV: methodOp(function(dir, unit) {
                      var this$1 = this,
                        doc = this.doc,
                        goals = [],
                        collapse =
                          !this.display.shift &&
                          !doc.extend &&
                          doc.sel.somethingSelected();
                      if (
                        (doc.extendSelectionsBy(function(range$$1) {
                          if (collapse)
                            return dir < 0 ? range$$1.from() : range$$1.to();
                          var headPos = cursorCoords(
                            this$1,
                            range$$1.head,
                            "div"
                          );
                          null != range$$1.goalColumn &&
                            (headPos.left = range$$1.goalColumn),
                            goals.push(headPos.left);
                          var pos = findPosV(this$1, headPos, dir, unit);
                          return (
                            "page" == unit &&
                              range$$1 == doc.sel.primary() &&
                              addToScrollTop(
                                this$1,
                                charCoords(this$1, pos, "div").top - headPos.top
                              ),
                            pos
                          );
                        }, sel_move),
                        goals.length)
                      )
                        for (var i = 0; i < doc.sel.ranges.length; i++)
                          doc.sel.ranges[i].goalColumn = goals[i];
                    }),
                    findWordAt: function(pos) {
                      var line = getLine(this.doc, pos.line).text,
                        start = pos.ch,
                        end = pos.ch;
                      if (line) {
                        var helper = this.getHelper(pos, "wordChars");
                        ("before" != pos.sticky && end != line.length) || !start
                          ? ++end
                          : --start;
                        for (
                          var startChar = line.charAt(start),
                            check = isWordChar(startChar, helper)
                              ? function(ch) {
                                  return isWordChar(ch, helper);
                                }
                              : /\s/.test(startChar)
                                ? function(ch) {
                                    return /\s/.test(ch);
                                  }
                                : function(ch) {
                                    return !/\s/.test(ch) && !isWordChar(ch);
                                  };
                          0 < start && check(line.charAt(start - 1));

                        )
                          --start;
                        for (; end < line.length && check(line.charAt(end)); )
                          ++end;
                      }
                      return new Range(
                        Pos(pos.line, start),
                        Pos(pos.line, end)
                      );
                    },
                    toggleOverwrite: function(value) {
                      (null != value && value == this.state.overwrite) ||
                        ((this.state.overwrite = !this.state.overwrite)
                          ? addClass(
                              this.display.cursorDiv,
                              "CodeMirror-overwrite"
                            )
                          : rmClass(
                              this.display.cursorDiv,
                              "CodeMirror-overwrite"
                            ),
                        signal(
                          this,
                          "overwriteToggle",
                          this,
                          this.state.overwrite
                        ));
                    },
                    hasFocus: function() {
                      return this.display.input.getField() == activeElt();
                    },
                    isReadOnly: function() {
                      return !(!this.options.readOnly && !this.doc.cantEdit);
                    },
                    scrollTo: methodOp(function(x, y) {
                      scrollToCoords(this, x, y);
                    }),
                    getScrollInfo: function() {
                      var scroller = this.display.scroller;
                      return {
                        left: scroller.scrollLeft,
                        top: scroller.scrollTop,
                        height:
                          scroller.scrollHeight -
                          scrollGap(this) -
                          this.display.barHeight,
                        width:
                          scroller.scrollWidth -
                          scrollGap(this) -
                          this.display.barWidth,
                        clientHeight: displayHeight(this),
                        clientWidth: displayWidth(this)
                      };
                    },
                    scrollIntoView: methodOp(function(range$$1, margin) {
                      null == range$$1
                        ? ((range$$1 = {
                            from: this.doc.sel.primary().head,
                            to: null
                          }),
                          null == margin &&
                            (margin = this.options.cursorScrollMargin))
                        : "number" == typeof range$$1
                          ? (range$$1 = { from: Pos(range$$1, 0), to: null })
                          : null == range$$1.from &&
                            (range$$1 = { from: range$$1, to: null }),
                        range$$1.to || (range$$1.to = range$$1.from),
                        (range$$1.margin = margin || 0),
                        null != range$$1.from.line
                          ? (function(cm, range$$1) {
                              resolveScrollToPos(cm),
                                (cm.curOp.scrollToPos = range$$1);
                            })(this, range$$1)
                          : scrollToCoordsRange(
                              this,
                              range$$1.from,
                              range$$1.to,
                              range$$1.margin
                            );
                    }),
                    setSize: methodOp(function(width, height) {
                      var this$1 = this,
                        interpret = function(val) {
                          return "number" == typeof val ||
                            /^\d+$/.test(String(val))
                            ? val + "px"
                            : val;
                        };
                      null != width &&
                        (this.display.wrapper.style.width = interpret(width)),
                        null != height &&
                          (this.display.wrapper.style.height = interpret(
                            height
                          )),
                        this.options.lineWrapping &&
                          clearLineMeasurementCache(this);
                      var lineNo$$1 = this.display.viewFrom;
                      this.doc.iter(lineNo$$1, this.display.viewTo, function(
                        line
                      ) {
                        if (line.widgets)
                          for (var i = 0; i < line.widgets.length; i++)
                            if (line.widgets[i].noHScroll) {
                              regLineChange(this$1, lineNo$$1, "widget");
                              break;
                            }
                        ++lineNo$$1;
                      }),
                        (this.curOp.forceUpdate = !0),
                        signal(this, "refresh", this);
                    }),
                    operation: function(f) {
                      return runInOp(this, f);
                    },
                    startOperation: function() {
                      return startOperation(this);
                    },
                    endOperation: function() {
                      return endOperation(this);
                    },
                    refresh: methodOp(function() {
                      var oldHeight = this.display.cachedTextHeight;
                      regChange(this),
                        (this.curOp.forceUpdate = !0),
                        clearCaches(this),
                        scrollToCoords(
                          this,
                          this.doc.scrollLeft,
                          this.doc.scrollTop
                        ),
                        updateGutterSpace(this),
                        (null == oldHeight ||
                          0.5 <
                            Math.abs(oldHeight - textHeight(this.display))) &&
                          estimateLineHeights(this),
                        signal(this, "refresh", this);
                    }),
                    swapDoc: methodOp(function(doc) {
                      var old = this.doc;
                      return (
                        (old.cm = null),
                        attachDoc(this, doc),
                        clearCaches(this),
                        this.display.input.reset(),
                        scrollToCoords(this, doc.scrollLeft, doc.scrollTop),
                        (this.curOp.forceScroll = !0),
                        signalLater(this, "swapDoc", this, old),
                        old
                      );
                    }),
                    getInputField: function() {
                      return this.display.input.getField();
                    },
                    getWrapperElement: function() {
                      return this.display.wrapper;
                    },
                    getScrollerElement: function() {
                      return this.display.scroller;
                    },
                    getGutterElement: function() {
                      return this.display.gutters;
                    }
                  }),
                    eventMixin(CodeMirror),
                    (CodeMirror.registerHelper = function(type, name, value) {
                      helpers.hasOwnProperty(type) ||
                        (helpers[type] = CodeMirror[type] = { _global: [] }),
                        (helpers[type][name] = value);
                    }),
                    (CodeMirror.registerGlobalHelper = function(
                      type,
                      name,
                      predicate,
                      value
                    ) {
                      CodeMirror.registerHelper(type, name, value),
                        helpers[type]._global.push({
                          pred: predicate,
                          val: value
                        });
                    });
                })(CodeMirror$1);
              var CodeMirror,
                dontDelegate = "iter insert remove copy getEditor constructor".split(
                  " "
                );
              for (var prop in Doc.prototype)
                Doc.prototype.hasOwnProperty(prop) &&
                  indexOf(dontDelegate, prop) < 0 &&
                  (CodeMirror$1.prototype[prop] = (function(method) {
                    return function() {
                      return method.apply(this.doc, arguments);
                    };
                  })(Doc.prototype[prop]));
              return (
                eventMixin(Doc),
                (CodeMirror$1.inputStyles = {
                  textarea: TextareaInput,
                  contenteditable: ContentEditableInput
                }),
                (CodeMirror$1.defineMode = function(name) {
                  CodeMirror$1.defaults.mode ||
                    "null" == name ||
                    (CodeMirror$1.defaults.mode = name),
                    function(name, mode) {
                      2 < arguments.length &&
                        (mode.dependencies = Array.prototype.slice.call(
                          arguments,
                          2
                        )),
                        (modes[name] = mode);
                    }.apply(this, arguments);
                }),
                (CodeMirror$1.defineMIME = function(mime, spec) {
                  mimeModes[mime] = spec;
                }),
                CodeMirror$1.defineMode("null", function() {
                  return {
                    token: function(stream) {
                      return stream.skipToEnd();
                    }
                  };
                }),
                CodeMirror$1.defineMIME("text/plain", "null"),
                (CodeMirror$1.defineExtension = function(name, func) {
                  CodeMirror$1.prototype[name] = func;
                }),
                (CodeMirror$1.defineDocExtension = function(name, func) {
                  Doc.prototype[name] = func;
                }),
                (CodeMirror$1.fromTextArea = function(textarea, options) {
                  if (
                    (((options = options ? copyObj(options) : {}).value =
                      textarea.value),
                    !options.tabindex &&
                      textarea.tabIndex &&
                      (options.tabindex = textarea.tabIndex),
                    !options.placeholder &&
                      textarea.placeholder &&
                      (options.placeholder = textarea.placeholder),
                    null == options.autofocus)
                  ) {
                    var hasFocus = activeElt();
                    options.autofocus =
                      hasFocus == textarea ||
                      (null != textarea.getAttribute("autofocus") &&
                        hasFocus == document.body);
                  }
                  function save() {
                    textarea.value = cm.getValue();
                  }
                  var realSubmit;
                  if (
                    textarea.form &&
                    (on(textarea.form, "submit", save),
                    !options.leaveSubmitMethodAlone)
                  ) {
                    var form = textarea.form;
                    realSubmit = form.submit;
                    try {
                      var wrappedSubmit = (form.submit = function() {
                        save(),
                          (form.submit = realSubmit),
                          form.submit(),
                          (form.submit = wrappedSubmit);
                      });
                    } catch (e) {}
                  }
                  (options.finishInit = function(cm) {
                    (cm.save = save),
                      (cm.getTextArea = function() {
                        return textarea;
                      }),
                      (cm.toTextArea = function() {
                        (cm.toTextArea = isNaN),
                          save(),
                          textarea.parentNode.removeChild(
                            cm.getWrapperElement()
                          ),
                          (textarea.style.display = ""),
                          textarea.form &&
                            (off(textarea.form, "submit", save),
                            "function" == typeof textarea.form.submit &&
                              (textarea.form.submit = realSubmit));
                      });
                  }),
                    (textarea.style.display = "none");
                  var cm = CodeMirror$1(function(node) {
                    return textarea.parentNode.insertBefore(
                      node,
                      textarea.nextSibling
                    );
                  }, options);
                  return cm;
                }),
                ((CodeMirror = CodeMirror$1).off = off),
                (CodeMirror.on = on),
                (CodeMirror.wheelEventPixels = wheelEventPixels),
                (CodeMirror.Doc = Doc),
                (CodeMirror.splitLines = splitLinesAuto),
                (CodeMirror.countColumn = countColumn),
                (CodeMirror.findColumn = findColumn),
                (CodeMirror.isWordChar = isWordCharBasic),
                (CodeMirror.Pass = Pass),
                (CodeMirror.signal = signal),
                (CodeMirror.Line = Line),
                (CodeMirror.changeEnd = changeEnd),
                (CodeMirror.scrollbarModel = scrollbarModel),
                (CodeMirror.Pos = Pos),
                (CodeMirror.cmpPos = cmp),
                (CodeMirror.modes = modes),
                (CodeMirror.mimeModes = mimeModes),
                (CodeMirror.resolveMode = resolveMode),
                (CodeMirror.getMode = getMode),
                (CodeMirror.modeExtensions = modeExtensions),
                (CodeMirror.extendMode = extendMode),
                (CodeMirror.copyState = copyState),
                (CodeMirror.startState = startState),
                (CodeMirror.innerMode = innerMode),
                (CodeMirror.commands = commands),
                (CodeMirror.keyMap = keyMap),
                (CodeMirror.keyName = keyName),
                (CodeMirror.isModifierKey = isModifierKey),
                (CodeMirror.lookupKey = lookupKey),
                (CodeMirror.normalizeKeyMap = normalizeKeyMap),
                (CodeMirror.StringStream = StringStream),
                (CodeMirror.SharedTextMarker = SharedTextMarker),
                (CodeMirror.TextMarker = TextMarker),
                (CodeMirror.LineWidget = LineWidget),
                (CodeMirror.e_preventDefault = e_preventDefault),
                (CodeMirror.e_stopPropagation = e_stopPropagation),
                (CodeMirror.e_stop = e_stop),
                (CodeMirror.addClass = addClass),
                (CodeMirror.contains = contains),
                (CodeMirror.rmClass = rmClass),
                (CodeMirror.keyNames = keyNames),
                (CodeMirror$1.version = "5.35.0"),
                CodeMirror$1
              );
            }),
            "object" == typeof exports && void 0 !== module
              ? (module.exports = factory())
              : (global.CodeMirror = factory());
        },
        {}
      ],
      67: [
        function(require, module, exports) {
          module.exports = {
            Aacute: "Á",
            aacute: "á",
            Abreve: "Ă",
            abreve: "ă",
            ac: "∾",
            acd: "∿",
            acE: "∾̳",
            Acirc: "Â",
            acirc: "â",
            acute: "´",
            Acy: "А",
            acy: "а",
            AElig: "Æ",
            aelig: "æ",
            af: "⁡",
            Afr: "𝔄",
            afr: "𝔞",
            Agrave: "À",
            agrave: "à",
            alefsym: "ℵ",
            aleph: "ℵ",
            Alpha: "Α",
            alpha: "α",
            Amacr: "Ā",
            amacr: "ā",
            amalg: "⨿",
            amp: "&",
            AMP: "&",
            andand: "⩕",
            And: "⩓",
            and: "∧",
            andd: "⩜",
            andslope: "⩘",
            andv: "⩚",
            ang: "∠",
            ange: "⦤",
            angle: "∠",
            angmsdaa: "⦨",
            angmsdab: "⦩",
            angmsdac: "⦪",
            angmsdad: "⦫",
            angmsdae: "⦬",
            angmsdaf: "⦭",
            angmsdag: "⦮",
            angmsdah: "⦯",
            angmsd: "∡",
            angrt: "∟",
            angrtvb: "⊾",
            angrtvbd: "⦝",
            angsph: "∢",
            angst: "Å",
            angzarr: "⍼",
            Aogon: "Ą",
            aogon: "ą",
            Aopf: "𝔸",
            aopf: "𝕒",
            apacir: "⩯",
            ap: "≈",
            apE: "⩰",
            ape: "≊",
            apid: "≋",
            apos: "'",
            ApplyFunction: "⁡",
            approx: "≈",
            approxeq: "≊",
            Aring: "Å",
            aring: "å",
            Ascr: "𝒜",
            ascr: "𝒶",
            Assign: "≔",
            ast: "*",
            asymp: "≈",
            asympeq: "≍",
            Atilde: "Ã",
            atilde: "ã",
            Auml: "Ä",
            auml: "ä",
            awconint: "∳",
            awint: "⨑",
            backcong: "≌",
            backepsilon: "϶",
            backprime: "‵",
            backsim: "∽",
            backsimeq: "⋍",
            Backslash: "∖",
            Barv: "⫧",
            barvee: "⊽",
            barwed: "⌅",
            Barwed: "⌆",
            barwedge: "⌅",
            bbrk: "⎵",
            bbrktbrk: "⎶",
            bcong: "≌",
            Bcy: "Б",
            bcy: "б",
            bdquo: "„",
            becaus: "∵",
            because: "∵",
            Because: "∵",
            bemptyv: "⦰",
            bepsi: "϶",
            bernou: "ℬ",
            Bernoullis: "ℬ",
            Beta: "Β",
            beta: "β",
            beth: "ℶ",
            between: "≬",
            Bfr: "𝔅",
            bfr: "𝔟",
            bigcap: "⋂",
            bigcirc: "◯",
            bigcup: "⋃",
            bigodot: "⨀",
            bigoplus: "⨁",
            bigotimes: "⨂",
            bigsqcup: "⨆",
            bigstar: "★",
            bigtriangledown: "▽",
            bigtriangleup: "△",
            biguplus: "⨄",
            bigvee: "⋁",
            bigwedge: "⋀",
            bkarow: "⤍",
            blacklozenge: "⧫",
            blacksquare: "▪",
            blacktriangle: "▴",
            blacktriangledown: "▾",
            blacktriangleleft: "◂",
            blacktriangleright: "▸",
            blank: "␣",
            blk12: "▒",
            blk14: "░",
            blk34: "▓",
            block: "█",
            bne: "=⃥",
            bnequiv: "≡⃥",
            bNot: "⫭",
            bnot: "⌐",
            Bopf: "𝔹",
            bopf: "𝕓",
            bot: "⊥",
            bottom: "⊥",
            bowtie: "⋈",
            boxbox: "⧉",
            boxdl: "┐",
            boxdL: "╕",
            boxDl: "╖",
            boxDL: "╗",
            boxdr: "┌",
            boxdR: "╒",
            boxDr: "╓",
            boxDR: "╔",
            boxh: "─",
            boxH: "═",
            boxhd: "┬",
            boxHd: "╤",
            boxhD: "╥",
            boxHD: "╦",
            boxhu: "┴",
            boxHu: "╧",
            boxhU: "╨",
            boxHU: "╩",
            boxminus: "⊟",
            boxplus: "⊞",
            boxtimes: "⊠",
            boxul: "┘",
            boxuL: "╛",
            boxUl: "╜",
            boxUL: "╝",
            boxur: "└",
            boxuR: "╘",
            boxUr: "╙",
            boxUR: "╚",
            boxv: "│",
            boxV: "║",
            boxvh: "┼",
            boxvH: "╪",
            boxVh: "╫",
            boxVH: "╬",
            boxvl: "┤",
            boxvL: "╡",
            boxVl: "╢",
            boxVL: "╣",
            boxvr: "├",
            boxvR: "╞",
            boxVr: "╟",
            boxVR: "╠",
            bprime: "‵",
            breve: "˘",
            Breve: "˘",
            brvbar: "¦",
            bscr: "𝒷",
            Bscr: "ℬ",
            bsemi: "⁏",
            bsim: "∽",
            bsime: "⋍",
            bsolb: "⧅",
            bsol: "\\",
            bsolhsub: "⟈",
            bull: "•",
            bullet: "•",
            bump: "≎",
            bumpE: "⪮",
            bumpe: "≏",
            Bumpeq: "≎",
            bumpeq: "≏",
            Cacute: "Ć",
            cacute: "ć",
            capand: "⩄",
            capbrcup: "⩉",
            capcap: "⩋",
            cap: "∩",
            Cap: "⋒",
            capcup: "⩇",
            capdot: "⩀",
            CapitalDifferentialD: "ⅅ",
            caps: "∩︀",
            caret: "⁁",
            caron: "ˇ",
            Cayleys: "ℭ",
            ccaps: "⩍",
            Ccaron: "Č",
            ccaron: "č",
            Ccedil: "Ç",
            ccedil: "ç",
            Ccirc: "Ĉ",
            ccirc: "ĉ",
            Cconint: "∰",
            ccups: "⩌",
            ccupssm: "⩐",
            Cdot: "Ċ",
            cdot: "ċ",
            cedil: "¸",
            Cedilla: "¸",
            cemptyv: "⦲",
            cent: "¢",
            centerdot: "·",
            CenterDot: "·",
            cfr: "𝔠",
            Cfr: "ℭ",
            CHcy: "Ч",
            chcy: "ч",
            check: "✓",
            checkmark: "✓",
            Chi: "Χ",
            chi: "χ",
            circ: "ˆ",
            circeq: "≗",
            circlearrowleft: "↺",
            circlearrowright: "↻",
            circledast: "⊛",
            circledcirc: "⊚",
            circleddash: "⊝",
            CircleDot: "⊙",
            circledR: "®",
            circledS: "Ⓢ",
            CircleMinus: "⊖",
            CirclePlus: "⊕",
            CircleTimes: "⊗",
            cir: "○",
            cirE: "⧃",
            cire: "≗",
            cirfnint: "⨐",
            cirmid: "⫯",
            cirscir: "⧂",
            ClockwiseContourIntegral: "∲",
            CloseCurlyDoubleQuote: "”",
            CloseCurlyQuote: "’",
            clubs: "♣",
            clubsuit: "♣",
            colon: ":",
            Colon: "∷",
            Colone: "⩴",
            colone: "≔",
            coloneq: "≔",
            comma: ",",
            commat: "@",
            comp: "∁",
            compfn: "∘",
            complement: "∁",
            complexes: "ℂ",
            cong: "≅",
            congdot: "⩭",
            Congruent: "≡",
            conint: "∮",
            Conint: "∯",
            ContourIntegral: "∮",
            copf: "𝕔",
            Copf: "ℂ",
            coprod: "∐",
            Coproduct: "∐",
            copy: "©",
            COPY: "©",
            copysr: "℗",
            CounterClockwiseContourIntegral: "∳",
            crarr: "↵",
            cross: "✗",
            Cross: "⨯",
            Cscr: "𝒞",
            cscr: "𝒸",
            csub: "⫏",
            csube: "⫑",
            csup: "⫐",
            csupe: "⫒",
            ctdot: "⋯",
            cudarrl: "⤸",
            cudarrr: "⤵",
            cuepr: "⋞",
            cuesc: "⋟",
            cularr: "↶",
            cularrp: "⤽",
            cupbrcap: "⩈",
            cupcap: "⩆",
            CupCap: "≍",
            cup: "∪",
            Cup: "⋓",
            cupcup: "⩊",
            cupdot: "⊍",
            cupor: "⩅",
            cups: "∪︀",
            curarr: "↷",
            curarrm: "⤼",
            curlyeqprec: "⋞",
            curlyeqsucc: "⋟",
            curlyvee: "⋎",
            curlywedge: "⋏",
            curren: "¤",
            curvearrowleft: "↶",
            curvearrowright: "↷",
            cuvee: "⋎",
            cuwed: "⋏",
            cwconint: "∲",
            cwint: "∱",
            cylcty: "⌭",
            dagger: "†",
            Dagger: "‡",
            daleth: "ℸ",
            darr: "↓",
            Darr: "↡",
            dArr: "⇓",
            dash: "‐",
            Dashv: "⫤",
            dashv: "⊣",
            dbkarow: "⤏",
            dblac: "˝",
            Dcaron: "Ď",
            dcaron: "ď",
            Dcy: "Д",
            dcy: "д",
            ddagger: "‡",
            ddarr: "⇊",
            DD: "ⅅ",
            dd: "ⅆ",
            DDotrahd: "⤑",
            ddotseq: "⩷",
            deg: "°",
            Del: "∇",
            Delta: "Δ",
            delta: "δ",
            demptyv: "⦱",
            dfisht: "⥿",
            Dfr: "𝔇",
            dfr: "𝔡",
            dHar: "⥥",
            dharl: "⇃",
            dharr: "⇂",
            DiacriticalAcute: "´",
            DiacriticalDot: "˙",
            DiacriticalDoubleAcute: "˝",
            DiacriticalGrave: "`",
            DiacriticalTilde: "˜",
            diam: "⋄",
            diamond: "⋄",
            Diamond: "⋄",
            diamondsuit: "♦",
            diams: "♦",
            die: "¨",
            DifferentialD: "ⅆ",
            digamma: "ϝ",
            disin: "⋲",
            div: "÷",
            divide: "÷",
            divideontimes: "⋇",
            divonx: "⋇",
            DJcy: "Ђ",
            djcy: "ђ",
            dlcorn: "⌞",
            dlcrop: "⌍",
            dollar: "$",
            Dopf: "𝔻",
            dopf: "𝕕",
            Dot: "¨",
            dot: "˙",
            DotDot: "⃜",
            doteq: "≐",
            doteqdot: "≑",
            DotEqual: "≐",
            dotminus: "∸",
            dotplus: "∔",
            dotsquare: "⊡",
            doublebarwedge: "⌆",
            DoubleContourIntegral: "∯",
            DoubleDot: "¨",
            DoubleDownArrow: "⇓",
            DoubleLeftArrow: "⇐",
            DoubleLeftRightArrow: "⇔",
            DoubleLeftTee: "⫤",
            DoubleLongLeftArrow: "⟸",
            DoubleLongLeftRightArrow: "⟺",
            DoubleLongRightArrow: "⟹",
            DoubleRightArrow: "⇒",
            DoubleRightTee: "⊨",
            DoubleUpArrow: "⇑",
            DoubleUpDownArrow: "⇕",
            DoubleVerticalBar: "∥",
            DownArrowBar: "⤓",
            downarrow: "↓",
            DownArrow: "↓",
            Downarrow: "⇓",
            DownArrowUpArrow: "⇵",
            DownBreve: "̑",
            downdownarrows: "⇊",
            downharpoonleft: "⇃",
            downharpoonright: "⇂",
            DownLeftRightVector: "⥐",
            DownLeftTeeVector: "⥞",
            DownLeftVectorBar: "⥖",
            DownLeftVector: "↽",
            DownRightTeeVector: "⥟",
            DownRightVectorBar: "⥗",
            DownRightVector: "⇁",
            DownTeeArrow: "↧",
            DownTee: "⊤",
            drbkarow: "⤐",
            drcorn: "⌟",
            drcrop: "⌌",
            Dscr: "𝒟",
            dscr: "𝒹",
            DScy: "Ѕ",
            dscy: "ѕ",
            dsol: "⧶",
            Dstrok: "Đ",
            dstrok: "đ",
            dtdot: "⋱",
            dtri: "▿",
            dtrif: "▾",
            duarr: "⇵",
            duhar: "⥯",
            dwangle: "⦦",
            DZcy: "Џ",
            dzcy: "џ",
            dzigrarr: "⟿",
            Eacute: "É",
            eacute: "é",
            easter: "⩮",
            Ecaron: "Ě",
            ecaron: "ě",
            Ecirc: "Ê",
            ecirc: "ê",
            ecir: "≖",
            ecolon: "≕",
            Ecy: "Э",
            ecy: "э",
            eDDot: "⩷",
            Edot: "Ė",
            edot: "ė",
            eDot: "≑",
            ee: "ⅇ",
            efDot: "≒",
            Efr: "𝔈",
            efr: "𝔢",
            eg: "⪚",
            Egrave: "È",
            egrave: "è",
            egs: "⪖",
            egsdot: "⪘",
            el: "⪙",
            Element: "∈",
            elinters: "⏧",
            ell: "ℓ",
            els: "⪕",
            elsdot: "⪗",
            Emacr: "Ē",
            emacr: "ē",
            empty: "∅",
            emptyset: "∅",
            EmptySmallSquare: "◻",
            emptyv: "∅",
            EmptyVerySmallSquare: "▫",
            emsp13: " ",
            emsp14: " ",
            emsp: " ",
            ENG: "Ŋ",
            eng: "ŋ",
            ensp: " ",
            Eogon: "Ę",
            eogon: "ę",
            Eopf: "𝔼",
            eopf: "𝕖",
            epar: "⋕",
            eparsl: "⧣",
            eplus: "⩱",
            epsi: "ε",
            Epsilon: "Ε",
            epsilon: "ε",
            epsiv: "ϵ",
            eqcirc: "≖",
            eqcolon: "≕",
            eqsim: "≂",
            eqslantgtr: "⪖",
            eqslantless: "⪕",
            Equal: "⩵",
            equals: "=",
            EqualTilde: "≂",
            equest: "≟",
            Equilibrium: "⇌",
            equiv: "≡",
            equivDD: "⩸",
            eqvparsl: "⧥",
            erarr: "⥱",
            erDot: "≓",
            escr: "ℯ",
            Escr: "ℰ",
            esdot: "≐",
            Esim: "⩳",
            esim: "≂",
            Eta: "Η",
            eta: "η",
            ETH: "Ð",
            eth: "ð",
            Euml: "Ë",
            euml: "ë",
            euro: "€",
            excl: "!",
            exist: "∃",
            Exists: "∃",
            expectation: "ℰ",
            exponentiale: "ⅇ",
            ExponentialE: "ⅇ",
            fallingdotseq: "≒",
            Fcy: "Ф",
            fcy: "ф",
            female: "♀",
            ffilig: "ﬃ",
            fflig: "ﬀ",
            ffllig: "ﬄ",
            Ffr: "𝔉",
            ffr: "𝔣",
            filig: "ﬁ",
            FilledSmallSquare: "◼",
            FilledVerySmallSquare: "▪",
            fjlig: "fj",
            flat: "♭",
            fllig: "ﬂ",
            fltns: "▱",
            fnof: "ƒ",
            Fopf: "𝔽",
            fopf: "𝕗",
            forall: "∀",
            ForAll: "∀",
            fork: "⋔",
            forkv: "⫙",
            Fouriertrf: "ℱ",
            fpartint: "⨍",
            frac12: "½",
            frac13: "⅓",
            frac14: "¼",
            frac15: "⅕",
            frac16: "⅙",
            frac18: "⅛",
            frac23: "⅔",
            frac25: "⅖",
            frac34: "¾",
            frac35: "⅗",
            frac38: "⅜",
            frac45: "⅘",
            frac56: "⅚",
            frac58: "⅝",
            frac78: "⅞",
            frasl: "⁄",
            frown: "⌢",
            fscr: "𝒻",
            Fscr: "ℱ",
            gacute: "ǵ",
            Gamma: "Γ",
            gamma: "γ",
            Gammad: "Ϝ",
            gammad: "ϝ",
            gap: "⪆",
            Gbreve: "Ğ",
            gbreve: "ğ",
            Gcedil: "Ģ",
            Gcirc: "Ĝ",
            gcirc: "ĝ",
            Gcy: "Г",
            gcy: "г",
            Gdot: "Ġ",
            gdot: "ġ",
            ge: "≥",
            gE: "≧",
            gEl: "⪌",
            gel: "⋛",
            geq: "≥",
            geqq: "≧",
            geqslant: "⩾",
            gescc: "⪩",
            ges: "⩾",
            gesdot: "⪀",
            gesdoto: "⪂",
            gesdotol: "⪄",
            gesl: "⋛︀",
            gesles: "⪔",
            Gfr: "𝔊",
            gfr: "𝔤",
            gg: "≫",
            Gg: "⋙",
            ggg: "⋙",
            gimel: "ℷ",
            GJcy: "Ѓ",
            gjcy: "ѓ",
            gla: "⪥",
            gl: "≷",
            glE: "⪒",
            glj: "⪤",
            gnap: "⪊",
            gnapprox: "⪊",
            gne: "⪈",
            gnE: "≩",
            gneq: "⪈",
            gneqq: "≩",
            gnsim: "⋧",
            Gopf: "𝔾",
            gopf: "𝕘",
            grave: "`",
            GreaterEqual: "≥",
            GreaterEqualLess: "⋛",
            GreaterFullEqual: "≧",
            GreaterGreater: "⪢",
            GreaterLess: "≷",
            GreaterSlantEqual: "⩾",
            GreaterTilde: "≳",
            Gscr: "𝒢",
            gscr: "ℊ",
            gsim: "≳",
            gsime: "⪎",
            gsiml: "⪐",
            gtcc: "⪧",
            gtcir: "⩺",
            gt: ">",
            GT: ">",
            Gt: "≫",
            gtdot: "⋗",
            gtlPar: "⦕",
            gtquest: "⩼",
            gtrapprox: "⪆",
            gtrarr: "⥸",
            gtrdot: "⋗",
            gtreqless: "⋛",
            gtreqqless: "⪌",
            gtrless: "≷",
            gtrsim: "≳",
            gvertneqq: "≩︀",
            gvnE: "≩︀",
            Hacek: "ˇ",
            hairsp: " ",
            half: "½",
            hamilt: "ℋ",
            HARDcy: "Ъ",
            hardcy: "ъ",
            harrcir: "⥈",
            harr: "↔",
            hArr: "⇔",
            harrw: "↭",
            Hat: "^",
            hbar: "ℏ",
            Hcirc: "Ĥ",
            hcirc: "ĥ",
            hearts: "♥",
            heartsuit: "♥",
            hellip: "…",
            hercon: "⊹",
            hfr: "𝔥",
            Hfr: "ℌ",
            HilbertSpace: "ℋ",
            hksearow: "⤥",
            hkswarow: "⤦",
            hoarr: "⇿",
            homtht: "∻",
            hookleftarrow: "↩",
            hookrightarrow: "↪",
            hopf: "𝕙",
            Hopf: "ℍ",
            horbar: "―",
            HorizontalLine: "─",
            hscr: "𝒽",
            Hscr: "ℋ",
            hslash: "ℏ",
            Hstrok: "Ħ",
            hstrok: "ħ",
            HumpDownHump: "≎",
            HumpEqual: "≏",
            hybull: "⁃",
            hyphen: "‐",
            Iacute: "Í",
            iacute: "í",
            ic: "⁣",
            Icirc: "Î",
            icirc: "î",
            Icy: "И",
            icy: "и",
            Idot: "İ",
            IEcy: "Е",
            iecy: "е",
            iexcl: "¡",
            iff: "⇔",
            ifr: "𝔦",
            Ifr: "ℑ",
            Igrave: "Ì",
            igrave: "ì",
            ii: "ⅈ",
            iiiint: "⨌",
            iiint: "∭",
            iinfin: "⧜",
            iiota: "℩",
            IJlig: "Ĳ",
            ijlig: "ĳ",
            Imacr: "Ī",
            imacr: "ī",
            image: "ℑ",
            ImaginaryI: "ⅈ",
            imagline: "ℐ",
            imagpart: "ℑ",
            imath: "ı",
            Im: "ℑ",
            imof: "⊷",
            imped: "Ƶ",
            Implies: "⇒",
            incare: "℅",
            in: "∈",
            infin: "∞",
            infintie: "⧝",
            inodot: "ı",
            intcal: "⊺",
            int: "∫",
            Int: "∬",
            integers: "ℤ",
            Integral: "∫",
            intercal: "⊺",
            Intersection: "⋂",
            intlarhk: "⨗",
            intprod: "⨼",
            InvisibleComma: "⁣",
            InvisibleTimes: "⁢",
            IOcy: "Ё",
            iocy: "ё",
            Iogon: "Į",
            iogon: "į",
            Iopf: "𝕀",
            iopf: "𝕚",
            Iota: "Ι",
            iota: "ι",
            iprod: "⨼",
            iquest: "¿",
            iscr: "𝒾",
            Iscr: "ℐ",
            isin: "∈",
            isindot: "⋵",
            isinE: "⋹",
            isins: "⋴",
            isinsv: "⋳",
            isinv: "∈",
            it: "⁢",
            Itilde: "Ĩ",
            itilde: "ĩ",
            Iukcy: "І",
            iukcy: "і",
            Iuml: "Ï",
            iuml: "ï",
            Jcirc: "Ĵ",
            jcirc: "ĵ",
            Jcy: "Й",
            jcy: "й",
            Jfr: "𝔍",
            jfr: "𝔧",
            jmath: "ȷ",
            Jopf: "𝕁",
            jopf: "𝕛",
            Jscr: "𝒥",
            jscr: "𝒿",
            Jsercy: "Ј",
            jsercy: "ј",
            Jukcy: "Є",
            jukcy: "є",
            Kappa: "Κ",
            kappa: "κ",
            kappav: "ϰ",
            Kcedil: "Ķ",
            kcedil: "ķ",
            Kcy: "К",
            kcy: "к",
            Kfr: "𝔎",
            kfr: "𝔨",
            kgreen: "ĸ",
            KHcy: "Х",
            khcy: "х",
            KJcy: "Ќ",
            kjcy: "ќ",
            Kopf: "𝕂",
            kopf: "𝕜",
            Kscr: "𝒦",
            kscr: "𝓀",
            lAarr: "⇚",
            Lacute: "Ĺ",
            lacute: "ĺ",
            laemptyv: "⦴",
            lagran: "ℒ",
            Lambda: "Λ",
            lambda: "λ",
            lang: "⟨",
            Lang: "⟪",
            langd: "⦑",
            langle: "⟨",
            lap: "⪅",
            Laplacetrf: "ℒ",
            laquo: "«",
            larrb: "⇤",
            larrbfs: "⤟",
            larr: "←",
            Larr: "↞",
            lArr: "⇐",
            larrfs: "⤝",
            larrhk: "↩",
            larrlp: "↫",
            larrpl: "⤹",
            larrsim: "⥳",
            larrtl: "↢",
            latail: "⤙",
            lAtail: "⤛",
            lat: "⪫",
            late: "⪭",
            lates: "⪭︀",
            lbarr: "⤌",
            lBarr: "⤎",
            lbbrk: "❲",
            lbrace: "{",
            lbrack: "[",
            lbrke: "⦋",
            lbrksld: "⦏",
            lbrkslu: "⦍",
            Lcaron: "Ľ",
            lcaron: "ľ",
            Lcedil: "Ļ",
            lcedil: "ļ",
            lceil: "⌈",
            lcub: "{",
            Lcy: "Л",
            lcy: "л",
            ldca: "⤶",
            ldquo: "“",
            ldquor: "„",
            ldrdhar: "⥧",
            ldrushar: "⥋",
            ldsh: "↲",
            le: "≤",
            lE: "≦",
            LeftAngleBracket: "⟨",
            LeftArrowBar: "⇤",
            leftarrow: "←",
            LeftArrow: "←",
            Leftarrow: "⇐",
            LeftArrowRightArrow: "⇆",
            leftarrowtail: "↢",
            LeftCeiling: "⌈",
            LeftDoubleBracket: "⟦",
            LeftDownTeeVector: "⥡",
            LeftDownVectorBar: "⥙",
            LeftDownVector: "⇃",
            LeftFloor: "⌊",
            leftharpoondown: "↽",
            leftharpoonup: "↼",
            leftleftarrows: "⇇",
            leftrightarrow: "↔",
            LeftRightArrow: "↔",
            Leftrightarrow: "⇔",
            leftrightarrows: "⇆",
            leftrightharpoons: "⇋",
            leftrightsquigarrow: "↭",
            LeftRightVector: "⥎",
            LeftTeeArrow: "↤",
            LeftTee: "⊣",
            LeftTeeVector: "⥚",
            leftthreetimes: "⋋",
            LeftTriangleBar: "⧏",
            LeftTriangle: "⊲",
            LeftTriangleEqual: "⊴",
            LeftUpDownVector: "⥑",
            LeftUpTeeVector: "⥠",
            LeftUpVectorBar: "⥘",
            LeftUpVector: "↿",
            LeftVectorBar: "⥒",
            LeftVector: "↼",
            lEg: "⪋",
            leg: "⋚",
            leq: "≤",
            leqq: "≦",
            leqslant: "⩽",
            lescc: "⪨",
            les: "⩽",
            lesdot: "⩿",
            lesdoto: "⪁",
            lesdotor: "⪃",
            lesg: "⋚︀",
            lesges: "⪓",
            lessapprox: "⪅",
            lessdot: "⋖",
            lesseqgtr: "⋚",
            lesseqqgtr: "⪋",
            LessEqualGreater: "⋚",
            LessFullEqual: "≦",
            LessGreater: "≶",
            lessgtr: "≶",
            LessLess: "⪡",
            lesssim: "≲",
            LessSlantEqual: "⩽",
            LessTilde: "≲",
            lfisht: "⥼",
            lfloor: "⌊",
            Lfr: "𝔏",
            lfr: "𝔩",
            lg: "≶",
            lgE: "⪑",
            lHar: "⥢",
            lhard: "↽",
            lharu: "↼",
            lharul: "⥪",
            lhblk: "▄",
            LJcy: "Љ",
            ljcy: "љ",
            llarr: "⇇",
            ll: "≪",
            Ll: "⋘",
            llcorner: "⌞",
            Lleftarrow: "⇚",
            llhard: "⥫",
            lltri: "◺",
            Lmidot: "Ŀ",
            lmidot: "ŀ",
            lmoustache: "⎰",
            lmoust: "⎰",
            lnap: "⪉",
            lnapprox: "⪉",
            lne: "⪇",
            lnE: "≨",
            lneq: "⪇",
            lneqq: "≨",
            lnsim: "⋦",
            loang: "⟬",
            loarr: "⇽",
            lobrk: "⟦",
            longleftarrow: "⟵",
            LongLeftArrow: "⟵",
            Longleftarrow: "⟸",
            longleftrightarrow: "⟷",
            LongLeftRightArrow: "⟷",
            Longleftrightarrow: "⟺",
            longmapsto: "⟼",
            longrightarrow: "⟶",
            LongRightArrow: "⟶",
            Longrightarrow: "⟹",
            looparrowleft: "↫",
            looparrowright: "↬",
            lopar: "⦅",
            Lopf: "𝕃",
            lopf: "𝕝",
            loplus: "⨭",
            lotimes: "⨴",
            lowast: "∗",
            lowbar: "_",
            LowerLeftArrow: "↙",
            LowerRightArrow: "↘",
            loz: "◊",
            lozenge: "◊",
            lozf: "⧫",
            lpar: "(",
            lparlt: "⦓",
            lrarr: "⇆",
            lrcorner: "⌟",
            lrhar: "⇋",
            lrhard: "⥭",
            lrm: "‎",
            lrtri: "⊿",
            lsaquo: "‹",
            lscr: "𝓁",
            Lscr: "ℒ",
            lsh: "↰",
            Lsh: "↰",
            lsim: "≲",
            lsime: "⪍",
            lsimg: "⪏",
            lsqb: "[",
            lsquo: "‘",
            lsquor: "‚",
            Lstrok: "Ł",
            lstrok: "ł",
            ltcc: "⪦",
            ltcir: "⩹",
            lt: "<",
            LT: "<",
            Lt: "≪",
            ltdot: "⋖",
            lthree: "⋋",
            ltimes: "⋉",
            ltlarr: "⥶",
            ltquest: "⩻",
            ltri: "◃",
            ltrie: "⊴",
            ltrif: "◂",
            ltrPar: "⦖",
            lurdshar: "⥊",
            luruhar: "⥦",
            lvertneqq: "≨︀",
            lvnE: "≨︀",
            macr: "¯",
            male: "♂",
            malt: "✠",
            maltese: "✠",
            Map: "⤅",
            map: "↦",
            mapsto: "↦",
            mapstodown: "↧",
            mapstoleft: "↤",
            mapstoup: "↥",
            marker: "▮",
            mcomma: "⨩",
            Mcy: "М",
            mcy: "м",
            mdash: "—",
            mDDot: "∺",
            measuredangle: "∡",
            MediumSpace: " ",
            Mellintrf: "ℳ",
            Mfr: "𝔐",
            mfr: "𝔪",
            mho: "℧",
            micro: "µ",
            midast: "*",
            midcir: "⫰",
            mid: "∣",
            middot: "·",
            minusb: "⊟",
            minus: "−",
            minusd: "∸",
            minusdu: "⨪",
            MinusPlus: "∓",
            mlcp: "⫛",
            mldr: "…",
            mnplus: "∓",
            models: "⊧",
            Mopf: "𝕄",
            mopf: "𝕞",
            mp: "∓",
            mscr: "𝓂",
            Mscr: "ℳ",
            mstpos: "∾",
            Mu: "Μ",
            mu: "μ",
            multimap: "⊸",
            mumap: "⊸",
            nabla: "∇",
            Nacute: "Ń",
            nacute: "ń",
            nang: "∠⃒",
            nap: "≉",
            napE: "⩰̸",
            napid: "≋̸",
            napos: "ŉ",
            napprox: "≉",
            natural: "♮",
            naturals: "ℕ",
            natur: "♮",
            nbsp: " ",
            nbump: "≎̸",
            nbumpe: "≏̸",
            ncap: "⩃",
            Ncaron: "Ň",
            ncaron: "ň",
            Ncedil: "Ņ",
            ncedil: "ņ",
            ncong: "≇",
            ncongdot: "⩭̸",
            ncup: "⩂",
            Ncy: "Н",
            ncy: "н",
            ndash: "–",
            nearhk: "⤤",
            nearr: "↗",
            neArr: "⇗",
            nearrow: "↗",
            ne: "≠",
            nedot: "≐̸",
            NegativeMediumSpace: "​",
            NegativeThickSpace: "​",
            NegativeThinSpace: "​",
            NegativeVeryThinSpace: "​",
            nequiv: "≢",
            nesear: "⤨",
            nesim: "≂̸",
            NestedGreaterGreater: "≫",
            NestedLessLess: "≪",
            NewLine: "\n",
            nexist: "∄",
            nexists: "∄",
            Nfr: "𝔑",
            nfr: "𝔫",
            ngE: "≧̸",
            nge: "≱",
            ngeq: "≱",
            ngeqq: "≧̸",
            ngeqslant: "⩾̸",
            nges: "⩾̸",
            nGg: "⋙̸",
            ngsim: "≵",
            nGt: "≫⃒",
            ngt: "≯",
            ngtr: "≯",
            nGtv: "≫̸",
            nharr: "↮",
            nhArr: "⇎",
            nhpar: "⫲",
            ni: "∋",
            nis: "⋼",
            nisd: "⋺",
            niv: "∋",
            NJcy: "Њ",
            njcy: "њ",
            nlarr: "↚",
            nlArr: "⇍",
            nldr: "‥",
            nlE: "≦̸",
            nle: "≰",
            nleftarrow: "↚",
            nLeftarrow: "⇍",
            nleftrightarrow: "↮",
            nLeftrightarrow: "⇎",
            nleq: "≰",
            nleqq: "≦̸",
            nleqslant: "⩽̸",
            nles: "⩽̸",
            nless: "≮",
            nLl: "⋘̸",
            nlsim: "≴",
            nLt: "≪⃒",
            nlt: "≮",
            nltri: "⋪",
            nltrie: "⋬",
            nLtv: "≪̸",
            nmid: "∤",
            NoBreak: "⁠",
            NonBreakingSpace: " ",
            nopf: "𝕟",
            Nopf: "ℕ",
            Not: "⫬",
            not: "¬",
            NotCongruent: "≢",
            NotCupCap: "≭",
            NotDoubleVerticalBar: "∦",
            NotElement: "∉",
            NotEqual: "≠",
            NotEqualTilde: "≂̸",
            NotExists: "∄",
            NotGreater: "≯",
            NotGreaterEqual: "≱",
            NotGreaterFullEqual: "≧̸",
            NotGreaterGreater: "≫̸",
            NotGreaterLess: "≹",
            NotGreaterSlantEqual: "⩾̸",
            NotGreaterTilde: "≵",
            NotHumpDownHump: "≎̸",
            NotHumpEqual: "≏̸",
            notin: "∉",
            notindot: "⋵̸",
            notinE: "⋹̸",
            notinva: "∉",
            notinvb: "⋷",
            notinvc: "⋶",
            NotLeftTriangleBar: "⧏̸",
            NotLeftTriangle: "⋪",
            NotLeftTriangleEqual: "⋬",
            NotLess: "≮",
            NotLessEqual: "≰",
            NotLessGreater: "≸",
            NotLessLess: "≪̸",
            NotLessSlantEqual: "⩽̸",
            NotLessTilde: "≴",
            NotNestedGreaterGreater: "⪢̸",
            NotNestedLessLess: "⪡̸",
            notni: "∌",
            notniva: "∌",
            notnivb: "⋾",
            notnivc: "⋽",
            NotPrecedes: "⊀",
            NotPrecedesEqual: "⪯̸",
            NotPrecedesSlantEqual: "⋠",
            NotReverseElement: "∌",
            NotRightTriangleBar: "⧐̸",
            NotRightTriangle: "⋫",
            NotRightTriangleEqual: "⋭",
            NotSquareSubset: "⊏̸",
            NotSquareSubsetEqual: "⋢",
            NotSquareSuperset: "⊐̸",
            NotSquareSupersetEqual: "⋣",
            NotSubset: "⊂⃒",
            NotSubsetEqual: "⊈",
            NotSucceeds: "⊁",
            NotSucceedsEqual: "⪰̸",
            NotSucceedsSlantEqual: "⋡",
            NotSucceedsTilde: "≿̸",
            NotSuperset: "⊃⃒",
            NotSupersetEqual: "⊉",
            NotTilde: "≁",
            NotTildeEqual: "≄",
            NotTildeFullEqual: "≇",
            NotTildeTilde: "≉",
            NotVerticalBar: "∤",
            nparallel: "∦",
            npar: "∦",
            nparsl: "⫽⃥",
            npart: "∂̸",
            npolint: "⨔",
            npr: "⊀",
            nprcue: "⋠",
            nprec: "⊀",
            npreceq: "⪯̸",
            npre: "⪯̸",
            nrarrc: "⤳̸",
            nrarr: "↛",
            nrArr: "⇏",
            nrarrw: "↝̸",
            nrightarrow: "↛",
            nRightarrow: "⇏",
            nrtri: "⋫",
            nrtrie: "⋭",
            nsc: "⊁",
            nsccue: "⋡",
            nsce: "⪰̸",
            Nscr: "𝒩",
            nscr: "𝓃",
            nshortmid: "∤",
            nshortparallel: "∦",
            nsim: "≁",
            nsime: "≄",
            nsimeq: "≄",
            nsmid: "∤",
            nspar: "∦",
            nsqsube: "⋢",
            nsqsupe: "⋣",
            nsub: "⊄",
            nsubE: "⫅̸",
            nsube: "⊈",
            nsubset: "⊂⃒",
            nsubseteq: "⊈",
            nsubseteqq: "⫅̸",
            nsucc: "⊁",
            nsucceq: "⪰̸",
            nsup: "⊅",
            nsupE: "⫆̸",
            nsupe: "⊉",
            nsupset: "⊃⃒",
            nsupseteq: "⊉",
            nsupseteqq: "⫆̸",
            ntgl: "≹",
            Ntilde: "Ñ",
            ntilde: "ñ",
            ntlg: "≸",
            ntriangleleft: "⋪",
            ntrianglelefteq: "⋬",
            ntriangleright: "⋫",
            ntrianglerighteq: "⋭",
            Nu: "Ν",
            nu: "ν",
            num: "#",
            numero: "№",
            numsp: " ",
            nvap: "≍⃒",
            nvdash: "⊬",
            nvDash: "⊭",
            nVdash: "⊮",
            nVDash: "⊯",
            nvge: "≥⃒",
            nvgt: ">⃒",
            nvHarr: "⤄",
            nvinfin: "⧞",
            nvlArr: "⤂",
            nvle: "≤⃒",
            nvlt: "<⃒",
            nvltrie: "⊴⃒",
            nvrArr: "⤃",
            nvrtrie: "⊵⃒",
            nvsim: "∼⃒",
            nwarhk: "⤣",
            nwarr: "↖",
            nwArr: "⇖",
            nwarrow: "↖",
            nwnear: "⤧",
            Oacute: "Ó",
            oacute: "ó",
            oast: "⊛",
            Ocirc: "Ô",
            ocirc: "ô",
            ocir: "⊚",
            Ocy: "О",
            ocy: "о",
            odash: "⊝",
            Odblac: "Ő",
            odblac: "ő",
            odiv: "⨸",
            odot: "⊙",
            odsold: "⦼",
            OElig: "Œ",
            oelig: "œ",
            ofcir: "⦿",
            Ofr: "𝔒",
            ofr: "𝔬",
            ogon: "˛",
            Ograve: "Ò",
            ograve: "ò",
            ogt: "⧁",
            ohbar: "⦵",
            ohm: "Ω",
            oint: "∮",
            olarr: "↺",
            olcir: "⦾",
            olcross: "⦻",
            oline: "‾",
            olt: "⧀",
            Omacr: "Ō",
            omacr: "ō",
            Omega: "Ω",
            omega: "ω",
            Omicron: "Ο",
            omicron: "ο",
            omid: "⦶",
            ominus: "⊖",
            Oopf: "𝕆",
            oopf: "𝕠",
            opar: "⦷",
            OpenCurlyDoubleQuote: "“",
            OpenCurlyQuote: "‘",
            operp: "⦹",
            oplus: "⊕",
            orarr: "↻",
            Or: "⩔",
            or: "∨",
            ord: "⩝",
            order: "ℴ",
            orderof: "ℴ",
            ordf: "ª",
            ordm: "º",
            origof: "⊶",
            oror: "⩖",
            orslope: "⩗",
            orv: "⩛",
            oS: "Ⓢ",
            Oscr: "𝒪",
            oscr: "ℴ",
            Oslash: "Ø",
            oslash: "ø",
            osol: "⊘",
            Otilde: "Õ",
            otilde: "õ",
            otimesas: "⨶",
            Otimes: "⨷",
            otimes: "⊗",
            Ouml: "Ö",
            ouml: "ö",
            ovbar: "⌽",
            OverBar: "‾",
            OverBrace: "⏞",
            OverBracket: "⎴",
            OverParenthesis: "⏜",
            para: "¶",
            parallel: "∥",
            par: "∥",
            parsim: "⫳",
            parsl: "⫽",
            part: "∂",
            PartialD: "∂",
            Pcy: "П",
            pcy: "п",
            percnt: "%",
            period: ".",
            permil: "‰",
            perp: "⊥",
            pertenk: "‱",
            Pfr: "𝔓",
            pfr: "𝔭",
            Phi: "Φ",
            phi: "φ",
            phiv: "ϕ",
            phmmat: "ℳ",
            phone: "☎",
            Pi: "Π",
            pi: "π",
            pitchfork: "⋔",
            piv: "ϖ",
            planck: "ℏ",
            planckh: "ℎ",
            plankv: "ℏ",
            plusacir: "⨣",
            plusb: "⊞",
            pluscir: "⨢",
            plus: "+",
            plusdo: "∔",
            plusdu: "⨥",
            pluse: "⩲",
            PlusMinus: "±",
            plusmn: "±",
            plussim: "⨦",
            plustwo: "⨧",
            pm: "±",
            Poincareplane: "ℌ",
            pointint: "⨕",
            popf: "𝕡",
            Popf: "ℙ",
            pound: "£",
            prap: "⪷",
            Pr: "⪻",
            pr: "≺",
            prcue: "≼",
            precapprox: "⪷",
            prec: "≺",
            preccurlyeq: "≼",
            Precedes: "≺",
            PrecedesEqual: "⪯",
            PrecedesSlantEqual: "≼",
            PrecedesTilde: "≾",
            preceq: "⪯",
            precnapprox: "⪹",
            precneqq: "⪵",
            precnsim: "⋨",
            pre: "⪯",
            prE: "⪳",
            precsim: "≾",
            prime: "′",
            Prime: "″",
            primes: "ℙ",
            prnap: "⪹",
            prnE: "⪵",
            prnsim: "⋨",
            prod: "∏",
            Product: "∏",
            profalar: "⌮",
            profline: "⌒",
            profsurf: "⌓",
            prop: "∝",
            Proportional: "∝",
            Proportion: "∷",
            propto: "∝",
            prsim: "≾",
            prurel: "⊰",
            Pscr: "𝒫",
            pscr: "𝓅",
            Psi: "Ψ",
            psi: "ψ",
            puncsp: " ",
            Qfr: "𝔔",
            qfr: "𝔮",
            qint: "⨌",
            qopf: "𝕢",
            Qopf: "ℚ",
            qprime: "⁗",
            Qscr: "𝒬",
            qscr: "𝓆",
            quaternions: "ℍ",
            quatint: "⨖",
            quest: "?",
            questeq: "≟",
            quot: '"',
            QUOT: '"',
            rAarr: "⇛",
            race: "∽̱",
            Racute: "Ŕ",
            racute: "ŕ",
            radic: "√",
            raemptyv: "⦳",
            rang: "⟩",
            Rang: "⟫",
            rangd: "⦒",
            range: "⦥",
            rangle: "⟩",
            raquo: "»",
            rarrap: "⥵",
            rarrb: "⇥",
            rarrbfs: "⤠",
            rarrc: "⤳",
            rarr: "→",
            Rarr: "↠",
            rArr: "⇒",
            rarrfs: "⤞",
            rarrhk: "↪",
            rarrlp: "↬",
            rarrpl: "⥅",
            rarrsim: "⥴",
            Rarrtl: "⤖",
            rarrtl: "↣",
            rarrw: "↝",
            ratail: "⤚",
            rAtail: "⤜",
            ratio: "∶",
            rationals: "ℚ",
            rbarr: "⤍",
            rBarr: "⤏",
            RBarr: "⤐",
            rbbrk: "❳",
            rbrace: "}",
            rbrack: "]",
            rbrke: "⦌",
            rbrksld: "⦎",
            rbrkslu: "⦐",
            Rcaron: "Ř",
            rcaron: "ř",
            Rcedil: "Ŗ",
            rcedil: "ŗ",
            rceil: "⌉",
            rcub: "}",
            Rcy: "Р",
            rcy: "р",
            rdca: "⤷",
            rdldhar: "⥩",
            rdquo: "”",
            rdquor: "”",
            rdsh: "↳",
            real: "ℜ",
            realine: "ℛ",
            realpart: "ℜ",
            reals: "ℝ",
            Re: "ℜ",
            rect: "▭",
            reg: "®",
            REG: "®",
            ReverseElement: "∋",
            ReverseEquilibrium: "⇋",
            ReverseUpEquilibrium: "⥯",
            rfisht: "⥽",
            rfloor: "⌋",
            rfr: "𝔯",
            Rfr: "ℜ",
            rHar: "⥤",
            rhard: "⇁",
            rharu: "⇀",
            rharul: "⥬",
            Rho: "Ρ",
            rho: "ρ",
            rhov: "ϱ",
            RightAngleBracket: "⟩",
            RightArrowBar: "⇥",
            rightarrow: "→",
            RightArrow: "→",
            Rightarrow: "⇒",
            RightArrowLeftArrow: "⇄",
            rightarrowtail: "↣",
            RightCeiling: "⌉",
            RightDoubleBracket: "⟧",
            RightDownTeeVector: "⥝",
            RightDownVectorBar: "⥕",
            RightDownVector: "⇂",
            RightFloor: "⌋",
            rightharpoondown: "⇁",
            rightharpoonup: "⇀",
            rightleftarrows: "⇄",
            rightleftharpoons: "⇌",
            rightrightarrows: "⇉",
            rightsquigarrow: "↝",
            RightTeeArrow: "↦",
            RightTee: "⊢",
            RightTeeVector: "⥛",
            rightthreetimes: "⋌",
            RightTriangleBar: "⧐",
            RightTriangle: "⊳",
            RightTriangleEqual: "⊵",
            RightUpDownVector: "⥏",
            RightUpTeeVector: "⥜",
            RightUpVectorBar: "⥔",
            RightUpVector: "↾",
            RightVectorBar: "⥓",
            RightVector: "⇀",
            ring: "˚",
            risingdotseq: "≓",
            rlarr: "⇄",
            rlhar: "⇌",
            rlm: "‏",
            rmoustache: "⎱",
            rmoust: "⎱",
            rnmid: "⫮",
            roang: "⟭",
            roarr: "⇾",
            robrk: "⟧",
            ropar: "⦆",
            ropf: "𝕣",
            Ropf: "ℝ",
            roplus: "⨮",
            rotimes: "⨵",
            RoundImplies: "⥰",
            rpar: ")",
            rpargt: "⦔",
            rppolint: "⨒",
            rrarr: "⇉",
            Rrightarrow: "⇛",
            rsaquo: "›",
            rscr: "𝓇",
            Rscr: "ℛ",
            rsh: "↱",
            Rsh: "↱",
            rsqb: "]",
            rsquo: "’",
            rsquor: "’",
            rthree: "⋌",
            rtimes: "⋊",
            rtri: "▹",
            rtrie: "⊵",
            rtrif: "▸",
            rtriltri: "⧎",
            RuleDelayed: "⧴",
            ruluhar: "⥨",
            rx: "℞",
            Sacute: "Ś",
            sacute: "ś",
            sbquo: "‚",
            scap: "⪸",
            Scaron: "Š",
            scaron: "š",
            Sc: "⪼",
            sc: "≻",
            sccue: "≽",
            sce: "⪰",
            scE: "⪴",
            Scedil: "Ş",
            scedil: "ş",
            Scirc: "Ŝ",
            scirc: "ŝ",
            scnap: "⪺",
            scnE: "⪶",
            scnsim: "⋩",
            scpolint: "⨓",
            scsim: "≿",
            Scy: "С",
            scy: "с",
            sdotb: "⊡",
            sdot: "⋅",
            sdote: "⩦",
            searhk: "⤥",
            searr: "↘",
            seArr: "⇘",
            searrow: "↘",
            sect: "§",
            semi: ";",
            seswar: "⤩",
            setminus: "∖",
            setmn: "∖",
            sext: "✶",
            Sfr: "𝔖",
            sfr: "𝔰",
            sfrown: "⌢",
            sharp: "♯",
            SHCHcy: "Щ",
            shchcy: "щ",
            SHcy: "Ш",
            shcy: "ш",
            ShortDownArrow: "↓",
            ShortLeftArrow: "←",
            shortmid: "∣",
            shortparallel: "∥",
            ShortRightArrow: "→",
            ShortUpArrow: "↑",
            shy: "­",
            Sigma: "Σ",
            sigma: "σ",
            sigmaf: "ς",
            sigmav: "ς",
            sim: "∼",
            simdot: "⩪",
            sime: "≃",
            simeq: "≃",
            simg: "⪞",
            simgE: "⪠",
            siml: "⪝",
            simlE: "⪟",
            simne: "≆",
            simplus: "⨤",
            simrarr: "⥲",
            slarr: "←",
            SmallCircle: "∘",
            smallsetminus: "∖",
            smashp: "⨳",
            smeparsl: "⧤",
            smid: "∣",
            smile: "⌣",
            smt: "⪪",
            smte: "⪬",
            smtes: "⪬︀",
            SOFTcy: "Ь",
            softcy: "ь",
            solbar: "⌿",
            solb: "⧄",
            sol: "/",
            Sopf: "𝕊",
            sopf: "𝕤",
            spades: "♠",
            spadesuit: "♠",
            spar: "∥",
            sqcap: "⊓",
            sqcaps: "⊓︀",
            sqcup: "⊔",
            sqcups: "⊔︀",
            Sqrt: "√",
            sqsub: "⊏",
            sqsube: "⊑",
            sqsubset: "⊏",
            sqsubseteq: "⊑",
            sqsup: "⊐",
            sqsupe: "⊒",
            sqsupset: "⊐",
            sqsupseteq: "⊒",
            square: "□",
            Square: "□",
            SquareIntersection: "⊓",
            SquareSubset: "⊏",
            SquareSubsetEqual: "⊑",
            SquareSuperset: "⊐",
            SquareSupersetEqual: "⊒",
            SquareUnion: "⊔",
            squarf: "▪",
            squ: "□",
            squf: "▪",
            srarr: "→",
            Sscr: "𝒮",
            sscr: "𝓈",
            ssetmn: "∖",
            ssmile: "⌣",
            sstarf: "⋆",
            Star: "⋆",
            star: "☆",
            starf: "★",
            straightepsilon: "ϵ",
            straightphi: "ϕ",
            strns: "¯",
            sub: "⊂",
            Sub: "⋐",
            subdot: "⪽",
            subE: "⫅",
            sube: "⊆",
            subedot: "⫃",
            submult: "⫁",
            subnE: "⫋",
            subne: "⊊",
            subplus: "⪿",
            subrarr: "⥹",
            subset: "⊂",
            Subset: "⋐",
            subseteq: "⊆",
            subseteqq: "⫅",
            SubsetEqual: "⊆",
            subsetneq: "⊊",
            subsetneqq: "⫋",
            subsim: "⫇",
            subsub: "⫕",
            subsup: "⫓",
            succapprox: "⪸",
            succ: "≻",
            succcurlyeq: "≽",
            Succeeds: "≻",
            SucceedsEqual: "⪰",
            SucceedsSlantEqual: "≽",
            SucceedsTilde: "≿",
            succeq: "⪰",
            succnapprox: "⪺",
            succneqq: "⪶",
            succnsim: "⋩",
            succsim: "≿",
            SuchThat: "∋",
            sum: "∑",
            Sum: "∑",
            sung: "♪",
            sup1: "¹",
            sup2: "²",
            sup3: "³",
            sup: "⊃",
            Sup: "⋑",
            supdot: "⪾",
            supdsub: "⫘",
            supE: "⫆",
            supe: "⊇",
            supedot: "⫄",
            Superset: "⊃",
            SupersetEqual: "⊇",
            suphsol: "⟉",
            suphsub: "⫗",
            suplarr: "⥻",
            supmult: "⫂",
            supnE: "⫌",
            supne: "⊋",
            supplus: "⫀",
            supset: "⊃",
            Supset: "⋑",
            supseteq: "⊇",
            supseteqq: "⫆",
            supsetneq: "⊋",
            supsetneqq: "⫌",
            supsim: "⫈",
            supsub: "⫔",
            supsup: "⫖",
            swarhk: "⤦",
            swarr: "↙",
            swArr: "⇙",
            swarrow: "↙",
            swnwar: "⤪",
            szlig: "ß",
            Tab: "\t",
            target: "⌖",
            Tau: "Τ",
            tau: "τ",
            tbrk: "⎴",
            Tcaron: "Ť",
            tcaron: "ť",
            Tcedil: "Ţ",
            tcedil: "ţ",
            Tcy: "Т",
            tcy: "т",
            tdot: "⃛",
            telrec: "⌕",
            Tfr: "𝔗",
            tfr: "𝔱",
            there4: "∴",
            therefore: "∴",
            Therefore: "∴",
            Theta: "Θ",
            theta: "θ",
            thetasym: "ϑ",
            thetav: "ϑ",
            thickapprox: "≈",
            thicksim: "∼",
            ThickSpace: "  ",
            ThinSpace: " ",
            thinsp: " ",
            thkap: "≈",
            thksim: "∼",
            THORN: "Þ",
            thorn: "þ",
            tilde: "˜",
            Tilde: "∼",
            TildeEqual: "≃",
            TildeFullEqual: "≅",
            TildeTilde: "≈",
            timesbar: "⨱",
            timesb: "⊠",
            times: "×",
            timesd: "⨰",
            tint: "∭",
            toea: "⤨",
            topbot: "⌶",
            topcir: "⫱",
            top: "⊤",
            Topf: "𝕋",
            topf: "𝕥",
            topfork: "⫚",
            tosa: "⤩",
            tprime: "‴",
            trade: "™",
            TRADE: "™",
            triangle: "▵",
            triangledown: "▿",
            triangleleft: "◃",
            trianglelefteq: "⊴",
            triangleq: "≜",
            triangleright: "▹",
            trianglerighteq: "⊵",
            tridot: "◬",
            trie: "≜",
            triminus: "⨺",
            TripleDot: "⃛",
            triplus: "⨹",
            trisb: "⧍",
            tritime: "⨻",
            trpezium: "⏢",
            Tscr: "𝒯",
            tscr: "𝓉",
            TScy: "Ц",
            tscy: "ц",
            TSHcy: "Ћ",
            tshcy: "ћ",
            Tstrok: "Ŧ",
            tstrok: "ŧ",
            twixt: "≬",
            twoheadleftarrow: "↞",
            twoheadrightarrow: "↠",
            Uacute: "Ú",
            uacute: "ú",
            uarr: "↑",
            Uarr: "↟",
            uArr: "⇑",
            Uarrocir: "⥉",
            Ubrcy: "Ў",
            ubrcy: "ў",
            Ubreve: "Ŭ",
            ubreve: "ŭ",
            Ucirc: "Û",
            ucirc: "û",
            Ucy: "У",
            ucy: "у",
            udarr: "⇅",
            Udblac: "Ű",
            udblac: "ű",
            udhar: "⥮",
            ufisht: "⥾",
            Ufr: "𝔘",
            ufr: "𝔲",
            Ugrave: "Ù",
            ugrave: "ù",
            uHar: "⥣",
            uharl: "↿",
            uharr: "↾",
            uhblk: "▀",
            ulcorn: "⌜",
            ulcorner: "⌜",
            ulcrop: "⌏",
            ultri: "◸",
            Umacr: "Ū",
            umacr: "ū",
            uml: "¨",
            UnderBar: "_",
            UnderBrace: "⏟",
            UnderBracket: "⎵",
            UnderParenthesis: "⏝",
            Union: "⋃",
            UnionPlus: "⊎",
            Uogon: "Ų",
            uogon: "ų",
            Uopf: "𝕌",
            uopf: "𝕦",
            UpArrowBar: "⤒",
            uparrow: "↑",
            UpArrow: "↑",
            Uparrow: "⇑",
            UpArrowDownArrow: "⇅",
            updownarrow: "↕",
            UpDownArrow: "↕",
            Updownarrow: "⇕",
            UpEquilibrium: "⥮",
            upharpoonleft: "↿",
            upharpoonright: "↾",
            uplus: "⊎",
            UpperLeftArrow: "↖",
            UpperRightArrow: "↗",
            upsi: "υ",
            Upsi: "ϒ",
            upsih: "ϒ",
            Upsilon: "Υ",
            upsilon: "υ",
            UpTeeArrow: "↥",
            UpTee: "⊥",
            upuparrows: "⇈",
            urcorn: "⌝",
            urcorner: "⌝",
            urcrop: "⌎",
            Uring: "Ů",
            uring: "ů",
            urtri: "◹",
            Uscr: "𝒰",
            uscr: "𝓊",
            utdot: "⋰",
            Utilde: "Ũ",
            utilde: "ũ",
            utri: "▵",
            utrif: "▴",
            uuarr: "⇈",
            Uuml: "Ü",
            uuml: "ü",
            uwangle: "⦧",
            vangrt: "⦜",
            varepsilon: "ϵ",
            varkappa: "ϰ",
            varnothing: "∅",
            varphi: "ϕ",
            varpi: "ϖ",
            varpropto: "∝",
            varr: "↕",
            vArr: "⇕",
            varrho: "ϱ",
            varsigma: "ς",
            varsubsetneq: "⊊︀",
            varsubsetneqq: "⫋︀",
            varsupsetneq: "⊋︀",
            varsupsetneqq: "⫌︀",
            vartheta: "ϑ",
            vartriangleleft: "⊲",
            vartriangleright: "⊳",
            vBar: "⫨",
            Vbar: "⫫",
            vBarv: "⫩",
            Vcy: "В",
            vcy: "в",
            vdash: "⊢",
            vDash: "⊨",
            Vdash: "⊩",
            VDash: "⊫",
            Vdashl: "⫦",
            veebar: "⊻",
            vee: "∨",
            Vee: "⋁",
            veeeq: "≚",
            vellip: "⋮",
            verbar: "|",
            Verbar: "‖",
            vert: "|",
            Vert: "‖",
            VerticalBar: "∣",
            VerticalLine: "|",
            VerticalSeparator: "❘",
            VerticalTilde: "≀",
            VeryThinSpace: " ",
            Vfr: "𝔙",
            vfr: "𝔳",
            vltri: "⊲",
            vnsub: "⊂⃒",
            vnsup: "⊃⃒",
            Vopf: "𝕍",
            vopf: "𝕧",
            vprop: "∝",
            vrtri: "⊳",
            Vscr: "𝒱",
            vscr: "𝓋",
            vsubnE: "⫋︀",
            vsubne: "⊊︀",
            vsupnE: "⫌︀",
            vsupne: "⊋︀",
            Vvdash: "⊪",
            vzigzag: "⦚",
            Wcirc: "Ŵ",
            wcirc: "ŵ",
            wedbar: "⩟",
            wedge: "∧",
            Wedge: "⋀",
            wedgeq: "≙",
            weierp: "℘",
            Wfr: "𝔚",
            wfr: "𝔴",
            Wopf: "𝕎",
            wopf: "𝕨",
            wp: "℘",
            wr: "≀",
            wreath: "≀",
            Wscr: "𝒲",
            wscr: "𝓌",
            xcap: "⋂",
            xcirc: "◯",
            xcup: "⋃",
            xdtri: "▽",
            Xfr: "𝔛",
            xfr: "𝔵",
            xharr: "⟷",
            xhArr: "⟺",
            Xi: "Ξ",
            xi: "ξ",
            xlarr: "⟵",
            xlArr: "⟸",
            xmap: "⟼",
            xnis: "⋻",
            xodot: "⨀",
            Xopf: "𝕏",
            xopf: "𝕩",
            xoplus: "⨁",
            xotime: "⨂",
            xrarr: "⟶",
            xrArr: "⟹",
            Xscr: "𝒳",
            xscr: "𝓍",
            xsqcup: "⨆",
            xuplus: "⨄",
            xutri: "△",
            xvee: "⋁",
            xwedge: "⋀",
            Yacute: "Ý",
            yacute: "ý",
            YAcy: "Я",
            yacy: "я",
            Ycirc: "Ŷ",
            ycirc: "ŷ",
            Ycy: "Ы",
            ycy: "ы",
            yen: "¥",
            Yfr: "𝔜",
            yfr: "𝔶",
            YIcy: "Ї",
            yicy: "ї",
            Yopf: "𝕐",
            yopf: "𝕪",
            Yscr: "𝒴",
            yscr: "𝓎",
            YUcy: "Ю",
            yucy: "ю",
            yuml: "ÿ",
            Yuml: "Ÿ",
            Zacute: "Ź",
            zacute: "ź",
            Zcaron: "Ž",
            zcaron: "ž",
            Zcy: "З",
            zcy: "з",
            Zdot: "Ż",
            zdot: "ż",
            zeetrf: "ℨ",
            ZeroWidthSpace: "​",
            Zeta: "Ζ",
            zeta: "ζ",
            zfr: "𝔷",
            Zfr: "ℨ",
            ZHcy: "Ж",
            zhcy: "ж",
            zigrarr: "⇝",
            zopf: "𝕫",
            Zopf: "ℤ",
            Zscr: "𝒵",
            zscr: "𝓏",
            zwj: "‍",
            zwnj: "‌"
          };
        },
        {}
      ],
      68: [
        function(require, module, exports) {
          "use strict";
          function makeEmptyFunction(arg) {
            return function() {
              return arg;
            };
          }
          var emptyFunction = function() {};
          (emptyFunction.thatReturns = makeEmptyFunction),
            (emptyFunction.thatReturnsFalse = makeEmptyFunction(!1)),
            (emptyFunction.thatReturnsTrue = makeEmptyFunction(!0)),
            (emptyFunction.thatReturnsNull = makeEmptyFunction(null)),
            (emptyFunction.thatReturnsThis = function() {
              return this;
            }),
            (emptyFunction.thatReturnsArgument = function(arg) {
              return arg;
            }),
            (module.exports = emptyFunction);
        },
        {}
      ],
      69: [
        function(require, module, exports) {
          (function(process) {
            "use strict";
            var validateFormat = function(format) {};
            "production" !== process.env.NODE_ENV &&
              (validateFormat = function(format) {
                if (void 0 === format)
                  throw new Error(
                    "invariant requires an error message argument"
                  );
              }),
              (module.exports = function(condition, format, a, b, c, d, e, f) {
                if ((validateFormat(format), !condition)) {
                  var error;
                  if (void 0 === format)
                    error = new Error(
                      "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
                    );
                  else {
                    var args = [a, b, c, d, e, f],
                      argIndex = 0;
                    (error = new Error(
                      format.replace(/%s/g, function() {
                        return args[argIndex++];
                      })
                    )).name =
                      "Invariant Violation";
                  }
                  throw ((error.framesToPop = 1), error);
                }
              });
          }.call(this, require("_process")));
        },
        { _process: 235 }
      ],
      70: [
        function(require, module, exports) {
          (function(process) {
            "use strict";
            var warning = require("./emptyFunction");
            if ("production" !== process.env.NODE_ENV) {
              warning = function(condition, format) {
                if (void 0 === format)
                  throw new Error(
                    "`warning(condition, format, ...args)` requires a warning message argument"
                  );
                if (
                  0 !== format.indexOf("Failed Composite propType: ") &&
                  !condition
                ) {
                  for (
                    var _len2 = arguments.length,
                      args = Array(2 < _len2 ? _len2 - 2 : 0),
                      _key2 = 2;
                    _key2 < _len2;
                    _key2++
                  )
                    args[_key2 - 2] = arguments[_key2];
                  (function(format) {
                    for (
                      var _len = arguments.length,
                        args = Array(1 < _len ? _len - 1 : 0),
                        _key = 1;
                      _key < _len;
                      _key++
                    )
                      args[_key - 1] = arguments[_key];
                    var argIndex = 0,
                      message =
                        "Warning: " +
                        format.replace(/%s/g, function() {
                          return args[argIndex++];
                        });
                    "undefined" != typeof console && console.error(message);
                    try {
                      throw new Error(message);
                    } catch (x) {}
                  }.apply(void 0, [format].concat(args)));
                }
              };
            }
            module.exports = warning;
          }.call(this, require("_process")));
        },
        { "./emptyFunction": 68, _process: 235 }
      ],
      71: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.GraphQLLanguageService = void 0);
          var _kinds = require("graphql/language/kinds"),
            _graphql = require("graphql"),
            _getAutocompleteSuggestions2 = require("./getAutocompleteSuggestions"),
            _getDiagnostics = require("./getDiagnostics"),
            _getDefinition = require("./getDefinition"),
            _graphqlLanguageServiceUtils = require("graphql-language-service-utils");
          exports.GraphQLLanguageService = (function() {
            function GraphQLLanguageService(cache) {
              !(function(instance, Constructor) {
                if (!(instance instanceof Constructor))
                  throw new TypeError("Cannot call a class as a function");
              })(this, GraphQLLanguageService),
                (this._graphQLCache = cache),
                (this._graphQLConfig = cache.getGraphQLConfig());
            }
            return (
              (GraphQLLanguageService.prototype.getDiagnostics = function(
                query,
                uri,
                isRelayCompatMode
              ) {
                var queryHasExtensions,
                  projectConfig,
                  schemaPath,
                  queryAST,
                  range,
                  source,
                  fragmentDefinitions,
                  fragmentDependencies,
                  dependenciesSource,
                  validationAst,
                  schema,
                  customRules,
                  customRulesModulePath,
                  rulesPath;
                return regeneratorRuntime.async(
                  function(_context) {
                    for (;;)
                      switch ((_context.prev = _context.next)) {
                        case 0:
                          (queryHasExtensions = !1),
                            (projectConfig = this._graphQLConfig.getConfigForFile(
                              uri
                            )),
                            (schemaPath = projectConfig.schemaPath),
                            (_context.prev = 3),
                            (queryAST = (0, _graphql.parse)(query)),
                            (schemaPath && uri === schemaPath) ||
                              (queryHasExtensions = queryAST.definitions.some(
                                function(definition) {
                                  switch (definition.kind) {
                                    case _kinds.OBJECT_TYPE_DEFINITION:
                                    case _kinds.INTERFACE_TYPE_DEFINITION:
                                    case _kinds.ENUM_TYPE_DEFINITION:
                                    case _kinds.UNION_TYPE_DEFINITION:
                                    case _kinds.SCALAR_TYPE_DEFINITION:
                                    case _kinds.INPUT_OBJECT_TYPE_DEFINITION:
                                    case _kinds.SCALAR_TYPE_EXTENSION:
                                    case _kinds.OBJECT_TYPE_EXTENSION:
                                    case _kinds.INTERFACE_TYPE_EXTENSION:
                                    case _kinds.UNION_TYPE_EXTENSION:
                                    case _kinds.ENUM_TYPE_EXTENSION:
                                    case _kinds.INPUT_OBJECT_TYPE_EXTENSION:
                                    case _kinds.DIRECTIVE_DEFINITION:
                                      return !0;
                                  }
                                  return !1;
                                }
                              )),
                            (_context.next = 12);
                          break;
                        case 8:
                          return (
                            (_context.prev = 8),
                            (_context.t0 = _context.catch(3)),
                            (range = (0, _getDiagnostics.getRange)(
                              _context.t0.locations[0],
                              query
                            )),
                            _context.abrupt("return", [
                              {
                                severity: _getDiagnostics.SEVERITY.ERROR,
                                message: _context.t0.message,
                                source: "GraphQL: Syntax",
                                range: range
                              }
                            ])
                          );
                        case 12:
                          if (schemaPath) {
                            _context.next = 14;
                            break;
                          }
                          return _context.abrupt("return", []);
                        case 14:
                          return (
                            (source = query),
                            (_context.next = 17),
                            regeneratorRuntime.awrap(
                              this._graphQLCache.getFragmentDefinitions(
                                projectConfig
                              )
                            )
                          );
                        case 17:
                          return (
                            (fragmentDefinitions = _context.sent),
                            (_context.next = 20),
                            regeneratorRuntime.awrap(
                              this._graphQLCache.getFragmentDependencies(
                                query,
                                fragmentDefinitions
                              )
                            )
                          );
                        case 20:
                          (fragmentDependencies = _context.sent),
                            (dependenciesSource = fragmentDependencies.reduce(
                              function(prev, cur) {
                                return (
                                  prev +
                                  " " +
                                  (0, _graphql.print)(cur.definition)
                                );
                              },
                              ""
                            )),
                            (source = source + " " + dependenciesSource),
                            (validationAst = null),
                            (_context.prev = 24),
                            (validationAst = (0, _graphql.parse)(source)),
                            (_context.next = 31);
                          break;
                        case 28:
                          return (
                            (_context.prev = 28),
                            (_context.t1 = _context.catch(24)),
                            _context.abrupt("return", [])
                          );
                        case 31:
                          return (
                            (_context.next = 33),
                            regeneratorRuntime.awrap(
                              this._graphQLCache.getSchema(
                                projectConfig.projectName,
                                queryHasExtensions
                              )
                            )
                          );
                        case 33:
                          return (
                            (schema = _context.sent),
                            (customRules = void 0),
                            (customRulesModulePath =
                              projectConfig.extensions.customValidationRules) &&
                              (rulesPath = require.resolve(
                                "" + customRulesModulePath
                              )) &&
                              (customRules = require("" + rulesPath)(
                                this._graphQLConfig
                              )),
                            _context.abrupt(
                              "return",
                              (0, _getDiagnostics.validateQuery)(
                                validationAst,
                                schema,
                                customRules,
                                isRelayCompatMode
                              )
                            )
                          );
                        case 38:
                        case "end":
                          return _context.stop();
                      }
                  },
                  null,
                  this,
                  [[3, 8], [24, 28]]
                );
              }),
              (GraphQLLanguageService.prototype.getAutocompleteSuggestions = function(
                query,
                position,
                filePath
              ) {
                var projectConfig, schema;
                return regeneratorRuntime.async(
                  function(_context2) {
                    for (;;)
                      switch ((_context2.prev = _context2.next)) {
                        case 0:
                          if (
                            !(projectConfig = this._graphQLConfig.getConfigForFile(
                              filePath
                            )).schemaPath
                          ) {
                            _context2.next = 7;
                            break;
                          }
                          return (
                            (_context2.next = 4),
                            regeneratorRuntime.awrap(
                              this._graphQLCache.getSchema(
                                projectConfig.projectName
                              )
                            )
                          );
                        case 4:
                          if (!(schema = _context2.sent)) {
                            _context2.next = 7;
                            break;
                          }
                          return _context2.abrupt(
                            "return",
                            (0,
                            _getAutocompleteSuggestions2.getAutocompleteSuggestions)(
                              schema,
                              query,
                              position
                            )
                          );
                        case 7:
                          return _context2.abrupt("return", []);
                        case 8:
                        case "end":
                          return _context2.stop();
                      }
                  },
                  null,
                  this
                );
              }),
              (GraphQLLanguageService.prototype.getDefinition = function(
                query,
                position,
                filePath
              ) {
                var projectConfig, ast, node;
                return regeneratorRuntime.async(
                  function(_context3) {
                    for (;;)
                      switch ((_context3.prev = _context3.next)) {
                        case 0:
                          (projectConfig = this._graphQLConfig.getConfigForFile(
                            filePath
                          )),
                            (ast = void 0),
                            (_context3.prev = 2),
                            (ast = (0, _graphql.parse)(query)),
                            (_context3.next = 9);
                          break;
                        case 6:
                          return (
                            (_context3.prev = 6),
                            (_context3.t0 = _context3.catch(2)),
                            _context3.abrupt("return", null)
                          );
                        case 9:
                          if (
                            !(node = (0,
                            _graphqlLanguageServiceUtils.getASTNodeAtPosition)(
                              query,
                              ast,
                              position
                            ))
                          ) {
                            _context3.next = 16;
                            break;
                          }
                          (_context3.t1 = node.kind),
                            (_context3.next =
                              _context3.t1 === _kinds.FRAGMENT_SPREAD
                                ? 14
                                : _context3.t1 === _kinds.FRAGMENT_DEFINITION
                                  ? 15
                                  : _context3.t1 === _kinds.OPERATION_DEFINITION
                                    ? 15
                                    : 16);
                          break;
                        case 14:
                          return _context3.abrupt(
                            "return",
                            this._getDefinitionForFragmentSpread(
                              query,
                              ast,
                              node,
                              filePath,
                              projectConfig
                            )
                          );
                        case 15:
                          return _context3.abrupt(
                            "return",
                            (0,
                            _getDefinition.getDefinitionQueryResultForDefinitionNode)(
                              filePath,
                              query,
                              node
                            )
                          );
                        case 16:
                          return _context3.abrupt("return", null);
                        case 17:
                        case "end":
                          return _context3.stop();
                      }
                  },
                  null,
                  this,
                  [[2, 6]]
                );
              }),
              (GraphQLLanguageService.prototype._getDefinitionForFragmentSpread = function(
                query,
                ast,
                node,
                filePath,
                projectConfig
              ) {
                var fragmentDefinitions,
                  dependencies,
                  localFragDefinitions,
                  localFragInfos,
                  result;
                return regeneratorRuntime.async(
                  function(_context4) {
                    for (;;)
                      switch ((_context4.prev = _context4.next)) {
                        case 0:
                          return (
                            (_context4.next = 2),
                            regeneratorRuntime.awrap(
                              this._graphQLCache.getFragmentDefinitions(
                                projectConfig
                              )
                            )
                          );
                        case 2:
                          return (
                            (fragmentDefinitions = _context4.sent),
                            (_context4.next = 5),
                            regeneratorRuntime.awrap(
                              this._graphQLCache.getFragmentDependenciesForAST(
                                ast,
                                fragmentDefinitions
                              )
                            )
                          );
                        case 5:
                          return (
                            (dependencies = _context4.sent),
                            (localFragDefinitions = ast.definitions.filter(
                              function(definition) {
                                return (
                                  definition.kind === _kinds.FRAGMENT_DEFINITION
                                );
                              }
                            )),
                            (localFragInfos = localFragDefinitions.map(function(
                              definition
                            ) {
                              return {
                                filePath: filePath,
                                content: query,
                                definition: definition
                              };
                            })),
                            (_context4.next = 11),
                            regeneratorRuntime.awrap(
                              (0,
                              _getDefinition.getDefinitionQueryResultForFragmentSpread)(
                                query,
                                node,
                                dependencies.concat(localFragInfos)
                              )
                            )
                          );
                        case 11:
                          return (
                            (result = _context4.sent),
                            _context4.abrupt("return", result)
                          );
                        case 13:
                        case "end":
                          return _context4.stop();
                      }
                  },
                  null,
                  this
                );
              }),
              GraphQLLanguageService
            );
          })();
        },
        {
          "./getAutocompleteSuggestions": 73,
          "./getDefinition": 74,
          "./getDiagnostics": 75,
          graphql: 101,
          "graphql-language-service-utils": 90,
          "graphql/language/kinds": 111
        }
      ],
      72: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.getDefinitionState = function(tokenState) {
              var definitionState = void 0;
              return (
                forEachState(tokenState, function(state) {
                  switch (state.kind) {
                    case "Query":
                    case "ShortQuery":
                    case "Mutation":
                    case "Subscription":
                    case "FragmentDefinition":
                      definitionState = state;
                  }
                }),
                definitionState
              );
            }),
            (exports.getFieldDef = function(schema, type, fieldName) {
              if (
                fieldName === _introspection.SchemaMetaFieldDef.name &&
                schema.getQueryType() === type
              )
                return _introspection.SchemaMetaFieldDef;
              if (
                fieldName === _introspection.TypeMetaFieldDef.name &&
                schema.getQueryType() === type
              )
                return _introspection.TypeMetaFieldDef;
              if (
                fieldName === _introspection.TypeNameMetaFieldDef.name &&
                (0, _graphql.isCompositeType)(type)
              )
                return _introspection.TypeNameMetaFieldDef;
              if (type.getFields && "function" == typeof type.getFields)
                return type.getFields()[fieldName];
              return null;
            }),
            (exports.forEachState = forEachState),
            (exports.objectValues = function(object) {
              for (
                var keys = Object.keys(object),
                  len = keys.length,
                  values = new Array(len),
                  i = 0;
                i < len;
                ++i
              )
                values[i] = object[keys[i]];
              return values;
            }),
            (exports.hintList = function(token, list) {
              return (function(list, text) {
                if (!text)
                  return filterNonEmpty(list, function(entry) {
                    return !entry.isDeprecated;
                  });
                return filterNonEmpty(
                  filterNonEmpty(
                    list.map(function(entry) {
                      return {
                        proximity: (function(suggestion, text) {
                          var proximity = (function(a, b) {
                            var i = void 0,
                              j = void 0,
                              d = [],
                              aLength = a.length,
                              bLength = b.length;
                            for (i = 0; i <= aLength; i++) d[i] = [i];
                            for (j = 1; j <= bLength; j++) d[0][j] = j;
                            for (i = 1; i <= aLength; i++)
                              for (j = 1; j <= bLength; j++) {
                                var cost = a[i - 1] === b[j - 1] ? 0 : 1;
                                (d[i][j] = Math.min(
                                  d[i - 1][j] + 1,
                                  d[i][j - 1] + 1,
                                  d[i - 1][j - 1] + cost
                                )),
                                  1 < i &&
                                    1 < j &&
                                    a[i - 1] === b[j - 2] &&
                                    a[i - 2] === b[j - 1] &&
                                    (d[i][j] = Math.min(
                                      d[i][j],
                                      d[i - 2][j - 2] + cost
                                    ));
                              }
                            return d[aLength][bLength];
                          })(text, suggestion);
                          suggestion.length > text.length &&
                            ((proximity -= suggestion.length - text.length - 1),
                            (proximity +=
                              0 === suggestion.indexOf(text) ? 0 : 0.5));
                          return proximity;
                        })(normalizeText(entry.label), text),
                        entry: entry
                      };
                    }),
                    function(pair) {
                      return pair.proximity <= 2;
                    }
                  ),
                  function(pair) {
                    return !pair.entry.isDeprecated;
                  }
                )
                  .sort(function(a, b) {
                    return (
                      (a.entry.isDeprecated ? 1 : 0) -
                        (b.entry.isDeprecated ? 1 : 0) ||
                      a.proximity - b.proximity ||
                      a.entry.label.length - b.entry.label.length
                    );
                  })
                  .map(function(pair) {
                    return pair.entry;
                  });
              })(list, normalizeText(token.string));
            });
          var _graphql = require("graphql"),
            _introspection = require("graphql/type/introspection");
          function forEachState(stack, fn) {
            for (
              var reverseStateStack = [], state = stack;
              state && state.kind;

            )
              reverseStateStack.push(state), (state = state.prevState);
            for (var i = reverseStateStack.length - 1; 0 <= i; i--)
              fn(reverseStateStack[i]);
          }
          function filterNonEmpty(array, predicate) {
            var filtered = array.filter(predicate);
            return 0 === filtered.length ? array : filtered;
          }
          function normalizeText(text) {
            return text.toLowerCase().replace(/\W/g, "");
          }
        },
        { graphql: 101, "graphql/type/introspection": 124 }
      ],
      73: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _extends =
            Object.assign ||
            function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source)
                  Object.prototype.hasOwnProperty.call(source, key) &&
                    (target[key] = source[key]);
              }
              return target;
            };
          exports.getAutocompleteSuggestions = function(
            schema,
            queryText,
            cursor,
            contextToken
          ) {
            var token =
                contextToken ||
                (function(queryText, cursor) {
                  var styleAtCursor = null,
                    stateAtCursor = null,
                    stringAtCursor = null,
                    token = runOnlineParser(queryText, function(
                      stream,
                      state,
                      style,
                      index
                    ) {
                      if (
                        index === cursor.line &&
                        stream.getCurrentPosition() >= cursor.character
                      )
                        return (
                          (styleAtCursor = style),
                          (stateAtCursor = _extends({}, state)),
                          (stringAtCursor = stream.current()),
                          "BREAK"
                        );
                    });
                  return {
                    start: token.start,
                    end: token.end,
                    string: stringAtCursor || token.string,
                    state: stateAtCursor || token.state,
                    style: styleAtCursor || token.style
                  };
                })(queryText, cursor),
              state =
                "Invalid" === token.state.kind
                  ? token.state.prevState
                  : token.state;
            if (!state) return [];
            var kind = state.kind,
              step = state.step,
              typeInfo = (function(schema, tokenState) {
                var argDef = void 0,
                  argDefs = void 0,
                  directiveDef = void 0,
                  enumValue = void 0,
                  fieldDef = void 0,
                  inputType = void 0,
                  objectFieldDefs = void 0,
                  parentType = void 0,
                  type = void 0;
                return (
                  (0, _autocompleteUtils.forEachState)(tokenState, function(
                    state
                  ) {
                    switch (state.kind) {
                      case "Query":
                      case "ShortQuery":
                        type = schema.getQueryType();
                        break;
                      case "Mutation":
                        type = schema.getMutationType();
                        break;
                      case "Subscription":
                        type = schema.getSubscriptionType();
                        break;
                      case "InlineFragment":
                      case "FragmentDefinition":
                        state.type && (type = schema.getType(state.type));
                        break;
                      case "Field":
                      case "AliasedField":
                        type && state.name
                          ? ((fieldDef = parentType
                              ? (0, _autocompleteUtils.getFieldDef)(
                                  schema,
                                  parentType,
                                  state.name
                                )
                              : null),
                            (type = fieldDef ? fieldDef.type : null))
                          : (fieldDef = null);
                        break;
                      case "SelectionSet":
                        parentType = (0, _graphql.getNamedType)(type);
                        break;
                      case "Directive":
                        directiveDef = state.name
                          ? schema.getDirective(state.name)
                          : null;
                        break;
                      case "Arguments":
                        if (state.prevState)
                          switch (state.prevState.kind) {
                            case "Field":
                              argDefs = fieldDef && fieldDef.args;
                              break;
                            case "Directive":
                              argDefs = directiveDef && directiveDef.args;
                              break;
                            case "AliasedField":
                              var name =
                                state.prevState && state.prevState.name;
                              if (!name) {
                                argDefs = null;
                                break;
                              }
                              var field = parentType
                                ? (0, _autocompleteUtils.getFieldDef)(
                                    schema,
                                    parentType,
                                    name
                                  )
                                : null;
                              if (!field) {
                                argDefs = null;
                                break;
                              }
                              argDefs = field.args;
                              break;
                            default:
                              argDefs = null;
                          }
                        else argDefs = null;
                        break;
                      case "Argument":
                        if (argDefs)
                          for (var i = 0; i < argDefs.length; i++)
                            if (argDefs[i].name === state.name) {
                              argDef = argDefs[i];
                              break;
                            }
                        inputType = argDef && argDef.type;
                        break;
                      case "EnumValue":
                        var enumType = (0, _graphql.getNamedType)(inputType);
                        enumValue =
                          enumType instanceof _graphql.GraphQLEnumType
                            ? (function(array, predicate) {
                                for (var i = 0; i < array.length; i++)
                                  if (predicate(array[i])) return array[i];
                                return null;
                              })(enumType.getValues(), function(val) {
                                return val.value === state.name;
                              })
                            : null;
                        break;
                      case "ListValue":
                        var nullableType = (0, _graphql.getNullableType)(
                          inputType
                        );
                        inputType =
                          nullableType instanceof _graphql.GraphQLList
                            ? nullableType.ofType
                            : null;
                        break;
                      case "ObjectValue":
                        var objectType = (0, _graphql.getNamedType)(inputType);
                        objectFieldDefs =
                          objectType instanceof _graphql.GraphQLInputObjectType
                            ? objectType.getFields()
                            : null;
                        break;
                      case "ObjectField":
                        var objectField =
                          state.name && objectFieldDefs
                            ? objectFieldDefs[state.name]
                            : null;
                        inputType = objectField && objectField.type;
                        break;
                      case "NamedType":
                        state.name && (type = schema.getType(state.name));
                    }
                  }),
                  {
                    argDef: argDef,
                    argDefs: argDefs,
                    directiveDef: directiveDef,
                    enumValue: enumValue,
                    fieldDef: fieldDef,
                    inputType: inputType,
                    objectFieldDefs: objectFieldDefs,
                    parentType: parentType,
                    type: type
                  }
                );
              })(schema, token.state);
            if ("Document" === kind)
              return (0, _autocompleteUtils.hintList)(token, [
                { label: "query" },
                { label: "mutation" },
                { label: "subscription" },
                { label: "fragment" },
                { label: "{" }
              ]);
            if (
              "SelectionSet" === kind ||
              "Field" === kind ||
              "AliasedField" === kind
            )
              return (function(token, typeInfo, schema) {
                if (typeInfo.parentType) {
                  var parentType = typeInfo.parentType,
                    fields =
                      parentType.getFields instanceof Function
                        ? (0, _autocompleteUtils.objectValues)(
                            parentType.getFields()
                          )
                        : [];
                  return (
                    (0, _graphql.isAbstractType)(parentType) &&
                      fields.push(_graphql.TypeNameMetaFieldDef),
                    parentType === schema.getQueryType() &&
                      fields.push(
                        _graphql.SchemaMetaFieldDef,
                        _graphql.TypeMetaFieldDef
                      ),
                    (0, _autocompleteUtils.hintList)(
                      token,
                      fields.map(function(field) {
                        return {
                          label: field.name,
                          detail: String(field.type),
                          documentation: field.description,
                          isDeprecated: field.isDeprecated,
                          deprecationReason: field.deprecationReason
                        };
                      })
                    )
                  );
                }
                return [];
              })(token, typeInfo, schema);
            if ("Arguments" === kind || ("Argument" === kind && 0 === step)) {
              var argDefs = typeInfo.argDefs;
              if (argDefs)
                return (0, _autocompleteUtils.hintList)(
                  token,
                  argDefs.map(function(argDef) {
                    return {
                      label: argDef.name,
                      detail: String(argDef.type),
                      documentation: argDef.description
                    };
                  })
                );
            }
            if (
              ("ObjectValue" === kind ||
                ("ObjectField" === kind && 0 === step)) &&
              typeInfo.objectFieldDefs
            ) {
              var objectFields = (0, _autocompleteUtils.objectValues)(
                typeInfo.objectFieldDefs
              );
              return (0, _autocompleteUtils.hintList)(
                token,
                objectFields.map(function(field) {
                  return {
                    label: field.name,
                    detail: String(field.type),
                    documentation: field.description
                  };
                })
              );
            }
            if (
              "EnumValue" === kind ||
              ("ListValue" === kind && 1 === step) ||
              ("ObjectField" === kind && 2 === step) ||
              ("Argument" === kind && 2 === step)
            )
              return (function(token, typeInfo) {
                var namedInputType = (0, _graphql.getNamedType)(
                  typeInfo.inputType
                );
                {
                  if (namedInputType instanceof _graphql.GraphQLEnumType) {
                    var values = namedInputType.getValues();
                    return (0, _autocompleteUtils.hintList)(
                      token,
                      values.map(function(value) {
                        return {
                          label: value.name,
                          detail: String(namedInputType),
                          documentation: value.description,
                          isDeprecated: value.isDeprecated,
                          deprecationReason: value.deprecationReason
                        };
                      })
                    );
                  }
                  if (namedInputType === _graphql.GraphQLBoolean)
                    return (0, _autocompleteUtils.hintList)(token, [
                      {
                        label: "true",
                        detail: String(_graphql.GraphQLBoolean),
                        documentation: "Not false."
                      },
                      {
                        label: "false",
                        detail: String(_graphql.GraphQLBoolean),
                        documentation: "Not true."
                      }
                    ]);
                }
                return [];
              })(token, typeInfo);
            if (
              ("TypeCondition" === kind && 1 === step) ||
              ("NamedType" === kind &&
                null != state.prevState &&
                "TypeCondition" === state.prevState.kind)
            )
              return (function(token, typeInfo, schema) {
                var possibleTypes = void 0;
                if (typeInfo.parentType)
                  if ((0, _graphql.isAbstractType)(typeInfo.parentType)) {
                    var abstractType = (0, _graphql.assertAbstractType)(
                        typeInfo.parentType
                      ),
                      possibleObjTypes = schema.getPossibleTypes(abstractType),
                      possibleIfaceMap = Object.create(null);
                    possibleObjTypes.forEach(function(type) {
                      type.getInterfaces().forEach(function(iface) {
                        possibleIfaceMap[iface.name] = iface;
                      });
                    }),
                      (possibleTypes = possibleObjTypes.concat(
                        (0, _autocompleteUtils.objectValues)(possibleIfaceMap)
                      ));
                  } else possibleTypes = [typeInfo.parentType];
                else {
                  var typeMap = schema.getTypeMap();
                  possibleTypes = (0, _autocompleteUtils.objectValues)(
                    typeMap
                  ).filter(_graphql.isCompositeType);
                }
                return (0, _autocompleteUtils.hintList)(
                  token,
                  possibleTypes.map(function(type) {
                    var namedType = (0, _graphql.getNamedType)(type);
                    return {
                      label: String(type),
                      documentation: (namedType && namedType.description) || ""
                    };
                  })
                );
              })(token, typeInfo, schema);
            if ("FragmentSpread" === kind && 1 === step)
              return (function(token, typeInfo, schema, queryText) {
                var typeMap = schema.getTypeMap(),
                  defState = (0, _autocompleteUtils.getDefinitionState)(
                    token.state
                  ),
                  relevantFrags = (function(queryText) {
                    var fragmentDefs = [];
                    return (
                      runOnlineParser(queryText, function(_, state) {
                        "FragmentDefinition" === state.kind &&
                          state.name &&
                          state.type &&
                          fragmentDefs.push({
                            kind: "FragmentDefinition",
                            name: { kind: "Name", value: state.name },
                            selectionSet: {
                              kind: "SelectionSet",
                              selections: []
                            },
                            typeCondition: {
                              kind: "NamedType",
                              name: { kind: "Name", value: state.type }
                            }
                          });
                      }),
                      fragmentDefs
                    );
                  })(queryText).filter(function(frag) {
                    return (
                      typeMap[frag.typeCondition.name.value] &&
                      !(
                        defState &&
                        "FragmentDefinition" === defState.kind &&
                        defState.name === frag.name.value
                      ) &&
                      (0, _graphql.isCompositeType)(typeInfo.parentType) &&
                      (0, _graphql.isCompositeType)(
                        typeMap[frag.typeCondition.name.value]
                      ) &&
                      (0, _graphql.doTypesOverlap)(
                        schema,
                        typeInfo.parentType,
                        typeMap[frag.typeCondition.name.value]
                      )
                    );
                  });
                return (0, _autocompleteUtils.hintList)(
                  token,
                  relevantFrags.map(function(frag) {
                    return {
                      label: frag.name.value,
                      detail: String(typeMap[frag.typeCondition.name.value]),
                      documentation:
                        "fragment " +
                        frag.name.value +
                        " on " +
                        frag.typeCondition.name.value
                    };
                  })
                );
              })(token, typeInfo, schema, queryText);
            if (
              ("VariableDefinition" === kind && 2 === step) ||
              ("ListType" === kind && 1 === step) ||
              ("NamedType" === kind &&
                state.prevState &&
                ("VariableDefinition" === state.prevState.kind ||
                  "ListType" === state.prevState.kind))
            )
              return (function(token, schema) {
                var inputTypeMap = schema.getTypeMap(),
                  inputTypes = (0, _autocompleteUtils.objectValues)(
                    inputTypeMap
                  ).filter(_graphql.isInputType);
                return (0, _autocompleteUtils.hintList)(
                  token,
                  inputTypes.map(function(type) {
                    return {
                      label: type.name,
                      documentation: type.description
                    };
                  })
                );
              })(token, schema);
            if ("Directive" === kind)
              return (function(token, state, schema) {
                if (state.prevState && state.prevState.kind) {
                  var directives = schema
                    .getDirectives()
                    .filter(function(directive) {
                      return (function(state, directive) {
                        if (!state || !state.kind) return !1;
                        var kind = state.kind,
                          locations = directive.locations;
                        switch (kind) {
                          case "Query":
                            return -1 !== locations.indexOf("QUERY");
                          case "Mutation":
                            return -1 !== locations.indexOf("MUTATION");
                          case "Subscription":
                            return -1 !== locations.indexOf("SUBSCRIPTION");
                          case "Field":
                          case "AliasedField":
                            return -1 !== locations.indexOf("FIELD");
                          case "FragmentDefinition":
                            return (
                              -1 !== locations.indexOf("FRAGMENT_DEFINITION")
                            );
                          case "FragmentSpread":
                            return -1 !== locations.indexOf("FRAGMENT_SPREAD");
                          case "InlineFragment":
                            return -1 !== locations.indexOf("INLINE_FRAGMENT");
                          case "SchemaDef":
                            return -1 !== locations.indexOf("SCHEMA");
                          case "ScalarDef":
                            return -1 !== locations.indexOf("SCALAR");
                          case "ObjectTypeDef":
                            return -1 !== locations.indexOf("OBJECT");
                          case "FieldDef":
                            return -1 !== locations.indexOf("FIELD_DEFINITION");
                          case "InterfaceDef":
                            return -1 !== locations.indexOf("INTERFACE");
                          case "UnionDef":
                            return -1 !== locations.indexOf("UNION");
                          case "EnumDef":
                            return -1 !== locations.indexOf("ENUM");
                          case "EnumValue":
                            return -1 !== locations.indexOf("ENUM_VALUE");
                          case "InputDef":
                            return -1 !== locations.indexOf("INPUT_OBJECT");
                          case "InputValueDef":
                            var prevStateKind =
                              state.prevState && state.prevState.kind;
                            switch (prevStateKind) {
                              case "ArgumentsDef":
                                return (
                                  -1 !==
                                  locations.indexOf("ARGUMENT_DEFINITION")
                                );
                              case "InputDef":
                                return (
                                  -1 !==
                                  locations.indexOf("INPUT_FIELD_DEFINITION")
                                );
                            }
                        }
                        return !1;
                      })(state.prevState, directive);
                    });
                  return (0, _autocompleteUtils.hintList)(
                    token,
                    directives.map(function(directive) {
                      return {
                        label: directive.name,
                        documentation: directive.description || ""
                      };
                    })
                  );
                }
                return [];
              })(token, state, schema);
            return [];
          };
          var _graphql = require("graphql"),
            _graphqlLanguageServiceParser = require("graphql-language-service-parser"),
            _autocompleteUtils = require("./autocompleteUtils");
          function runOnlineParser(queryText, callback) {
            for (
              var lines = queryText.split("\n"),
                parser = (0, _graphqlLanguageServiceParser.onlineParser)(),
                state = parser.startState(),
                style = "",
                stream = new _graphqlLanguageServiceParser.CharacterStream(""),
                i = 0;
              i < lines.length;
              i++
            ) {
              for (
                stream = new _graphqlLanguageServiceParser.CharacterStream(
                  lines[i]
                );
                !stream.eol();

              ) {
                if (
                  "BREAK" ===
                  callback(
                    stream,
                    state,
                    (style = parser.token(stream, state)),
                    i
                  )
                )
                  break;
              }
              callback(stream, state, style, i),
                state.kind || (state = parser.startState());
            }
            return {
              start: stream.getStartOfToken(),
              end: stream.getCurrentPosition(),
              string: stream.current(),
              state: state,
              style: style
            };
          }
        },
        {
          "./autocompleteUtils": 72,
          graphql: 101,
          "graphql-language-service-parser": 81
        }
      ],
      74: [
        function(require, module, exports) {
          (function(process) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.LANGUAGE = void 0),
              (exports.getDefinitionQueryResultForFragmentSpread = function(
                text,
                fragment,
                dependencies
              ) {
                var name, defNodes, definitions;
                return regeneratorRuntime.async(
                  function(_context) {
                    for (;;)
                      switch ((_context.prev = _context.next)) {
                        case 0:
                          if (
                            ((name = fragment.name.value),
                            0 !==
                              (defNodes = dependencies.filter(function(_ref) {
                                var definition = _ref.definition;
                                return definition.name.value === name;
                              })).length)
                          ) {
                            _context.next = 5;
                            break;
                          }
                          return (
                            process.stderr.write(
                              "Definition not found for GraphQL fragment " +
                                name
                            ),
                            _context.abrupt("return", {
                              queryRange: [],
                              definitions: []
                            })
                          );
                        case 5:
                          return (
                            (definitions = defNodes.map(function(_ref2) {
                              var filePath = _ref2.filePath,
                                content = _ref2.content,
                                definition = _ref2.definition;
                              return getDefinitionForFragmentDefinition(
                                filePath || "",
                                content,
                                definition
                              );
                            })),
                            _context.abrupt("return", {
                              definitions: definitions,
                              queryRange: definitions.map(function(_) {
                                return getRange(text, fragment);
                              })
                            })
                          );
                        case 7:
                        case "end":
                          return _context.stop();
                      }
                  },
                  null,
                  this
                );
              }),
              (exports.getDefinitionQueryResultForDefinitionNode = function(
                path,
                text,
                definition
              ) {
                return {
                  definitions: [
                    getDefinitionForFragmentDefinition(path, text, definition)
                  ],
                  queryRange: definition.name
                    ? [getRange(text, definition.name)]
                    : []
                };
              });
            var obj,
              _graphqlLanguageServiceUtils = require("graphql-language-service-utils"),
              _assert = require("assert"),
              _assert2 =
                (obj = _assert) && obj.__esModule ? obj : { default: obj };
            var LANGUAGE = (exports.LANGUAGE = "GraphQL");
            function getRange(text, node) {
              var location = node.loc;
              return (
                (0, _assert2.default)(
                  location,
                  "Expected ASTNode to have a location."
                ),
                (0, _graphqlLanguageServiceUtils.locToRange)(text, location)
              );
            }
            function getDefinitionForFragmentDefinition(
              path,
              text,
              definition
            ) {
              var name = definition.name;
              return (
                (0, _assert2.default)(name, "Expected ASTNode to have a Name."),
                {
                  path: path,
                  position: (function(text, node) {
                    var location = node.loc;
                    return (
                      (0, _assert2.default)(
                        location,
                        "Expected ASTNode to have a location."
                      ),
                      (0, _graphqlLanguageServiceUtils.offsetToPosition)(
                        text,
                        location.start
                      )
                    );
                  })(text, name),
                  range: getRange(text, definition),
                  name: name.value || "",
                  language: LANGUAGE,
                  projectRoot: path
                }
              );
            }
          }.call(this, require("_process")));
        },
        { _process: 235, assert: 36, "graphql-language-service-utils": 90 }
      ],
      75: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.SEVERITY = void 0),
            (exports.getDiagnostics = function(query) {
              var schema =
                  1 < arguments.length && void 0 !== arguments[1]
                    ? arguments[1]
                    : null,
                customRules = arguments[2],
                isRelayCompatMode = arguments[3],
                ast = null;
              try {
                ast = (0, _graphql.parse)(query);
              } catch (error) {
                var range = getRange(error.locations[0], query);
                return [
                  {
                    severity: SEVERITY.ERROR,
                    message: error.message,
                    source: "GraphQL: Syntax",
                    range: range
                  }
                ];
              }
              return validateQuery(ast, schema, customRules, isRelayCompatMode);
            }),
            (exports.validateQuery = validateQuery),
            (exports.getRange = getRange);
          var obj,
            _assert = require("assert"),
            _assert2 =
              (obj = _assert) && obj.__esModule ? obj : { default: obj },
            _graphql = require("graphql"),
            _graphqlLanguageServiceParser = require("graphql-language-service-parser"),
            _graphqlLanguageServiceUtils = require("graphql-language-service-utils");
          var SEVERITY = (exports.SEVERITY = {
            ERROR: 1,
            WARNING: 2,
            INFORMATION: 3,
            HINT: 4
          });
          function validateQuery(ast) {
            var schema =
                1 < arguments.length && void 0 !== arguments[1]
                  ? arguments[1]
                  : null,
              customRules = arguments[2],
              isRelayCompatMode = arguments[3];
            if (!schema) return [];
            var validationErrorAnnotations = mapCat(
                (0, _graphqlLanguageServiceUtils.validateWithCustomRules)(
                  schema,
                  ast,
                  customRules,
                  isRelayCompatMode
                ),
                function(error) {
                  return annotations(error, SEVERITY.ERROR, "Validation");
                }
              ),
              deprecationWarningAnnotations = _graphql.findDeprecatedUsages
                ? mapCat(
                    (0, _graphql.findDeprecatedUsages)(schema, ast),
                    function(error) {
                      return annotations(
                        error,
                        SEVERITY.WARNING,
                        "Deprecation"
                      );
                    }
                  )
                : [];
            return validationErrorAnnotations.concat(
              deprecationWarningAnnotations
            );
          }
          function mapCat(array, mapper) {
            return Array.prototype.concat.apply([], array.map(mapper));
          }
          function annotations(error, severity, type) {
            return error.nodes
              ? error.nodes.map(function(node) {
                  var highlightNode =
                    "Variable" !== node.kind && node.name
                      ? node.name
                      : node.variable ? node.variable : node;
                  (0,
                  _assert2.default)(error.locations, "GraphQL validation error requires locations.");
                  var loc = error.locations[0],
                    highlightLoc = (function(node) {
                      var location = node.loc;
                      return (
                        (0, _assert2.default)(
                          location,
                          "Expected ASTNode to have a location."
                        ),
                        location
                      );
                    })(highlightNode),
                    end = loc.column + (highlightLoc.end - highlightLoc.start);
                  return {
                    source: "GraphQL: " + type,
                    message: error.message,
                    severity: severity,
                    range: new _graphqlLanguageServiceUtils.Range(
                      new _graphqlLanguageServiceUtils.Position(
                        loc.line - 1,
                        loc.column - 1
                      ),
                      new _graphqlLanguageServiceUtils.Position(
                        loc.line - 1,
                        end
                      )
                    )
                  };
                })
              : [];
          }
          function getRange(location, queryText) {
            var parser = (0, _graphqlLanguageServiceParser.onlineParser)(),
              state = parser.startState(),
              lines = queryText.split("\n");
            (0, _assert2.default)(
              lines.length >= location.line,
              "Query text must have more lines than where the error happened"
            );
            for (var stream = null, i = 0; i < location.line; i++)
              for (
                stream = new _graphqlLanguageServiceParser.CharacterStream(
                  lines[i]
                );
                !stream.eol();

              ) {
                if ("invalidchar" === parser.token(stream, state)) break;
              }
            (0, _assert2.default)(
              stream,
              "Expected Parser stream to be available."
            );
            var line = location.line - 1,
              start = stream.getStartOfToken(),
              end = stream.getCurrentPosition();
            return new _graphqlLanguageServiceUtils.Range(
              new _graphqlLanguageServiceUtils.Position(line, start),
              new _graphqlLanguageServiceUtils.Position(line, end)
            );
          }
        },
        {
          assert: 36,
          graphql: 101,
          "graphql-language-service-parser": 81,
          "graphql-language-service-utils": 90
        }
      ],
      76: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _extends =
            Object.assign ||
            function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source)
                  Object.prototype.hasOwnProperty.call(source, key) &&
                    (target[key] = source[key]);
              }
              return target;
            };
          exports.getOutline = function(queryText) {
            var ast = void 0;
            try {
              ast = (0, _graphql.parse)(queryText);
            } catch (error) {
              return null;
            }
            var visitorFns = ((docText = queryText),
            (meta = function(node) {
              return {
                representativeName: node.name,
                startPosition: (0,
                _graphqlLanguageServiceUtils.offsetToPosition)(
                  docText,
                  node.loc.start
                ),
                endPosition: (0, _graphqlLanguageServiceUtils.offsetToPosition)(
                  docText,
                  node.loc.end
                ),
                children: node.selectionSet || []
              };
            }),
            {
              Field: function(node) {
                var tokenizedText = node.alias
                  ? [buildToken("plain", node.alias), buildToken("plain", ": ")]
                  : [];
                return (
                  tokenizedText.push(buildToken("plain", node.name)),
                  _extends({ tokenizedText: tokenizedText }, meta(node))
                );
              },
              OperationDefinition: function(node) {
                return _extends(
                  {
                    tokenizedText: [
                      buildToken("keyword", node.operation),
                      buildToken("whitespace", " "),
                      buildToken("class-name", node.name)
                    ]
                  },
                  meta(node)
                );
              },
              Document: function(node) {
                return node.definitions;
              },
              SelectionSet: function(node) {
                return (function(arr, fn) {
                  for (var res = [], i = 0; i < arr.length; i++) {
                    var x = fn(arr[i], i);
                    Array.isArray(x) ? res.push.apply(res, x) : res.push(x);
                  }
                  return res;
                })(node.selections, function(child) {
                  return child.kind === _kinds.INLINE_FRAGMENT
                    ? child.selectionSet
                    : child;
                });
              },
              Name: function(node) {
                return node.value;
              },
              FragmentDefinition: function(node) {
                return _extends(
                  {
                    tokenizedText: [
                      buildToken("keyword", "fragment"),
                      buildToken("whitespace", " "),
                      buildToken("class-name", node.name)
                    ]
                  },
                  meta(node)
                );
              },
              FragmentSpread: function(node) {
                return _extends(
                  {
                    tokenizedText: [
                      buildToken("plain", "..."),
                      buildToken("class-name", node.name)
                    ]
                  },
                  meta(node)
                );
              },
              InlineFragment: function(node) {
                return node.selectionSet;
              }
            });
            var docText, meta;
            return {
              outlineTrees: (0, _graphql.visit)(ast, {
                leave: function(node) {
                  return OUTLINEABLE_KINDS.hasOwnProperty(node.kind) &&
                    visitorFns[node.kind]
                    ? visitorFns[node.kind](node)
                    : null;
                }
              })
            };
          };
          var _graphql = require("graphql"),
            _kinds = require("graphql/language/kinds"),
            _graphqlLanguageServiceUtils = require("graphql-language-service-utils"),
            OUTLINEABLE_KINDS = {
              Field: !0,
              OperationDefinition: !0,
              Document: !0,
              SelectionSet: !0,
              Name: !0,
              FragmentDefinition: !0,
              FragmentSpread: !0,
              InlineFragment: !0
            };
          function buildToken(kind, value) {
            return { kind: kind, value: value };
          }
        },
        {
          graphql: 101,
          "graphql-language-service-utils": 90,
          "graphql/language/kinds": 111
        }
      ],
      77: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _autocompleteUtils = require("./autocompleteUtils");
          Object.defineProperty(exports, "getDefinitionState", {
            enumerable: !0,
            get: function() {
              return _autocompleteUtils.getDefinitionState;
            }
          }),
            Object.defineProperty(exports, "getFieldDef", {
              enumerable: !0,
              get: function() {
                return _autocompleteUtils.getFieldDef;
              }
            }),
            Object.defineProperty(exports, "forEachState", {
              enumerable: !0,
              get: function() {
                return _autocompleteUtils.forEachState;
              }
            }),
            Object.defineProperty(exports, "objectValues", {
              enumerable: !0,
              get: function() {
                return _autocompleteUtils.objectValues;
              }
            }),
            Object.defineProperty(exports, "hintList", {
              enumerable: !0,
              get: function() {
                return _autocompleteUtils.hintList;
              }
            });
          var _getAutocompleteSuggestions = require("./getAutocompleteSuggestions");
          Object.defineProperty(exports, "getAutocompleteSuggestions", {
            enumerable: !0,
            get: function() {
              return _getAutocompleteSuggestions.getAutocompleteSuggestions;
            }
          });
          var _getDefinition = require("./getDefinition");
          Object.defineProperty(exports, "LANGUAGE", {
            enumerable: !0,
            get: function() {
              return _getDefinition.LANGUAGE;
            }
          }),
            Object.defineProperty(
              exports,
              "getDefinitionQueryResultForFragmentSpread",
              {
                enumerable: !0,
                get: function() {
                  return _getDefinition.getDefinitionQueryResultForFragmentSpread;
                }
              }
            ),
            Object.defineProperty(
              exports,
              "getDefinitionQueryResultForDefinitionNode",
              {
                enumerable: !0,
                get: function() {
                  return _getDefinition.getDefinitionQueryResultForDefinitionNode;
                }
              }
            );
          var _getDiagnostics = require("./getDiagnostics");
          Object.defineProperty(exports, "getDiagnostics", {
            enumerable: !0,
            get: function() {
              return _getDiagnostics.getDiagnostics;
            }
          }),
            Object.defineProperty(exports, "validateQuery", {
              enumerable: !0,
              get: function() {
                return _getDiagnostics.validateQuery;
              }
            });
          var _getOutline = require("./getOutline");
          Object.defineProperty(exports, "getOutline", {
            enumerable: !0,
            get: function() {
              return _getOutline.getOutline;
            }
          });
          var _GraphQLLanguageService = require("./GraphQLLanguageService");
          Object.defineProperty(exports, "GraphQLLanguageService", {
            enumerable: !0,
            get: function() {
              return _GraphQLLanguageService.GraphQLLanguageService;
            }
          });
        },
        {
          "./GraphQLLanguageService": 71,
          "./autocompleteUtils": 72,
          "./getAutocompleteSuggestions": 73,
          "./getDefinition": 74,
          "./getDiagnostics": 75,
          "./getOutline": 76
        }
      ],
      78: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var CharacterStream = (function() {
            function CharacterStream(sourceText) {
              var _this = this;
              !(function(instance, Constructor) {
                if (!(instance instanceof Constructor))
                  throw new TypeError("Cannot call a class as a function");
              })(this, CharacterStream),
                (this.getStartOfToken = function() {
                  return _this._start;
                }),
                (this.getCurrentPosition = function() {
                  return _this._pos;
                }),
                (this.eol = function() {
                  return _this._sourceText.length === _this._pos;
                }),
                (this.sol = function() {
                  return 0 === _this._pos;
                }),
                (this.peek = function() {
                  return _this._sourceText.charAt(_this._pos)
                    ? _this._sourceText.charAt(_this._pos)
                    : null;
                }),
                (this.next = function() {
                  var char = _this._sourceText.charAt(_this._pos);
                  return _this._pos++, char;
                }),
                (this.eat = function(pattern) {
                  if (_this._testNextCharacter(pattern))
                    return (
                      (_this._start = _this._pos),
                      _this._pos++,
                      _this._sourceText.charAt(_this._pos - 1)
                    );
                }),
                (this.eatWhile = function(match) {
                  var isMatched = _this._testNextCharacter(match),
                    didEat = !1;
                  for (
                    isMatched &&
                    ((didEat = isMatched), (_this._start = _this._pos));
                    isMatched;

                  )
                    _this._pos++,
                      (isMatched = _this._testNextCharacter(match)),
                      (didEat = !0);
                  return didEat;
                }),
                (this.eatSpace = function() {
                  return _this.eatWhile(/[\s\u00a0]/);
                }),
                (this.skipToEnd = function() {
                  _this._pos = _this._sourceText.length;
                }),
                (this.skipTo = function(position) {
                  _this._pos = position;
                }),
                (this.match = function(pattern) {
                  var consume =
                      !(1 < arguments.length && void 0 !== arguments[1]) ||
                      arguments[1],
                    caseFold =
                      2 < arguments.length &&
                      void 0 !== arguments[2] &&
                      arguments[2],
                    token = null,
                    match = null;
                  "string" == typeof pattern
                    ? ((match = new RegExp(pattern, caseFold ? "i" : "g").test(
                        _this._sourceText.substr(_this._pos, pattern.length)
                      )),
                      (token = pattern))
                    : pattern instanceof RegExp &&
                      (token =
                        (match = _this._sourceText
                          .slice(_this._pos)
                          .match(pattern)) && match[0]);
                  return (
                    !(
                      null == match ||
                      !(
                        "string" == typeof pattern ||
                        (match instanceof Array &&
                          _this._sourceText.startsWith(match[0], _this._pos))
                      )
                    ) &&
                    (consume &&
                      ((_this._start = _this._pos),
                      token && token.length && (_this._pos += token.length)),
                    match)
                  );
                }),
                (this.backUp = function(num) {
                  _this._pos -= num;
                }),
                (this.column = function() {
                  return _this._pos;
                }),
                (this.indentation = function() {
                  var match = _this._sourceText.match(/\s*/),
                    indent = 0;
                  if (match && 0 === match.length)
                    for (
                      var whitespaces = match[0], pos = 0;
                      whitespaces.length > pos;

                    )
                      9 === whitespaces.charCodeAt(pos)
                        ? (indent += 2)
                        : indent++,
                        pos++;
                  return indent;
                }),
                (this.current = function() {
                  return _this._sourceText.slice(_this._start, _this._pos);
                }),
                (this._start = 0),
                (this._pos = 0),
                (this._sourceText = sourceText);
            }
            return (
              (CharacterStream.prototype._testNextCharacter = function(
                pattern
              ) {
                var character = this._sourceText.charAt(this._pos);
                return "string" == typeof pattern
                  ? character === pattern
                  : pattern instanceof RegExp
                    ? pattern.test(character)
                    : pattern(character);
              }),
              CharacterStream
            );
          })();
          exports.default = CharacterStream;
        },
        {}
      ],
      79: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.opt = function(ofRule) {
              return { ofRule: ofRule };
            }),
            (exports.list = function(ofRule, separator) {
              return { ofRule: ofRule, isList: !0, separator: separator };
            }),
            (exports.butNot = function(rule, exclusions) {
              var ruleMatch = rule.match;
              return (
                (rule.match = function(token) {
                  var check = !1;
                  return (
                    ruleMatch && (check = ruleMatch(token)),
                    check &&
                      exclusions.every(function(exclusion) {
                        return exclusion.match && !exclusion.match(token);
                      })
                  );
                }),
                rule
              );
            }),
            (exports.t = function(kind, style) {
              return {
                style: style,
                match: function(token) {
                  return token.kind === kind;
                }
              };
            }),
            (exports.p = function(value, style) {
              return {
                style: style || "punctuation",
                match: function(token) {
                  return "Punctuation" === token.kind && token.value === value;
                }
              };
            });
        },
        {}
      ],
      80: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.ParseRules = exports.LexRules = exports.isIgnored = void 0);
          var style,
            _RuleHelpers = require("./RuleHelpers");
          (exports.isIgnored = function(ch) {
            return (
              " " === ch ||
              "\t" === ch ||
              "," === ch ||
              "\n" === ch ||
              "\r" === ch ||
              "\ufeff" === ch
            );
          }),
            (exports.LexRules = {
              Name: /^[_A-Za-z][_0-9A-Za-z]*/,
              Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|@|\[|]|\{|\||\})/,
              Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
              String: /^(?:"""(?:\\"""|[^"]|"[^"]|""[^"])*(?:""")?|"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?)/,
              Comment: /^#.*/
            }),
            (exports.ParseRules = {
              Document: [(0, _RuleHelpers.list)("Definition")],
              Definition: function(token) {
                switch (token.value) {
                  case "{":
                    return "ShortQuery";
                  case "query":
                    return "Query";
                  case "mutation":
                    return "Mutation";
                  case "subscription":
                    return "Subscription";
                  case "fragment":
                    return "FragmentDefinition";
                  case "schema":
                    return "SchemaDef";
                  case "scalar":
                    return "ScalarDef";
                  case "type":
                    return "ObjectTypeDef";
                  case "interface":
                    return "InterfaceDef";
                  case "union":
                    return "UnionDef";
                  case "enum":
                    return "EnumDef";
                  case "input":
                    return "InputDef";
                  case "extend":
                    return "ExtendDef";
                  case "directive":
                    return "DirectiveDef";
                }
              },
              ShortQuery: ["SelectionSet"],
              Query: [
                word("query"),
                (0, _RuleHelpers.opt)(name("def")),
                (0, _RuleHelpers.opt)("VariableDefinitions"),
                (0, _RuleHelpers.list)("Directive"),
                "SelectionSet"
              ],
              Mutation: [
                word("mutation"),
                (0, _RuleHelpers.opt)(name("def")),
                (0, _RuleHelpers.opt)("VariableDefinitions"),
                (0, _RuleHelpers.list)("Directive"),
                "SelectionSet"
              ],
              Subscription: [
                word("subscription"),
                (0, _RuleHelpers.opt)(name("def")),
                (0, _RuleHelpers.opt)("VariableDefinitions"),
                (0, _RuleHelpers.list)("Directive"),
                "SelectionSet"
              ],
              VariableDefinitions: [
                (0, _RuleHelpers.p)("("),
                (0, _RuleHelpers.list)("VariableDefinition"),
                (0, _RuleHelpers.p)(")")
              ],
              VariableDefinition: [
                "Variable",
                (0, _RuleHelpers.p)(":"),
                "Type",
                (0, _RuleHelpers.opt)("DefaultValue")
              ],
              Variable: [
                (0, _RuleHelpers.p)("$", "variable"),
                name("variable")
              ],
              DefaultValue: [(0, _RuleHelpers.p)("="), "Value"],
              SelectionSet: [
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("Selection"),
                (0, _RuleHelpers.p)("}")
              ],
              Selection: function(token, stream) {
                return "..." === token.value
                  ? stream.match(/[\s\u00a0,]*(on\b|@|{)/, !1)
                    ? "InlineFragment"
                    : "FragmentSpread"
                  : stream.match(/[\s\u00a0,]*:/, !1)
                    ? "AliasedField"
                    : "Field";
              },
              AliasedField: [
                name("property"),
                (0, _RuleHelpers.p)(":"),
                name("qualifier"),
                (0, _RuleHelpers.opt)("Arguments"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.opt)("SelectionSet")
              ],
              Field: [
                name("property"),
                (0, _RuleHelpers.opt)("Arguments"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.opt)("SelectionSet")
              ],
              Arguments: [
                (0, _RuleHelpers.p)("("),
                (0, _RuleHelpers.list)("Argument"),
                (0, _RuleHelpers.p)(")")
              ],
              Argument: [name("attribute"), (0, _RuleHelpers.p)(":"), "Value"],
              FragmentSpread: [
                (0, _RuleHelpers.p)("..."),
                name("def"),
                (0, _RuleHelpers.list)("Directive")
              ],
              InlineFragment: [
                (0, _RuleHelpers.p)("..."),
                (0, _RuleHelpers.opt)("TypeCondition"),
                (0, _RuleHelpers.list)("Directive"),
                "SelectionSet"
              ],
              FragmentDefinition: [
                word("fragment"),
                (0, _RuleHelpers.opt)(
                  (0, _RuleHelpers.butNot)(name("def"), [word("on")])
                ),
                "TypeCondition",
                (0, _RuleHelpers.list)("Directive"),
                "SelectionSet"
              ],
              TypeCondition: [word("on"), "NamedType"],
              Value: function(token) {
                switch (token.kind) {
                  case "Number":
                    return "NumberValue";
                  case "String":
                    return "StringValue";
                  case "Punctuation":
                    switch (token.value) {
                      case "[":
                        return "ListValue";
                      case "{":
                        return "ObjectValue";
                      case "$":
                        return "Variable";
                    }
                    return null;
                  case "Name":
                    switch (token.value) {
                      case "true":
                      case "false":
                        return "BooleanValue";
                    }
                    return "null" === token.value ? "NullValue" : "EnumValue";
                }
              },
              NumberValue: [(0, _RuleHelpers.t)("Number", "number")],
              StringValue: [(0, _RuleHelpers.t)("String", "string")],
              BooleanValue: [(0, _RuleHelpers.t)("Name", "builtin")],
              NullValue: [(0, _RuleHelpers.t)("Name", "keyword")],
              EnumValue: [name("string-2")],
              ListValue: [
                (0, _RuleHelpers.p)("["),
                (0, _RuleHelpers.list)("Value"),
                (0, _RuleHelpers.p)("]")
              ],
              ObjectValue: [
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("ObjectField"),
                (0, _RuleHelpers.p)("}")
              ],
              ObjectField: [
                name("attribute"),
                (0, _RuleHelpers.p)(":"),
                "Value"
              ],
              Type: function(token) {
                return "[" === token.value ? "ListType" : "NonNullType";
              },
              ListType: [
                (0, _RuleHelpers.p)("["),
                "Type",
                (0, _RuleHelpers.p)("]"),
                (0, _RuleHelpers.opt)((0, _RuleHelpers.p)("!"))
              ],
              NonNullType: [
                "NamedType",
                (0, _RuleHelpers.opt)((0, _RuleHelpers.p)("!"))
              ],
              NamedType: [
                ((style = "atom"),
                {
                  style: style,
                  match: function(token) {
                    return "Name" === token.kind;
                  },
                  update: function(state, token) {
                    state.prevState &&
                      state.prevState.prevState &&
                      ((state.name = token.value),
                      (state.prevState.prevState.type = token.value));
                  }
                })
              ],
              Directive: [
                (0, _RuleHelpers.p)("@", "meta"),
                name("meta"),
                (0, _RuleHelpers.opt)("Arguments")
              ],
              SchemaDef: [
                word("schema"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("OperationTypeDef"),
                (0, _RuleHelpers.p)("}")
              ],
              OperationTypeDef: [
                name("keyword"),
                (0, _RuleHelpers.p)(":"),
                name("atom")
              ],
              ScalarDef: [
                word("scalar"),
                name("atom"),
                (0, _RuleHelpers.list)("Directive")
              ],
              ObjectTypeDef: [
                word("type"),
                name("atom"),
                (0, _RuleHelpers.opt)("Implements"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("FieldDef"),
                (0, _RuleHelpers.p)("}")
              ],
              Implements: [
                word("implements"),
                (0, _RuleHelpers.list)("NamedType")
              ],
              FieldDef: [
                name("property"),
                (0, _RuleHelpers.opt)("ArgumentsDef"),
                (0, _RuleHelpers.p)(":"),
                "Type",
                (0, _RuleHelpers.list)("Directive")
              ],
              ArgumentsDef: [
                (0, _RuleHelpers.p)("("),
                (0, _RuleHelpers.list)("InputValueDef"),
                (0, _RuleHelpers.p)(")")
              ],
              InputValueDef: [
                name("attribute"),
                (0, _RuleHelpers.p)(":"),
                "Type",
                (0, _RuleHelpers.opt)("DefaultValue"),
                (0, _RuleHelpers.list)("Directive")
              ],
              InterfaceDef: [
                word("interface"),
                name("atom"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("FieldDef"),
                (0, _RuleHelpers.p)("}")
              ],
              UnionDef: [
                word("union"),
                name("atom"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.p)("="),
                (0, _RuleHelpers.list)("UnionMember", (0, _RuleHelpers.p)("|"))
              ],
              UnionMember: ["NamedType"],
              EnumDef: [
                word("enum"),
                name("atom"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("EnumValueDef"),
                (0, _RuleHelpers.p)("}")
              ],
              EnumValueDef: [
                name("string-2"),
                (0, _RuleHelpers.list)("Directive")
              ],
              InputDef: [
                word("input"),
                name("atom"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("InputValueDef"),
                (0, _RuleHelpers.p)("}")
              ],
              ExtendDef: [word("extend"), "ObjectTypeDef"],
              DirectiveDef: [
                word("directive"),
                (0, _RuleHelpers.p)("@", "meta"),
                name("meta"),
                (0, _RuleHelpers.opt)("ArgumentsDef"),
                word("on"),
                (0, _RuleHelpers.list)(
                  "DirectiveLocation",
                  (0, _RuleHelpers.p)("|")
                )
              ],
              DirectiveLocation: [name("string-2")]
            });
          function word(value) {
            return {
              style: "keyword",
              match: function(token) {
                return "Name" === token.kind && token.value === value;
              }
            };
          }
          function name(style) {
            return {
              style: style,
              match: function(token) {
                return "Name" === token.kind;
              },
              update: function(state, token) {
                state.name = token.value;
              }
            };
          }
        },
        { "./RuleHelpers": 79 }
      ],
      81: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _CharacterStream = require("./CharacterStream");
          Object.defineProperty(exports, "CharacterStream", {
            enumerable: !0,
            get: function() {
              return _interopRequireDefault(_CharacterStream).default;
            }
          });
          var _Rules = require("./Rules");
          Object.defineProperty(exports, "LexRules", {
            enumerable: !0,
            get: function() {
              return _Rules.LexRules;
            }
          }),
            Object.defineProperty(exports, "ParseRules", {
              enumerable: !0,
              get: function() {
                return _Rules.ParseRules;
              }
            }),
            Object.defineProperty(exports, "isIgnored", {
              enumerable: !0,
              get: function() {
                return _Rules.isIgnored;
              }
            });
          var _RuleHelpers = require("./RuleHelpers");
          Object.defineProperty(exports, "butNot", {
            enumerable: !0,
            get: function() {
              return _RuleHelpers.butNot;
            }
          }),
            Object.defineProperty(exports, "list", {
              enumerable: !0,
              get: function() {
                return _RuleHelpers.list;
              }
            }),
            Object.defineProperty(exports, "opt", {
              enumerable: !0,
              get: function() {
                return _RuleHelpers.opt;
              }
            }),
            Object.defineProperty(exports, "p", {
              enumerable: !0,
              get: function() {
                return _RuleHelpers.p;
              }
            }),
            Object.defineProperty(exports, "t", {
              enumerable: !0,
              get: function() {
                return _RuleHelpers.t;
              }
            });
          var _onlineParser = require("./onlineParser");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          Object.defineProperty(exports, "onlineParser", {
            enumerable: !0,
            get: function() {
              return _interopRequireDefault(_onlineParser).default;
            }
          });
        },
        {
          "./CharacterStream": 78,
          "./RuleHelpers": 79,
          "./Rules": 80,
          "./onlineParser": 82
        }
      ],
      82: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _extends =
            Object.assign ||
            function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source)
                  Object.prototype.hasOwnProperty.call(source, key) &&
                    (target[key] = source[key]);
              }
              return target;
            };
          exports.default = function() {
            var options =
              0 < arguments.length && void 0 !== arguments[0]
                ? arguments[0]
                : {
                    eatWhitespace: function(stream) {
                      return stream.eatWhile(_Rules.isIgnored);
                    },
                    lexRules: _Rules.LexRules,
                    parseRules: _Rules.ParseRules,
                    editorConfig: {}
                  };
            return {
              startState: function() {
                var initialState = {
                  level: 0,
                  step: 0,
                  name: null,
                  kind: null,
                  type: null,
                  rule: null,
                  needsSeperator: !1,
                  prevState: null
                };
                return (
                  pushRule(options.parseRules, initialState, "Document"),
                  initialState
                );
              },
              token: function(stream, state) {
                return (function(stream, state, options) {
                  var lexRules = options.lexRules,
                    parseRules = options.parseRules,
                    eatWhitespace = options.eatWhitespace,
                    editorConfig = options.editorConfig;
                  state.rule && 0 === state.rule.length
                    ? popRule(state)
                    : state.needsAdvance &&
                      ((state.needsAdvance = !1), advanceRule(state, !0));
                  if (stream.sol()) {
                    var tabSize = (editorConfig && editorConfig.tabSize) || 2;
                    state.indentLevel = Math.floor(
                      stream.indentation() / tabSize
                    );
                  }
                  if (eatWhitespace(stream)) return "ws";
                  var token = (function(lexRules, stream) {
                    for (
                      var kinds = Object.keys(lexRules), i = 0;
                      i < kinds.length;
                      i++
                    ) {
                      var match = stream.match(lexRules[kinds[i]]);
                      if (match && match instanceof Array)
                        return { kind: kinds[i], value: match[0] };
                    }
                  })(lexRules, stream);
                  if (!token)
                    return (
                      stream.match(/\S+/),
                      pushRule(SpecialParseRules, state, "Invalid"),
                      "invalidchar"
                    );
                  if ("Comment" === token.kind)
                    return (
                      pushRule(SpecialParseRules, state, "Comment"), "comment"
                    );
                  var backupState = assign({}, state);
                  if ("Punctuation" === token.kind)
                    if (/^[{([]/.test(token.value))
                      state.levels = (state.levels || []).concat(
                        state.indentLevel + 1
                      );
                    else if (/^[})\]]/.test(token.value)) {
                      var levels = (state.levels = (state.levels || []).slice(
                        0,
                        -1
                      ));
                      state.indentLevel &&
                        0 < levels.length &&
                        levels[levels.length - 1] < state.indentLevel &&
                        (state.indentLevel = levels[levels.length - 1]);
                    }
                  for (; state.rule; ) {
                    var expected =
                      "function" == typeof state.rule
                        ? 0 === state.step ? state.rule(token, stream) : null
                        : state.rule[state.step];
                    if (
                      (state.needsSeperator &&
                        (expected = expected && expected.separator),
                      expected)
                    ) {
                      if (
                        (expected.ofRule && (expected = expected.ofRule),
                        "string" == typeof expected)
                      ) {
                        pushRule(parseRules, state, expected);
                        continue;
                      }
                      if (expected.match && expected.match(token))
                        return (
                          expected.update && expected.update(state, token),
                          "Punctuation" === token.kind
                            ? advanceRule(state, !0)
                            : (state.needsAdvance = !0),
                          expected.style
                        );
                    }
                    unsuccessful(state);
                  }
                  return (
                    assign(state, backupState),
                    pushRule(SpecialParseRules, state, "Invalid"),
                    "invalidchar"
                  );
                })(stream, state, options);
              }
            };
          };
          var _Rules = require("./Rules");
          function assign(to, from) {
            for (var keys = Object.keys(from), i = 0; i < keys.length; i++)
              to[keys[i]] = from[keys[i]];
            return to;
          }
          var SpecialParseRules = { Invalid: [], Comment: [] };
          function pushRule(rules, state, ruleKind) {
            if (!rules[ruleKind])
              throw new TypeError("Unknown rule: " + ruleKind);
            (state.prevState = _extends({}, state)),
              (state.kind = ruleKind),
              (state.name = null),
              (state.type = null),
              (state.rule = rules[ruleKind]),
              (state.step = 0),
              (state.needsSeperator = !1);
          }
          function popRule(state) {
            state.prevState &&
              ((state.kind = state.prevState.kind),
              (state.name = state.prevState.name),
              (state.type = state.prevState.type),
              (state.rule = state.prevState.rule),
              (state.step = state.prevState.step),
              (state.needsSeperator = state.prevState.needsSeperator),
              (state.prevState = state.prevState.prevState));
          }
          function advanceRule(state, successful) {
            if (isList(state)) {
              if (state.rule && state.rule[state.step].separator) {
                var separator = state.rule[state.step].separator;
                if (
                  ((state.needsSeperator = !state.needsSeperator),
                  !state.needsSeperator && separator.ofRule)
                )
                  return;
              }
              if (successful) return;
            }
            for (
              state.needsSeperator = !1, state.step++;
              state.rule &&
              !(Array.isArray(state.rule) && state.step < state.rule.length);

            )
              popRule(state),
                state.rule &&
                  (isList(state)
                    ? state.rule &&
                      state.rule[state.step].separator &&
                      (state.needsSeperator = !state.needsSeperator)
                    : ((state.needsSeperator = !1), state.step++));
          }
          function isList(state) {
            return (
              Array.isArray(state.rule) &&
              "string" != typeof state.rule[state.step] &&
              state.rule[state.step].isList
            );
          }
          function unsuccessful(state) {
            for (
              ;
              state.rule &&
              (!Array.isArray(state.rule) || !state.rule[state.step].ofRule);

            )
              popRule(state);
            state.rule && advanceRule(state, !1);
          }
        },
        { "./Rules": 80 }
      ],
      83: [
        function(require, module, exports) {
          arguments[4][78][0].apply(exports, arguments);
        },
        { dup: 78 }
      ],
      84: [
        function(require, module, exports) {
          arguments[4][79][0].apply(exports, arguments);
        },
        { dup: 79 }
      ],
      85: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.ParseRules = exports.LexRules = exports.isIgnored = void 0);
          var style,
            _RuleHelpers = require("./RuleHelpers");
          (exports.isIgnored = function(ch) {
            return (
              " " === ch ||
              "\t" === ch ||
              "," === ch ||
              "\n" === ch ||
              "\r" === ch ||
              "\ufeff" === ch
            );
          }),
            (exports.LexRules = {
              Name: /^[_A-Za-z][_0-9A-Za-z]*/,
              Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|@|\[|]|\{|\||\})/,
              Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
              String: /^"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?/,
              Comment: /^#.*/
            }),
            (exports.ParseRules = {
              Document: [(0, _RuleHelpers.list)("Definition")],
              Definition: function(token) {
                switch (token.value) {
                  case "{":
                    return "ShortQuery";
                  case "query":
                    return "Query";
                  case "mutation":
                    return "Mutation";
                  case "subscription":
                    return "Subscription";
                  case "fragment":
                    return "FragmentDefinition";
                  case "schema":
                    return "SchemaDef";
                  case "scalar":
                    return "ScalarDef";
                  case "type":
                    return "ObjectTypeDef";
                  case "interface":
                    return "InterfaceDef";
                  case "union":
                    return "UnionDef";
                  case "enum":
                    return "EnumDef";
                  case "input":
                    return "InputDef";
                  case "extend":
                    return "ExtendDef";
                  case "directive":
                    return "DirectiveDef";
                }
              },
              ShortQuery: ["SelectionSet"],
              Query: [
                word("query"),
                (0, _RuleHelpers.opt)(name("def")),
                (0, _RuleHelpers.opt)("VariableDefinitions"),
                (0, _RuleHelpers.list)("Directive"),
                "SelectionSet"
              ],
              Mutation: [
                word("mutation"),
                (0, _RuleHelpers.opt)(name("def")),
                (0, _RuleHelpers.opt)("VariableDefinitions"),
                (0, _RuleHelpers.list)("Directive"),
                "SelectionSet"
              ],
              Subscription: [
                word("subscription"),
                (0, _RuleHelpers.opt)(name("def")),
                (0, _RuleHelpers.opt)("VariableDefinitions"),
                (0, _RuleHelpers.list)("Directive"),
                "SelectionSet"
              ],
              VariableDefinitions: [
                (0, _RuleHelpers.p)("("),
                (0, _RuleHelpers.list)("VariableDefinition"),
                (0, _RuleHelpers.p)(")")
              ],
              VariableDefinition: [
                "Variable",
                (0, _RuleHelpers.p)(":"),
                "Type",
                (0, _RuleHelpers.opt)("DefaultValue")
              ],
              Variable: [
                (0, _RuleHelpers.p)("$", "variable"),
                name("variable")
              ],
              DefaultValue: [(0, _RuleHelpers.p)("="), "Value"],
              SelectionSet: [
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("Selection"),
                (0, _RuleHelpers.p)("}")
              ],
              Selection: function(token, stream) {
                return "..." === token.value
                  ? stream.match(/[\s\u00a0,]*(on\b|@|{)/, !1)
                    ? "InlineFragment"
                    : "FragmentSpread"
                  : stream.match(/[\s\u00a0,]*:/, !1)
                    ? "AliasedField"
                    : "Field";
              },
              AliasedField: [
                name("property"),
                (0, _RuleHelpers.p)(":"),
                name("qualifier"),
                (0, _RuleHelpers.opt)("Arguments"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.opt)("SelectionSet")
              ],
              Field: [
                name("property"),
                (0, _RuleHelpers.opt)("Arguments"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.opt)("SelectionSet")
              ],
              Arguments: [
                (0, _RuleHelpers.p)("("),
                (0, _RuleHelpers.list)("Argument"),
                (0, _RuleHelpers.p)(")")
              ],
              Argument: [name("attribute"), (0, _RuleHelpers.p)(":"), "Value"],
              FragmentSpread: [
                (0, _RuleHelpers.p)("..."),
                name("def"),
                (0, _RuleHelpers.list)("Directive")
              ],
              InlineFragment: [
                (0, _RuleHelpers.p)("..."),
                (0, _RuleHelpers.opt)("TypeCondition"),
                (0, _RuleHelpers.list)("Directive"),
                "SelectionSet"
              ],
              FragmentDefinition: [
                word("fragment"),
                (0, _RuleHelpers.opt)(
                  (0, _RuleHelpers.butNot)(name("def"), [word("on")])
                ),
                "TypeCondition",
                (0, _RuleHelpers.list)("Directive"),
                "SelectionSet"
              ],
              TypeCondition: [word("on"), "NamedType"],
              Value: function(token) {
                switch (token.kind) {
                  case "Number":
                    return "NumberValue";
                  case "String":
                    return "StringValue";
                  case "Punctuation":
                    switch (token.value) {
                      case "[":
                        return "ListValue";
                      case "{":
                        return "ObjectValue";
                      case "$":
                        return "Variable";
                    }
                    return null;
                  case "Name":
                    switch (token.value) {
                      case "true":
                      case "false":
                        return "BooleanValue";
                    }
                    return "null" === token.value ? "NullValue" : "EnumValue";
                }
              },
              NumberValue: [(0, _RuleHelpers.t)("Number", "number")],
              StringValue: [(0, _RuleHelpers.t)("String", "string")],
              BooleanValue: [(0, _RuleHelpers.t)("Name", "builtin")],
              NullValue: [(0, _RuleHelpers.t)("Name", "keyword")],
              EnumValue: [name("string-2")],
              ListValue: [
                (0, _RuleHelpers.p)("["),
                (0, _RuleHelpers.list)("Value"),
                (0, _RuleHelpers.p)("]")
              ],
              ObjectValue: [
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("ObjectField"),
                (0, _RuleHelpers.p)("}")
              ],
              ObjectField: [
                name("attribute"),
                (0, _RuleHelpers.p)(":"),
                "Value"
              ],
              Type: function(token) {
                return "[" === token.value ? "ListType" : "NonNullType";
              },
              ListType: [
                (0, _RuleHelpers.p)("["),
                "Type",
                (0, _RuleHelpers.p)("]"),
                (0, _RuleHelpers.opt)((0, _RuleHelpers.p)("!"))
              ],
              NonNullType: [
                "NamedType",
                (0, _RuleHelpers.opt)((0, _RuleHelpers.p)("!"))
              ],
              NamedType: [
                ((style = "atom"),
                {
                  style: style,
                  match: function(token) {
                    return "Name" === token.kind;
                  },
                  update: function(state, token) {
                    state.prevState &&
                      state.prevState.prevState &&
                      ((state.name = token.value),
                      (state.prevState.prevState.type = token.value));
                  }
                })
              ],
              Directive: [
                (0, _RuleHelpers.p)("@", "meta"),
                name("meta"),
                (0, _RuleHelpers.opt)("Arguments")
              ],
              SchemaDef: [
                word("schema"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("OperationTypeDef"),
                (0, _RuleHelpers.p)("}")
              ],
              OperationTypeDef: [
                name("keyword"),
                (0, _RuleHelpers.p)(":"),
                name("atom")
              ],
              ScalarDef: [
                word("scalar"),
                name("atom"),
                (0, _RuleHelpers.list)("Directive")
              ],
              ObjectTypeDef: [
                word("type"),
                name("atom"),
                (0, _RuleHelpers.opt)("Implements"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("FieldDef"),
                (0, _RuleHelpers.p)("}")
              ],
              Implements: [
                word("implements"),
                (0, _RuleHelpers.list)("NamedType")
              ],
              FieldDef: [
                name("property"),
                (0, _RuleHelpers.opt)("ArgumentsDef"),
                (0, _RuleHelpers.p)(":"),
                "Type",
                (0, _RuleHelpers.list)("Directive")
              ],
              ArgumentsDef: [
                (0, _RuleHelpers.p)("("),
                (0, _RuleHelpers.list)("InputValueDef"),
                (0, _RuleHelpers.p)(")")
              ],
              InputValueDef: [
                name("attribute"),
                (0, _RuleHelpers.p)(":"),
                "Type",
                (0, _RuleHelpers.opt)("DefaultValue"),
                (0, _RuleHelpers.list)("Directive")
              ],
              InterfaceDef: [
                word("interface"),
                name("atom"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("FieldDef"),
                (0, _RuleHelpers.p)("}")
              ],
              UnionDef: [
                word("union"),
                name("atom"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.p)("="),
                (0, _RuleHelpers.list)("UnionMember", (0, _RuleHelpers.p)("|"))
              ],
              UnionMember: ["NamedType"],
              EnumDef: [
                word("enum"),
                name("atom"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("EnumValueDef"),
                (0, _RuleHelpers.p)("}")
              ],
              EnumValueDef: [
                name("string-2"),
                (0, _RuleHelpers.list)("Directive")
              ],
              InputDef: [
                word("input"),
                name("atom"),
                (0, _RuleHelpers.list)("Directive"),
                (0, _RuleHelpers.p)("{"),
                (0, _RuleHelpers.list)("InputValueDef"),
                (0, _RuleHelpers.p)("}")
              ],
              ExtendDef: [word("extend"), "ObjectTypeDef"],
              DirectiveDef: [
                word("directive"),
                (0, _RuleHelpers.p)("@", "meta"),
                name("meta"),
                (0, _RuleHelpers.opt)("ArgumentsDef"),
                word("on"),
                (0, _RuleHelpers.list)(
                  "DirectiveLocation",
                  (0, _RuleHelpers.p)("|")
                )
              ],
              DirectiveLocation: [name("string-2")]
            });
          function word(value) {
            return {
              style: "keyword",
              match: function(token) {
                return "Name" === token.kind && token.value === value;
              }
            };
          }
          function name(style) {
            return {
              style: style,
              match: function(token) {
                return "Name" === token.kind;
              },
              update: function(state, token) {
                state.name = token.value;
              }
            };
          }
        },
        { "./RuleHelpers": 84 }
      ],
      86: [
        function(require, module, exports) {
          arguments[4][81][0].apply(exports, arguments);
        },
        {
          "./CharacterStream": 83,
          "./RuleHelpers": 84,
          "./Rules": 85,
          "./onlineParser": 87,
          dup: 81
        }
      ],
      87: [
        function(require, module, exports) {
          arguments[4][82][0].apply(exports, arguments);
        },
        { "./Rules": 85, dup: 82 }
      ],
      88: [
        function(require, module, exports) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          }
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.offsetToPosition = offsetToPosition),
            (exports.locToRange = function(text, loc) {
              var start = offsetToPosition(text, loc.start),
                end = offsetToPosition(text, loc.end);
              return new Range(start, end);
            });
          var Range = (exports.Range = (function() {
              function Range(start, end) {
                var _this = this;
                _classCallCheck(this, Range),
                  (this.containsPosition = function(position) {
                    return _this.start.line === position.line
                      ? _this.start.character <= position.character
                      : _this.end.line === position.line
                        ? _this.end.character >= position.character
                        : _this.start.line <= position.line &&
                          _this.end.line >= position.line;
                  }),
                  (this.start = start),
                  (this.end = end);
              }
              return (
                (Range.prototype.setStart = function(line, character) {
                  this.start = new Position(line, character);
                }),
                (Range.prototype.setEnd = function(line, character) {
                  this.end = new Position(line, character);
                }),
                Range
              );
            })()),
            Position = (exports.Position = (function() {
              function Position(line, character) {
                var _this2 = this;
                _classCallCheck(this, Position),
                  (this.lessThanOrEqualTo = function(position) {
                    return (
                      _this2.line < position.line ||
                      (_this2.line === position.line &&
                        _this2.character <= position.character)
                    );
                  }),
                  (this.line = line),
                  (this.character = character);
              }
              return (
                (Position.prototype.setLine = function(line) {
                  this.line = line;
                }),
                (Position.prototype.setCharacter = function(character) {
                  this.character = character;
                }),
                Position
              );
            })());
          function offsetToPosition(text, loc) {
            var buf = text.slice(0, loc),
              lines = buf.split("\n").length - 1,
              lastLineIndex = buf.lastIndexOf("\n");
            return new Position(lines, loc - lastLineIndex - 1);
          }
        },
        {}
      ],
      89: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.getASTNodeAtPosition = function(query, ast, point) {
              var offset = pointToOffset(query, point),
                nodeContainingPosition = void 0;
              return (
                (0, _graphql.visit)(ast, {
                  enter: function(node) {
                    if (
                      !(
                        "Name" !== node.kind &&
                        node.loc &&
                        node.loc.start <= offset &&
                        offset <= node.loc.end
                      )
                    )
                      return !1;
                    nodeContainingPosition = node;
                  },
                  leave: function(node) {
                    if (
                      node.loc &&
                      node.loc.start <= offset &&
                      offset <= node.loc.end
                    )
                      return !1;
                  }
                }),
                nodeContainingPosition
              );
            }),
            (exports.pointToOffset = pointToOffset);
          require("./Range");
          var _graphql = require("graphql");
          function pointToOffset(text, point) {
            var linesUntilPosition = text.split("\n").slice(0, point.line);
            return (
              point.character +
              linesUntilPosition
                .map(function(line) {
                  return line.length + 1;
                })
                .reduce(function(a, b) {
                  return a + b;
                }, 0)
            );
          }
        },
        { "./Range": 88, graphql: 101 }
      ],
      90: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _getASTNodeAtPosition = require("./getASTNodeAtPosition");
          Object.defineProperty(exports, "getASTNodeAtPosition", {
            enumerable: !0,
            get: function() {
              return _getASTNodeAtPosition.getASTNodeAtPosition;
            }
          }),
            Object.defineProperty(exports, "pointToOffset", {
              enumerable: !0,
              get: function() {
                return _getASTNodeAtPosition.pointToOffset;
              }
            });
          var _Range = require("./Range");
          Object.defineProperty(exports, "Position", {
            enumerable: !0,
            get: function() {
              return _Range.Position;
            }
          }),
            Object.defineProperty(exports, "Range", {
              enumerable: !0,
              get: function() {
                return _Range.Range;
              }
            }),
            Object.defineProperty(exports, "locToRange", {
              enumerable: !0,
              get: function() {
                return _Range.locToRange;
              }
            }),
            Object.defineProperty(exports, "offsetToPosition", {
              enumerable: !0,
              get: function() {
                return _Range.offsetToPosition;
              }
            });
          var _validateWithCustomRules = require("./validateWithCustomRules");
          Object.defineProperty(exports, "validateWithCustomRules", {
            enumerable: !0,
            get: function() {
              return _validateWithCustomRules.validateWithCustomRules;
            }
          });
        },
        {
          "./Range": 88,
          "./getASTNodeAtPosition": 89,
          "./validateWithCustomRules": 91
        }
      ],
      91: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.validateWithCustomRules = function(
              schema,
              ast,
              customRules,
              isRelayCompatMode
            ) {
              var rulesToSkip = [
                require("graphql/validation/rules/NoUnusedFragments")
                  .NoUnusedFragments
              ];
              if (isRelayCompatMode) {
                var _require2 = require("graphql/validation/rules/KnownFragmentNames"),
                  KnownFragmentNames = _require2.KnownFragmentNames;
                rulesToSkip.push(KnownFragmentNames);
              }
              var rules = _graphql.specifiedRules.filter(function(rule) {
                  return !rulesToSkip.some(function(r) {
                    return r === rule;
                  });
                }),
                typeInfo = new _graphql.TypeInfo(schema);
              customRules && Array.prototype.push.apply(rules, customRules);
              var errors = (0, _graphql.validate)(schema, ast, rules, typeInfo);
              if (0 < errors.length)
                return errors.filter(function(error) {
                  return (
                    -1 === error.message.indexOf("Unknown directive") ||
                    !(
                      (error.nodes &&
                        error.nodes[0] &&
                        error.nodes[0].name &&
                        "arguments" === error.nodes[0].name.value) ||
                      (error.nodes &&
                        error.nodes[0] &&
                        error.nodes[0].name &&
                        error.nodes[0].name.value &&
                        "argumentDefinitions" === error.nodes[0].name.value)
                    )
                  );
                });
              return [];
            });
          var _graphql = require("graphql");
        },
        {
          graphql: 101,
          "graphql/validation/rules/KnownFragmentNames": 153,
          "graphql/validation/rules/NoUnusedFragments": 158
        }
      ],
      92: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.GraphQLError = GraphQLError);
          var _location = require("../language/location");
          function GraphQLError(
            message,
            nodes,
            source,
            positions,
            path,
            originalError
          ) {
            var _source = source;
            if (!_source && nodes && 0 < nodes.length) {
              var node = nodes[0];
              _source = node && node.loc && node.loc.source;
            }
            var _positions = positions;
            !_positions &&
              nodes &&
              (_positions = nodes
                .filter(function(node) {
                  return Boolean(node.loc);
                })
                .map(function(node) {
                  return node.loc.start;
                })),
              _positions && 0 === _positions.length && (_positions = void 0);
            var _locations = void 0,
              _source2 = _source;
            _source2 &&
              _positions &&
              (_locations = _positions.map(function(pos) {
                return (0, _location.getLocation)(_source2, pos);
              })),
              Object.defineProperties(this, {
                message: { value: message, enumerable: !0, writable: !0 },
                locations: { value: _locations || void 0, enumerable: !0 },
                path: { value: path || void 0, enumerable: !0 },
                nodes: { value: nodes || void 0 },
                source: { value: _source || void 0 },
                positions: { value: _positions || void 0 },
                originalError: { value: originalError }
              }),
              originalError && originalError.stack
                ? Object.defineProperty(this, "stack", {
                    value: originalError.stack,
                    writable: !0,
                    configurable: !0
                  })
                : Error.captureStackTrace
                  ? Error.captureStackTrace(this, GraphQLError)
                  : Object.defineProperty(this, "stack", {
                      value: Error().stack,
                      writable: !0,
                      configurable: !0
                    });
          }
          GraphQLError.prototype = Object.create(Error.prototype, {
            constructor: { value: GraphQLError },
            name: { value: "GraphQLError" }
          });
        },
        { "../language/location": 113 }
      ],
      93: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.formatError = function(error) {
              return (
                error ||
                  (0, _invariant2.default)(
                    0,
                    "Received null or undefined error."
                  ),
                {
                  message: error.message,
                  locations: error.locations,
                  path: error.path
                }
              );
            });
          var obj,
            _invariant = require("../jsutils/invariant"),
            _invariant2 =
              (obj = _invariant) && obj.__esModule ? obj : { default: obj };
        },
        { "../jsutils/invariant": 103 }
      ],
      94: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _GraphQLError = require("./GraphQLError");
          Object.defineProperty(exports, "GraphQLError", {
            enumerable: !0,
            get: function() {
              return _GraphQLError.GraphQLError;
            }
          });
          var _syntaxError = require("./syntaxError");
          Object.defineProperty(exports, "syntaxError", {
            enumerable: !0,
            get: function() {
              return _syntaxError.syntaxError;
            }
          });
          var _locatedError = require("./locatedError");
          Object.defineProperty(exports, "locatedError", {
            enumerable: !0,
            get: function() {
              return _locatedError.locatedError;
            }
          });
          var _formatError = require("./formatError");
          Object.defineProperty(exports, "formatError", {
            enumerable: !0,
            get: function() {
              return _formatError.formatError;
            }
          });
        },
        {
          "./GraphQLError": 92,
          "./formatError": 93,
          "./locatedError": 95,
          "./syntaxError": 96
        }
      ],
      95: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.locatedError = function(originalError, nodes, path) {
              if (originalError && originalError.path) return originalError;
              var message = originalError
                ? originalError.message || String(originalError)
                : "An unknown error occurred.";
              return new _GraphQLError.GraphQLError(
                message,
                (originalError && originalError.nodes) || nodes,
                originalError && originalError.source,
                originalError && originalError.positions,
                path,
                originalError
              );
            });
          var _GraphQLError = require("./GraphQLError");
        },
        { "./GraphQLError": 92 }
      ],
      96: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.syntaxError = function(source, position, description) {
              var location = (0, _location.getLocation)(source, position),
                line = location.line + source.locationOffset.line - 1,
                columnOffset = getColumnOffset(source, location),
                column = location.column + columnOffset;
              return new _GraphQLError.GraphQLError(
                "Syntax Error " +
                  source.name +
                  " (" +
                  line +
                  ":" +
                  column +
                  ") " +
                  description +
                  "\n\n" +
                  (function(source, location) {
                    var line = location.line,
                      lineOffset = source.locationOffset.line - 1,
                      columnOffset = getColumnOffset(source, location),
                      contextLine = line + lineOffset,
                      prevLineNum = (contextLine - 1).toString(),
                      lineNum = contextLine.toString(),
                      nextLineNum = (contextLine + 1).toString(),
                      padLen = nextLineNum.length,
                      lines = source.body.split(/\r\n|[\n\r]/g);
                    return (
                      (lines[0] =
                        whitespace(source.locationOffset.column - 1) +
                        lines[0]),
                      (2 <= line
                        ? lpad(padLen, prevLineNum) +
                          ": " +
                          lines[line - 2] +
                          "\n"
                        : "") +
                        lpad(padLen, lineNum) +
                        ": " +
                        lines[line - 1] +
                        "\n" +
                        whitespace(
                          2 + padLen + location.column - 1 + columnOffset
                        ) +
                        "^\n" +
                        (line < lines.length
                          ? lpad(padLen, nextLineNum) +
                            ": " +
                            lines[line] +
                            "\n"
                          : "")
                    );
                  })(source, location),
                void 0,
                source,
                [position]
              );
            });
          var _location = require("../language/location"),
            _GraphQLError = require("./GraphQLError");
          function getColumnOffset(source, location) {
            return 1 === location.line ? source.locationOffset.column - 1 : 0;
          }
          function whitespace(len) {
            return Array(len + 1).join(" ");
          }
          function lpad(len, str) {
            return whitespace(len - str.length) + str;
          }
        },
        { "../language/location": 113, "./GraphQLError": 92 }
      ],
      97: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.defaultFieldResolver = void 0);
          var _typeof =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    "function" == typeof Symbol &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? "symbol"
                    : typeof obj;
                };
          (exports.execute = function(
            argsOrSchema,
            document,
            rootValue,
            contextValue,
            variableValues,
            operationName,
            fieldResolver
          ) {
            var args = 1 === arguments.length ? argsOrSchema : void 0,
              schema = args ? args.schema : argsOrSchema;
            return args
              ? executeImpl(
                  schema,
                  args.document,
                  args.rootValue,
                  args.contextValue,
                  args.variableValues,
                  args.operationName,
                  args.fieldResolver
                )
              : executeImpl(
                  schema,
                  document,
                  rootValue,
                  contextValue,
                  variableValues,
                  operationName,
                  fieldResolver
                );
          }),
            (exports.responsePathAsArray = responsePathAsArray),
            (exports.addPath = addPath),
            (exports.assertValidExecutionArguments = assertValidExecutionArguments),
            (exports.buildExecutionContext = buildExecutionContext),
            (exports.getOperationRootType = getOperationRootType),
            (exports.collectFields = collectFields),
            (exports.buildResolveInfo = buildResolveInfo),
            (exports.resolveFieldValueOrError = resolveFieldValueOrError),
            (exports.getFieldDef = getFieldDef);
          var _iterall = require("iterall"),
            _error = require("../error"),
            _invariant2 = _interopRequireDefault(
              require("../jsutils/invariant")
            ),
            _isNullish2 = _interopRequireDefault(
              require("../jsutils/isNullish")
            ),
            _typeFromAST = require("../utilities/typeFromAST"),
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../language/kinds")),
            _values = require("./values"),
            _definition = require("../type/definition"),
            _schema = require("../type/schema"),
            _introspection = require("../type/introspection"),
            _directives = require("../type/directives");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function executeImpl(
            schema,
            document,
            rootValue,
            contextValue,
            variableValues,
            operationName,
            fieldResolver
          ) {
            assertValidExecutionArguments(schema, document, variableValues);
            var context = void 0;
            try {
              context = buildExecutionContext(
                schema,
                document,
                rootValue,
                contextValue,
                variableValues,
                operationName,
                fieldResolver
              );
            } catch (error) {
              return Promise.resolve({ errors: [error] });
            }
            return Promise.resolve(
              (function(exeContext, operation, rootValue) {
                var type = getOperationRootType(exeContext.schema, operation),
                  fields = collectFields(
                    exeContext,
                    type,
                    operation.selectionSet,
                    Object.create(null),
                    Object.create(null)
                  ),
                  path = void 0;
                try {
                  var result =
                      "mutation" === operation.operation
                        ? (function(
                            exeContext,
                            parentType,
                            sourceValue,
                            path,
                            fields
                          ) {
                            return Object.keys(fields).reduce(function(
                              prevPromise,
                              responseName
                            ) {
                              return prevPromise.then(function(results) {
                                var fieldNodes = fields[responseName],
                                  fieldPath = addPath(path, responseName),
                                  result = resolveField(
                                    exeContext,
                                    parentType,
                                    sourceValue,
                                    fieldNodes,
                                    fieldPath
                                  );
                                if (void 0 === result) return results;
                                var promise = getPromise(result);
                                return promise
                                  ? promise.then(function(resolvedResult) {
                                      return (
                                        (results[
                                          responseName
                                        ] = resolvedResult),
                                        results
                                      );
                                    })
                                  : ((results[responseName] = result), results);
                              });
                            },
                            Promise.resolve({}));
                          })(exeContext, type, rootValue, path, fields)
                        : executeFields(
                            exeContext,
                            type,
                            rootValue,
                            path,
                            fields
                          ),
                    promise = getPromise(result);
                  return promise
                    ? promise.then(void 0, function(error) {
                        return (
                          exeContext.errors.push(error), Promise.resolve(null)
                        );
                      })
                    : result;
                } catch (error) {
                  return exeContext.errors.push(error), null;
                }
              })(context, context.operation, rootValue)
            ).then(function(data) {
              return 0 === context.errors.length
                ? { data: data }
                : { errors: context.errors, data: data };
            });
          }
          function responsePathAsArray(path) {
            for (var flattened = [], curr = path; curr; )
              flattened.push(curr.key), (curr = curr.prev);
            return flattened.reverse();
          }
          function addPath(prev, key) {
            return { prev: prev, key: key };
          }
          function assertValidExecutionArguments(
            schema,
            document,
            rawVariableValues
          ) {
            schema || (0, _invariant2.default)(0, "Must provide schema"),
              document || (0, _invariant2.default)(0, "Must provide document"),
              schema instanceof _schema.GraphQLSchema ||
                (0, _invariant2.default)(
                  0,
                  "Schema must be an instance of GraphQLSchema. Also ensure that there are not multiple versions of GraphQL installed in your node_modules directory."
                ),
              rawVariableValues &&
                "object" !==
                  (void 0 === rawVariableValues
                    ? "undefined"
                    : _typeof(rawVariableValues)) &&
                (0, _invariant2.default)(
                  0,
                  "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
                );
          }
          function buildExecutionContext(
            schema,
            document,
            rootValue,
            contextValue,
            rawVariableValues,
            operationName,
            fieldResolver
          ) {
            var operation = void 0,
              fragments = Object.create(null);
            if (
              (document.definitions.forEach(function(definition) {
                switch (definition.kind) {
                  case Kind.OPERATION_DEFINITION:
                    if (!operationName && operation)
                      throw new _error.GraphQLError(
                        "Must provide operation name if query contains multiple operations."
                      );
                    (!operationName ||
                      (definition.name &&
                        definition.name.value === operationName)) &&
                      (operation = definition);
                    break;
                  case Kind.FRAGMENT_DEFINITION:
                    fragments[definition.name.value] = definition;
                    break;
                  default:
                    throw new _error.GraphQLError(
                      "GraphQL cannot execute a request containing a " +
                        definition.kind +
                        ".",
                      [definition]
                    );
                }
              }),
              !operation)
            )
              throw operationName
                ? new _error.GraphQLError(
                    'Unknown operation named "' + operationName + '".'
                  )
                : new _error.GraphQLError("Must provide an operation.");
            var variableValues = (0, _values.getVariableValues)(
              schema,
              operation.variableDefinitions || [],
              rawVariableValues || {}
            );
            return {
              schema: schema,
              fragments: fragments,
              rootValue: rootValue,
              contextValue: contextValue,
              operation: operation,
              variableValues: variableValues,
              fieldResolver: fieldResolver || defaultFieldResolver,
              errors: []
            };
          }
          function getOperationRootType(schema, operation) {
            switch (operation.operation) {
              case "query":
                return schema.getQueryType();
              case "mutation":
                var mutationType = schema.getMutationType();
                if (!mutationType)
                  throw new _error.GraphQLError(
                    "Schema is not configured for mutations",
                    [operation]
                  );
                return mutationType;
              case "subscription":
                var subscriptionType = schema.getSubscriptionType();
                if (!subscriptionType)
                  throw new _error.GraphQLError(
                    "Schema is not configured for subscriptions",
                    [operation]
                  );
                return subscriptionType;
              default:
                throw new _error.GraphQLError(
                  "Can only execute queries, mutations and subscriptions",
                  [operation]
                );
            }
          }
          function executeFields(
            exeContext,
            parentType,
            sourceValue,
            path,
            fields
          ) {
            var object,
              keys,
              valuesAndPromises,
              containsPromise = !1,
              finalResults = Object.keys(fields).reduce(function(
                results,
                responseName
              ) {
                var fieldNodes = fields[responseName],
                  fieldPath = addPath(path, responseName),
                  result = resolveField(
                    exeContext,
                    parentType,
                    sourceValue,
                    fieldNodes,
                    fieldPath
                  );
                return (
                  void 0 === result ||
                    (getPromise((results[responseName] = result)) &&
                      (containsPromise = !0)),
                  results
                );
              },
              Object.create(null));
            return containsPromise
              ? ((object = finalResults),
                (keys = Object.keys(object)),
                (valuesAndPromises = keys.map(function(name) {
                  return object[name];
                })),
                Promise.all(valuesAndPromises).then(function(values) {
                  return values.reduce(function(resolvedObject, value, i) {
                    return (resolvedObject[keys[i]] = value), resolvedObject;
                  }, Object.create(null));
                }))
              : finalResults;
          }
          function collectFields(
            exeContext,
            runtimeType,
            selectionSet,
            fields,
            visitedFragmentNames
          ) {
            for (var i = 0; i < selectionSet.selections.length; i++) {
              var selection = selectionSet.selections[i];
              switch (selection.kind) {
                case Kind.FIELD:
                  if (!shouldIncludeNode(exeContext, selection)) continue;
                  var _name = (node = selection).alias
                    ? node.alias.value
                    : node.name.value;
                  fields[_name] || (fields[_name] = []),
                    fields[_name].push(selection);
                  break;
                case Kind.INLINE_FRAGMENT:
                  if (
                    !shouldIncludeNode(exeContext, selection) ||
                    !doesFragmentConditionMatch(
                      exeContext,
                      selection,
                      runtimeType
                    )
                  )
                    continue;
                  collectFields(
                    exeContext,
                    runtimeType,
                    selection.selectionSet,
                    fields,
                    visitedFragmentNames
                  );
                  break;
                case Kind.FRAGMENT_SPREAD:
                  var fragName = selection.name.value;
                  if (
                    visitedFragmentNames[fragName] ||
                    !shouldIncludeNode(exeContext, selection)
                  )
                    continue;
                  visitedFragmentNames[fragName] = !0;
                  var fragment = exeContext.fragments[fragName];
                  if (
                    !fragment ||
                    !doesFragmentConditionMatch(
                      exeContext,
                      fragment,
                      runtimeType
                    )
                  )
                    continue;
                  collectFields(
                    exeContext,
                    runtimeType,
                    fragment.selectionSet,
                    fields,
                    visitedFragmentNames
                  );
              }
            }
            var node;
            return fields;
          }
          function shouldIncludeNode(exeContext, node) {
            var skip = (0, _values.getDirectiveValues)(
              _directives.GraphQLSkipDirective,
              node,
              exeContext.variableValues
            );
            if (skip && !0 === skip.if) return !1;
            var include = (0, _values.getDirectiveValues)(
              _directives.GraphQLIncludeDirective,
              node,
              exeContext.variableValues
            );
            return !include || !1 !== include.if;
          }
          function doesFragmentConditionMatch(exeContext, fragment, type) {
            var typeConditionNode = fragment.typeCondition;
            if (!typeConditionNode) return !0;
            var conditionalType = (0, _typeFromAST.typeFromAST)(
              exeContext.schema,
              typeConditionNode
            );
            return (
              conditionalType === type ||
              (!!(0, _definition.isAbstractType)(conditionalType) &&
                exeContext.schema.isPossibleType(conditionalType, type))
            );
          }
          function resolveField(
            exeContext,
            parentType,
            source,
            fieldNodes,
            path
          ) {
            var fieldName = fieldNodes[0].name.value,
              fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);
            if (fieldDef) {
              var resolveFn = fieldDef.resolve || exeContext.fieldResolver,
                info = buildResolveInfo(
                  exeContext,
                  fieldDef,
                  fieldNodes,
                  parentType,
                  path
                ),
                result = resolveFieldValueOrError(
                  exeContext,
                  fieldDef,
                  fieldNodes,
                  resolveFn,
                  source,
                  info
                );
              return completeValueCatchingError(
                exeContext,
                fieldDef.type,
                fieldNodes,
                info,
                path,
                result
              );
            }
          }
          function buildResolveInfo(
            exeContext,
            fieldDef,
            fieldNodes,
            parentType,
            path
          ) {
            return {
              fieldName: fieldNodes[0].name.value,
              fieldNodes: fieldNodes,
              returnType: fieldDef.type,
              parentType: parentType,
              path: path,
              schema: exeContext.schema,
              fragments: exeContext.fragments,
              rootValue: exeContext.rootValue,
              operation: exeContext.operation,
              variableValues: exeContext.variableValues
            };
          }
          function resolveFieldValueOrError(
            exeContext,
            fieldDef,
            fieldNodes,
            resolveFn,
            source,
            info
          ) {
            try {
              return resolveFn(
                source,
                (0, _values.getArgumentValues)(
                  fieldDef,
                  fieldNodes[0],
                  exeContext.variableValues
                ),
                exeContext.contextValue,
                info
              );
            } catch (error) {
              return error instanceof Error ? error : new Error(error);
            }
          }
          function completeValueCatchingError(
            exeContext,
            returnType,
            fieldNodes,
            info,
            path,
            result
          ) {
            if (returnType instanceof _definition.GraphQLNonNull)
              return completeValueWithLocatedError(
                exeContext,
                returnType,
                fieldNodes,
                info,
                path,
                result
              );
            try {
              var completed = completeValueWithLocatedError(
                  exeContext,
                  returnType,
                  fieldNodes,
                  info,
                  path,
                  result
                ),
                promise = getPromise(completed);
              return promise
                ? promise.then(void 0, function(error) {
                    return exeContext.errors.push(error), Promise.resolve(null);
                  })
                : completed;
            } catch (error) {
              return exeContext.errors.push(error), null;
            }
          }
          function completeValueWithLocatedError(
            exeContext,
            returnType,
            fieldNodes,
            info,
            path,
            result
          ) {
            try {
              var completed = (function completeValue(
                  exeContext,
                  returnType,
                  fieldNodes,
                  info,
                  path,
                  result
                ) {
                  var promise = getPromise(result);
                  if (promise)
                    return promise.then(function(resolved) {
                      return completeValue(
                        exeContext,
                        returnType,
                        fieldNodes,
                        info,
                        path,
                        resolved
                      );
                    });
                  if (result instanceof Error) throw result;
                  if (returnType instanceof _definition.GraphQLNonNull) {
                    var completed = completeValue(
                      exeContext,
                      returnType.ofType,
                      fieldNodes,
                      info,
                      path,
                      result
                    );
                    if (null === completed)
                      throw new Error(
                        "Cannot return null for non-nullable field " +
                          info.parentType.name +
                          "." +
                          info.fieldName +
                          "."
                      );
                    return completed;
                  }
                  if ((0, _isNullish2.default)(result)) return null;
                  if (returnType instanceof _definition.GraphQLList)
                    return (function(
                      exeContext,
                      returnType,
                      fieldNodes,
                      info,
                      path,
                      result
                    ) {
                      (0, _iterall.isCollection)(result) ||
                        (0, _invariant2.default)(
                          0,
                          "Expected Iterable, but did not find one for field " +
                            info.parentType.name +
                            "." +
                            info.fieldName +
                            "."
                        );
                      var itemType = returnType.ofType,
                        containsPromise = !1,
                        completedResults = [];
                      return (
                        (0, _iterall.forEach)(result, function(item, index) {
                          var fieldPath = addPath(path, index),
                            completedItem = completeValueCatchingError(
                              exeContext,
                              itemType,
                              fieldNodes,
                              info,
                              fieldPath,
                              item
                            );
                          !containsPromise &&
                            getPromise(completedItem) &&
                            (containsPromise = !0),
                            completedResults.push(completedItem);
                        }),
                        containsPromise
                          ? Promise.all(completedResults)
                          : completedResults
                      );
                    })(exeContext, returnType, fieldNodes, info, path, result);
                  if ((0, _definition.isLeafType)(returnType))
                    return (function(returnType, result) {
                      returnType.serialize ||
                        (0, _invariant2.default)(
                          0,
                          "Missing serialize method on type"
                        );
                      var serializedResult = returnType.serialize(result);
                      if ((0, _isNullish2.default)(serializedResult))
                        throw new Error(
                          'Expected a value of type "' +
                            String(returnType) +
                            '" but received: ' +
                            String(result)
                        );
                      return serializedResult;
                    })(returnType, result);
                  if ((0, _definition.isAbstractType)(returnType))
                    return (function(
                      exeContext,
                      returnType,
                      fieldNodes,
                      info,
                      path,
                      result
                    ) {
                      var runtimeType = returnType.resolveType
                          ? returnType.resolveType(
                              result,
                              exeContext.contextValue,
                              info
                            )
                          : (function(value, context, info, abstractType) {
                              for (
                                var possibleTypes = info.schema.getPossibleTypes(
                                    abstractType
                                  ),
                                  promisedIsTypeOfResults = [],
                                  i = 0;
                                i < possibleTypes.length;
                                i++
                              ) {
                                var type = possibleTypes[i];
                                if (type.isTypeOf) {
                                  var isTypeOfResult = type.isTypeOf(
                                      value,
                                      context,
                                      info
                                    ),
                                    promise = getPromise(isTypeOfResult);
                                  if (promise)
                                    promisedIsTypeOfResults[i] = promise;
                                  else if (isTypeOfResult) return type;
                                }
                              }
                              if (promisedIsTypeOfResults.length)
                                return Promise.all(
                                  promisedIsTypeOfResults
                                ).then(function(isTypeOfResults) {
                                  for (
                                    var _i = 0;
                                    _i < isTypeOfResults.length;
                                    _i++
                                  )
                                    if (isTypeOfResults[_i])
                                      return possibleTypes[_i];
                                });
                            })(
                              result,
                              exeContext.contextValue,
                              info,
                              returnType
                            ),
                        promise = getPromise(runtimeType);
                      if (promise)
                        return promise.then(function(resolvedRuntimeType) {
                          return completeObjectValue(
                            exeContext,
                            ensureValidRuntimeType(
                              resolvedRuntimeType,
                              exeContext,
                              returnType,
                              fieldNodes,
                              info,
                              result
                            ),
                            fieldNodes,
                            info,
                            path,
                            result
                          );
                        });
                      return completeObjectValue(
                        exeContext,
                        ensureValidRuntimeType(
                          runtimeType,
                          exeContext,
                          returnType,
                          fieldNodes,
                          info,
                          result
                        ),
                        fieldNodes,
                        info,
                        path,
                        result
                      );
                    })(exeContext, returnType, fieldNodes, info, path, result);
                  if (returnType instanceof _definition.GraphQLObjectType)
                    return completeObjectValue(
                      exeContext,
                      returnType,
                      fieldNodes,
                      info,
                      path,
                      result
                    );
                  throw new Error(
                    'Cannot complete value of unexpected type "' +
                      String(returnType) +
                      '".'
                  );
                })(exeContext, returnType, fieldNodes, info, path, result),
                promise = getPromise(completed);
              return promise
                ? promise.then(void 0, function(error) {
                    return Promise.reject(
                      (0, _error.locatedError)(
                        error,
                        fieldNodes,
                        responsePathAsArray(path)
                      )
                    );
                  })
                : completed;
            } catch (error) {
              throw (0, _error.locatedError)(
                error,
                fieldNodes,
                responsePathAsArray(path)
              );
            }
          }
          function ensureValidRuntimeType(
            runtimeTypeOrName,
            exeContext,
            returnType,
            fieldNodes,
            info,
            result
          ) {
            var runtimeType =
              "string" == typeof runtimeTypeOrName
                ? exeContext.schema.getType(runtimeTypeOrName)
                : runtimeTypeOrName;
            if (!(runtimeType instanceof _definition.GraphQLObjectType))
              throw new _error.GraphQLError(
                "Abstract type " +
                  returnType.name +
                  " must resolve to an Object type at runtime for field " +
                  info.parentType.name +
                  "." +
                  info.fieldName +
                  ' with value "' +
                  String(result) +
                  '", received "' +
                  String(runtimeType) +
                  '".',
                fieldNodes
              );
            if (!exeContext.schema.isPossibleType(returnType, runtimeType))
              throw new _error.GraphQLError(
                'Runtime Object type "' +
                  runtimeType.name +
                  '" is not a possible type for "' +
                  returnType.name +
                  '".',
                fieldNodes
              );
            return runtimeType;
          }
          function completeObjectValue(
            exeContext,
            returnType,
            fieldNodes,
            info,
            path,
            result
          ) {
            if (returnType.isTypeOf) {
              var isTypeOf = returnType.isTypeOf(
                  result,
                  exeContext.contextValue,
                  info
                ),
                promise = getPromise(isTypeOf);
              if (promise)
                return promise.then(function(isTypeOfResult) {
                  if (!isTypeOfResult)
                    throw invalidReturnTypeError(
                      returnType,
                      result,
                      fieldNodes
                    );
                  return collectAndExecuteSubfields(
                    exeContext,
                    returnType,
                    fieldNodes,
                    info,
                    path,
                    result
                  );
                });
              if (!isTypeOf)
                throw invalidReturnTypeError(returnType, result, fieldNodes);
            }
            return collectAndExecuteSubfields(
              exeContext,
              returnType,
              fieldNodes,
              info,
              path,
              result
            );
          }
          function invalidReturnTypeError(returnType, result, fieldNodes) {
            return new _error.GraphQLError(
              'Expected value of type "' +
                returnType.name +
                '" but got: ' +
                String(result) +
                ".",
              fieldNodes
            );
          }
          function collectAndExecuteSubfields(
            exeContext,
            returnType,
            fieldNodes,
            info,
            path,
            result
          ) {
            for (
              var subFieldNodes = Object.create(null),
                visitedFragmentNames = Object.create(null),
                i = 0;
              i < fieldNodes.length;
              i++
            ) {
              var selectionSet = fieldNodes[i].selectionSet;
              selectionSet &&
                (subFieldNodes = collectFields(
                  exeContext,
                  returnType,
                  selectionSet,
                  subFieldNodes,
                  visitedFragmentNames
                ));
            }
            return executeFields(
              exeContext,
              returnType,
              result,
              path,
              subFieldNodes
            );
          }
          var defaultFieldResolver = (exports.defaultFieldResolver = function(
            source,
            args,
            context,
            info
          ) {
            if (
              "object" ===
                (void 0 === source ? "undefined" : _typeof(source)) ||
              "function" == typeof source
            ) {
              var property = source[info.fieldName];
              return "function" == typeof property
                ? source[info.fieldName](args, context, info)
                : property;
            }
          });
          function getPromise(value) {
            if (
              "object" === (void 0 === value ? "undefined" : _typeof(value)) &&
              null !== value &&
              "function" == typeof value.then
            )
              return value;
          }
          function getFieldDef(schema, parentType, fieldName) {
            return fieldName === _introspection.SchemaMetaFieldDef.name &&
              schema.getQueryType() === parentType
              ? _introspection.SchemaMetaFieldDef
              : fieldName === _introspection.TypeMetaFieldDef.name &&
                schema.getQueryType() === parentType
                ? _introspection.TypeMetaFieldDef
                : fieldName === _introspection.TypeNameMetaFieldDef.name
                  ? _introspection.TypeNameMetaFieldDef
                  : parentType.getFields()[fieldName];
          }
        },
        {
          "../error": 94,
          "../jsutils/invariant": 103,
          "../jsutils/isNullish": 105,
          "../language/kinds": 111,
          "../type/definition": 121,
          "../type/directives": 122,
          "../type/introspection": 124,
          "../type/schema": 126,
          "../utilities/typeFromAST": 144,
          "./values": 99,
          iterall: 175
        }
      ],
      98: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _execute = require("./execute");
          Object.defineProperty(exports, "execute", {
            enumerable: !0,
            get: function() {
              return _execute.execute;
            }
          }),
            Object.defineProperty(exports, "defaultFieldResolver", {
              enumerable: !0,
              get: function() {
                return _execute.defaultFieldResolver;
              }
            }),
            Object.defineProperty(exports, "responsePathAsArray", {
              enumerable: !0,
              get: function() {
                return _execute.responsePathAsArray;
              }
            });
          var _values = require("./values");
          Object.defineProperty(exports, "getDirectiveValues", {
            enumerable: !0,
            get: function() {
              return _values.getDirectiveValues;
            }
          });
        },
        { "./execute": 97, "./values": 99 }
      ],
      99: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _typeof =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    "function" == typeof Symbol &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? "symbol"
                    : typeof obj;
                };
          (exports.getVariableValues = function(schema, varDefNodes, inputs) {
            for (
              var coercedValues = Object.create(null), i = 0;
              i < varDefNodes.length;
              i++
            ) {
              var varDefNode = varDefNodes[i],
                varName = varDefNode.variable.name.value,
                varType = (0, _typeFromAST.typeFromAST)(
                  schema,
                  varDefNode.type
                );
              if (!(0, _definition.isInputType)(varType))
                throw new _error.GraphQLError(
                  'Variable "$' +
                    varName +
                    '" expected value of type "' +
                    (0, _printer.print)(varDefNode.type) +
                    '" which cannot be used as an input type.',
                  [varDefNode.type]
                );
              var value = inputs[varName];
              if ((0, _isInvalid2.default)(value)) {
                var defaultValue = varDefNode.defaultValue;
                if (
                  (defaultValue &&
                    (coercedValues[varName] = (0, _valueFromAST.valueFromAST)(
                      defaultValue,
                      varType
                    )),
                  varType instanceof _definition.GraphQLNonNull)
                )
                  throw new _error.GraphQLError(
                    'Variable "$' +
                      varName +
                      '" of required type "' +
                      String(varType) +
                      '" was not provided.',
                    [varDefNode]
                  );
              } else {
                var errors = (0, _isValidJSValue.isValidJSValue)(
                  value,
                  varType
                );
                if (errors.length) {
                  var message = errors ? "\n" + errors.join("\n") : "";
                  throw new _error.GraphQLError(
                    'Variable "$' +
                      varName +
                      '" got invalid value ' +
                      JSON.stringify(value) +
                      "." +
                      message,
                    [varDefNode]
                  );
                }
                var coercedValue = coerceValue(varType, value);
                (0, _isInvalid2.default)(coercedValue) &&
                  (0, _invariant2.default)(0, "Should have reported error."),
                  (coercedValues[varName] = coercedValue);
              }
            }
            return coercedValues;
          }),
            (exports.getArgumentValues = getArgumentValues),
            (exports.getDirectiveValues = function(
              directiveDef,
              node,
              variableValues
            ) {
              var directiveNode =
                node.directives &&
                (0, _find2.default)(node.directives, function(directive) {
                  return directive.name.value === directiveDef.name;
                });
              if (directiveNode)
                return getArgumentValues(
                  directiveDef,
                  directiveNode,
                  variableValues
                );
            });
          var _iterall = require("iterall"),
            _error = require("../error"),
            _find2 = _interopRequireDefault(require("../jsutils/find")),
            _invariant2 = _interopRequireDefault(
              require("../jsutils/invariant")
            ),
            _isNullish2 = _interopRequireDefault(
              require("../jsutils/isNullish")
            ),
            _isInvalid2 = _interopRequireDefault(
              require("../jsutils/isInvalid")
            ),
            _keyMap2 = _interopRequireDefault(require("../jsutils/keyMap")),
            _typeFromAST = require("../utilities/typeFromAST"),
            _valueFromAST = require("../utilities/valueFromAST"),
            _isValidJSValue = require("../utilities/isValidJSValue"),
            _isValidLiteralValue = require("../utilities/isValidLiteralValue"),
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../language/kinds")),
            _printer = require("../language/printer"),
            _definition = require("../type/definition");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function getArgumentValues(def, node, variableValues) {
            var argDefs = def.args,
              argNodes = node.arguments;
            if (!argDefs || !argNodes) return {};
            for (
              var coercedValues = Object.create(null),
                argNodeMap = (0, _keyMap2.default)(argNodes, function(arg) {
                  return arg.name.value;
                }),
                i = 0;
              i < argDefs.length;
              i++
            ) {
              var argDef = argDefs[i],
                name = argDef.name,
                argType = argDef.type,
                argumentNode = argNodeMap[name],
                defaultValue = argDef.defaultValue;
              if (argumentNode)
                if (argumentNode.value.kind === Kind.VARIABLE) {
                  var variableName = argumentNode.value.name.value;
                  if (
                    variableValues &&
                    !(0, _isInvalid2.default)(variableValues[variableName])
                  )
                    coercedValues[name] = variableValues[variableName];
                  else if ((0, _isInvalid2.default)(defaultValue)) {
                    if (argType instanceof _definition.GraphQLNonNull)
                      throw new _error.GraphQLError(
                        'Argument "' +
                          name +
                          '" of required type "' +
                          String(argType) +
                          '" was provided the variable "$' +
                          variableName +
                          '" which was not provided a runtime value.',
                        [argumentNode.value]
                      );
                  } else coercedValues[name] = defaultValue;
                } else {
                  var valueNode = argumentNode.value,
                    coercedValue = (0, _valueFromAST.valueFromAST)(
                      valueNode,
                      argType,
                      variableValues
                    );
                  if ((0, _isInvalid2.default)(coercedValue)) {
                    var errors = (0, _isValidLiteralValue.isValidLiteralValue)(
                        argType,
                        valueNode
                      ),
                      message = errors ? "\n" + errors.join("\n") : "";
                    throw new _error.GraphQLError(
                      'Argument "' +
                        name +
                        '" got invalid value ' +
                        (0, _printer.print)(valueNode) +
                        "." +
                        message,
                      [argumentNode.value]
                    );
                  }
                  coercedValues[name] = coercedValue;
                }
              else if ((0, _isInvalid2.default)(defaultValue)) {
                if (argType instanceof _definition.GraphQLNonNull)
                  throw new _error.GraphQLError(
                    'Argument "' +
                      name +
                      '" of required type "' +
                      String(argType) +
                      '" was not provided.',
                    [node]
                  );
              } else coercedValues[name] = defaultValue;
            }
            return coercedValues;
          }
          function coerceValue(type, value) {
            var _value = value;
            if (!(0, _isInvalid2.default)(_value)) {
              if (type instanceof _definition.GraphQLNonNull) {
                if (null === _value) return;
                return coerceValue(type.ofType, _value);
              }
              if (null === _value) return null;
              if (type instanceof _definition.GraphQLList) {
                var itemType = type.ofType;
                if ((0, _iterall.isCollection)(_value)) {
                  var coercedValues = [],
                    valueIter = (0, _iterall.createIterator)(_value);
                  if (!valueIter) return;
                  for (var step = void 0; !(step = valueIter.next()).done; ) {
                    var itemValue = coerceValue(itemType, step.value);
                    if ((0, _isInvalid2.default)(itemValue)) return;
                    coercedValues.push(itemValue);
                  }
                  return coercedValues;
                }
                var coercedValue = coerceValue(itemType, _value);
                if ((0, _isInvalid2.default)(coercedValue)) return;
                return [coerceValue(itemType, _value)];
              }
              if (type instanceof _definition.GraphQLInputObjectType) {
                if (
                  "object" !==
                  (void 0 === _value ? "undefined" : _typeof(_value))
                )
                  return;
                for (
                  var coercedObj = Object.create(null),
                    fields = type.getFields(),
                    fieldNames = Object.keys(fields),
                    i = 0;
                  i < fieldNames.length;
                  i++
                ) {
                  var fieldName = fieldNames[i],
                    field = fields[fieldName];
                  if ((0, _isInvalid2.default)(_value[fieldName]))
                    if ((0, _isInvalid2.default)(field.defaultValue)) {
                      if (field.type instanceof _definition.GraphQLNonNull)
                        return;
                    } else coercedObj[fieldName] = field.defaultValue;
                  else {
                    var fieldValue = coerceValue(field.type, _value[fieldName]);
                    if ((0, _isInvalid2.default)(fieldValue)) return;
                    coercedObj[fieldName] = fieldValue;
                  }
                }
                return coercedObj;
              }
              type instanceof _definition.GraphQLScalarType ||
                type instanceof _definition.GraphQLEnumType ||
                (0, _invariant2.default)(0, "Must be input type");
              var parsed = type.parseValue(_value);
              if (!(0, _isNullish2.default)(parsed)) return parsed;
            }
          }
        },
        {
          "../error": 94,
          "../jsutils/find": 102,
          "../jsutils/invariant": 103,
          "../jsutils/isInvalid": 104,
          "../jsutils/isNullish": 105,
          "../jsutils/keyMap": 106,
          "../language/kinds": 111,
          "../language/printer": 115,
          "../type/definition": 121,
          "../utilities/isValidJSValue": 139,
          "../utilities/isValidLiteralValue": 140,
          "../utilities/typeFromAST": 144,
          "../utilities/valueFromAST": 145,
          iterall: 175
        }
      ],
      100: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.graphql = function(
              argsOrSchema,
              source,
              rootValue,
              contextValue,
              variableValues,
              operationName,
              fieldResolver
            ) {
              var args = 1 === arguments.length ? argsOrSchema : void 0,
                schema = args ? args.schema : argsOrSchema;
              return args
                ? graphqlImpl(
                    schema,
                    args.source,
                    args.rootValue,
                    args.contextValue,
                    args.variableValues,
                    args.operationName,
                    args.fieldResolver
                  )
                : graphqlImpl(
                    schema,
                    source,
                    rootValue,
                    contextValue,
                    variableValues,
                    operationName,
                    fieldResolver
                  );
            });
          var _parser = require("./language/parser"),
            _validate = require("./validation/validate"),
            _execute = require("./execution/execute");
          function graphqlImpl(
            schema,
            source,
            rootValue,
            contextValue,
            variableValues,
            operationName,
            fieldResolver
          ) {
            return new Promise(function(resolve) {
              var document = void 0;
              try {
                document = (0, _parser.parse)(source);
              } catch (syntaxError) {
                return resolve({ errors: [syntaxError] });
              }
              var validationErrors = (0, _validate.validate)(schema, document);
              if (0 < validationErrors.length)
                return resolve({ errors: validationErrors });
              resolve(
                (0, _execute.execute)(
                  schema,
                  document,
                  rootValue,
                  contextValue,
                  variableValues,
                  operationName,
                  fieldResolver
                )
              );
            });
          }
        },
        {
          "./execution/execute": 97,
          "./language/parser": 114,
          "./validation/validate": 174
        }
      ],
      101: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _graphql = require("./graphql");
          Object.defineProperty(exports, "graphql", {
            enumerable: !0,
            get: function() {
              return _graphql.graphql;
            }
          });
          var _type = require("./type");
          Object.defineProperty(exports, "GraphQLSchema", {
            enumerable: !0,
            get: function() {
              return _type.GraphQLSchema;
            }
          }),
            Object.defineProperty(exports, "GraphQLScalarType", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLScalarType;
              }
            }),
            Object.defineProperty(exports, "GraphQLObjectType", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLObjectType;
              }
            }),
            Object.defineProperty(exports, "GraphQLInterfaceType", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLInterfaceType;
              }
            }),
            Object.defineProperty(exports, "GraphQLUnionType", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLUnionType;
              }
            }),
            Object.defineProperty(exports, "GraphQLEnumType", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLEnumType;
              }
            }),
            Object.defineProperty(exports, "GraphQLInputObjectType", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLInputObjectType;
              }
            }),
            Object.defineProperty(exports, "GraphQLList", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLList;
              }
            }),
            Object.defineProperty(exports, "GraphQLNonNull", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLNonNull;
              }
            }),
            Object.defineProperty(exports, "GraphQLDirective", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLDirective;
              }
            }),
            Object.defineProperty(exports, "TypeKind", {
              enumerable: !0,
              get: function() {
                return _type.TypeKind;
              }
            }),
            Object.defineProperty(exports, "DirectiveLocation", {
              enumerable: !0,
              get: function() {
                return _type.DirectiveLocation;
              }
            }),
            Object.defineProperty(exports, "GraphQLInt", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLInt;
              }
            }),
            Object.defineProperty(exports, "GraphQLFloat", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLFloat;
              }
            }),
            Object.defineProperty(exports, "GraphQLString", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLString;
              }
            }),
            Object.defineProperty(exports, "GraphQLBoolean", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLBoolean;
              }
            }),
            Object.defineProperty(exports, "GraphQLID", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLID;
              }
            }),
            Object.defineProperty(exports, "specifiedDirectives", {
              enumerable: !0,
              get: function() {
                return _type.specifiedDirectives;
              }
            }),
            Object.defineProperty(exports, "GraphQLIncludeDirective", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLIncludeDirective;
              }
            }),
            Object.defineProperty(exports, "GraphQLSkipDirective", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLSkipDirective;
              }
            }),
            Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
              enumerable: !0,
              get: function() {
                return _type.GraphQLDeprecatedDirective;
              }
            }),
            Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
              enumerable: !0,
              get: function() {
                return _type.DEFAULT_DEPRECATION_REASON;
              }
            }),
            Object.defineProperty(exports, "SchemaMetaFieldDef", {
              enumerable: !0,
              get: function() {
                return _type.SchemaMetaFieldDef;
              }
            }),
            Object.defineProperty(exports, "TypeMetaFieldDef", {
              enumerable: !0,
              get: function() {
                return _type.TypeMetaFieldDef;
              }
            }),
            Object.defineProperty(exports, "TypeNameMetaFieldDef", {
              enumerable: !0,
              get: function() {
                return _type.TypeNameMetaFieldDef;
              }
            }),
            Object.defineProperty(exports, "__Schema", {
              enumerable: !0,
              get: function() {
                return _type.__Schema;
              }
            }),
            Object.defineProperty(exports, "__Directive", {
              enumerable: !0,
              get: function() {
                return _type.__Directive;
              }
            }),
            Object.defineProperty(exports, "__DirectiveLocation", {
              enumerable: !0,
              get: function() {
                return _type.__DirectiveLocation;
              }
            }),
            Object.defineProperty(exports, "__Type", {
              enumerable: !0,
              get: function() {
                return _type.__Type;
              }
            }),
            Object.defineProperty(exports, "__Field", {
              enumerable: !0,
              get: function() {
                return _type.__Field;
              }
            }),
            Object.defineProperty(exports, "__InputValue", {
              enumerable: !0,
              get: function() {
                return _type.__InputValue;
              }
            }),
            Object.defineProperty(exports, "__EnumValue", {
              enumerable: !0,
              get: function() {
                return _type.__EnumValue;
              }
            }),
            Object.defineProperty(exports, "__TypeKind", {
              enumerable: !0,
              get: function() {
                return _type.__TypeKind;
              }
            }),
            Object.defineProperty(exports, "isType", {
              enumerable: !0,
              get: function() {
                return _type.isType;
              }
            }),
            Object.defineProperty(exports, "isInputType", {
              enumerable: !0,
              get: function() {
                return _type.isInputType;
              }
            }),
            Object.defineProperty(exports, "isOutputType", {
              enumerable: !0,
              get: function() {
                return _type.isOutputType;
              }
            }),
            Object.defineProperty(exports, "isLeafType", {
              enumerable: !0,
              get: function() {
                return _type.isLeafType;
              }
            }),
            Object.defineProperty(exports, "isCompositeType", {
              enumerable: !0,
              get: function() {
                return _type.isCompositeType;
              }
            }),
            Object.defineProperty(exports, "isAbstractType", {
              enumerable: !0,
              get: function() {
                return _type.isAbstractType;
              }
            }),
            Object.defineProperty(exports, "isNamedType", {
              enumerable: !0,
              get: function() {
                return _type.isNamedType;
              }
            }),
            Object.defineProperty(exports, "assertType", {
              enumerable: !0,
              get: function() {
                return _type.assertType;
              }
            }),
            Object.defineProperty(exports, "assertInputType", {
              enumerable: !0,
              get: function() {
                return _type.assertInputType;
              }
            }),
            Object.defineProperty(exports, "assertOutputType", {
              enumerable: !0,
              get: function() {
                return _type.assertOutputType;
              }
            }),
            Object.defineProperty(exports, "assertLeafType", {
              enumerable: !0,
              get: function() {
                return _type.assertLeafType;
              }
            }),
            Object.defineProperty(exports, "assertCompositeType", {
              enumerable: !0,
              get: function() {
                return _type.assertCompositeType;
              }
            }),
            Object.defineProperty(exports, "assertAbstractType", {
              enumerable: !0,
              get: function() {
                return _type.assertAbstractType;
              }
            }),
            Object.defineProperty(exports, "assertNamedType", {
              enumerable: !0,
              get: function() {
                return _type.assertNamedType;
              }
            }),
            Object.defineProperty(exports, "getNullableType", {
              enumerable: !0,
              get: function() {
                return _type.getNullableType;
              }
            }),
            Object.defineProperty(exports, "getNamedType", {
              enumerable: !0,
              get: function() {
                return _type.getNamedType;
              }
            });
          var _language = require("./language");
          Object.defineProperty(exports, "Source", {
            enumerable: !0,
            get: function() {
              return _language.Source;
            }
          }),
            Object.defineProperty(exports, "getLocation", {
              enumerable: !0,
              get: function() {
                return _language.getLocation;
              }
            }),
            Object.defineProperty(exports, "parse", {
              enumerable: !0,
              get: function() {
                return _language.parse;
              }
            }),
            Object.defineProperty(exports, "parseValue", {
              enumerable: !0,
              get: function() {
                return _language.parseValue;
              }
            }),
            Object.defineProperty(exports, "parseType", {
              enumerable: !0,
              get: function() {
                return _language.parseType;
              }
            }),
            Object.defineProperty(exports, "print", {
              enumerable: !0,
              get: function() {
                return _language.print;
              }
            }),
            Object.defineProperty(exports, "visit", {
              enumerable: !0,
              get: function() {
                return _language.visit;
              }
            }),
            Object.defineProperty(exports, "visitInParallel", {
              enumerable: !0,
              get: function() {
                return _language.visitInParallel;
              }
            }),
            Object.defineProperty(exports, "visitWithTypeInfo", {
              enumerable: !0,
              get: function() {
                return _language.visitWithTypeInfo;
              }
            }),
            Object.defineProperty(exports, "getVisitFn", {
              enumerable: !0,
              get: function() {
                return _language.getVisitFn;
              }
            }),
            Object.defineProperty(exports, "Kind", {
              enumerable: !0,
              get: function() {
                return _language.Kind;
              }
            }),
            Object.defineProperty(exports, "TokenKind", {
              enumerable: !0,
              get: function() {
                return _language.TokenKind;
              }
            }),
            Object.defineProperty(exports, "BREAK", {
              enumerable: !0,
              get: function() {
                return _language.BREAK;
              }
            });
          var _execution = require("./execution");
          Object.defineProperty(exports, "execute", {
            enumerable: !0,
            get: function() {
              return _execution.execute;
            }
          }),
            Object.defineProperty(exports, "defaultFieldResolver", {
              enumerable: !0,
              get: function() {
                return _execution.defaultFieldResolver;
              }
            }),
            Object.defineProperty(exports, "responsePathAsArray", {
              enumerable: !0,
              get: function() {
                return _execution.responsePathAsArray;
              }
            }),
            Object.defineProperty(exports, "getDirectiveValues", {
              enumerable: !0,
              get: function() {
                return _execution.getDirectiveValues;
              }
            });
          var _subscription = require("./subscription");
          Object.defineProperty(exports, "subscribe", {
            enumerable: !0,
            get: function() {
              return _subscription.subscribe;
            }
          }),
            Object.defineProperty(exports, "createSourceEventStream", {
              enumerable: !0,
              get: function() {
                return _subscription.createSourceEventStream;
              }
            });
          var _validation = require("./validation");
          Object.defineProperty(exports, "validate", {
            enumerable: !0,
            get: function() {
              return _validation.validate;
            }
          }),
            Object.defineProperty(exports, "ValidationContext", {
              enumerable: !0,
              get: function() {
                return _validation.ValidationContext;
              }
            }),
            Object.defineProperty(exports, "specifiedRules", {
              enumerable: !0,
              get: function() {
                return _validation.specifiedRules;
              }
            }),
            Object.defineProperty(exports, "ArgumentsOfCorrectTypeRule", {
              enumerable: !0,
              get: function() {
                return _validation.ArgumentsOfCorrectTypeRule;
              }
            }),
            Object.defineProperty(exports, "DefaultValuesOfCorrectTypeRule", {
              enumerable: !0,
              get: function() {
                return _validation.DefaultValuesOfCorrectTypeRule;
              }
            }),
            Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
              enumerable: !0,
              get: function() {
                return _validation.FieldsOnCorrectTypeRule;
              }
            }),
            Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
              enumerable: !0,
              get: function() {
                return _validation.FragmentsOnCompositeTypesRule;
              }
            }),
            Object.defineProperty(exports, "KnownArgumentNamesRule", {
              enumerable: !0,
              get: function() {
                return _validation.KnownArgumentNamesRule;
              }
            }),
            Object.defineProperty(exports, "KnownDirectivesRule", {
              enumerable: !0,
              get: function() {
                return _validation.KnownDirectivesRule;
              }
            }),
            Object.defineProperty(exports, "KnownFragmentNamesRule", {
              enumerable: !0,
              get: function() {
                return _validation.KnownFragmentNamesRule;
              }
            }),
            Object.defineProperty(exports, "KnownTypeNamesRule", {
              enumerable: !0,
              get: function() {
                return _validation.KnownTypeNamesRule;
              }
            }),
            Object.defineProperty(exports, "LoneAnonymousOperationRule", {
              enumerable: !0,
              get: function() {
                return _validation.LoneAnonymousOperationRule;
              }
            }),
            Object.defineProperty(exports, "NoFragmentCyclesRule", {
              enumerable: !0,
              get: function() {
                return _validation.NoFragmentCyclesRule;
              }
            }),
            Object.defineProperty(exports, "NoUndefinedVariablesRule", {
              enumerable: !0,
              get: function() {
                return _validation.NoUndefinedVariablesRule;
              }
            }),
            Object.defineProperty(exports, "NoUnusedFragmentsRule", {
              enumerable: !0,
              get: function() {
                return _validation.NoUnusedFragmentsRule;
              }
            }),
            Object.defineProperty(exports, "NoUnusedVariablesRule", {
              enumerable: !0,
              get: function() {
                return _validation.NoUnusedVariablesRule;
              }
            }),
            Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
              enumerable: !0,
              get: function() {
                return _validation.OverlappingFieldsCanBeMergedRule;
              }
            }),
            Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
              enumerable: !0,
              get: function() {
                return _validation.PossibleFragmentSpreadsRule;
              }
            }),
            Object.defineProperty(exports, "ProvidedNonNullArgumentsRule", {
              enumerable: !0,
              get: function() {
                return _validation.ProvidedNonNullArgumentsRule;
              }
            }),
            Object.defineProperty(exports, "ScalarLeafsRule", {
              enumerable: !0,
              get: function() {
                return _validation.ScalarLeafsRule;
              }
            }),
            Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
              enumerable: !0,
              get: function() {
                return _validation.SingleFieldSubscriptionsRule;
              }
            }),
            Object.defineProperty(exports, "UniqueArgumentNamesRule", {
              enumerable: !0,
              get: function() {
                return _validation.UniqueArgumentNamesRule;
              }
            }),
            Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
              enumerable: !0,
              get: function() {
                return _validation.UniqueDirectivesPerLocationRule;
              }
            }),
            Object.defineProperty(exports, "UniqueFragmentNamesRule", {
              enumerable: !0,
              get: function() {
                return _validation.UniqueFragmentNamesRule;
              }
            }),
            Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
              enumerable: !0,
              get: function() {
                return _validation.UniqueInputFieldNamesRule;
              }
            }),
            Object.defineProperty(exports, "UniqueOperationNamesRule", {
              enumerable: !0,
              get: function() {
                return _validation.UniqueOperationNamesRule;
              }
            }),
            Object.defineProperty(exports, "UniqueVariableNamesRule", {
              enumerable: !0,
              get: function() {
                return _validation.UniqueVariableNamesRule;
              }
            }),
            Object.defineProperty(exports, "VariablesAreInputTypesRule", {
              enumerable: !0,
              get: function() {
                return _validation.VariablesAreInputTypesRule;
              }
            }),
            Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
              enumerable: !0,
              get: function() {
                return _validation.VariablesInAllowedPositionRule;
              }
            });
          var _error = require("./error");
          Object.defineProperty(exports, "GraphQLError", {
            enumerable: !0,
            get: function() {
              return _error.GraphQLError;
            }
          }),
            Object.defineProperty(exports, "formatError", {
              enumerable: !0,
              get: function() {
                return _error.formatError;
              }
            });
          var _utilities = require("./utilities");
          Object.defineProperty(exports, "introspectionQuery", {
            enumerable: !0,
            get: function() {
              return _utilities.introspectionQuery;
            }
          }),
            Object.defineProperty(exports, "getOperationAST", {
              enumerable: !0,
              get: function() {
                return _utilities.getOperationAST;
              }
            }),
            Object.defineProperty(exports, "buildClientSchema", {
              enumerable: !0,
              get: function() {
                return _utilities.buildClientSchema;
              }
            }),
            Object.defineProperty(exports, "buildASTSchema", {
              enumerable: !0,
              get: function() {
                return _utilities.buildASTSchema;
              }
            }),
            Object.defineProperty(exports, "buildSchema", {
              enumerable: !0,
              get: function() {
                return _utilities.buildSchema;
              }
            }),
            Object.defineProperty(exports, "extendSchema", {
              enumerable: !0,
              get: function() {
                return _utilities.extendSchema;
              }
            }),
            Object.defineProperty(exports, "printSchema", {
              enumerable: !0,
              get: function() {
                return _utilities.printSchema;
              }
            }),
            Object.defineProperty(exports, "printIntrospectionSchema", {
              enumerable: !0,
              get: function() {
                return _utilities.printIntrospectionSchema;
              }
            }),
            Object.defineProperty(exports, "printType", {
              enumerable: !0,
              get: function() {
                return _utilities.printType;
              }
            }),
            Object.defineProperty(exports, "typeFromAST", {
              enumerable: !0,
              get: function() {
                return _utilities.typeFromAST;
              }
            }),
            Object.defineProperty(exports, "valueFromAST", {
              enumerable: !0,
              get: function() {
                return _utilities.valueFromAST;
              }
            }),
            Object.defineProperty(exports, "astFromValue", {
              enumerable: !0,
              get: function() {
                return _utilities.astFromValue;
              }
            }),
            Object.defineProperty(exports, "TypeInfo", {
              enumerable: !0,
              get: function() {
                return _utilities.TypeInfo;
              }
            }),
            Object.defineProperty(exports, "isValidJSValue", {
              enumerable: !0,
              get: function() {
                return _utilities.isValidJSValue;
              }
            }),
            Object.defineProperty(exports, "isValidLiteralValue", {
              enumerable: !0,
              get: function() {
                return _utilities.isValidLiteralValue;
              }
            }),
            Object.defineProperty(exports, "concatAST", {
              enumerable: !0,
              get: function() {
                return _utilities.concatAST;
              }
            }),
            Object.defineProperty(exports, "separateOperations", {
              enumerable: !0,
              get: function() {
                return _utilities.separateOperations;
              }
            }),
            Object.defineProperty(exports, "isEqualType", {
              enumerable: !0,
              get: function() {
                return _utilities.isEqualType;
              }
            }),
            Object.defineProperty(exports, "isTypeSubTypeOf", {
              enumerable: !0,
              get: function() {
                return _utilities.isTypeSubTypeOf;
              }
            }),
            Object.defineProperty(exports, "doTypesOverlap", {
              enumerable: !0,
              get: function() {
                return _utilities.doTypesOverlap;
              }
            }),
            Object.defineProperty(exports, "assertValidName", {
              enumerable: !0,
              get: function() {
                return _utilities.assertValidName;
              }
            }),
            Object.defineProperty(exports, "findBreakingChanges", {
              enumerable: !0,
              get: function() {
                return _utilities.findBreakingChanges;
              }
            }),
            Object.defineProperty(exports, "BreakingChangeType", {
              enumerable: !0,
              get: function() {
                return _utilities.BreakingChangeType;
              }
            }),
            Object.defineProperty(exports, "DangerousChangeType", {
              enumerable: !0,
              get: function() {
                return _utilities.DangerousChangeType;
              }
            }),
            Object.defineProperty(exports, "findDeprecatedUsages", {
              enumerable: !0,
              get: function() {
                return _utilities.findDeprecatedUsages;
              }
            });
        },
        {
          "./error": 94,
          "./execution": 98,
          "./graphql": 100,
          "./language": 110,
          "./subscription": 118,
          "./type": 123,
          "./utilities": 137,
          "./validation": 146
        }
      ],
      102: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(list, predicate) {
              for (var i = 0; i < list.length; i++)
                if (predicate(list[i])) return list[i];
            });
        },
        {}
      ],
      103: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(condition, message) {
              if (!condition) throw new Error(message);
            });
        },
        {}
      ],
      104: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(value) {
              return void 0 === value || value != value;
            });
        },
        {}
      ],
      105: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(value) {
              return null == value || value != value;
            });
        },
        {}
      ],
      106: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(list, keyFn) {
              return list.reduce(function(map, item) {
                return (map[keyFn(item)] = item), map;
              }, Object.create(null));
            });
        },
        {}
      ],
      107: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(list, keyFn, valFn) {
              return list.reduce(function(map, item) {
                return (map[keyFn(item)] = valFn(item)), map;
              }, Object.create(null));
            });
        },
        {}
      ],
      108: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(items) {
              var selected = items.slice(0, MAX_LENGTH);
              return selected
                .map(function(item) {
                  return '"' + item + '"';
                })
                .reduce(function(list, quoted, index) {
                  return (
                    list +
                    (2 < selected.length ? ", " : " ") +
                    (index === selected.length - 1 ? "or " : "") +
                    quoted
                  );
                });
            });
          var MAX_LENGTH = 5;
        },
        {}
      ],
      109: [
        function(require, module, exports) {
          "use strict";
          function lexicalDistance(a, b) {
            var i = void 0,
              j = void 0,
              d = [],
              aLength = a.length,
              bLength = b.length;
            for (i = 0; i <= aLength; i++) d[i] = [i];
            for (j = 1; j <= bLength; j++) d[0][j] = j;
            for (i = 1; i <= aLength; i++)
              for (j = 1; j <= bLength; j++) {
                var cost = a[i - 1] === b[j - 1] ? 0 : 1;
                (d[i][j] = Math.min(
                  d[i - 1][j] + 1,
                  d[i][j - 1] + 1,
                  d[i - 1][j - 1] + cost
                )),
                  1 < i &&
                    1 < j &&
                    a[i - 1] === b[j - 2] &&
                    a[i - 2] === b[j - 1] &&
                    (d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost));
              }
            return d[aLength][bLength];
          }
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(input, options) {
              for (
                var optionsByDistance = Object.create(null),
                  oLength = options.length,
                  inputThreshold = input.length / 2,
                  i = 0;
                i < oLength;
                i++
              ) {
                var distance = lexicalDistance(input, options[i]),
                  threshold = Math.max(
                    inputThreshold,
                    options[i].length / 2,
                    1
                  );
                distance <= threshold &&
                  (optionsByDistance[options[i]] = distance);
              }
              return Object.keys(optionsByDistance).sort(function(a, b) {
                return optionsByDistance[a] - optionsByDistance[b];
              });
            });
        },
        {}
      ],
      110: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.BREAK = exports.getVisitFn = exports.visitWithTypeInfo = exports.visitInParallel = exports.visit = exports.Source = exports.print = exports.parseType = exports.parseValue = exports.parse = exports.TokenKind = exports.createLexer = exports.Kind = exports.getLocation = void 0);
          var _location = require("./location");
          Object.defineProperty(exports, "getLocation", {
            enumerable: !0,
            get: function() {
              return _location.getLocation;
            }
          });
          var _lexer = require("./lexer");
          Object.defineProperty(exports, "createLexer", {
            enumerable: !0,
            get: function() {
              return _lexer.createLexer;
            }
          }),
            Object.defineProperty(exports, "TokenKind", {
              enumerable: !0,
              get: function() {
                return _lexer.TokenKind;
              }
            });
          var _parser = require("./parser");
          Object.defineProperty(exports, "parse", {
            enumerable: !0,
            get: function() {
              return _parser.parse;
            }
          }),
            Object.defineProperty(exports, "parseValue", {
              enumerable: !0,
              get: function() {
                return _parser.parseValue;
              }
            }),
            Object.defineProperty(exports, "parseType", {
              enumerable: !0,
              get: function() {
                return _parser.parseType;
              }
            });
          var _printer = require("./printer");
          Object.defineProperty(exports, "print", {
            enumerable: !0,
            get: function() {
              return _printer.print;
            }
          });
          var _source = require("./source");
          Object.defineProperty(exports, "Source", {
            enumerable: !0,
            get: function() {
              return _source.Source;
            }
          });
          var _visitor = require("./visitor");
          Object.defineProperty(exports, "visit", {
            enumerable: !0,
            get: function() {
              return _visitor.visit;
            }
          }),
            Object.defineProperty(exports, "visitInParallel", {
              enumerable: !0,
              get: function() {
                return _visitor.visitInParallel;
              }
            }),
            Object.defineProperty(exports, "visitWithTypeInfo", {
              enumerable: !0,
              get: function() {
                return _visitor.visitWithTypeInfo;
              }
            }),
            Object.defineProperty(exports, "getVisitFn", {
              enumerable: !0,
              get: function() {
                return _visitor.getVisitFn;
              }
            }),
            Object.defineProperty(exports, "BREAK", {
              enumerable: !0,
              get: function() {
                return _visitor.BREAK;
              }
            });
          var Kind = (function(obj) {
            {
              if (obj && obj.__esModule) return obj;
              var newObj = {};
              if (null != obj)
                for (var key in obj)
                  Object.prototype.hasOwnProperty.call(obj, key) &&
                    (newObj[key] = obj[key]);
              return (newObj.default = obj), newObj;
            }
          })(require("./kinds"));
          exports.Kind = Kind;
        },
        {
          "./kinds": 111,
          "./lexer": 112,
          "./location": 113,
          "./parser": 114,
          "./printer": 115,
          "./source": 116,
          "./visitor": 117
        }
      ],
      111: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          (exports.NAME = "Name"),
            (exports.DOCUMENT = "Document"),
            (exports.OPERATION_DEFINITION = "OperationDefinition"),
            (exports.VARIABLE_DEFINITION = "VariableDefinition"),
            (exports.VARIABLE = "Variable"),
            (exports.SELECTION_SET = "SelectionSet"),
            (exports.FIELD = "Field"),
            (exports.ARGUMENT = "Argument"),
            (exports.FRAGMENT_SPREAD = "FragmentSpread"),
            (exports.INLINE_FRAGMENT = "InlineFragment"),
            (exports.FRAGMENT_DEFINITION = "FragmentDefinition"),
            (exports.INT = "IntValue"),
            (exports.FLOAT = "FloatValue"),
            (exports.STRING = "StringValue"),
            (exports.BOOLEAN = "BooleanValue"),
            (exports.NULL = "NullValue"),
            (exports.ENUM = "EnumValue"),
            (exports.LIST = "ListValue"),
            (exports.OBJECT = "ObjectValue"),
            (exports.OBJECT_FIELD = "ObjectField"),
            (exports.DIRECTIVE = "Directive"),
            (exports.NAMED_TYPE = "NamedType"),
            (exports.LIST_TYPE = "ListType"),
            (exports.NON_NULL_TYPE = "NonNullType"),
            (exports.SCHEMA_DEFINITION = "SchemaDefinition"),
            (exports.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition"),
            (exports.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition"),
            (exports.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition"),
            (exports.FIELD_DEFINITION = "FieldDefinition"),
            (exports.INPUT_VALUE_DEFINITION = "InputValueDefinition"),
            (exports.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition"),
            (exports.UNION_TYPE_DEFINITION = "UnionTypeDefinition"),
            (exports.ENUM_TYPE_DEFINITION = "EnumTypeDefinition"),
            (exports.ENUM_VALUE_DEFINITION = "EnumValueDefinition"),
            (exports.INPUT_OBJECT_TYPE_DEFINITION =
              "InputObjectTypeDefinition"),
            (exports.TYPE_EXTENSION_DEFINITION = "TypeExtensionDefinition"),
            (exports.DIRECTIVE_DEFINITION = "DirectiveDefinition");
        },
        {}
      ],
      112: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.TokenKind = void 0),
            (exports.createLexer = function(source, options) {
              var startOfFileToken = new Tok(SOF, 0, 0, 0, 0, null);
              return {
                source: source,
                options: options,
                lastToken: startOfFileToken,
                token: startOfFileToken,
                line: 1,
                lineStart: 0,
                advance: advanceLexer
              };
            }),
            (exports.getTokenDesc = function(token) {
              var value = token.value;
              return value ? token.kind + ' "' + value + '"' : token.kind;
            });
          var _error = require("../error");
          function advanceLexer() {
            var token = (this.lastToken = this.token);
            if (token.kind !== EOF) {
              for (
                ;
                (token = token.next = readToken(this, token)).kind === COMMENT;

              );
              this.token = token;
            }
            return token;
          }
          var SOF = "<SOF>",
            EOF = "<EOF>",
            BANG = "!",
            DOLLAR = "$",
            PAREN_L = "(",
            PAREN_R = ")",
            SPREAD = "...",
            COLON = ":",
            EQUALS = "=",
            AT = "@",
            BRACKET_L = "[",
            BRACKET_R = "]",
            BRACE_L = "{",
            PIPE = "|",
            BRACE_R = "}",
            NAME = "Name",
            INT = "Int",
            FLOAT = "Float",
            STRING = "String",
            COMMENT = "Comment";
          exports.TokenKind = {
            SOF: SOF,
            EOF: EOF,
            BANG: BANG,
            DOLLAR: DOLLAR,
            PAREN_L: PAREN_L,
            PAREN_R: PAREN_R,
            SPREAD: SPREAD,
            COLON: COLON,
            EQUALS: EQUALS,
            AT: AT,
            BRACKET_L: BRACKET_L,
            BRACKET_R: BRACKET_R,
            BRACE_L: BRACE_L,
            PIPE: PIPE,
            BRACE_R: BRACE_R,
            NAME: NAME,
            INT: INT,
            FLOAT: FLOAT,
            STRING: STRING,
            COMMENT: COMMENT
          };
          var charCodeAt = String.prototype.charCodeAt,
            slice = String.prototype.slice;
          function Tok(kind, start, end, line, column, prev, value) {
            (this.kind = kind),
              (this.start = start),
              (this.end = end),
              (this.line = line),
              (this.column = column),
              (this.value = value),
              (this.prev = prev),
              (this.next = null);
          }
          function printCharCode(code) {
            return isNaN(code)
              ? EOF
              : code < 127
                ? JSON.stringify(String.fromCharCode(code))
                : '"\\u' +
                  ("00" + code.toString(16).toUpperCase()).slice(-4) +
                  '"';
          }
          function readToken(lexer, prev) {
            var source = lexer.source,
              body = source.body,
              bodyLength = body.length,
              position = (function(body, startPosition, lexer) {
                var bodyLength = body.length,
                  position = startPosition;
                for (; position < bodyLength; ) {
                  var code = charCodeAt.call(body, position);
                  if (
                    9 === code ||
                    32 === code ||
                    44 === code ||
                    65279 === code
                  )
                    ++position;
                  else if (10 === code)
                    ++position, ++lexer.line, (lexer.lineStart = position);
                  else {
                    if (13 !== code) break;
                    10 === charCodeAt.call(body, position + 1)
                      ? (position += 2)
                      : ++position,
                      ++lexer.line,
                      (lexer.lineStart = position);
                  }
                }
                return position;
              })(body, prev.end, lexer),
              line = lexer.line,
              col = 1 + position - lexer.lineStart;
            if (bodyLength <= position)
              return new Tok(EOF, bodyLength, bodyLength, line, col, prev);
            var code = charCodeAt.call(body, position);
            if (code < 32 && 9 !== code && 10 !== code && 13 !== code)
              throw (0, _error.syntaxError)(
                source,
                position,
                "Cannot contain the invalid character " +
                  printCharCode(code) +
                  "."
              );
            switch (code) {
              case 33:
                return new Tok(BANG, position, position + 1, line, col, prev);
              case 35:
                return (function(source, start, line, col, prev) {
                  var body = source.body,
                    code = void 0,
                    position = start;
                  for (
                    ;
                    (code = charCodeAt.call(body, ++position)),
                      null !== code && (31 < code || 9 === code);

                  );
                  return new Tok(
                    COMMENT,
                    start,
                    position,
                    line,
                    col,
                    prev,
                    slice.call(body, start + 1, position)
                  );
                })(source, position, line, col, prev);
              case 36:
                return new Tok(DOLLAR, position, position + 1, line, col, prev);
              case 40:
                return new Tok(
                  PAREN_L,
                  position,
                  position + 1,
                  line,
                  col,
                  prev
                );
              case 41:
                return new Tok(
                  PAREN_R,
                  position,
                  position + 1,
                  line,
                  col,
                  prev
                );
              case 46:
                if (
                  46 === charCodeAt.call(body, position + 1) &&
                  46 === charCodeAt.call(body, position + 2)
                )
                  return new Tok(
                    SPREAD,
                    position,
                    position + 3,
                    line,
                    col,
                    prev
                  );
                break;
              case 58:
                return new Tok(COLON, position, position + 1, line, col, prev);
              case 61:
                return new Tok(EQUALS, position, position + 1, line, col, prev);
              case 64:
                return new Tok(AT, position, position + 1, line, col, prev);
              case 91:
                return new Tok(
                  BRACKET_L,
                  position,
                  position + 1,
                  line,
                  col,
                  prev
                );
              case 93:
                return new Tok(
                  BRACKET_R,
                  position,
                  position + 1,
                  line,
                  col,
                  prev
                );
              case 123:
                return new Tok(
                  BRACE_L,
                  position,
                  position + 1,
                  line,
                  col,
                  prev
                );
              case 124:
                return new Tok(PIPE, position, position + 1, line, col, prev);
              case 125:
                return new Tok(
                  BRACE_R,
                  position,
                  position + 1,
                  line,
                  col,
                  prev
                );
              case 65:
              case 66:
              case 67:
              case 68:
              case 69:
              case 70:
              case 71:
              case 72:
              case 73:
              case 74:
              case 75:
              case 76:
              case 77:
              case 78:
              case 79:
              case 80:
              case 81:
              case 82:
              case 83:
              case 84:
              case 85:
              case 86:
              case 87:
              case 88:
              case 89:
              case 90:
              case 95:
              case 97:
              case 98:
              case 99:
              case 100:
              case 101:
              case 102:
              case 103:
              case 104:
              case 105:
              case 106:
              case 107:
              case 108:
              case 109:
              case 110:
              case 111:
              case 112:
              case 113:
              case 114:
              case 115:
              case 116:
              case 117:
              case 118:
              case 119:
              case 120:
              case 121:
              case 122:
                return (function(source, position, line, col, prev) {
                  var body = source.body,
                    bodyLength = body.length,
                    end = position + 1,
                    code = 0;
                  for (
                    ;
                    end !== bodyLength &&
                    null !== (code = charCodeAt.call(body, end)) &&
                    (95 === code ||
                      (48 <= code && code <= 57) ||
                      (65 <= code && code <= 90) ||
                      (97 <= code && code <= 122));

                  )
                    ++end;
                  return new Tok(
                    NAME,
                    position,
                    end,
                    line,
                    col,
                    prev,
                    slice.call(body, position, end)
                  );
                })(source, position, line, col, prev);
              case 45:
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return (function(source, start, firstCode, line, col, prev) {
                  var body = source.body,
                    code = firstCode,
                    position = start,
                    isFloat = !1;
                  45 === code && (code = charCodeAt.call(body, ++position));
                  if (48 === code) {
                    if (
                      48 <= (code = charCodeAt.call(body, ++position)) &&
                      code <= 57
                    )
                      throw (0, _error.syntaxError)(
                        source,
                        position,
                        "Invalid number, unexpected digit after 0: " +
                          printCharCode(code) +
                          "."
                      );
                  } else
                    (position = readDigits(source, position, code)),
                      (code = charCodeAt.call(body, position));
                  46 === code &&
                    ((isFloat = !0),
                    (code = charCodeAt.call(body, ++position)),
                    (position = readDigits(source, position, code)),
                    (code = charCodeAt.call(body, position)));
                  (69 !== code && 101 !== code) ||
                    ((isFloat = !0),
                    (43 !== (code = charCodeAt.call(body, ++position)) &&
                      45 !== code) ||
                      (code = charCodeAt.call(body, ++position)),
                    (position = readDigits(source, position, code)));
                  return new Tok(
                    isFloat ? FLOAT : INT,
                    start,
                    position,
                    line,
                    col,
                    prev,
                    slice.call(body, start, position)
                  );
                })(source, position, code, line, col, prev);
              case 34:
                return (function(source, start, line, col, prev) {
                  var body = source.body,
                    position = start + 1,
                    chunkStart = position,
                    code = 0,
                    value = "";
                  for (
                    ;
                    position < body.length &&
                    null !== (code = charCodeAt.call(body, position)) &&
                    10 !== code &&
                    13 !== code &&
                    34 !== code;

                  ) {
                    if (code < 32 && 9 !== code)
                      throw (0, _error.syntaxError)(
                        source,
                        position,
                        "Invalid character within String: " +
                          printCharCode(code) +
                          "."
                      );
                    if ((++position, 92 === code)) {
                      switch (((value += slice.call(
                        body,
                        chunkStart,
                        position - 1
                      )),
                      (code = charCodeAt.call(body, position)))) {
                        case 34:
                          value += '"';
                          break;
                        case 47:
                          value += "/";
                          break;
                        case 92:
                          value += "\\";
                          break;
                        case 98:
                          value += "\b";
                          break;
                        case 102:
                          value += "\f";
                          break;
                        case 110:
                          value += "\n";
                          break;
                        case 114:
                          value += "\r";
                          break;
                        case 116:
                          value += "\t";
                          break;
                        case 117:
                          var charCode = ((a = charCodeAt.call(
                            body,
                            position + 1
                          )),
                          (b = charCodeAt.call(body, position + 2)),
                          (c = charCodeAt.call(body, position + 3)),
                          (d = charCodeAt.call(body, position + 4)),
                          (char2hex(a) << 12) |
                            (char2hex(b) << 8) |
                            (char2hex(c) << 4) |
                            char2hex(d));
                          if (charCode < 0)
                            throw (0, _error.syntaxError)(
                              source,
                              position,
                              "Invalid character escape sequence: \\u" +
                                body.slice(position + 1, position + 5) +
                                "."
                            );
                          (value += String.fromCharCode(charCode)),
                            (position += 4);
                          break;
                        default:
                          throw (0, _error.syntaxError)(
                            source,
                            position,
                            "Invalid character escape sequence: \\" +
                              String.fromCharCode(code) +
                              "."
                          );
                      }
                      chunkStart = ++position;
                    }
                  }
                  var a, b, c, d;
                  if (34 !== code)
                    throw (0, _error.syntaxError)(
                      source,
                      position,
                      "Unterminated string."
                    );
                  return (
                    (value += slice.call(body, chunkStart, position)),
                    new Tok(STRING, start, position + 1, line, col, prev, value)
                  );
                })(source, position, line, col, prev);
            }
            throw (0, _error.syntaxError)(
              source,
              position,
              (function(code) {
                if (39 === code)
                  return "Unexpected single quote character ('), did you mean to use a double quote (\")?";
                return (
                  "Cannot parse the unexpected character " +
                  printCharCode(code) +
                  "."
                );
              })(code)
            );
          }
          function readDigits(source, start, firstCode) {
            var body = source.body,
              position = start,
              code = firstCode;
            if (48 <= code && code <= 57) {
              for (
                ;
                48 <= (code = charCodeAt.call(body, ++position)) && code <= 57;

              );
              return position;
            }
            throw (0, _error.syntaxError)(
              source,
              position,
              "Invalid number, expected digit but got: " +
                printCharCode(code) +
                "."
            );
          }
          function char2hex(a) {
            return 48 <= a && a <= 57
              ? a - 48
              : 65 <= a && a <= 70 ? a - 55 : 97 <= a && a <= 102 ? a - 87 : -1;
          }
          Tok.prototype.toJSON = Tok.prototype.inspect = function() {
            return {
              kind: this.kind,
              value: this.value,
              line: this.line,
              column: this.column
            };
          };
        },
        { "../error": 94 }
      ],
      113: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.getLocation = function(source, position) {
              var lineRegexp = /\r\n|[\n\r]/g,
                line = 1,
                column = position + 1,
                match = void 0;
              for (
                ;
                (match = lineRegexp.exec(source.body)) &&
                match.index < position;

              )
                (line += 1),
                  (column = position + 1 - (match.index + match[0].length));
              return { line: line, column: column };
            });
        },
        {}
      ],
      114: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.parse = function(source, options) {
              var sourceObj =
                "string" == typeof source ? new _source.Source(source) : source;
              if (!(sourceObj instanceof _source.Source))
                throw new TypeError(
                  "Must provide Source. Received: " + String(sourceObj)
                );
              return (function(lexer) {
                var start = lexer.token;
                expect(lexer, _lexer.TokenKind.SOF);
                var definitions = [];
                for (
                  ;
                  definitions.push(parseDefinition(lexer)),
                    !skip(lexer, _lexer.TokenKind.EOF);

                );
                return {
                  kind: _kinds.DOCUMENT,
                  definitions: definitions,
                  loc: loc(lexer, start)
                };
              })((0, _lexer.createLexer)(sourceObj, options || {}));
            }),
            (exports.parseValue = function(source, options) {
              var sourceObj =
                  "string" == typeof source
                    ? new _source.Source(source)
                    : source,
                lexer = (0, _lexer.createLexer)(sourceObj, options || {});
              expect(lexer, _lexer.TokenKind.SOF);
              var value = parseValueLiteral(lexer, !1);
              return expect(lexer, _lexer.TokenKind.EOF), value;
            }),
            (exports.parseType = function(source, options) {
              var sourceObj =
                  "string" == typeof source
                    ? new _source.Source(source)
                    : source,
                lexer = (0, _lexer.createLexer)(sourceObj, options || {});
              expect(lexer, _lexer.TokenKind.SOF);
              var type = parseTypeReference(lexer);
              return expect(lexer, _lexer.TokenKind.EOF), type;
            }),
            (exports.parseConstValue = parseConstValue),
            (exports.parseTypeReference = parseTypeReference),
            (exports.parseNamedType = parseNamedType);
          var _source = require("./source"),
            _error = require("../error"),
            _lexer = require("./lexer"),
            _kinds = require("./kinds");
          function parseName(lexer) {
            var token = expect(lexer, _lexer.TokenKind.NAME);
            return {
              kind: _kinds.NAME,
              value: token.value,
              loc: loc(lexer, token)
            };
          }
          function parseDefinition(lexer) {
            if (peek(lexer, _lexer.TokenKind.BRACE_L))
              return parseOperationDefinition(lexer);
            if (peek(lexer, _lexer.TokenKind.NAME))
              switch (lexer.token.value) {
                case "query":
                case "mutation":
                case "subscription":
                  return parseOperationDefinition(lexer);
                case "fragment":
                  return (function(lexer) {
                    var start = lexer.token;
                    return (
                      expectKeyword(lexer, "fragment"),
                      {
                        kind: _kinds.FRAGMENT_DEFINITION,
                        name: parseFragmentName(lexer),
                        typeCondition: (expectKeyword(lexer, "on"),
                        parseNamedType(lexer)),
                        directives: parseDirectives(lexer),
                        selectionSet: parseSelectionSet(lexer),
                        loc: loc(lexer, start)
                      }
                    );
                  })(lexer);
                case "schema":
                case "scalar":
                case "type":
                case "interface":
                case "union":
                case "enum":
                case "input":
                case "extend":
                case "directive":
                  return (function(lexer) {
                    if (peek(lexer, _lexer.TokenKind.NAME))
                      switch (lexer.token.value) {
                        case "schema":
                          return (function(lexer) {
                            var start = lexer.token;
                            expectKeyword(lexer, "schema");
                            var directives = parseDirectives(lexer),
                              operationTypes = many(
                                lexer,
                                _lexer.TokenKind.BRACE_L,
                                parseOperationTypeDefinition,
                                _lexer.TokenKind.BRACE_R
                              );
                            return {
                              kind: _kinds.SCHEMA_DEFINITION,
                              directives: directives,
                              operationTypes: operationTypes,
                              loc: loc(lexer, start)
                            };
                          })(lexer);
                        case "scalar":
                          return (function(lexer) {
                            var start = lexer.token;
                            expectKeyword(lexer, "scalar");
                            var name = parseName(lexer),
                              directives = parseDirectives(lexer);
                            return {
                              kind: _kinds.SCALAR_TYPE_DEFINITION,
                              name: name,
                              directives: directives,
                              loc: loc(lexer, start)
                            };
                          })(lexer);
                        case "type":
                          return parseObjectTypeDefinition(lexer);
                        case "interface":
                          return (function(lexer) {
                            var start = lexer.token;
                            expectKeyword(lexer, "interface");
                            var name = parseName(lexer),
                              directives = parseDirectives(lexer),
                              fields = any(
                                lexer,
                                _lexer.TokenKind.BRACE_L,
                                parseFieldDefinition,
                                _lexer.TokenKind.BRACE_R
                              );
                            return {
                              kind: _kinds.INTERFACE_TYPE_DEFINITION,
                              name: name,
                              directives: directives,
                              fields: fields,
                              loc: loc(lexer, start)
                            };
                          })(lexer);
                        case "union":
                          return (function(lexer) {
                            var start = lexer.token;
                            expectKeyword(lexer, "union");
                            var name = parseName(lexer),
                              directives = parseDirectives(lexer);
                            expect(lexer, _lexer.TokenKind.EQUALS);
                            var types = (function(lexer) {
                              skip(lexer, _lexer.TokenKind.PIPE);
                              var members = [];
                              for (
                                ;
                                members.push(parseNamedType(lexer)),
                                  skip(lexer, _lexer.TokenKind.PIPE);

                              );
                              return members;
                            })(lexer);
                            return {
                              kind: _kinds.UNION_TYPE_DEFINITION,
                              name: name,
                              directives: directives,
                              types: types,
                              loc: loc(lexer, start)
                            };
                          })(lexer);
                        case "enum":
                          return (function(lexer) {
                            var start = lexer.token;
                            expectKeyword(lexer, "enum");
                            var name = parseName(lexer),
                              directives = parseDirectives(lexer),
                              values = many(
                                lexer,
                                _lexer.TokenKind.BRACE_L,
                                parseEnumValueDefinition,
                                _lexer.TokenKind.BRACE_R
                              );
                            return {
                              kind: _kinds.ENUM_TYPE_DEFINITION,
                              name: name,
                              directives: directives,
                              values: values,
                              loc: loc(lexer, start)
                            };
                          })(lexer);
                        case "input":
                          return (function(lexer) {
                            var start = lexer.token;
                            expectKeyword(lexer, "input");
                            var name = parseName(lexer),
                              directives = parseDirectives(lexer),
                              fields = any(
                                lexer,
                                _lexer.TokenKind.BRACE_L,
                                parseInputValueDef,
                                _lexer.TokenKind.BRACE_R
                              );
                            return {
                              kind: _kinds.INPUT_OBJECT_TYPE_DEFINITION,
                              name: name,
                              directives: directives,
                              fields: fields,
                              loc: loc(lexer, start)
                            };
                          })(lexer);
                        case "extend":
                          return (function(lexer) {
                            var start = lexer.token;
                            expectKeyword(lexer, "extend");
                            var definition = parseObjectTypeDefinition(lexer);
                            return {
                              kind: _kinds.TYPE_EXTENSION_DEFINITION,
                              definition: definition,
                              loc: loc(lexer, start)
                            };
                          })(lexer);
                        case "directive":
                          return (function(lexer) {
                            var start = lexer.token;
                            expectKeyword(lexer, "directive"),
                              expect(lexer, _lexer.TokenKind.AT);
                            var name = parseName(lexer),
                              args = parseArgumentDefs(lexer);
                            expectKeyword(lexer, "on");
                            var locations = (function(lexer) {
                              skip(lexer, _lexer.TokenKind.PIPE);
                              var locations = [];
                              for (
                                ;
                                locations.push(parseName(lexer)),
                                  skip(lexer, _lexer.TokenKind.PIPE);

                              );
                              return locations;
                            })(lexer);
                            return {
                              kind: _kinds.DIRECTIVE_DEFINITION,
                              name: name,
                              arguments: args,
                              locations: locations,
                              loc: loc(lexer, start)
                            };
                          })(lexer);
                      }
                    throw unexpected(lexer);
                  })(lexer);
              }
            throw unexpected(lexer);
          }
          function parseOperationDefinition(lexer) {
            var start = lexer.token;
            if (peek(lexer, _lexer.TokenKind.BRACE_L))
              return {
                kind: _kinds.OPERATION_DEFINITION,
                operation: "query",
                name: null,
                variableDefinitions: null,
                directives: [],
                selectionSet: parseSelectionSet(lexer),
                loc: loc(lexer, start)
              };
            var operation = parseOperationType(lexer),
              name = void 0;
            return (
              peek(lexer, _lexer.TokenKind.NAME) && (name = parseName(lexer)),
              {
                kind: _kinds.OPERATION_DEFINITION,
                operation: operation,
                name: name,
                variableDefinitions: (function(lexer) {
                  return peek(lexer, _lexer.TokenKind.PAREN_L)
                    ? many(
                        lexer,
                        _lexer.TokenKind.PAREN_L,
                        parseVariableDefinition,
                        _lexer.TokenKind.PAREN_R
                      )
                    : [];
                })(lexer),
                directives: parseDirectives(lexer),
                selectionSet: parseSelectionSet(lexer),
                loc: loc(lexer, start)
              }
            );
          }
          function parseOperationType(lexer) {
            var operationToken = expect(lexer, _lexer.TokenKind.NAME);
            switch (operationToken.value) {
              case "query":
                return "query";
              case "mutation":
                return "mutation";
              case "subscription":
                return "subscription";
            }
            throw unexpected(lexer, operationToken);
          }
          function parseVariableDefinition(lexer) {
            var start = lexer.token;
            return {
              kind: _kinds.VARIABLE_DEFINITION,
              variable: parseVariable(lexer),
              type: (expect(lexer, _lexer.TokenKind.COLON),
              parseTypeReference(lexer)),
              defaultValue: skip(lexer, _lexer.TokenKind.EQUALS)
                ? parseValueLiteral(lexer, !0)
                : null,
              loc: loc(lexer, start)
            };
          }
          function parseVariable(lexer) {
            var start = lexer.token;
            return (
              expect(lexer, _lexer.TokenKind.DOLLAR),
              {
                kind: _kinds.VARIABLE,
                name: parseName(lexer),
                loc: loc(lexer, start)
              }
            );
          }
          function parseSelectionSet(lexer) {
            var start = lexer.token;
            return {
              kind: _kinds.SELECTION_SET,
              selections: many(
                lexer,
                _lexer.TokenKind.BRACE_L,
                parseSelection,
                _lexer.TokenKind.BRACE_R
              ),
              loc: loc(lexer, start)
            };
          }
          function parseSelection(lexer) {
            return peek(lexer, _lexer.TokenKind.SPREAD)
              ? (function(lexer) {
                  var start = lexer.token;
                  if (
                    (expect(lexer, _lexer.TokenKind.SPREAD),
                    peek(lexer, _lexer.TokenKind.NAME) &&
                      "on" !== lexer.token.value)
                  )
                    return {
                      kind: _kinds.FRAGMENT_SPREAD,
                      name: parseFragmentName(lexer),
                      directives: parseDirectives(lexer),
                      loc: loc(lexer, start)
                    };
                  var typeCondition = null;
                  "on" === lexer.token.value &&
                    (lexer.advance(), (typeCondition = parseNamedType(lexer)));
                  return {
                    kind: _kinds.INLINE_FRAGMENT,
                    typeCondition: typeCondition,
                    directives: parseDirectives(lexer),
                    selectionSet: parseSelectionSet(lexer),
                    loc: loc(lexer, start)
                  };
                })(lexer)
              : (function(lexer) {
                  var start = lexer.token,
                    nameOrAlias = parseName(lexer),
                    alias = void 0,
                    name = void 0;
                  skip(lexer, _lexer.TokenKind.COLON)
                    ? ((alias = nameOrAlias), (name = parseName(lexer)))
                    : ((alias = null), (name = nameOrAlias));
                  return {
                    kind: _kinds.FIELD,
                    alias: alias,
                    name: name,
                    arguments: parseArguments(lexer),
                    directives: parseDirectives(lexer),
                    selectionSet: peek(lexer, _lexer.TokenKind.BRACE_L)
                      ? parseSelectionSet(lexer)
                      : null,
                    loc: loc(lexer, start)
                  };
                })(lexer);
          }
          function parseArguments(lexer) {
            return peek(lexer, _lexer.TokenKind.PAREN_L)
              ? many(
                  lexer,
                  _lexer.TokenKind.PAREN_L,
                  parseArgument,
                  _lexer.TokenKind.PAREN_R
                )
              : [];
          }
          function parseArgument(lexer) {
            var start = lexer.token;
            return {
              kind: _kinds.ARGUMENT,
              name: parseName(lexer),
              value: (expect(lexer, _lexer.TokenKind.COLON),
              parseValueLiteral(lexer, !1)),
              loc: loc(lexer, start)
            };
          }
          function parseFragmentName(lexer) {
            if ("on" === lexer.token.value) throw unexpected(lexer);
            return parseName(lexer);
          }
          function parseValueLiteral(lexer, isConst) {
            var token = lexer.token;
            switch (token.kind) {
              case _lexer.TokenKind.BRACKET_L:
                return (function(lexer, isConst) {
                  var start = lexer.token,
                    item = isConst ? parseConstValue : parseValueValue;
                  return {
                    kind: _kinds.LIST,
                    values: any(
                      lexer,
                      _lexer.TokenKind.BRACKET_L,
                      item,
                      _lexer.TokenKind.BRACKET_R
                    ),
                    loc: loc(lexer, start)
                  };
                })(lexer, isConst);
              case _lexer.TokenKind.BRACE_L:
                return (function(lexer, isConst) {
                  var start = lexer.token;
                  expect(lexer, _lexer.TokenKind.BRACE_L);
                  var fields = [];
                  for (; !skip(lexer, _lexer.TokenKind.BRACE_R); )
                    fields.push(parseObjectField(lexer, isConst));
                  return {
                    kind: _kinds.OBJECT,
                    fields: fields,
                    loc: loc(lexer, start)
                  };
                })(lexer, isConst);
              case _lexer.TokenKind.INT:
                return (
                  lexer.advance(),
                  {
                    kind: _kinds.INT,
                    value: token.value,
                    loc: loc(lexer, token)
                  }
                );
              case _lexer.TokenKind.FLOAT:
                return (
                  lexer.advance(),
                  {
                    kind: _kinds.FLOAT,
                    value: token.value,
                    loc: loc(lexer, token)
                  }
                );
              case _lexer.TokenKind.STRING:
                return (
                  lexer.advance(),
                  {
                    kind: _kinds.STRING,
                    value: token.value,
                    loc: loc(lexer, token)
                  }
                );
              case _lexer.TokenKind.NAME:
                return "true" === token.value || "false" === token.value
                  ? (lexer.advance(),
                    {
                      kind: _kinds.BOOLEAN,
                      value: "true" === token.value,
                      loc: loc(lexer, token)
                    })
                  : "null" === token.value
                    ? (lexer.advance(),
                      { kind: _kinds.NULL, loc: loc(lexer, token) })
                    : (lexer.advance(),
                      {
                        kind: _kinds.ENUM,
                        value: token.value,
                        loc: loc(lexer, token)
                      });
              case _lexer.TokenKind.DOLLAR:
                if (!isConst) return parseVariable(lexer);
            }
            throw unexpected(lexer);
          }
          function parseConstValue(lexer) {
            return parseValueLiteral(lexer, !0);
          }
          function parseValueValue(lexer) {
            return parseValueLiteral(lexer, !1);
          }
          function parseObjectField(lexer, isConst) {
            var start = lexer.token;
            return {
              kind: _kinds.OBJECT_FIELD,
              name: parseName(lexer),
              value: (expect(lexer, _lexer.TokenKind.COLON),
              parseValueLiteral(lexer, isConst)),
              loc: loc(lexer, start)
            };
          }
          function parseDirectives(lexer) {
            for (var directives = []; peek(lexer, _lexer.TokenKind.AT); )
              directives.push(parseDirective(lexer));
            return directives;
          }
          function parseDirective(lexer) {
            var start = lexer.token;
            return (
              expect(lexer, _lexer.TokenKind.AT),
              {
                kind: _kinds.DIRECTIVE,
                name: parseName(lexer),
                arguments: parseArguments(lexer),
                loc: loc(lexer, start)
              }
            );
          }
          function parseTypeReference(lexer) {
            var start = lexer.token,
              type = void 0;
            return (
              skip(lexer, _lexer.TokenKind.BRACKET_L)
                ? ((type = parseTypeReference(lexer)),
                  expect(lexer, _lexer.TokenKind.BRACKET_R),
                  (type = {
                    kind: _kinds.LIST_TYPE,
                    type: type,
                    loc: loc(lexer, start)
                  }))
                : (type = parseNamedType(lexer)),
              skip(lexer, _lexer.TokenKind.BANG)
                ? {
                    kind: _kinds.NON_NULL_TYPE,
                    type: type,
                    loc: loc(lexer, start)
                  }
                : type
            );
          }
          function parseNamedType(lexer) {
            var start = lexer.token;
            return {
              kind: _kinds.NAMED_TYPE,
              name: parseName(lexer),
              loc: loc(lexer, start)
            };
          }
          function parseOperationTypeDefinition(lexer) {
            var start = lexer.token,
              operation = parseOperationType(lexer);
            expect(lexer, _lexer.TokenKind.COLON);
            var type = parseNamedType(lexer);
            return {
              kind: _kinds.OPERATION_TYPE_DEFINITION,
              operation: operation,
              type: type,
              loc: loc(lexer, start)
            };
          }
          function parseObjectTypeDefinition(lexer) {
            var start = lexer.token;
            expectKeyword(lexer, "type");
            var name = parseName(lexer),
              interfaces = (function(lexer) {
                var types = [];
                if ("implements" === lexer.token.value)
                  for (
                    lexer.advance();
                    types.push(parseNamedType(lexer)),
                      peek(lexer, _lexer.TokenKind.NAME);

                  );
                return types;
              })(lexer),
              directives = parseDirectives(lexer),
              fields = any(
                lexer,
                _lexer.TokenKind.BRACE_L,
                parseFieldDefinition,
                _lexer.TokenKind.BRACE_R
              );
            return {
              kind: _kinds.OBJECT_TYPE_DEFINITION,
              name: name,
              interfaces: interfaces,
              directives: directives,
              fields: fields,
              loc: loc(lexer, start)
            };
          }
          function parseFieldDefinition(lexer) {
            var start = lexer.token,
              name = parseName(lexer),
              args = parseArgumentDefs(lexer);
            expect(lexer, _lexer.TokenKind.COLON);
            var type = parseTypeReference(lexer),
              directives = parseDirectives(lexer);
            return {
              kind: _kinds.FIELD_DEFINITION,
              name: name,
              arguments: args,
              type: type,
              directives: directives,
              loc: loc(lexer, start)
            };
          }
          function parseArgumentDefs(lexer) {
            return peek(lexer, _lexer.TokenKind.PAREN_L)
              ? many(
                  lexer,
                  _lexer.TokenKind.PAREN_L,
                  parseInputValueDef,
                  _lexer.TokenKind.PAREN_R
                )
              : [];
          }
          function parseInputValueDef(lexer) {
            var start = lexer.token,
              name = parseName(lexer);
            expect(lexer, _lexer.TokenKind.COLON);
            var type = parseTypeReference(lexer),
              defaultValue = null;
            skip(lexer, _lexer.TokenKind.EQUALS) &&
              (defaultValue = parseConstValue(lexer));
            var directives = parseDirectives(lexer);
            return {
              kind: _kinds.INPUT_VALUE_DEFINITION,
              name: name,
              type: type,
              defaultValue: defaultValue,
              directives: directives,
              loc: loc(lexer, start)
            };
          }
          function parseEnumValueDefinition(lexer) {
            var start = lexer.token,
              name = parseName(lexer),
              directives = parseDirectives(lexer);
            return {
              kind: _kinds.ENUM_VALUE_DEFINITION,
              name: name,
              directives: directives,
              loc: loc(lexer, start)
            };
          }
          function loc(lexer, startToken) {
            if (!lexer.options.noLocation)
              return new Loc(startToken, lexer.lastToken, lexer.source);
          }
          function Loc(startToken, endToken, source) {
            (this.start = startToken.start),
              (this.end = endToken.end),
              (this.startToken = startToken),
              (this.endToken = endToken),
              (this.source = source);
          }
          function peek(lexer, kind) {
            return lexer.token.kind === kind;
          }
          function skip(lexer, kind) {
            var match = lexer.token.kind === kind;
            return match && lexer.advance(), match;
          }
          function expect(lexer, kind) {
            var token = lexer.token;
            if (token.kind === kind) return lexer.advance(), token;
            throw (0, _error.syntaxError)(
              lexer.source,
              token.start,
              "Expected " + kind + ", found " + (0, _lexer.getTokenDesc)(token)
            );
          }
          function expectKeyword(lexer, value) {
            var token = lexer.token;
            if (token.kind === _lexer.TokenKind.NAME && token.value === value)
              return lexer.advance(), token;
            throw (0, _error.syntaxError)(
              lexer.source,
              token.start,
              'Expected "' +
                value +
                '", found ' +
                (0, _lexer.getTokenDesc)(token)
            );
          }
          function unexpected(lexer, atToken) {
            var token = atToken || lexer.token;
            return (0, _error.syntaxError)(
              lexer.source,
              token.start,
              "Unexpected " + (0, _lexer.getTokenDesc)(token)
            );
          }
          function any(lexer, openKind, parseFn, closeKind) {
            expect(lexer, openKind);
            for (var nodes = []; !skip(lexer, closeKind); )
              nodes.push(parseFn(lexer));
            return nodes;
          }
          function many(lexer, openKind, parseFn, closeKind) {
            expect(lexer, openKind);
            for (var nodes = [parseFn(lexer)]; !skip(lexer, closeKind); )
              nodes.push(parseFn(lexer));
            return nodes;
          }
          Loc.prototype.toJSON = Loc.prototype.inspect = function() {
            return { start: this.start, end: this.end };
          };
        },
        { "../error": 94, "./kinds": 111, "./lexer": 112, "./source": 116 }
      ],
      115: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.print = function(ast) {
              return (0, _visitor.visit)(ast, { leave: printDocASTReducer });
            });
          var _visitor = require("./visitor");
          var printDocASTReducer = {
            Name: function(node) {
              return node.value;
            },
            Variable: function(node) {
              return "$" + node.name;
            },
            Document: function(node) {
              return join(node.definitions, "\n\n") + "\n";
            },
            OperationDefinition: function(node) {
              var op = node.operation,
                name = node.name,
                varDefs = wrap("(", join(node.variableDefinitions, ", "), ")"),
                directives = join(node.directives, " "),
                selectionSet = node.selectionSet;
              return name || directives || varDefs || "query" !== op
                ? join(
                    [op, join([name, varDefs]), directives, selectionSet],
                    " "
                  )
                : selectionSet;
            },
            VariableDefinition: function(_ref) {
              return (
                _ref.variable +
                ": " +
                _ref.type +
                wrap(" = ", _ref.defaultValue)
              );
            },
            SelectionSet: function(_ref2) {
              return block(_ref2.selections);
            },
            Field: function(_ref3) {
              var alias = _ref3.alias,
                name = _ref3.name,
                args = _ref3.arguments,
                directives = _ref3.directives,
                selectionSet = _ref3.selectionSet;
              return join(
                [
                  wrap("", alias, ": ") +
                    name +
                    wrap("(", join(args, ", "), ")"),
                  join(directives, " "),
                  selectionSet
                ],
                " "
              );
            },
            Argument: function(_ref4) {
              return _ref4.name + ": " + _ref4.value;
            },
            FragmentSpread: function(_ref5) {
              return (
                "..." + _ref5.name + wrap(" ", join(_ref5.directives, " "))
              );
            },
            InlineFragment: function(_ref6) {
              var typeCondition = _ref6.typeCondition,
                directives = _ref6.directives,
                selectionSet = _ref6.selectionSet;
              return join(
                [
                  "...",
                  wrap("on ", typeCondition),
                  join(directives, " "),
                  selectionSet
                ],
                " "
              );
            },
            FragmentDefinition: function(_ref7) {
              var name = _ref7.name,
                typeCondition = _ref7.typeCondition,
                directives = _ref7.directives,
                selectionSet = _ref7.selectionSet;
              return (
                "fragment " +
                name +
                " on " +
                typeCondition +
                " " +
                wrap("", join(directives, " "), " ") +
                selectionSet
              );
            },
            IntValue: function(_ref8) {
              return _ref8.value;
            },
            FloatValue: function(_ref9) {
              return _ref9.value;
            },
            StringValue: function(_ref10) {
              var value = _ref10.value;
              return JSON.stringify(value);
            },
            BooleanValue: function(_ref11) {
              var value = _ref11.value;
              return JSON.stringify(value);
            },
            NullValue: function() {
              return "null";
            },
            EnumValue: function(_ref12) {
              return _ref12.value;
            },
            ListValue: function(_ref13) {
              return "[" + join(_ref13.values, ", ") + "]";
            },
            ObjectValue: function(_ref14) {
              return "{" + join(_ref14.fields, ", ") + "}";
            },
            ObjectField: function(_ref15) {
              return _ref15.name + ": " + _ref15.value;
            },
            Directive: function(_ref16) {
              return (
                "@" + _ref16.name + wrap("(", join(_ref16.arguments, ", "), ")")
              );
            },
            NamedType: function(_ref17) {
              return _ref17.name;
            },
            ListType: function(_ref18) {
              return "[" + _ref18.type + "]";
            },
            NonNullType: function(_ref19) {
              return _ref19.type + "!";
            },
            SchemaDefinition: function(_ref20) {
              var directives = _ref20.directives,
                operationTypes = _ref20.operationTypes;
              return join(
                ["schema", join(directives, " "), block(operationTypes)],
                " "
              );
            },
            OperationTypeDefinition: function(_ref21) {
              return _ref21.operation + ": " + _ref21.type;
            },
            ScalarTypeDefinition: function(_ref22) {
              return join(
                ["scalar", _ref22.name, join(_ref22.directives, " ")],
                " "
              );
            },
            ObjectTypeDefinition: function(_ref23) {
              var name = _ref23.name,
                interfaces = _ref23.interfaces,
                directives = _ref23.directives,
                fields = _ref23.fields;
              return join(
                [
                  "type",
                  name,
                  wrap("implements ", join(interfaces, ", ")),
                  join(directives, " "),
                  block(fields)
                ],
                " "
              );
            },
            FieldDefinition: function(_ref24) {
              var name = _ref24.name,
                args = _ref24.arguments,
                type = _ref24.type,
                directives = _ref24.directives;
              return (
                name +
                wrap("(", join(args, ", "), ")") +
                ": " +
                type +
                wrap(" ", join(directives, " "))
              );
            },
            InputValueDefinition: function(_ref25) {
              var name = _ref25.name,
                type = _ref25.type,
                defaultValue = _ref25.defaultValue,
                directives = _ref25.directives;
              return join(
                [
                  name + ": " + type,
                  wrap("= ", defaultValue),
                  join(directives, " ")
                ],
                " "
              );
            },
            InterfaceTypeDefinition: function(_ref26) {
              var name = _ref26.name,
                directives = _ref26.directives,
                fields = _ref26.fields;
              return join(
                ["interface", name, join(directives, " "), block(fields)],
                " "
              );
            },
            UnionTypeDefinition: function(_ref27) {
              var name = _ref27.name,
                directives = _ref27.directives,
                types = _ref27.types;
              return join(
                [
                  "union",
                  name,
                  join(directives, " "),
                  "= " + join(types, " | ")
                ],
                " "
              );
            },
            EnumTypeDefinition: function(_ref28) {
              var name = _ref28.name,
                directives = _ref28.directives,
                values = _ref28.values;
              return join(
                ["enum", name, join(directives, " "), block(values)],
                " "
              );
            },
            EnumValueDefinition: function(_ref29) {
              return join([_ref29.name, join(_ref29.directives, " ")], " ");
            },
            InputObjectTypeDefinition: function(_ref30) {
              var name = _ref30.name,
                directives = _ref30.directives,
                fields = _ref30.fields;
              return join(
                ["input", name, join(directives, " "), block(fields)],
                " "
              );
            },
            TypeExtensionDefinition: function(_ref31) {
              return "extend " + _ref31.definition;
            },
            DirectiveDefinition: function(_ref32) {
              var name = _ref32.name,
                args = _ref32.arguments,
                locations = _ref32.locations;
              return (
                "directive @" +
                name +
                wrap("(", join(args, ", "), ")") +
                " on " +
                join(locations, " | ")
              );
            }
          };
          function join(maybeArray, separator) {
            return maybeArray
              ? maybeArray
                  .filter(function(x) {
                    return x;
                  })
                  .join(separator || "")
              : "";
          }
          function block(array) {
            return array && 0 !== array.length
              ? ((maybeString = "{\n" + join(array, "\n")) &&
                  maybeString.replace(/\n/g, "\n  ")) + "\n}"
              : "{}";
            var maybeString;
          }
          function wrap(start, maybeString, end) {
            return maybeString ? start + maybeString + (end || "") : "";
          }
        },
        { "./visitor": 117 }
      ],
      116: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.Source = void 0);
          var obj,
            _invariant = require("../jsutils/invariant"),
            _invariant2 =
              (obj = _invariant) && obj.__esModule ? obj : { default: obj };
          exports.Source = function Source(body, name, locationOffset) {
            !(function(instance, Constructor) {
              if (!(instance instanceof Constructor))
                throw new TypeError("Cannot call a class as a function");
            })(this, Source),
              (this.body = body),
              (this.name = name || "GraphQL request"),
              (this.locationOffset = locationOffset || { line: 1, column: 1 }),
              0 < this.locationOffset.line ||
                (0, _invariant2.default)(
                  0,
                  "line in locationOffset is 1-indexed and must be positive"
                ),
              0 < this.locationOffset.column ||
                (0, _invariant2.default)(
                  0,
                  "column in locationOffset is 1-indexed and must be positive"
                );
          };
        },
        { "../jsutils/invariant": 103 }
      ],
      117: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.visit = function(root, visitor, keyMap) {
              var visitorKeys = keyMap || QueryDocumentKeys,
                stack = void 0,
                inArray = Array.isArray(root),
                keys = [root],
                index = -1,
                edits = [],
                parent = void 0,
                path = [],
                ancestors = [],
                newRoot = root;
              do {
                var isLeaving = ++index === keys.length,
                  key = void 0,
                  node = void 0,
                  isEdited = isLeaving && 0 !== edits.length;
                if (isLeaving) {
                  if (
                    ((key = 0 === ancestors.length ? void 0 : path.pop()),
                    (node = parent),
                    (parent = ancestors.pop()),
                    isEdited)
                  ) {
                    if (inArray) node = node.slice();
                    else {
                      var clone = {};
                      for (var k in node)
                        node.hasOwnProperty(k) && (clone[k] = node[k]);
                      node = clone;
                    }
                    for (var editOffset = 0, ii = 0; ii < edits.length; ii++) {
                      var editKey = edits[ii][0],
                        editValue = edits[ii][1];
                      inArray && (editKey -= editOffset),
                        inArray && null === editValue
                          ? (node.splice(editKey, 1), editOffset++)
                          : (node[editKey] = editValue);
                    }
                  }
                  (index = stack.index),
                    (keys = stack.keys),
                    (edits = stack.edits),
                    (inArray = stack.inArray),
                    (stack = stack.prev);
                } else {
                  if (
                    ((key = parent ? (inArray ? index : keys[index]) : void 0),
                    null == (node = parent ? parent[key] : newRoot))
                  )
                    continue;
                  parent && path.push(key);
                }
                var result = void 0;
                if (!Array.isArray(node)) {
                  if (!isNode(node))
                    throw new Error(
                      "Invalid AST Node: " + JSON.stringify(node)
                    );
                  var visitFn = getVisitFn(visitor, node.kind, isLeaving);
                  if (visitFn) {
                    if (
                      (result = visitFn.call(
                        visitor,
                        node,
                        key,
                        parent,
                        path,
                        ancestors
                      )) === BREAK
                    )
                      break;
                    if (!1 === result) {
                      if (!isLeaving) {
                        path.pop();
                        continue;
                      }
                    } else if (
                      void 0 !== result &&
                      (edits.push([key, result]), !isLeaving)
                    ) {
                      if (!isNode(result)) {
                        path.pop();
                        continue;
                      }
                      node = result;
                    }
                  }
                }
                void 0 === result && isEdited && edits.push([key, node]),
                  isLeaving ||
                    ((stack = {
                      inArray: inArray,
                      index: index,
                      keys: keys,
                      edits: edits,
                      prev: stack
                    }),
                    (inArray = Array.isArray(node)),
                    (keys = inArray ? node : visitorKeys[node.kind] || []),
                    (index = -1),
                    (edits = []),
                    parent && ancestors.push(parent),
                    (parent = node));
              } while (void 0 !== stack);
              0 !== edits.length && (newRoot = edits[edits.length - 1][1]);
              return newRoot;
            }),
            (exports.visitInParallel = function(visitors) {
              var skipping = new Array(visitors.length);
              return {
                enter: function(node) {
                  for (var i = 0; i < visitors.length; i++)
                    if (!skipping[i]) {
                      var fn = getVisitFn(visitors[i], node.kind, !1);
                      if (fn) {
                        var result = fn.apply(visitors[i], arguments);
                        if (!1 === result) skipping[i] = node;
                        else if (result === BREAK) skipping[i] = BREAK;
                        else if (void 0 !== result) return result;
                      }
                    }
                },
                leave: function(node) {
                  for (var i = 0; i < visitors.length; i++)
                    if (skipping[i])
                      skipping[i] === node && (skipping[i] = null);
                    else {
                      var fn = getVisitFn(visitors[i], node.kind, !0);
                      if (fn) {
                        var result = fn.apply(visitors[i], arguments);
                        if (result === BREAK) skipping[i] = BREAK;
                        else if (void 0 !== result && !1 !== result)
                          return result;
                      }
                    }
                }
              };
            }),
            (exports.visitWithTypeInfo = function(typeInfo, visitor) {
              return {
                enter: function(node) {
                  typeInfo.enter(node);
                  var fn = getVisitFn(visitor, node.kind, !1);
                  if (fn) {
                    var result = fn.apply(visitor, arguments);
                    return (
                      void 0 !== result &&
                        (typeInfo.leave(node),
                        isNode(result) && typeInfo.enter(result)),
                      result
                    );
                  }
                },
                leave: function(node) {
                  var fn = getVisitFn(visitor, node.kind, !0),
                    result = void 0;
                  return (
                    fn && (result = fn.apply(visitor, arguments)),
                    typeInfo.leave(node),
                    result
                  );
                }
              };
            }),
            (exports.getVisitFn = getVisitFn);
          var QueryDocumentKeys = (exports.QueryDocumentKeys = {
              Name: [],
              Document: ["definitions"],
              OperationDefinition: [
                "name",
                "variableDefinitions",
                "directives",
                "selectionSet"
              ],
              VariableDefinition: ["variable", "type", "defaultValue"],
              Variable: ["name"],
              SelectionSet: ["selections"],
              Field: [
                "alias",
                "name",
                "arguments",
                "directives",
                "selectionSet"
              ],
              Argument: ["name", "value"],
              FragmentSpread: ["name", "directives"],
              InlineFragment: ["typeCondition", "directives", "selectionSet"],
              FragmentDefinition: [
                "name",
                "typeCondition",
                "directives",
                "selectionSet"
              ],
              IntValue: [],
              FloatValue: [],
              StringValue: [],
              BooleanValue: [],
              NullValue: [],
              EnumValue: [],
              ListValue: ["values"],
              ObjectValue: ["fields"],
              ObjectField: ["name", "value"],
              Directive: ["name", "arguments"],
              NamedType: ["name"],
              ListType: ["type"],
              NonNullType: ["type"],
              SchemaDefinition: ["directives", "operationTypes"],
              OperationTypeDefinition: ["type"],
              ScalarTypeDefinition: ["name", "directives"],
              ObjectTypeDefinition: [
                "name",
                "interfaces",
                "directives",
                "fields"
              ],
              FieldDefinition: ["name", "arguments", "type", "directives"],
              InputValueDefinition: [
                "name",
                "type",
                "defaultValue",
                "directives"
              ],
              InterfaceTypeDefinition: ["name", "directives", "fields"],
              UnionTypeDefinition: ["name", "directives", "types"],
              EnumTypeDefinition: ["name", "directives", "values"],
              EnumValueDefinition: ["name", "directives"],
              InputObjectTypeDefinition: ["name", "directives", "fields"],
              TypeExtensionDefinition: ["definition"],
              DirectiveDefinition: ["name", "arguments", "locations"]
            }),
            BREAK = (exports.BREAK = {});
          function isNode(maybeNode) {
            return maybeNode && "string" == typeof maybeNode.kind;
          }
          function getVisitFn(visitor, kind, isLeaving) {
            var kindVisitor = visitor[kind];
            if (kindVisitor) {
              if (!isLeaving && "function" == typeof kindVisitor)
                return kindVisitor;
              var kindSpecificVisitor = isLeaving
                ? kindVisitor.leave
                : kindVisitor.enter;
              if ("function" == typeof kindSpecificVisitor)
                return kindSpecificVisitor;
            } else {
              var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
              if (specificVisitor) {
                if ("function" == typeof specificVisitor)
                  return specificVisitor;
                var specificKindVisitor = specificVisitor[kind];
                if ("function" == typeof specificKindVisitor)
                  return specificKindVisitor;
              }
            }
          }
        },
        {}
      ],
      118: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _subscribe = require("./subscribe");
          Object.defineProperty(exports, "subscribe", {
            enumerable: !0,
            get: function() {
              return _subscribe.subscribe;
            }
          }),
            Object.defineProperty(exports, "createSourceEventStream", {
              enumerable: !0,
              get: function() {
                return _subscribe.createSourceEventStream;
              }
            });
        },
        { "./subscribe": 120 }
      ],
      119: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.default = function(iterable, callback) {
              var iterator = (0, _iterall.getAsyncIterator)(iterable),
                $return = void 0,
                abruptClose = void 0;
              "function" == typeof iterator.return &&
                (($return = iterator.return),
                (abruptClose = function(error) {
                  var rethrow = function() {
                    return Promise.reject(error);
                  };
                  return $return.call(iterator).then(rethrow, rethrow);
                }));
              function mapResult(result) {
                return result.done
                  ? result
                  : (function(value, callback) {
                      return new Promise(function(resolve) {
                        return resolve(callback(value));
                      });
                    })(result.value, callback).then(
                      iteratorResult,
                      abruptClose
                    );
              }
              return (function(obj, key, value) {
                key in obj
                  ? Object.defineProperty(obj, key, {
                      value: value,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0
                    })
                  : (obj[key] = value);
                return obj;
              })(
                {
                  next: function() {
                    return iterator.next().then(mapResult);
                  },
                  return: function() {
                    return $return
                      ? $return.call(iterator).then(mapResult)
                      : Promise.resolve({ value: void 0, done: !0 });
                  },
                  throw: function(error) {
                    return "function" == typeof iterator.throw
                      ? iterator.throw(error).then(mapResult)
                      : Promise.reject(error).catch(abruptClose);
                  }
                },
                _iterall.$$asyncIterator,
                function() {
                  return this;
                }
              );
            });
          var _iterall = require("iterall");
          function iteratorResult(value) {
            return { value: value, done: !1 };
          }
        },
        { iterall: 175 }
      ],
      120: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.subscribe = function(
              argsOrSchema,
              document,
              rootValue,
              contextValue,
              variableValues,
              operationName,
              fieldResolver,
              subscribeFieldResolver
            ) {
              var args = 1 === arguments.length ? argsOrSchema : void 0,
                schema = args ? args.schema : argsOrSchema;
              return args
                ? subscribeImpl(
                    schema,
                    args.document,
                    args.rootValue,
                    args.contextValue,
                    args.variableValues,
                    args.operationName,
                    args.fieldResolver,
                    args.subscribeFieldResolver
                  )
                : subscribeImpl(
                    schema,
                    document,
                    rootValue,
                    contextValue,
                    variableValues,
                    operationName,
                    fieldResolver,
                    subscribeFieldResolver
                  );
            }),
            (exports.createSourceEventStream = createSourceEventStream);
          var _iterall = require("iterall"),
            _execute = require("../execution/execute"),
            _invariant2 = (require("../type/schema"),
            _interopRequireDefault(require("../jsutils/invariant"))),
            _mapAsyncIterator2 = _interopRequireDefault(
              require("./mapAsyncIterator")
            );
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function subscribeImpl(
            schema,
            document,
            rootValue,
            contextValue,
            variableValues,
            operationName,
            fieldResolver,
            subscribeFieldResolver
          ) {
            var subscription = createSourceEventStream(
              schema,
              document,
              rootValue,
              contextValue,
              variableValues,
              operationName,
              subscribeFieldResolver
            );
            return (0, _mapAsyncIterator2.default)(subscription, function(
              payload
            ) {
              return (0, _execute.execute)(
                schema,
                document,
                payload,
                contextValue,
                variableValues,
                operationName,
                fieldResolver
              );
            });
          }
          function createSourceEventStream(
            schema,
            document,
            rootValue,
            contextValue,
            variableValues,
            operationName,
            fieldResolver
          ) {
            (0, _execute.assertValidExecutionArguments)(
              schema,
              document,
              variableValues
            );
            var exeContext = (0, _execute.buildExecutionContext)(
                schema,
                document,
                rootValue,
                contextValue,
                variableValues,
                operationName,
                fieldResolver
              ),
              type = (0, _execute.getOperationRootType)(
                schema,
                exeContext.operation
              ),
              fields = (0, _execute.collectFields)(
                exeContext,
                type,
                exeContext.operation.selectionSet,
                Object.create(null),
                Object.create(null)
              ),
              responseName = Object.keys(fields)[0],
              fieldNodes = fields[responseName],
              fieldNode = fieldNodes[0],
              fieldDef = (0, _execute.getFieldDef)(
                schema,
                type,
                fieldNode.name.value
              );
            fieldDef ||
              (0, _invariant2.default)(
                0,
                "This subscription is not defined by the schema."
              );
            var resolveFn = fieldDef.subscribe || exeContext.fieldResolver,
              info = (0, _execute.buildResolveInfo)(
                exeContext,
                fieldDef,
                fieldNodes,
                type,
                (0, _execute.addPath)(void 0, responseName)
              ),
              subscription = (0, _execute.resolveFieldValueOrError)(
                exeContext,
                fieldDef,
                fieldNodes,
                resolveFn,
                rootValue,
                info
              );
            if (subscription instanceof Error) throw subscription;
            if (!(0, _iterall.isAsyncIterable)(subscription))
              throw new Error(
                "Subscription must return Async Iterable. Received: " +
                  String(subscription)
              );
            return subscription;
          }
        },
        {
          "../execution/execute": 97,
          "../jsutils/invariant": 103,
          "../type/schema": 126,
          "./mapAsyncIterator": 119,
          iterall: 175
        }
      ],
      121: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.GraphQLNonNull = exports.GraphQLList = exports.GraphQLInputObjectType = exports.GraphQLEnumType = exports.GraphQLUnionType = exports.GraphQLInterfaceType = exports.GraphQLObjectType = exports.GraphQLScalarType = void 0);
          var _typeof =
              "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
                ? function(obj) {
                    return typeof obj;
                  }
                : function(obj) {
                    return obj &&
                      "function" == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? "symbol"
                      : typeof obj;
                  },
            _extends =
              Object.assign ||
              function(target) {
                for (var i = 1; i < arguments.length; i++) {
                  var source = arguments[i];
                  for (var key in source)
                    Object.prototype.hasOwnProperty.call(source, key) &&
                      (target[key] = source[key]);
                }
                return target;
              };
          (exports.isType = isType),
            (exports.assertType = function(type) {
              return (
                isType(type) ||
                  (0, _invariant2.default)(
                    0,
                    "Expected " + String(type) + " to be a GraphQL type."
                  ),
                type
              );
            }),
            (exports.isInputType = isInputType),
            (exports.assertInputType = function(type) {
              return (
                isInputType(type) ||
                  (0, _invariant2.default)(
                    0,
                    "Expected " + String(type) + " to be a GraphQL input type."
                  ),
                type
              );
            }),
            (exports.isOutputType = isOutputType),
            (exports.assertOutputType = function(type) {
              return (
                isOutputType(type) ||
                  (0, _invariant2.default)(
                    0,
                    "Expected " + String(type) + " to be a GraphQL output type."
                  ),
                type
              );
            }),
            (exports.isLeafType = isLeafType),
            (exports.assertLeafType = function(type) {
              return (
                isLeafType(type) ||
                  (0, _invariant2.default)(
                    0,
                    "Expected " + String(type) + " to be a GraphQL leaf type."
                  ),
                type
              );
            }),
            (exports.isCompositeType = isCompositeType),
            (exports.assertCompositeType = function(type) {
              return (
                isCompositeType(type) ||
                  (0, _invariant2.default)(
                    0,
                    "Expected " +
                      String(type) +
                      " to be a GraphQL composite type."
                  ),
                type
              );
            }),
            (exports.isAbstractType = isAbstractType),
            (exports.assertAbstractType = function(type) {
              return (
                isAbstractType(type) ||
                  (0, _invariant2.default)(
                    0,
                    "Expected " +
                      String(type) +
                      " to be a GraphQL abstract type."
                  ),
                type
              );
            }),
            (exports.getNullableType = function(type) {
              return type instanceof GraphQLNonNull ? type.ofType : type;
            }),
            (exports.isNamedType = isNamedType),
            (exports.assertNamedType = function(type) {
              return (
                isNamedType(type) ||
                  (0, _invariant2.default)(
                    0,
                    "Expected " + String(type) + " to be a GraphQL named type."
                  ),
                type
              );
            }),
            (exports.getNamedType = function(type) {
              if (type) {
                for (
                  var unmodifiedType = type;
                  unmodifiedType instanceof GraphQLList ||
                  unmodifiedType instanceof GraphQLNonNull;

                )
                  unmodifiedType = unmodifiedType.ofType;
                return unmodifiedType;
              }
            });
          var _invariant2 = _interopRequireDefault(
              require("../jsutils/invariant")
            ),
            _isNullish2 = _interopRequireDefault(
              require("../jsutils/isNullish")
            ),
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../language/kinds")),
            _assertValidName = require("../utilities/assertValidName");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor))
              throw new TypeError("Cannot call a class as a function");
          }
          function isType(type) {
            return (
              type instanceof GraphQLScalarType ||
              type instanceof GraphQLObjectType ||
              type instanceof GraphQLInterfaceType ||
              type instanceof GraphQLUnionType ||
              type instanceof GraphQLEnumType ||
              type instanceof GraphQLInputObjectType ||
              type instanceof GraphQLList ||
              type instanceof GraphQLNonNull
            );
          }
          function isInputType(type) {
            return (
              type instanceof GraphQLScalarType ||
              type instanceof GraphQLEnumType ||
              type instanceof GraphQLInputObjectType ||
              (type instanceof GraphQLNonNull && isInputType(type.ofType)) ||
              (type instanceof GraphQLList && isInputType(type.ofType))
            );
          }
          function isOutputType(type) {
            return (
              type instanceof GraphQLScalarType ||
              type instanceof GraphQLObjectType ||
              type instanceof GraphQLInterfaceType ||
              type instanceof GraphQLUnionType ||
              type instanceof GraphQLEnumType ||
              (type instanceof GraphQLNonNull && isOutputType(type.ofType)) ||
              (type instanceof GraphQLList && isOutputType(type.ofType))
            );
          }
          function isLeafType(type) {
            return (
              type instanceof GraphQLScalarType ||
              type instanceof GraphQLEnumType
            );
          }
          function isCompositeType(type) {
            return (
              type instanceof GraphQLObjectType ||
              type instanceof GraphQLInterfaceType ||
              type instanceof GraphQLUnionType
            );
          }
          function isAbstractType(type) {
            return (
              type instanceof GraphQLInterfaceType ||
              type instanceof GraphQLUnionType
            );
          }
          function isNamedType(type) {
            return (
              type instanceof GraphQLScalarType ||
              type instanceof GraphQLObjectType ||
              type instanceof GraphQLInterfaceType ||
              type instanceof GraphQLUnionType ||
              type instanceof GraphQLEnumType ||
              type instanceof GraphQLInputObjectType
            );
          }
          function resolveThunk(thunk) {
            return "function" == typeof thunk ? thunk() : thunk;
          }
          var GraphQLScalarType = (exports.GraphQLScalarType = (function() {
            function GraphQLScalarType(config) {
              _classCallCheck(this, GraphQLScalarType),
                (0, _assertValidName.assertValidName)(config.name),
                (this.name = config.name),
                (this.description = config.description),
                (this.astNode = config.astNode),
                "function" != typeof config.serialize &&
                  (0, _invariant2.default)(
                    0,
                    this.name +
                      ' must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.'
                  ),
                (config.parseValue || config.parseLiteral) &&
                  ("function" != typeof config.parseValue ||
                    "function" != typeof config.parseLiteral) &&
                  (0, _invariant2.default)(
                    0,
                    this.name +
                      ' must provide both "parseValue" and "parseLiteral" functions.'
                  ),
                (this._scalarConfig = config);
            }
            return (
              (GraphQLScalarType.prototype.serialize = function(value) {
                return (0, this._scalarConfig.serialize)(value);
              }),
              (GraphQLScalarType.prototype.isValidValue = function(value) {
                return !(0, _isNullish2.default)(this.parseValue(value));
              }),
              (GraphQLScalarType.prototype.parseValue = function(value) {
                var parser = this._scalarConfig.parseValue;
                return parser && !(0, _isNullish2.default)(value)
                  ? parser(value)
                  : void 0;
              }),
              (GraphQLScalarType.prototype.isValidLiteral = function(
                valueNode
              ) {
                return !(0, _isNullish2.default)(this.parseLiteral(valueNode));
              }),
              (GraphQLScalarType.prototype.parseLiteral = function(valueNode) {
                var parser = this._scalarConfig.parseLiteral;
                return parser ? parser(valueNode) : void 0;
              }),
              (GraphQLScalarType.prototype.toString = function() {
                return this.name;
              }),
              GraphQLScalarType
            );
          })());
          GraphQLScalarType.prototype.toJSON = GraphQLScalarType.prototype.inspect =
            GraphQLScalarType.prototype.toString;
          var GraphQLObjectType = (exports.GraphQLObjectType = (function() {
            function GraphQLObjectType(config) {
              _classCallCheck(this, GraphQLObjectType),
                (0, _assertValidName.assertValidName)(
                  config.name,
                  config.isIntrospection
                ),
                (this.name = config.name),
                (this.description = config.description),
                (this.astNode = config.astNode),
                (this.extensionASTNodes = config.extensionASTNodes || []),
                config.isTypeOf &&
                  "function" != typeof config.isTypeOf &&
                  (0, _invariant2.default)(
                    0,
                    this.name + ' must provide "isTypeOf" as a function.'
                  ),
                (this.isTypeOf = config.isTypeOf),
                (this._typeConfig = config);
            }
            return (
              (GraphQLObjectType.prototype.getFields = function() {
                return (
                  this._fields ||
                  (this._fields = defineFieldMap(this, this._typeConfig.fields))
                );
              }),
              (GraphQLObjectType.prototype.getInterfaces = function() {
                return (
                  this._interfaces ||
                  (this._interfaces = (function(type, interfacesThunk) {
                    var interfaces = resolveThunk(interfacesThunk);
                    if (!interfaces) return [];
                    Array.isArray(interfaces) ||
                      (0, _invariant2.default)(
                        0,
                        type.name +
                          " interfaces must be an Array or a function which returns an Array."
                      );
                    var implementedTypeNames = Object.create(null);
                    return (
                      interfaces.forEach(function(iface) {
                        iface instanceof GraphQLInterfaceType ||
                          (0, _invariant2.default)(
                            0,
                            type.name +
                              " may only implement Interface types, it cannot implement: " +
                              String(iface) +
                              "."
                          ),
                          implementedTypeNames[iface.name] &&
                            (0, _invariant2.default)(
                              0,
                              type.name +
                                " may declare it implements " +
                                iface.name +
                                " only once."
                            ),
                          (implementedTypeNames[iface.name] = !0),
                          "function" != typeof iface.resolveType &&
                            "function" != typeof type.isTypeOf &&
                            (0, _invariant2.default)(
                              0,
                              "Interface Type " +
                                iface.name +
                                ' does not provide a "resolveType" function and implementing Type ' +
                                type.name +
                                ' does not provide a "isTypeOf" function. There is no way to resolve this implementing type during execution.'
                            );
                      }),
                      interfaces
                    );
                  })(this, this._typeConfig.interfaces))
                );
              }),
              (GraphQLObjectType.prototype.toString = function() {
                return this.name;
              }),
              GraphQLObjectType
            );
          })());
          function defineFieldMap(type, fieldsThunk) {
            var fieldMap = resolveThunk(fieldsThunk);
            isPlainObj(fieldMap) ||
              (0, _invariant2.default)(
                0,
                type.name +
                  " fields must be an object with field names as keys or a function which returns such an object."
              );
            var fieldNames = Object.keys(fieldMap);
            0 < fieldNames.length ||
              (0, _invariant2.default)(
                0,
                type.name +
                  " fields must be an object with field names as keys or a function which returns such an object."
              );
            var resultFieldMap = Object.create(null);
            return (
              fieldNames.forEach(function(fieldName) {
                (0, _assertValidName.assertValidName)(fieldName);
                var fieldConfig = fieldMap[fieldName];
                isPlainObj(fieldConfig) ||
                  (0, _invariant2.default)(
                    0,
                    type.name +
                      "." +
                      fieldName +
                      " field config must be an object"
                  ),
                  fieldConfig.hasOwnProperty("isDeprecated") &&
                    (0, _invariant2.default)(
                      0,
                      type.name +
                        "." +
                        fieldName +
                        ' should provide "deprecationReason" instead of "isDeprecated".'
                    );
                var resolver,
                  field = _extends({}, fieldConfig, {
                    isDeprecated: Boolean(fieldConfig.deprecationReason),
                    name: fieldName
                  });
                isOutputType(field.type) ||
                  (0, _invariant2.default)(
                    0,
                    type.name +
                      "." +
                      fieldName +
                      " field type must be Output Type but got: " +
                      String(field.type) +
                      "."
                  ),
                  null != (resolver = field.resolve) &&
                    "function" != typeof resolver &&
                    (0, _invariant2.default)(
                      0,
                      type.name +
                        "." +
                        fieldName +
                        " field resolver must be a function if provided, but got: " +
                        String(field.resolve) +
                        "."
                    );
                var argsConfig = fieldConfig.args;
                argsConfig
                  ? (isPlainObj(argsConfig) ||
                      (0, _invariant2.default)(
                        0,
                        type.name +
                          "." +
                          fieldName +
                          " args must be an object with argument names as keys."
                      ),
                    (field.args = Object.keys(argsConfig).map(function(
                      argName
                    ) {
                      (0, _assertValidName.assertValidName)(argName);
                      var arg = argsConfig[argName];
                      return (
                        isInputType(arg.type) ||
                          (0, _invariant2.default)(
                            0,
                            type.name +
                              "." +
                              fieldName +
                              "(" +
                              argName +
                              ":) argument type must be Input Type but got: " +
                              String(arg.type) +
                              "."
                          ),
                        {
                          name: argName,
                          description:
                            void 0 === arg.description ? null : arg.description,
                          type: arg.type,
                          defaultValue: arg.defaultValue,
                          astNode: arg.astNode
                        }
                      );
                    })))
                  : (field.args = []),
                  (resultFieldMap[fieldName] = field);
              }),
              resultFieldMap
            );
          }
          function isPlainObj(obj) {
            return (
              obj &&
              "object" === (void 0 === obj ? "undefined" : _typeof(obj)) &&
              !Array.isArray(obj)
            );
          }
          GraphQLObjectType.prototype.toJSON = GraphQLObjectType.prototype.inspect =
            GraphQLObjectType.prototype.toString;
          var GraphQLInterfaceType = (exports.GraphQLInterfaceType = (function() {
            function GraphQLInterfaceType(config) {
              _classCallCheck(this, GraphQLInterfaceType),
                (0, _assertValidName.assertValidName)(config.name),
                (this.name = config.name),
                (this.description = config.description),
                (this.astNode = config.astNode),
                config.resolveType &&
                  "function" != typeof config.resolveType &&
                  (0, _invariant2.default)(
                    0,
                    this.name + ' must provide "resolveType" as a function.'
                  ),
                (this.resolveType = config.resolveType),
                (this._typeConfig = config);
            }
            return (
              (GraphQLInterfaceType.prototype.getFields = function() {
                return (
                  this._fields ||
                  (this._fields = defineFieldMap(this, this._typeConfig.fields))
                );
              }),
              (GraphQLInterfaceType.prototype.toString = function() {
                return this.name;
              }),
              GraphQLInterfaceType
            );
          })());
          GraphQLInterfaceType.prototype.toJSON = GraphQLInterfaceType.prototype.inspect =
            GraphQLInterfaceType.prototype.toString;
          var GraphQLUnionType = (exports.GraphQLUnionType = (function() {
            function GraphQLUnionType(config) {
              _classCallCheck(this, GraphQLUnionType),
                (0, _assertValidName.assertValidName)(config.name),
                (this.name = config.name),
                (this.description = config.description),
                (this.astNode = config.astNode),
                config.resolveType &&
                  "function" != typeof config.resolveType &&
                  (0, _invariant2.default)(
                    0,
                    this.name + ' must provide "resolveType" as a function.'
                  ),
                (this.resolveType = config.resolveType),
                (this._typeConfig = config);
            }
            return (
              (GraphQLUnionType.prototype.getTypes = function() {
                return (
                  this._types ||
                  (this._types = (function(unionType, typesThunk) {
                    var types = resolveThunk(typesThunk);
                    (Array.isArray(types) && 0 < types.length) ||
                      (0, _invariant2.default)(
                        0,
                        "Must provide Array of types or a function which returns such an array for Union " +
                          unionType.name +
                          "."
                      );
                    var includedTypeNames = Object.create(null);
                    return (
                      types.forEach(function(objType) {
                        objType instanceof GraphQLObjectType ||
                          (0, _invariant2.default)(
                            0,
                            unionType.name +
                              " may only contain Object types, it cannot contain: " +
                              String(objType) +
                              "."
                          ),
                          includedTypeNames[objType.name] &&
                            (0, _invariant2.default)(
                              0,
                              unionType.name +
                                " can include " +
                                objType.name +
                                " type only once."
                            ),
                          (includedTypeNames[objType.name] = !0),
                          "function" != typeof unionType.resolveType &&
                            "function" != typeof objType.isTypeOf &&
                            (0, _invariant2.default)(
                              0,
                              'Union type "' +
                                unionType.name +
                                '" does not provide a "resolveType" function and possible type "' +
                                objType.name +
                                '" does not provide an "isTypeOf" function. There is no way to resolve this possible type during execution.'
                            );
                      }),
                      types
                    );
                  })(this, this._typeConfig.types))
                );
              }),
              (GraphQLUnionType.prototype.toString = function() {
                return this.name;
              }),
              GraphQLUnionType
            );
          })());
          GraphQLUnionType.prototype.toJSON = GraphQLUnionType.prototype.inspect =
            GraphQLUnionType.prototype.toString;
          var GraphQLEnumType = (exports.GraphQLEnumType = (function() {
            function GraphQLEnumType(config) {
              _classCallCheck(this, GraphQLEnumType),
                (this.name = config.name),
                (0, _assertValidName.assertValidName)(
                  config.name,
                  config.isIntrospection
                ),
                (this.description = config.description),
                (this.astNode = config.astNode),
                (this._values = (function(type, valueMap) {
                  isPlainObj(valueMap) ||
                    (0, _invariant2.default)(
                      0,
                      type.name +
                        " values must be an object with value names as keys."
                    );
                  var valueNames = Object.keys(valueMap);
                  return (
                    0 < valueNames.length ||
                      (0, _invariant2.default)(
                        0,
                        type.name +
                          " values must be an object with value names as keys."
                      ),
                    valueNames.map(function(valueName) {
                      (0, _assertValidName.assertValidName)(valueName),
                        -1 !== ["true", "false", "null"].indexOf(valueName) &&
                          (0, _invariant2.default)(
                            0,
                            'Name "' +
                              valueName +
                              '" can not be used as an Enum value.'
                          );
                      var value = valueMap[valueName];
                      return (
                        isPlainObj(value) ||
                          (0, _invariant2.default)(
                            0,
                            type.name +
                              "." +
                              valueName +
                              ' must refer to an object with a "value" key representing an internal value but got: ' +
                              String(value) +
                              "."
                          ),
                        value.hasOwnProperty("isDeprecated") &&
                          (0, _invariant2.default)(
                            0,
                            type.name +
                              "." +
                              valueName +
                              ' should provide "deprecationReason" instead of "isDeprecated".'
                          ),
                        {
                          name: valueName,
                          description: value.description,
                          isDeprecated: Boolean(value.deprecationReason),
                          deprecationReason: value.deprecationReason,
                          astNode: value.astNode,
                          value: value.hasOwnProperty("value")
                            ? value.value
                            : valueName
                        }
                      );
                    })
                  );
                })(this, config.values)),
                (this._enumConfig = config);
            }
            return (
              (GraphQLEnumType.prototype.getValues = function() {
                return this._values;
              }),
              (GraphQLEnumType.prototype.getValue = function(name) {
                return this._getNameLookup()[name];
              }),
              (GraphQLEnumType.prototype.serialize = function(value) {
                var enumValue = this._getValueLookup().get(value);
                return enumValue ? enumValue.name : null;
              }),
              (GraphQLEnumType.prototype.isValidValue = function(value) {
                return (
                  "string" == typeof value &&
                  void 0 !== this._getNameLookup()[value]
                );
              }),
              (GraphQLEnumType.prototype.parseValue = function(value) {
                if ("string" == typeof value) {
                  var enumValue = this._getNameLookup()[value];
                  if (enumValue) return enumValue.value;
                }
              }),
              (GraphQLEnumType.prototype.isValidLiteral = function(valueNode) {
                return (
                  valueNode.kind === Kind.ENUM &&
                  void 0 !== this._getNameLookup()[valueNode.value]
                );
              }),
              (GraphQLEnumType.prototype.parseLiteral = function(valueNode) {
                if (valueNode.kind === Kind.ENUM) {
                  var enumValue = this._getNameLookup()[valueNode.value];
                  if (enumValue) return enumValue.value;
                }
              }),
              (GraphQLEnumType.prototype._getValueLookup = function() {
                if (!this._valueLookup) {
                  var lookup = new Map();
                  this.getValues().forEach(function(value) {
                    lookup.set(value.value, value);
                  }),
                    (this._valueLookup = lookup);
                }
                return this._valueLookup;
              }),
              (GraphQLEnumType.prototype._getNameLookup = function() {
                if (!this._nameLookup) {
                  var lookup = Object.create(null);
                  this.getValues().forEach(function(value) {
                    lookup[value.name] = value;
                  }),
                    (this._nameLookup = lookup);
                }
                return this._nameLookup;
              }),
              (GraphQLEnumType.prototype.toString = function() {
                return this.name;
              }),
              GraphQLEnumType
            );
          })());
          GraphQLEnumType.prototype.toJSON = GraphQLEnumType.prototype.inspect =
            GraphQLEnumType.prototype.toString;
          var GraphQLInputObjectType = (exports.GraphQLInputObjectType = (function() {
            function GraphQLInputObjectType(config) {
              _classCallCheck(this, GraphQLInputObjectType),
                (0, _assertValidName.assertValidName)(config.name),
                (this.name = config.name),
                (this.description = config.description),
                (this.astNode = config.astNode),
                (this._typeConfig = config);
            }
            return (
              (GraphQLInputObjectType.prototype.getFields = function() {
                return this._fields || (this._fields = this._defineFieldMap());
              }),
              (GraphQLInputObjectType.prototype._defineFieldMap = function() {
                var _this = this,
                  fieldMap = resolveThunk(this._typeConfig.fields);
                isPlainObj(fieldMap) ||
                  (0, _invariant2.default)(
                    0,
                    this.name +
                      " fields must be an object with field names as keys or a function which returns such an object."
                  );
                var fieldNames = Object.keys(fieldMap);
                0 < fieldNames.length ||
                  (0, _invariant2.default)(
                    0,
                    this.name +
                      " fields must be an object with field names as keys or a function which returns such an object."
                  );
                var resultFieldMap = Object.create(null);
                return (
                  fieldNames.forEach(function(fieldName) {
                    (0, _assertValidName.assertValidName)(fieldName);
                    var field = _extends({}, fieldMap[fieldName], {
                      name: fieldName
                    });
                    isInputType(field.type) ||
                      (0, _invariant2.default)(
                        0,
                        _this.name +
                          "." +
                          fieldName +
                          " field type must be Input Type but got: " +
                          String(field.type) +
                          "."
                      ),
                      null != field.resolve &&
                        (0, _invariant2.default)(
                          0,
                          _this.name +
                            "." +
                            fieldName +
                            " field type has a resolve property, but Input Types cannot define resolvers."
                        ),
                      (resultFieldMap[fieldName] = field);
                  }),
                  resultFieldMap
                );
              }),
              (GraphQLInputObjectType.prototype.toString = function() {
                return this.name;
              }),
              GraphQLInputObjectType
            );
          })());
          GraphQLInputObjectType.prototype.toJSON = GraphQLInputObjectType.prototype.inspect =
            GraphQLInputObjectType.prototype.toString;
          var GraphQLList = (exports.GraphQLList = (function() {
            function GraphQLList(type) {
              _classCallCheck(this, GraphQLList),
                isType(type) ||
                  (0, _invariant2.default)(
                    0,
                    "Can only create List of a GraphQLType but got: " +
                      String(type) +
                      "."
                  ),
                (this.ofType = type);
            }
            return (
              (GraphQLList.prototype.toString = function() {
                return "[" + String(this.ofType) + "]";
              }),
              GraphQLList
            );
          })());
          GraphQLList.prototype.toJSON = GraphQLList.prototype.inspect =
            GraphQLList.prototype.toString;
          var GraphQLNonNull = (exports.GraphQLNonNull = (function() {
            function GraphQLNonNull(type) {
              _classCallCheck(this, GraphQLNonNull),
                (!isType(type) || type instanceof GraphQLNonNull) &&
                  (0, _invariant2.default)(
                    0,
                    "Can only create NonNull of a Nullable GraphQLType but got: " +
                      String(type) +
                      "."
                  ),
                (this.ofType = type);
            }
            return (
              (GraphQLNonNull.prototype.toString = function() {
                return this.ofType.toString() + "!";
              }),
              GraphQLNonNull
            );
          })());
          GraphQLNonNull.prototype.toJSON = GraphQLNonNull.prototype.inspect =
            GraphQLNonNull.prototype.toString;
        },
        {
          "../jsutils/invariant": 103,
          "../jsutils/isNullish": 105,
          "../language/kinds": 111,
          "../utilities/assertValidName": 128
        }
      ],
      122: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.specifiedDirectives = exports.GraphQLDeprecatedDirective = exports.DEFAULT_DEPRECATION_REASON = exports.GraphQLSkipDirective = exports.GraphQLIncludeDirective = exports.GraphQLDirective = exports.DirectiveLocation = void 0);
          var obj,
            _definition = require("./definition"),
            _scalars = require("./scalars"),
            _invariant = require("../jsutils/invariant"),
            _invariant2 =
              (obj = _invariant) && obj.__esModule ? obj : { default: obj },
            _assertValidName = require("../utilities/assertValidName");
          var DirectiveLocation = (exports.DirectiveLocation = {
              QUERY: "QUERY",
              MUTATION: "MUTATION",
              SUBSCRIPTION: "SUBSCRIPTION",
              FIELD: "FIELD",
              FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
              FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
              INLINE_FRAGMENT: "INLINE_FRAGMENT",
              SCHEMA: "SCHEMA",
              SCALAR: "SCALAR",
              OBJECT: "OBJECT",
              FIELD_DEFINITION: "FIELD_DEFINITION",
              ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
              INTERFACE: "INTERFACE",
              UNION: "UNION",
              ENUM: "ENUM",
              ENUM_VALUE: "ENUM_VALUE",
              INPUT_OBJECT: "INPUT_OBJECT",
              INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
            }),
            GraphQLDirective = (exports.GraphQLDirective = function GraphQLDirective(
              config
            ) {
              !(function(instance, Constructor) {
                if (!(instance instanceof Constructor))
                  throw new TypeError("Cannot call a class as a function");
              })(this, GraphQLDirective),
                config.name ||
                  (0, _invariant2.default)(0, "Directive must be named."),
                (0, _assertValidName.assertValidName)(config.name),
                Array.isArray(config.locations) ||
                  (0, _invariant2.default)(
                    0,
                    "Must provide locations for directive."
                  ),
                (this.name = config.name),
                (this.description = config.description),
                (this.locations = config.locations),
                (this.astNode = config.astNode);
              var args = config.args;
              args
                ? (Array.isArray(args) &&
                    (0, _invariant2.default)(
                      0,
                      "@" +
                        config.name +
                        " args must be an object with argument names as keys."
                    ),
                  (this.args = Object.keys(args).map(function(argName) {
                    (0, _assertValidName.assertValidName)(argName);
                    var arg = args[argName];
                    return (
                      (0, _definition.isInputType)(arg.type) ||
                        (0, _invariant2.default)(
                          0,
                          "@" +
                            config.name +
                            "(" +
                            argName +
                            ":) argument type must be Input Type but got: " +
                            String(arg.type) +
                            "."
                        ),
                      {
                        name: argName,
                        description:
                          void 0 === arg.description ? null : arg.description,
                        type: arg.type,
                        defaultValue: arg.defaultValue,
                        astNode: arg.astNode
                      }
                    );
                  })))
                : (this.args = []);
            }),
            GraphQLIncludeDirective = (exports.GraphQLIncludeDirective = new GraphQLDirective(
              {
                name: "include",
                description:
                  "Directs the executor to include this field or fragment only when the `if` argument is true.",
                locations: [
                  DirectiveLocation.FIELD,
                  DirectiveLocation.FRAGMENT_SPREAD,
                  DirectiveLocation.INLINE_FRAGMENT
                ],
                args: {
                  if: {
                    type: new _definition.GraphQLNonNull(
                      _scalars.GraphQLBoolean
                    ),
                    description: "Included when true."
                  }
                }
              }
            )),
            GraphQLSkipDirective = (exports.GraphQLSkipDirective = new GraphQLDirective(
              {
                name: "skip",
                description:
                  "Directs the executor to skip this field or fragment when the `if` argument is true.",
                locations: [
                  DirectiveLocation.FIELD,
                  DirectiveLocation.FRAGMENT_SPREAD,
                  DirectiveLocation.INLINE_FRAGMENT
                ],
                args: {
                  if: {
                    type: new _definition.GraphQLNonNull(
                      _scalars.GraphQLBoolean
                    ),
                    description: "Skipped when true."
                  }
                }
              }
            )),
            DEFAULT_DEPRECATION_REASON = (exports.DEFAULT_DEPRECATION_REASON =
              "No longer supported"),
            GraphQLDeprecatedDirective = (exports.GraphQLDeprecatedDirective = new GraphQLDirective(
              {
                name: "deprecated",
                description:
                  "Marks an element of a GraphQL schema as no longer supported.",
                locations: [
                  DirectiveLocation.FIELD_DEFINITION,
                  DirectiveLocation.ENUM_VALUE
                ],
                args: {
                  reason: {
                    type: _scalars.GraphQLString,
                    description:
                      "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted in [Markdown](https://daringfireball.net/projects/markdown/).",
                    defaultValue: DEFAULT_DEPRECATION_REASON
                  }
                }
              }
            ));
          exports.specifiedDirectives = [
            GraphQLIncludeDirective,
            GraphQLSkipDirective,
            GraphQLDeprecatedDirective
          ];
        },
        {
          "../jsutils/invariant": 103,
          "../utilities/assertValidName": 128,
          "./definition": 121,
          "./scalars": 125
        }
      ],
      123: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _schema = require("./schema");
          Object.defineProperty(exports, "GraphQLSchema", {
            enumerable: !0,
            get: function() {
              return _schema.GraphQLSchema;
            }
          });
          var _definition = require("./definition");
          Object.defineProperty(exports, "isType", {
            enumerable: !0,
            get: function() {
              return _definition.isType;
            }
          }),
            Object.defineProperty(exports, "isInputType", {
              enumerable: !0,
              get: function() {
                return _definition.isInputType;
              }
            }),
            Object.defineProperty(exports, "isOutputType", {
              enumerable: !0,
              get: function() {
                return _definition.isOutputType;
              }
            }),
            Object.defineProperty(exports, "isLeafType", {
              enumerable: !0,
              get: function() {
                return _definition.isLeafType;
              }
            }),
            Object.defineProperty(exports, "isCompositeType", {
              enumerable: !0,
              get: function() {
                return _definition.isCompositeType;
              }
            }),
            Object.defineProperty(exports, "isAbstractType", {
              enumerable: !0,
              get: function() {
                return _definition.isAbstractType;
              }
            }),
            Object.defineProperty(exports, "isNamedType", {
              enumerable: !0,
              get: function() {
                return _definition.isNamedType;
              }
            }),
            Object.defineProperty(exports, "assertType", {
              enumerable: !0,
              get: function() {
                return _definition.assertType;
              }
            }),
            Object.defineProperty(exports, "assertInputType", {
              enumerable: !0,
              get: function() {
                return _definition.assertInputType;
              }
            }),
            Object.defineProperty(exports, "assertOutputType", {
              enumerable: !0,
              get: function() {
                return _definition.assertOutputType;
              }
            }),
            Object.defineProperty(exports, "assertLeafType", {
              enumerable: !0,
              get: function() {
                return _definition.assertLeafType;
              }
            }),
            Object.defineProperty(exports, "assertCompositeType", {
              enumerable: !0,
              get: function() {
                return _definition.assertCompositeType;
              }
            }),
            Object.defineProperty(exports, "assertAbstractType", {
              enumerable: !0,
              get: function() {
                return _definition.assertAbstractType;
              }
            }),
            Object.defineProperty(exports, "assertNamedType", {
              enumerable: !0,
              get: function() {
                return _definition.assertNamedType;
              }
            }),
            Object.defineProperty(exports, "getNullableType", {
              enumerable: !0,
              get: function() {
                return _definition.getNullableType;
              }
            }),
            Object.defineProperty(exports, "getNamedType", {
              enumerable: !0,
              get: function() {
                return _definition.getNamedType;
              }
            }),
            Object.defineProperty(exports, "GraphQLScalarType", {
              enumerable: !0,
              get: function() {
                return _definition.GraphQLScalarType;
              }
            }),
            Object.defineProperty(exports, "GraphQLObjectType", {
              enumerable: !0,
              get: function() {
                return _definition.GraphQLObjectType;
              }
            }),
            Object.defineProperty(exports, "GraphQLInterfaceType", {
              enumerable: !0,
              get: function() {
                return _definition.GraphQLInterfaceType;
              }
            }),
            Object.defineProperty(exports, "GraphQLUnionType", {
              enumerable: !0,
              get: function() {
                return _definition.GraphQLUnionType;
              }
            }),
            Object.defineProperty(exports, "GraphQLEnumType", {
              enumerable: !0,
              get: function() {
                return _definition.GraphQLEnumType;
              }
            }),
            Object.defineProperty(exports, "GraphQLInputObjectType", {
              enumerable: !0,
              get: function() {
                return _definition.GraphQLInputObjectType;
              }
            }),
            Object.defineProperty(exports, "GraphQLList", {
              enumerable: !0,
              get: function() {
                return _definition.GraphQLList;
              }
            }),
            Object.defineProperty(exports, "GraphQLNonNull", {
              enumerable: !0,
              get: function() {
                return _definition.GraphQLNonNull;
              }
            });
          var _directives = require("./directives");
          Object.defineProperty(exports, "DirectiveLocation", {
            enumerable: !0,
            get: function() {
              return _directives.DirectiveLocation;
            }
          }),
            Object.defineProperty(exports, "GraphQLDirective", {
              enumerable: !0,
              get: function() {
                return _directives.GraphQLDirective;
              }
            }),
            Object.defineProperty(exports, "specifiedDirectives", {
              enumerable: !0,
              get: function() {
                return _directives.specifiedDirectives;
              }
            }),
            Object.defineProperty(exports, "GraphQLIncludeDirective", {
              enumerable: !0,
              get: function() {
                return _directives.GraphQLIncludeDirective;
              }
            }),
            Object.defineProperty(exports, "GraphQLSkipDirective", {
              enumerable: !0,
              get: function() {
                return _directives.GraphQLSkipDirective;
              }
            }),
            Object.defineProperty(exports, "GraphQLDeprecatedDirective", {
              enumerable: !0,
              get: function() {
                return _directives.GraphQLDeprecatedDirective;
              }
            }),
            Object.defineProperty(exports, "DEFAULT_DEPRECATION_REASON", {
              enumerable: !0,
              get: function() {
                return _directives.DEFAULT_DEPRECATION_REASON;
              }
            });
          var _scalars = require("./scalars");
          Object.defineProperty(exports, "GraphQLInt", {
            enumerable: !0,
            get: function() {
              return _scalars.GraphQLInt;
            }
          }),
            Object.defineProperty(exports, "GraphQLFloat", {
              enumerable: !0,
              get: function() {
                return _scalars.GraphQLFloat;
              }
            }),
            Object.defineProperty(exports, "GraphQLString", {
              enumerable: !0,
              get: function() {
                return _scalars.GraphQLString;
              }
            }),
            Object.defineProperty(exports, "GraphQLBoolean", {
              enumerable: !0,
              get: function() {
                return _scalars.GraphQLBoolean;
              }
            }),
            Object.defineProperty(exports, "GraphQLID", {
              enumerable: !0,
              get: function() {
                return _scalars.GraphQLID;
              }
            });
          var _introspection = require("./introspection");
          Object.defineProperty(exports, "TypeKind", {
            enumerable: !0,
            get: function() {
              return _introspection.TypeKind;
            }
          }),
            Object.defineProperty(exports, "__Schema", {
              enumerable: !0,
              get: function() {
                return _introspection.__Schema;
              }
            }),
            Object.defineProperty(exports, "__Directive", {
              enumerable: !0,
              get: function() {
                return _introspection.__Directive;
              }
            }),
            Object.defineProperty(exports, "__DirectiveLocation", {
              enumerable: !0,
              get: function() {
                return _introspection.__DirectiveLocation;
              }
            }),
            Object.defineProperty(exports, "__Type", {
              enumerable: !0,
              get: function() {
                return _introspection.__Type;
              }
            }),
            Object.defineProperty(exports, "__Field", {
              enumerable: !0,
              get: function() {
                return _introspection.__Field;
              }
            }),
            Object.defineProperty(exports, "__InputValue", {
              enumerable: !0,
              get: function() {
                return _introspection.__InputValue;
              }
            }),
            Object.defineProperty(exports, "__EnumValue", {
              enumerable: !0,
              get: function() {
                return _introspection.__EnumValue;
              }
            }),
            Object.defineProperty(exports, "__TypeKind", {
              enumerable: !0,
              get: function() {
                return _introspection.__TypeKind;
              }
            }),
            Object.defineProperty(exports, "SchemaMetaFieldDef", {
              enumerable: !0,
              get: function() {
                return _introspection.SchemaMetaFieldDef;
              }
            }),
            Object.defineProperty(exports, "TypeMetaFieldDef", {
              enumerable: !0,
              get: function() {
                return _introspection.TypeMetaFieldDef;
              }
            }),
            Object.defineProperty(exports, "TypeNameMetaFieldDef", {
              enumerable: !0,
              get: function() {
                return _introspection.TypeNameMetaFieldDef;
              }
            });
        },
        {
          "./definition": 121,
          "./directives": 122,
          "./introspection": 124,
          "./scalars": 125,
          "./schema": 126
        }
      ],
      124: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.TypeNameMetaFieldDef = exports.TypeMetaFieldDef = exports.SchemaMetaFieldDef = exports.__TypeKind = exports.TypeKind = exports.__EnumValue = exports.__InputValue = exports.__Field = exports.__Type = exports.__DirectiveLocation = exports.__Directive = exports.__Schema = void 0);
          var obj,
            _isInvalid = require("../jsutils/isInvalid"),
            _isInvalid2 =
              (obj = _isInvalid) && obj.__esModule ? obj : { default: obj },
            _astFromValue = require("../utilities/astFromValue"),
            _printer = require("../language/printer"),
            _definition = require("./definition"),
            _scalars = require("./scalars"),
            _directives = require("./directives");
          var __Schema = (exports.__Schema = new _definition.GraphQLObjectType({
              name: "__Schema",
              isIntrospection: !0,
              description:
                "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
              fields: function() {
                return {
                  types: {
                    description:
                      "A list of all types supported by this server.",
                    type: new _definition.GraphQLNonNull(
                      new _definition.GraphQLList(
                        new _definition.GraphQLNonNull(__Type)
                      )
                    ),
                    resolve: function(schema) {
                      var typeMap = schema.getTypeMap();
                      return Object.keys(typeMap).map(function(key) {
                        return typeMap[key];
                      });
                    }
                  },
                  queryType: {
                    description:
                      "The type that query operations will be rooted at.",
                    type: new _definition.GraphQLNonNull(__Type),
                    resolve: function(schema) {
                      return schema.getQueryType();
                    }
                  },
                  mutationType: {
                    description:
                      "If this server supports mutation, the type that mutation operations will be rooted at.",
                    type: __Type,
                    resolve: function(schema) {
                      return schema.getMutationType();
                    }
                  },
                  subscriptionType: {
                    description:
                      "If this server support subscription, the type that subscription operations will be rooted at.",
                    type: __Type,
                    resolve: function(schema) {
                      return schema.getSubscriptionType();
                    }
                  },
                  directives: {
                    description:
                      "A list of all directives supported by this server.",
                    type: new _definition.GraphQLNonNull(
                      new _definition.GraphQLList(
                        new _definition.GraphQLNonNull(__Directive)
                      )
                    ),
                    resolve: function(schema) {
                      return schema.getDirectives();
                    }
                  }
                };
              }
            })),
            __Directive = (exports.__Directive = new _definition.GraphQLObjectType(
              {
                name: "__Directive",
                isIntrospection: !0,
                description:
                  "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
                fields: function() {
                  return {
                    name: {
                      type: new _definition.GraphQLNonNull(
                        _scalars.GraphQLString
                      )
                    },
                    description: { type: _scalars.GraphQLString },
                    locations: {
                      type: new _definition.GraphQLNonNull(
                        new _definition.GraphQLList(
                          new _definition.GraphQLNonNull(__DirectiveLocation)
                        )
                      )
                    },
                    args: {
                      type: new _definition.GraphQLNonNull(
                        new _definition.GraphQLList(
                          new _definition.GraphQLNonNull(__InputValue)
                        )
                      ),
                      resolve: function(directive) {
                        return directive.args || [];
                      }
                    },
                    onOperation: {
                      deprecationReason: "Use `locations`.",
                      type: new _definition.GraphQLNonNull(
                        _scalars.GraphQLBoolean
                      ),
                      resolve: function(d) {
                        return (
                          -1 !==
                            d.locations.indexOf(
                              _directives.DirectiveLocation.QUERY
                            ) ||
                          -1 !==
                            d.locations.indexOf(
                              _directives.DirectiveLocation.MUTATION
                            ) ||
                          -1 !==
                            d.locations.indexOf(
                              _directives.DirectiveLocation.SUBSCRIPTION
                            )
                        );
                      }
                    },
                    onFragment: {
                      deprecationReason: "Use `locations`.",
                      type: new _definition.GraphQLNonNull(
                        _scalars.GraphQLBoolean
                      ),
                      resolve: function(d) {
                        return (
                          -1 !==
                            d.locations.indexOf(
                              _directives.DirectiveLocation.FRAGMENT_SPREAD
                            ) ||
                          -1 !==
                            d.locations.indexOf(
                              _directives.DirectiveLocation.INLINE_FRAGMENT
                            ) ||
                          -1 !==
                            d.locations.indexOf(
                              _directives.DirectiveLocation.FRAGMENT_DEFINITION
                            )
                        );
                      }
                    },
                    onField: {
                      deprecationReason: "Use `locations`.",
                      type: new _definition.GraphQLNonNull(
                        _scalars.GraphQLBoolean
                      ),
                      resolve: function(d) {
                        return (
                          -1 !==
                          d.locations.indexOf(
                            _directives.DirectiveLocation.FIELD
                          )
                        );
                      }
                    }
                  };
                }
              }
            )),
            __DirectiveLocation = (exports.__DirectiveLocation = new _definition.GraphQLEnumType(
              {
                name: "__DirectiveLocation",
                isIntrospection: !0,
                description:
                  "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
                values: {
                  QUERY: {
                    value: _directives.DirectiveLocation.QUERY,
                    description: "Location adjacent to a query operation."
                  },
                  MUTATION: {
                    value: _directives.DirectiveLocation.MUTATION,
                    description: "Location adjacent to a mutation operation."
                  },
                  SUBSCRIPTION: {
                    value: _directives.DirectiveLocation.SUBSCRIPTION,
                    description:
                      "Location adjacent to a subscription operation."
                  },
                  FIELD: {
                    value: _directives.DirectiveLocation.FIELD,
                    description: "Location adjacent to a field."
                  },
                  FRAGMENT_DEFINITION: {
                    value: _directives.DirectiveLocation.FRAGMENT_DEFINITION,
                    description: "Location adjacent to a fragment definition."
                  },
                  FRAGMENT_SPREAD: {
                    value: _directives.DirectiveLocation.FRAGMENT_SPREAD,
                    description: "Location adjacent to a fragment spread."
                  },
                  INLINE_FRAGMENT: {
                    value: _directives.DirectiveLocation.INLINE_FRAGMENT,
                    description: "Location adjacent to an inline fragment."
                  },
                  SCHEMA: {
                    value: _directives.DirectiveLocation.SCHEMA,
                    description: "Location adjacent to a schema definition."
                  },
                  SCALAR: {
                    value: _directives.DirectiveLocation.SCALAR,
                    description: "Location adjacent to a scalar definition."
                  },
                  OBJECT: {
                    value: _directives.DirectiveLocation.OBJECT,
                    description:
                      "Location adjacent to an object type definition."
                  },
                  FIELD_DEFINITION: {
                    value: _directives.DirectiveLocation.FIELD_DEFINITION,
                    description: "Location adjacent to a field definition."
                  },
                  ARGUMENT_DEFINITION: {
                    value: _directives.DirectiveLocation.ARGUMENT_DEFINITION,
                    description: "Location adjacent to an argument definition."
                  },
                  INTERFACE: {
                    value: _directives.DirectiveLocation.INTERFACE,
                    description: "Location adjacent to an interface definition."
                  },
                  UNION: {
                    value: _directives.DirectiveLocation.UNION,
                    description: "Location adjacent to a union definition."
                  },
                  ENUM: {
                    value: _directives.DirectiveLocation.ENUM,
                    description: "Location adjacent to an enum definition."
                  },
                  ENUM_VALUE: {
                    value: _directives.DirectiveLocation.ENUM_VALUE,
                    description:
                      "Location adjacent to an enum value definition."
                  },
                  INPUT_OBJECT: {
                    value: _directives.DirectiveLocation.INPUT_OBJECT,
                    description:
                      "Location adjacent to an input object type definition."
                  },
                  INPUT_FIELD_DEFINITION: {
                    value: _directives.DirectiveLocation.INPUT_FIELD_DEFINITION,
                    description:
                      "Location adjacent to an input object field definition."
                  }
                }
              }
            )),
            __Type = (exports.__Type = new _definition.GraphQLObjectType({
              name: "__Type",
              isIntrospection: !0,
              description:
                "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name and description, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
              fields: function() {
                return {
                  kind: {
                    type: new _definition.GraphQLNonNull(__TypeKind),
                    resolve: function(type) {
                      if (type instanceof _definition.GraphQLScalarType)
                        return TypeKind.SCALAR;
                      if (type instanceof _definition.GraphQLObjectType)
                        return TypeKind.OBJECT;
                      if (type instanceof _definition.GraphQLInterfaceType)
                        return TypeKind.INTERFACE;
                      if (type instanceof _definition.GraphQLUnionType)
                        return TypeKind.UNION;
                      if (type instanceof _definition.GraphQLEnumType)
                        return TypeKind.ENUM;
                      if (type instanceof _definition.GraphQLInputObjectType)
                        return TypeKind.INPUT_OBJECT;
                      if (type instanceof _definition.GraphQLList)
                        return TypeKind.LIST;
                      if (type instanceof _definition.GraphQLNonNull)
                        return TypeKind.NON_NULL;
                      throw new Error("Unknown kind of type: " + type);
                    }
                  },
                  name: { type: _scalars.GraphQLString },
                  description: { type: _scalars.GraphQLString },
                  fields: {
                    type: new _definition.GraphQLList(
                      new _definition.GraphQLNonNull(__Field)
                    ),
                    args: {
                      includeDeprecated: {
                        type: _scalars.GraphQLBoolean,
                        defaultValue: !1
                      }
                    },
                    resolve: function(type, _ref) {
                      var includeDeprecated = _ref.includeDeprecated;
                      if (
                        type instanceof _definition.GraphQLObjectType ||
                        type instanceof _definition.GraphQLInterfaceType
                      ) {
                        var fieldMap = type.getFields(),
                          fields = Object.keys(fieldMap).map(function(
                            fieldName
                          ) {
                            return fieldMap[fieldName];
                          });
                        return (
                          includeDeprecated ||
                            (fields = fields.filter(function(field) {
                              return !field.deprecationReason;
                            })),
                          fields
                        );
                      }
                      return null;
                    }
                  },
                  interfaces: {
                    type: new _definition.GraphQLList(
                      new _definition.GraphQLNonNull(__Type)
                    ),
                    resolve: function(type) {
                      if (type instanceof _definition.GraphQLObjectType)
                        return type.getInterfaces();
                    }
                  },
                  possibleTypes: {
                    type: new _definition.GraphQLList(
                      new _definition.GraphQLNonNull(__Type)
                    ),
                    resolve: function(type, args, context, _ref2) {
                      var schema = _ref2.schema;
                      if ((0, _definition.isAbstractType)(type))
                        return schema.getPossibleTypes(type);
                    }
                  },
                  enumValues: {
                    type: new _definition.GraphQLList(
                      new _definition.GraphQLNonNull(__EnumValue)
                    ),
                    args: {
                      includeDeprecated: {
                        type: _scalars.GraphQLBoolean,
                        defaultValue: !1
                      }
                    },
                    resolve: function(type, _ref3) {
                      var includeDeprecated = _ref3.includeDeprecated;
                      if (type instanceof _definition.GraphQLEnumType) {
                        var values = type.getValues();
                        return (
                          includeDeprecated ||
                            (values = values.filter(function(value) {
                              return !value.deprecationReason;
                            })),
                          values
                        );
                      }
                    }
                  },
                  inputFields: {
                    type: new _definition.GraphQLList(
                      new _definition.GraphQLNonNull(__InputValue)
                    ),
                    resolve: function(type) {
                      if (type instanceof _definition.GraphQLInputObjectType) {
                        var fieldMap = type.getFields();
                        return Object.keys(fieldMap).map(function(fieldName) {
                          return fieldMap[fieldName];
                        });
                      }
                    }
                  },
                  ofType: { type: __Type }
                };
              }
            })),
            __Field = (exports.__Field = new _definition.GraphQLObjectType({
              name: "__Field",
              isIntrospection: !0,
              description:
                "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
              fields: function() {
                return {
                  name: {
                    type: new _definition.GraphQLNonNull(_scalars.GraphQLString)
                  },
                  description: { type: _scalars.GraphQLString },
                  args: {
                    type: new _definition.GraphQLNonNull(
                      new _definition.GraphQLList(
                        new _definition.GraphQLNonNull(__InputValue)
                      )
                    ),
                    resolve: function(field) {
                      return field.args || [];
                    }
                  },
                  type: { type: new _definition.GraphQLNonNull(__Type) },
                  isDeprecated: {
                    type: new _definition.GraphQLNonNull(
                      _scalars.GraphQLBoolean
                    )
                  },
                  deprecationReason: { type: _scalars.GraphQLString }
                };
              }
            })),
            __InputValue = (exports.__InputValue = new _definition.GraphQLObjectType(
              {
                name: "__InputValue",
                isIntrospection: !0,
                description:
                  "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
                fields: function() {
                  return {
                    name: {
                      type: new _definition.GraphQLNonNull(
                        _scalars.GraphQLString
                      )
                    },
                    description: { type: _scalars.GraphQLString },
                    type: { type: new _definition.GraphQLNonNull(__Type) },
                    defaultValue: {
                      type: _scalars.GraphQLString,
                      description:
                        "A GraphQL-formatted string representing the default value for this input value.",
                      resolve: function(inputVal) {
                        return (0, _isInvalid2.default)(inputVal.defaultValue)
                          ? null
                          : (0, _printer.print)(
                              (0, _astFromValue.astFromValue)(
                                inputVal.defaultValue,
                                inputVal.type
                              )
                            );
                      }
                    }
                  };
                }
              }
            )),
            __EnumValue = (exports.__EnumValue = new _definition.GraphQLObjectType(
              {
                name: "__EnumValue",
                isIntrospection: !0,
                description:
                  "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
                fields: function() {
                  return {
                    name: {
                      type: new _definition.GraphQLNonNull(
                        _scalars.GraphQLString
                      )
                    },
                    description: { type: _scalars.GraphQLString },
                    isDeprecated: {
                      type: new _definition.GraphQLNonNull(
                        _scalars.GraphQLBoolean
                      )
                    },
                    deprecationReason: { type: _scalars.GraphQLString }
                  };
                }
              }
            )),
            TypeKind = (exports.TypeKind = {
              SCALAR: "SCALAR",
              OBJECT: "OBJECT",
              INTERFACE: "INTERFACE",
              UNION: "UNION",
              ENUM: "ENUM",
              INPUT_OBJECT: "INPUT_OBJECT",
              LIST: "LIST",
              NON_NULL: "NON_NULL"
            }),
            __TypeKind = (exports.__TypeKind = new _definition.GraphQLEnumType({
              name: "__TypeKind",
              isIntrospection: !0,
              description:
                "An enum describing what kind of type a given `__Type` is.",
              values: {
                SCALAR: {
                  value: TypeKind.SCALAR,
                  description: "Indicates this type is a scalar."
                },
                OBJECT: {
                  value: TypeKind.OBJECT,
                  description:
                    "Indicates this type is an object. `fields` and `interfaces` are valid fields."
                },
                INTERFACE: {
                  value: TypeKind.INTERFACE,
                  description:
                    "Indicates this type is an interface. `fields` and `possibleTypes` are valid fields."
                },
                UNION: {
                  value: TypeKind.UNION,
                  description:
                    "Indicates this type is a union. `possibleTypes` is a valid field."
                },
                ENUM: {
                  value: TypeKind.ENUM,
                  description:
                    "Indicates this type is an enum. `enumValues` is a valid field."
                },
                INPUT_OBJECT: {
                  value: TypeKind.INPUT_OBJECT,
                  description:
                    "Indicates this type is an input object. `inputFields` is a valid field."
                },
                LIST: {
                  value: TypeKind.LIST,
                  description:
                    "Indicates this type is a list. `ofType` is a valid field."
                },
                NON_NULL: {
                  value: TypeKind.NON_NULL,
                  description:
                    "Indicates this type is a non-null. `ofType` is a valid field."
                }
              }
            }));
          (exports.SchemaMetaFieldDef = {
            name: "__schema",
            type: new _definition.GraphQLNonNull(__Schema),
            description: "Access the current type schema of this server.",
            args: [],
            resolve: function(source, args, context, _ref4) {
              return _ref4.schema;
            }
          }),
            (exports.TypeMetaFieldDef = {
              name: "__type",
              type: __Type,
              description: "Request the type information of a single type.",
              args: [
                {
                  name: "name",
                  type: new _definition.GraphQLNonNull(_scalars.GraphQLString)
                }
              ],
              resolve: function(source, _ref5, context, _ref6) {
                var name = _ref5.name;
                return _ref6.schema.getType(name);
              }
            }),
            (exports.TypeNameMetaFieldDef = {
              name: "__typename",
              type: new _definition.GraphQLNonNull(_scalars.GraphQLString),
              description: "The name of the current Object type at runtime.",
              args: [],
              resolve: function(source, args, context, _ref7) {
                return _ref7.parentType.name;
              }
            });
        },
        {
          "../jsutils/isInvalid": 104,
          "../language/printer": 115,
          "../utilities/astFromValue": 129,
          "./definition": 121,
          "./directives": 122,
          "./scalars": 125
        }
      ],
      125: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.GraphQLID = exports.GraphQLBoolean = exports.GraphQLString = exports.GraphQLFloat = exports.GraphQLInt = void 0);
          var _definition = require("./definition"),
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../language/kinds"));
          var MAX_INT = 2147483647,
            MIN_INT = -2147483648;
          function coerceInt(value) {
            if ("" === value)
              throw new TypeError(
                "Int cannot represent non 32-bit signed integer value: (empty string)"
              );
            var num = Number(value);
            if (num != num || MAX_INT < num || num < MIN_INT)
              throw new TypeError(
                "Int cannot represent non 32-bit signed integer value: " +
                  String(value)
              );
            var int = Math.floor(num);
            if (int !== num)
              throw new TypeError(
                "Int cannot represent non-integer value: " + String(value)
              );
            return int;
          }
          exports.GraphQLInt = new _definition.GraphQLScalarType({
            name: "Int",
            description:
              "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. ",
            serialize: coerceInt,
            parseValue: coerceInt,
            parseLiteral: function(ast) {
              if (ast.kind === Kind.INT) {
                var num = parseInt(ast.value, 10);
                if (num <= MAX_INT && MIN_INT <= num) return num;
              }
              return null;
            }
          });
          function coerceFloat(value) {
            if ("" === value)
              throw new TypeError(
                "Float cannot represent non numeric value: (empty string)"
              );
            var num = Number(value);
            if (num == num) return num;
            throw new TypeError(
              "Float cannot represent non numeric value: " + String(value)
            );
          }
          (exports.GraphQLFloat = new _definition.GraphQLScalarType({
            name: "Float",
            description:
              "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). ",
            serialize: coerceFloat,
            parseValue: coerceFloat,
            parseLiteral: function(ast) {
              return ast.kind === Kind.FLOAT || ast.kind === Kind.INT
                ? parseFloat(ast.value)
                : null;
            }
          })),
            (exports.GraphQLString = new _definition.GraphQLScalarType({
              name: "String",
              description:
                "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
              serialize: String,
              parseValue: String,
              parseLiteral: function(ast) {
                return ast.kind === Kind.STRING ? ast.value : null;
              }
            })),
            (exports.GraphQLBoolean = new _definition.GraphQLScalarType({
              name: "Boolean",
              description:
                "The `Boolean` scalar type represents `true` or `false`.",
              serialize: Boolean,
              parseValue: Boolean,
              parseLiteral: function(ast) {
                return ast.kind === Kind.BOOLEAN ? ast.value : null;
              }
            })),
            (exports.GraphQLID = new _definition.GraphQLScalarType({
              name: "ID",
              description:
                'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
              serialize: String,
              parseValue: String,
              parseLiteral: function(ast) {
                return ast.kind === Kind.STRING || ast.kind === Kind.INT
                  ? ast.value
                  : null;
              }
            }));
        },
        { "../language/kinds": 111, "./definition": 121 }
      ],
      126: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.GraphQLSchema = void 0);
          var _typeof =
              "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
                ? function(obj) {
                    return typeof obj;
                  }
                : function(obj) {
                    return obj &&
                      "function" == typeof Symbol &&
                      obj.constructor === Symbol &&
                      obj !== Symbol.prototype
                      ? "symbol"
                      : typeof obj;
                  },
            _definition = require("./definition"),
            _directives = require("./directives"),
            _introspection = require("./introspection"),
            _find2 = _interopRequireDefault(require("../jsutils/find")),
            _invariant2 = _interopRequireDefault(
              require("../jsutils/invariant")
            ),
            _typeComparators = require("../utilities/typeComparators");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          exports.GraphQLSchema = (function() {
            function GraphQLSchema(config) {
              var _this = this;
              !(function(instance, Constructor) {
                if (!(instance instanceof Constructor))
                  throw new TypeError("Cannot call a class as a function");
              })(this, GraphQLSchema),
                "object" !==
                  (void 0 === config ? "undefined" : _typeof(config)) &&
                  (0, _invariant2.default)(
                    0,
                    "Must provide configuration object."
                  ),
                config.query instanceof _definition.GraphQLObjectType ||
                  (0, _invariant2.default)(
                    0,
                    "Schema query must be Object Type but got: " +
                      String(config.query) +
                      "."
                  ),
                (this._queryType = config.query),
                !config.mutation ||
                  config.mutation instanceof _definition.GraphQLObjectType ||
                  (0, _invariant2.default)(
                    0,
                    "Schema mutation must be Object Type if provided but got: " +
                      String(config.mutation) +
                      "."
                  ),
                (this._mutationType = config.mutation),
                !config.subscription ||
                  config.subscription instanceof
                    _definition.GraphQLObjectType ||
                  (0, _invariant2.default)(
                    0,
                    "Schema subscription must be Object Type if provided but got: " +
                      String(config.subscription) +
                      "."
                  ),
                (this._subscriptionType = config.subscription),
                config.types &&
                  !Array.isArray(config.types) &&
                  (0, _invariant2.default)(
                    0,
                    "Schema types must be Array if provided but got: " +
                      String(config.types) +
                      "."
                  ),
                !config.directives ||
                  (Array.isArray(config.directives) &&
                    config.directives.every(function(directive) {
                      return directive instanceof _directives.GraphQLDirective;
                    })) ||
                  (0, _invariant2.default)(
                    0,
                    "Schema directives must be Array<GraphQLDirective> if provided but got: " +
                      String(config.directives) +
                      "."
                  ),
                (this._directives =
                  config.directives || _directives.specifiedDirectives),
                (this.astNode = config.astNode || null);
              var initialTypes = [
                  this.getQueryType(),
                  this.getMutationType(),
                  this.getSubscriptionType(),
                  _introspection.__Schema
                ],
                types = config.types;
              types && (initialTypes = initialTypes.concat(types)),
                (this._typeMap = initialTypes.reduce(
                  typeMapReducer,
                  Object.create(null)
                )),
                (this._implementations = Object.create(null)),
                Object.keys(this._typeMap).forEach(function(typeName) {
                  var type = _this._typeMap[typeName];
                  type instanceof _definition.GraphQLObjectType &&
                    type.getInterfaces().forEach(function(iface) {
                      var impls = _this._implementations[iface.name];
                      impls
                        ? impls.push(type)
                        : (_this._implementations[iface.name] = [type]);
                    });
                }),
                Object.keys(this._typeMap).forEach(function(typeName) {
                  var type = _this._typeMap[typeName];
                  type instanceof _definition.GraphQLObjectType &&
                    type.getInterfaces().forEach(function(iface) {
                      return (function(schema, object, iface) {
                        var objectFieldMap = object.getFields(),
                          ifaceFieldMap = iface.getFields();
                        Object.keys(ifaceFieldMap).forEach(function(fieldName) {
                          var objectField = objectFieldMap[fieldName],
                            ifaceField = ifaceFieldMap[fieldName];
                          objectField ||
                            (0, _invariant2.default)(
                              0,
                              '"' +
                                iface.name +
                                '" expects field "' +
                                fieldName +
                                '" but "' +
                                object.name +
                                '" does not provide it.'
                            ),
                            (0, _typeComparators.isTypeSubTypeOf)(
                              schema,
                              objectField.type,
                              ifaceField.type
                            ) ||
                              (0, _invariant2.default)(
                                0,
                                iface.name +
                                  "." +
                                  fieldName +
                                  ' expects type "' +
                                  String(ifaceField.type) +
                                  '" but ' +
                                  object.name +
                                  "." +
                                  fieldName +
                                  ' provides type "' +
                                  String(objectField.type) +
                                  '".'
                              ),
                            ifaceField.args.forEach(function(ifaceArg) {
                              var argName = ifaceArg.name,
                                objectArg = (0, _find2.default)(
                                  objectField.args,
                                  function(arg) {
                                    return arg.name === argName;
                                  }
                                );
                              objectArg ||
                                (0, _invariant2.default)(
                                  0,
                                  iface.name +
                                    "." +
                                    fieldName +
                                    ' expects argument "' +
                                    argName +
                                    '" but ' +
                                    object.name +
                                    "." +
                                    fieldName +
                                    " does not provide it."
                                ),
                                (0, _typeComparators.isEqualType)(
                                  ifaceArg.type,
                                  objectArg.type
                                ) ||
                                  (0, _invariant2.default)(
                                    0,
                                    iface.name +
                                      "." +
                                      fieldName +
                                      "(" +
                                      argName +
                                      ':) expects type "' +
                                      String(ifaceArg.type) +
                                      '" but ' +
                                      object.name +
                                      "." +
                                      fieldName +
                                      "(" +
                                      argName +
                                      ':) provides type "' +
                                      String(objectArg.type) +
                                      '".'
                                  );
                            }),
                            objectField.args.forEach(function(objectArg) {
                              var argName = objectArg.name,
                                ifaceArg = (0, _find2.default)(
                                  ifaceField.args,
                                  function(arg) {
                                    return arg.name === argName;
                                  }
                                );
                              ifaceArg ||
                                (objectArg.type instanceof
                                  _definition.GraphQLNonNull &&
                                  (0, _invariant2.default)(
                                    0,
                                    object.name +
                                      "." +
                                      fieldName +
                                      "(" +
                                      argName +
                                      ':) is of required type "' +
                                      String(objectArg.type) +
                                      '" but is not also provided by the interface ' +
                                      iface.name +
                                      "." +
                                      fieldName +
                                      "."
                                  ));
                            });
                        });
                      })(_this, type, iface);
                    });
                });
            }
            return (
              (GraphQLSchema.prototype.getQueryType = function() {
                return this._queryType;
              }),
              (GraphQLSchema.prototype.getMutationType = function() {
                return this._mutationType;
              }),
              (GraphQLSchema.prototype.getSubscriptionType = function() {
                return this._subscriptionType;
              }),
              (GraphQLSchema.prototype.getTypeMap = function() {
                return this._typeMap;
              }),
              (GraphQLSchema.prototype.getType = function(name) {
                return this.getTypeMap()[name];
              }),
              (GraphQLSchema.prototype.getPossibleTypes = function(
                abstractType
              ) {
                return abstractType instanceof _definition.GraphQLUnionType
                  ? abstractType.getTypes()
                  : (abstractType instanceof _definition.GraphQLInterfaceType ||
                      (0, _invariant2.default)(0),
                    this._implementations[abstractType.name]);
              }),
              (GraphQLSchema.prototype.isPossibleType = function(
                abstractType,
                possibleType
              ) {
                var possibleTypeMap = this._possibleTypeMap;
                if (
                  (possibleTypeMap ||
                    (this._possibleTypeMap = possibleTypeMap = Object.create(
                      null
                    )),
                  !possibleTypeMap[abstractType.name])
                ) {
                  var possibleTypes = this.getPossibleTypes(abstractType);
                  Array.isArray(possibleTypes) ||
                    (0, _invariant2.default)(
                      0,
                      "Could not find possible implementing types for " +
                        abstractType.name +
                        " in schema. Check that schema.types is defined and is an array of all possible types in the schema."
                    ),
                    (possibleTypeMap[abstractType.name] = possibleTypes.reduce(
                      function(map, type) {
                        return (map[type.name] = !0), map;
                      },
                      Object.create(null)
                    ));
                }
                return Boolean(
                  possibleTypeMap[abstractType.name][possibleType.name]
                );
              }),
              (GraphQLSchema.prototype.getDirectives = function() {
                return this._directives;
              }),
              (GraphQLSchema.prototype.getDirective = function(name) {
                return (0, _find2.default)(this.getDirectives(), function(
                  directive
                ) {
                  return directive.name === name;
                });
              }),
              GraphQLSchema
            );
          })();
          function typeMapReducer(map, type) {
            if (!type) return map;
            if (
              type instanceof _definition.GraphQLList ||
              type instanceof _definition.GraphQLNonNull
            )
              return typeMapReducer(map, type.ofType);
            if (map[type.name])
              return (
                map[type.name] !== type &&
                  (0, _invariant2.default)(
                    0,
                    'Schema must contain unique named types but contains multiple types named "' +
                      type.name +
                      '".'
                  ),
                map
              );
            map[type.name] = type;
            var reducedMap = map;
            if (
              (type instanceof _definition.GraphQLUnionType &&
                (reducedMap = type
                  .getTypes()
                  .reduce(typeMapReducer, reducedMap)),
              type instanceof _definition.GraphQLObjectType &&
                (reducedMap = type
                  .getInterfaces()
                  .reduce(typeMapReducer, reducedMap)),
              type instanceof _definition.GraphQLObjectType ||
                type instanceof _definition.GraphQLInterfaceType)
            ) {
              var fieldMap = type.getFields();
              Object.keys(fieldMap).forEach(function(fieldName) {
                var field = fieldMap[fieldName];
                if (field.args) {
                  var fieldArgTypes = field.args.map(function(arg) {
                    return arg.type;
                  });
                  reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);
                }
                reducedMap = typeMapReducer(reducedMap, field.type);
              });
            }
            if (type instanceof _definition.GraphQLInputObjectType) {
              var _fieldMap = type.getFields();
              Object.keys(_fieldMap).forEach(function(fieldName) {
                var field = _fieldMap[fieldName];
                reducedMap = typeMapReducer(reducedMap, field.type);
              });
            }
            return reducedMap;
          }
        },
        {
          "../jsutils/find": 102,
          "../jsutils/invariant": 103,
          "../utilities/typeComparators": 143,
          "./definition": 121,
          "./directives": 122,
          "./introspection": 124
        }
      ],
      127: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.TypeInfo = void 0);
          var obj,
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../language/kinds")),
            _definition = require("../type/definition"),
            _introspection = require("../type/introspection"),
            _typeFromAST = require("./typeFromAST"),
            _find = require("../jsutils/find"),
            _find2 = (obj = _find) && obj.__esModule ? obj : { default: obj };
          exports.TypeInfo = (function() {
            function TypeInfo(schema, getFieldDefFn) {
              !(function(instance, Constructor) {
                if (!(instance instanceof Constructor))
                  throw new TypeError("Cannot call a class as a function");
              })(this, TypeInfo),
                (this._schema = schema),
                (this._typeStack = []),
                (this._parentTypeStack = []),
                (this._inputTypeStack = []),
                (this._fieldDefStack = []),
                (this._directive = null),
                (this._argument = null),
                (this._enumValue = null),
                (this._getFieldDef = getFieldDefFn || getFieldDef);
            }
            return (
              (TypeInfo.prototype.getType = function() {
                if (0 < this._typeStack.length)
                  return this._typeStack[this._typeStack.length - 1];
              }),
              (TypeInfo.prototype.getParentType = function() {
                if (0 < this._parentTypeStack.length)
                  return this._parentTypeStack[
                    this._parentTypeStack.length - 1
                  ];
              }),
              (TypeInfo.prototype.getInputType = function() {
                if (0 < this._inputTypeStack.length)
                  return this._inputTypeStack[this._inputTypeStack.length - 1];
              }),
              (TypeInfo.prototype.getFieldDef = function() {
                if (0 < this._fieldDefStack.length)
                  return this._fieldDefStack[this._fieldDefStack.length - 1];
              }),
              (TypeInfo.prototype.getDirective = function() {
                return this._directive;
              }),
              (TypeInfo.prototype.getArgument = function() {
                return this._argument;
              }),
              (TypeInfo.prototype.getEnumValue = function() {
                return this._enumValue;
              }),
              (TypeInfo.prototype.enter = function(node) {
                var schema = this._schema;
                switch (node.kind) {
                  case Kind.SELECTION_SET:
                    var namedType = (0, _definition.getNamedType)(
                      this.getType()
                    );
                    this._parentTypeStack.push(
                      (0, _definition.isCompositeType)(namedType)
                        ? namedType
                        : void 0
                    );
                    break;
                  case Kind.FIELD:
                    var parentType = this.getParentType(),
                      fieldDef = void 0;
                    parentType &&
                      (fieldDef = this._getFieldDef(schema, parentType, node)),
                      this._fieldDefStack.push(fieldDef),
                      this._typeStack.push(fieldDef && fieldDef.type);
                    break;
                  case Kind.DIRECTIVE:
                    this._directive = schema.getDirective(node.name.value);
                    break;
                  case Kind.OPERATION_DEFINITION:
                    var type = void 0;
                    "query" === node.operation
                      ? (type = schema.getQueryType())
                      : "mutation" === node.operation
                        ? (type = schema.getMutationType())
                        : "subscription" === node.operation &&
                          (type = schema.getSubscriptionType()),
                      this._typeStack.push(type);
                    break;
                  case Kind.INLINE_FRAGMENT:
                  case Kind.FRAGMENT_DEFINITION:
                    var typeConditionAST = node.typeCondition,
                      outputType = typeConditionAST
                        ? (0, _typeFromAST.typeFromAST)(
                            schema,
                            typeConditionAST
                          )
                        : this.getType();
                    this._typeStack.push(
                      (0, _definition.isOutputType)(outputType)
                        ? outputType
                        : void 0
                    );
                    break;
                  case Kind.VARIABLE_DEFINITION:
                    var inputType = (0, _typeFromAST.typeFromAST)(
                      schema,
                      node.type
                    );
                    this._inputTypeStack.push(
                      (0, _definition.isInputType)(inputType)
                        ? inputType
                        : void 0
                    );
                    break;
                  case Kind.ARGUMENT:
                    var argDef = void 0,
                      argType = void 0,
                      fieldOrDirective =
                        this.getDirective() || this.getFieldDef();
                    fieldOrDirective &&
                      (argDef = (0, _find2.default)(
                        fieldOrDirective.args,
                        function(arg) {
                          return arg.name === node.name.value;
                        }
                      )) &&
                      (argType = argDef.type),
                      (this._argument = argDef),
                      this._inputTypeStack.push(argType);
                    break;
                  case Kind.LIST:
                    var listType = (0, _definition.getNullableType)(
                      this.getInputType()
                    );
                    this._inputTypeStack.push(
                      listType instanceof _definition.GraphQLList
                        ? listType.ofType
                        : void 0
                    );
                    break;
                  case Kind.OBJECT_FIELD:
                    var objectType = (0, _definition.getNamedType)(
                        this.getInputType()
                      ),
                      fieldType = void 0;
                    if (
                      objectType instanceof _definition.GraphQLInputObjectType
                    ) {
                      var inputField = objectType.getFields()[node.name.value];
                      fieldType = inputField ? inputField.type : void 0;
                    }
                    this._inputTypeStack.push(fieldType);
                    break;
                  case Kind.ENUM:
                    var enumType = (0, _definition.getNamedType)(
                        this.getInputType()
                      ),
                      enumValue = void 0;
                    enumType instanceof _definition.GraphQLEnumType &&
                      (enumValue = enumType.getValue(node.value)),
                      (this._enumValue = enumValue);
                }
              }),
              (TypeInfo.prototype.leave = function(node) {
                switch (node.kind) {
                  case Kind.SELECTION_SET:
                    this._parentTypeStack.pop();
                    break;
                  case Kind.FIELD:
                    this._fieldDefStack.pop(), this._typeStack.pop();
                    break;
                  case Kind.DIRECTIVE:
                    this._directive = null;
                    break;
                  case Kind.OPERATION_DEFINITION:
                  case Kind.INLINE_FRAGMENT:
                  case Kind.FRAGMENT_DEFINITION:
                    this._typeStack.pop();
                    break;
                  case Kind.VARIABLE_DEFINITION:
                    this._inputTypeStack.pop();
                    break;
                  case Kind.ARGUMENT:
                    (this._argument = null), this._inputTypeStack.pop();
                    break;
                  case Kind.LIST:
                  case Kind.OBJECT_FIELD:
                    this._inputTypeStack.pop();
                    break;
                  case Kind.ENUM:
                    this._enumValue = null;
                }
              }),
              TypeInfo
            );
          })();
          function getFieldDef(schema, parentType, fieldNode) {
            var name = fieldNode.name.value;
            return name === _introspection.SchemaMetaFieldDef.name &&
              schema.getQueryType() === parentType
              ? _introspection.SchemaMetaFieldDef
              : name === _introspection.TypeMetaFieldDef.name &&
                schema.getQueryType() === parentType
                ? _introspection.TypeMetaFieldDef
                : name === _introspection.TypeNameMetaFieldDef.name &&
                  (0, _definition.isCompositeType)(parentType)
                  ? _introspection.TypeNameMetaFieldDef
                  : parentType instanceof _definition.GraphQLObjectType ||
                    parentType instanceof _definition.GraphQLInterfaceType
                    ? parentType.getFields()[name]
                    : void 0;
          }
        },
        {
          "../jsutils/find": 102,
          "../language/kinds": 111,
          "../type/definition": 121,
          "../type/introspection": 124,
          "./typeFromAST": 144
        }
      ],
      128: [
        function(require, module, exports) {
          (function(process) {
            "use strict";
            Object.defineProperty(exports, "__esModule", { value: !0 }),
              (exports.assertValidName = function(name, isIntrospection) {
                if (!name || "string" != typeof name)
                  throw new Error(
                    "Must be named. Unexpected name: " + name + "."
                  );
                if (
                  !isIntrospection &&
                  !hasWarnedAboutDunder &&
                  !noNameWarning &&
                  "__" === name.slice(0, 2) &&
                  ((hasWarnedAboutDunder = !0), console && console.warn)
                ) {
                  var error = new Error(
                    'Name "' +
                      name +
                      '" must not begin with "__", which is reserved by GraphQL introspection. In a future release of graphql this will become a hard error.'
                  );
                  console.warn(formatWarning(error));
                }
                if (!NAME_RX.test(name))
                  throw new Error(
                    'Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "' +
                      name +
                      '" does not.'
                  );
              }),
              (exports.formatWarning = formatWarning);
            var NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/,
              ERROR_PREFIX_RX = /^Error: /,
              noNameWarning = Boolean(
                process && process.env && process.env.GRAPHQL_NO_NAME_WARNING
              ),
              hasWarnedAboutDunder = !1;
            function formatWarning(error) {
              var formatted = "",
                errorString = String(error).replace(ERROR_PREFIX_RX, ""),
                stack = error.stack;
              return (
                stack && (formatted = stack.replace(ERROR_PREFIX_RX, "")),
                -1 === formatted.indexOf(errorString) &&
                  (formatted = errorString + "\n" + formatted),
                formatted.trim()
              );
            }
          }.call(this, require("_process")));
        },
        { _process: 235 }
      ],
      129: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _typeof =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    "function" == typeof Symbol &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? "symbol"
                    : typeof obj;
                };
          exports.astFromValue = function astFromValue(value, type) {
            var _value = value;
            if (type instanceof _definition.GraphQLNonNull) {
              var astValue = astFromValue(_value, type.ofType);
              return astValue && astValue.kind === Kind.NULL ? null : astValue;
            }
            if (null === _value) return { kind: Kind.NULL };
            if ((0, _isInvalid2.default)(_value)) return null;
            if (type instanceof _definition.GraphQLList) {
              var itemType = type.ofType;
              if ((0, _iterall.isCollection)(_value)) {
                var valuesNodes = [];
                return (
                  (0, _iterall.forEach)(_value, function(item) {
                    var itemNode = astFromValue(item, itemType);
                    itemNode && valuesNodes.push(itemNode);
                  }),
                  { kind: Kind.LIST, values: valuesNodes }
                );
              }
              return astFromValue(_value, itemType);
            }
            if (type instanceof _definition.GraphQLInputObjectType) {
              if (
                null === _value ||
                "object" !== (void 0 === _value ? "undefined" : _typeof(_value))
              )
                return null;
              var fields = type.getFields(),
                fieldNodes = [];
              return (
                Object.keys(fields).forEach(function(fieldName) {
                  var fieldType = fields[fieldName].type,
                    fieldValue = astFromValue(_value[fieldName], fieldType);
                  fieldValue &&
                    fieldNodes.push({
                      kind: Kind.OBJECT_FIELD,
                      name: { kind: Kind.NAME, value: fieldName },
                      value: fieldValue
                    });
                }),
                { kind: Kind.OBJECT, fields: fieldNodes }
              );
            }
            type instanceof _definition.GraphQLScalarType ||
              type instanceof _definition.GraphQLEnumType ||
              (0, _invariant2.default)(
                0,
                "Must provide Input Type, cannot use: " + String(type)
              );
            var serialized = type.serialize(_value);
            if ((0, _isNullish2.default)(serialized)) return null;
            if ("boolean" == typeof serialized)
              return { kind: Kind.BOOLEAN, value: serialized };
            if ("number" == typeof serialized) {
              var stringNum = String(serialized);
              return /^[0-9]+$/.test(stringNum)
                ? { kind: Kind.INT, value: stringNum }
                : { kind: Kind.FLOAT, value: stringNum };
            }
            if ("string" == typeof serialized)
              return type instanceof _definition.GraphQLEnumType
                ? { kind: Kind.ENUM, value: serialized }
                : type === _scalars.GraphQLID && /^[0-9]+$/.test(serialized)
                  ? { kind: Kind.INT, value: serialized }
                  : {
                      kind: Kind.STRING,
                      value: JSON.stringify(serialized).slice(1, -1)
                    };
            throw new TypeError(
              "Cannot convert value to AST: " + String(serialized)
            );
          };
          var _iterall = require("iterall"),
            _invariant2 = _interopRequireDefault(
              require("../jsutils/invariant")
            ),
            _isNullish2 = _interopRequireDefault(
              require("../jsutils/isNullish")
            ),
            _isInvalid2 = _interopRequireDefault(
              require("../jsutils/isInvalid")
            ),
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../language/kinds")),
            _definition = require("../type/definition"),
            _scalars = require("../type/scalars");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
        },
        {
          "../jsutils/invariant": 103,
          "../jsutils/isInvalid": 104,
          "../jsutils/isNullish": 105,
          "../language/kinds": 111,
          "../type/definition": 121,
          "../type/scalars": 125,
          iterall: 175
        }
      ],
      130: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.buildASTSchema = buildASTSchema),
            (exports.getDeprecationReason = getDeprecationReason),
            (exports.getDescription = getDescription),
            (exports.buildSchema = function(source) {
              return buildASTSchema((0, _parser.parse)(source));
            });
          var _invariant2 = _interopRequireDefault(
              require("../jsutils/invariant")
            ),
            _keyValMap2 = _interopRequireDefault(
              require("../jsutils/keyValMap")
            ),
            _valueFromAST = require("./valueFromAST"),
            _lexer = require("../language/lexer"),
            _parser = require("../language/parser"),
            _values = require("../execution/values"),
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../language/kinds")),
            _schema = require("../type/schema"),
            _scalars = require("../type/scalars"),
            _definition = require("../type/definition"),
            _directives = require("../type/directives"),
            _introspection = require("../type/introspection");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function buildASTSchema(ast) {
            if (!ast || ast.kind !== Kind.DOCUMENT)
              throw new Error("Must provide a document ast.");
            for (
              var schemaDef = void 0,
                typeDefs = [],
                nodeMap = Object.create(null),
                directiveDefs = [],
                i = 0;
              i < ast.definitions.length;
              i++
            ) {
              var d = ast.definitions[i];
              switch (d.kind) {
                case Kind.SCHEMA_DEFINITION:
                  if (schemaDef)
                    throw new Error("Must provide only one schema definition.");
                  schemaDef = d;
                  break;
                case Kind.SCALAR_TYPE_DEFINITION:
                case Kind.OBJECT_TYPE_DEFINITION:
                case Kind.INTERFACE_TYPE_DEFINITION:
                case Kind.ENUM_TYPE_DEFINITION:
                case Kind.UNION_TYPE_DEFINITION:
                case Kind.INPUT_OBJECT_TYPE_DEFINITION:
                  var typeName = d.name.value;
                  if (nodeMap[typeName])
                    throw new Error(
                      'Type "' + typeName + '" was defined more than once.'
                    );
                  typeDefs.push(d), (nodeMap[typeName] = d);
                  break;
                case Kind.DIRECTIVE_DEFINITION:
                  directiveDefs.push(d);
              }
            }
            var queryTypeName = void 0,
              mutationTypeName = void 0,
              subscriptionTypeName = void 0;
            if (
              (schemaDef
                ? schemaDef.operationTypes.forEach(function(operationType) {
                    var typeName = operationType.type.name.value;
                    if ("query" === operationType.operation) {
                      if (queryTypeName)
                        throw new Error(
                          "Must provide only one query type in schema."
                        );
                      if (!nodeMap[typeName])
                        throw new Error(
                          'Specified query type "' +
                            typeName +
                            '" not found in document.'
                        );
                      queryTypeName = typeName;
                    } else if ("mutation" === operationType.operation) {
                      if (mutationTypeName)
                        throw new Error(
                          "Must provide only one mutation type in schema."
                        );
                      if (!nodeMap[typeName])
                        throw new Error(
                          'Specified mutation type "' +
                            typeName +
                            '" not found in document.'
                        );
                      mutationTypeName = typeName;
                    } else if ("subscription" === operationType.operation) {
                      if (subscriptionTypeName)
                        throw new Error(
                          "Must provide only one subscription type in schema."
                        );
                      if (!nodeMap[typeName])
                        throw new Error(
                          'Specified subscription type "' +
                            typeName +
                            '" not found in document.'
                        );
                      subscriptionTypeName = typeName;
                    }
                  })
                : (nodeMap.Query && (queryTypeName = "Query"),
                  nodeMap.Mutation && (mutationTypeName = "Mutation"),
                  nodeMap.Subscription &&
                    (subscriptionTypeName = "Subscription")),
              !queryTypeName)
            )
              throw new Error(
                "Must provide schema definition with query type or a type named Query."
              );
            var innerTypeMap = {
                String: _scalars.GraphQLString,
                Int: _scalars.GraphQLInt,
                Float: _scalars.GraphQLFloat,
                Boolean: _scalars.GraphQLBoolean,
                ID: _scalars.GraphQLID,
                __Schema: _introspection.__Schema,
                __Directive: _introspection.__Directive,
                __DirectiveLocation: _introspection.__DirectiveLocation,
                __Type: _introspection.__Type,
                __Field: _introspection.__Field,
                __InputValue: _introspection.__InputValue,
                __EnumValue: _introspection.__EnumValue,
                __TypeKind: _introspection.__TypeKind
              },
              types = typeDefs.map(function(def) {
                return typeDefNamed(def.name.value);
              }),
              directives = directiveDefs.map(function(directiveNode) {
                return new _directives.GraphQLDirective({
                  name: directiveNode.name.value,
                  description: getDescription(directiveNode),
                  locations: directiveNode.locations.map(function(node) {
                    return node.value;
                  }),
                  args:
                    directiveNode.arguments &&
                    makeInputValues(directiveNode.arguments),
                  astNode: directiveNode
                });
              });
            return (
              directives.some(function(directive) {
                return "skip" === directive.name;
              }) || directives.push(_directives.GraphQLSkipDirective),
              directives.some(function(directive) {
                return "include" === directive.name;
              }) || directives.push(_directives.GraphQLIncludeDirective),
              directives.some(function(directive) {
                return "deprecated" === directive.name;
              }) || directives.push(_directives.GraphQLDeprecatedDirective),
              new _schema.GraphQLSchema({
                query: getObjectType(nodeMap[queryTypeName]),
                mutation: mutationTypeName
                  ? getObjectType(nodeMap[mutationTypeName])
                  : null,
                subscription: subscriptionTypeName
                  ? getObjectType(nodeMap[subscriptionTypeName])
                  : null,
                types: types,
                directives: directives,
                astNode: schemaDef
              })
            );
            function getObjectType(typeNode) {
              var type = typeDefNamed(typeNode.name.value);
              return (
                type instanceof _definition.GraphQLObjectType ||
                  (0, _invariant2.default)(0, "AST must provide object type."),
                type
              );
            }
            function produceType(typeNode) {
              return (function buildWrappedType(innerType, inputTypeNode) {
                if (inputTypeNode.kind === Kind.LIST_TYPE)
                  return new _definition.GraphQLList(
                    buildWrappedType(innerType, inputTypeNode.type)
                  );
                if (inputTypeNode.kind === Kind.NON_NULL_TYPE) {
                  var wrappedType = buildWrappedType(
                    innerType,
                    inputTypeNode.type
                  );
                  return (
                    wrappedType instanceof _definition.GraphQLNonNull &&
                      (0, _invariant2.default)(0, "No nesting nonnull."),
                    new _definition.GraphQLNonNull(wrappedType)
                  );
                }
                return innerType;
              })(
                typeDefNamed(
                  (function(typeNode) {
                    for (
                      var namedType = typeNode;
                      namedType.kind === Kind.LIST_TYPE ||
                      namedType.kind === Kind.NON_NULL_TYPE;

                    )
                      namedType = namedType.type;
                    return namedType;
                  })(typeNode).name.value
                ),
                typeNode
              );
            }
            function typeDefNamed(typeName) {
              if (innerTypeMap[typeName]) return innerTypeMap[typeName];
              if (!nodeMap[typeName])
                throw new Error(
                  'Type "' + typeName + '" not found in document.'
                );
              var innerTypeDef = (function(def) {
                if (!def) throw new Error("def must be defined");
                switch (def.kind) {
                  case Kind.OBJECT_TYPE_DEFINITION:
                    return (function(def) {
                      var typeName = def.name.value;
                      return new _definition.GraphQLObjectType({
                        name: typeName,
                        description: getDescription(def),
                        fields: function() {
                          return makeFieldDefMap(def);
                        },
                        interfaces: function() {
                          return (function(def) {
                            return (
                              def.interfaces &&
                              def.interfaces.map(function(iface) {
                                return (
                                  (type = produceType(iface)) instanceof
                                    _definition.GraphQLInterfaceType ||
                                    (0, _invariant2.default)(
                                      0,
                                      "Expected Interface type."
                                    ),
                                  type
                                );
                                var type;
                              })
                            );
                          })(def);
                        },
                        astNode: def
                      });
                    })(def);
                  case Kind.INTERFACE_TYPE_DEFINITION:
                    return (function(def) {
                      var typeName = def.name.value;
                      return new _definition.GraphQLInterfaceType({
                        name: typeName,
                        description: getDescription(def),
                        fields: function() {
                          return makeFieldDefMap(def);
                        },
                        astNode: def,
                        resolveType: cannotExecuteSchema
                      });
                    })(def);
                  case Kind.ENUM_TYPE_DEFINITION:
                    return (function(def) {
                      return new _definition.GraphQLEnumType({
                        name: def.name.value,
                        description: getDescription(def),
                        values: (0, _keyValMap2.default)(
                          def.values,
                          function(enumValue) {
                            return enumValue.name.value;
                          },
                          function(enumValue) {
                            return {
                              description: getDescription(enumValue),
                              deprecationReason: getDeprecationReason(
                                enumValue
                              ),
                              astNode: enumValue
                            };
                          }
                        ),
                        astNode: def
                      });
                    })(def);
                  case Kind.UNION_TYPE_DEFINITION:
                    return (function(def) {
                      return new _definition.GraphQLUnionType({
                        name: def.name.value,
                        description: getDescription(def),
                        types: def.types.map(function(t) {
                          return (
                            (type = produceType(t)) instanceof
                              _definition.GraphQLObjectType ||
                              (0, _invariant2.default)(
                                0,
                                "Expected Object type."
                              ),
                            type
                          );
                          var type;
                        }),
                        resolveType: cannotExecuteSchema,
                        astNode: def
                      });
                    })(def);
                  case Kind.SCALAR_TYPE_DEFINITION:
                    return (function(def) {
                      return new _definition.GraphQLScalarType({
                        name: def.name.value,
                        description: getDescription(def),
                        astNode: def,
                        serialize: function() {
                          return null;
                        },
                        parseValue: function() {
                          return !1;
                        },
                        parseLiteral: function() {
                          return !1;
                        }
                      });
                    })(def);
                  case Kind.INPUT_OBJECT_TYPE_DEFINITION:
                    return (function(def) {
                      return new _definition.GraphQLInputObjectType({
                        name: def.name.value,
                        description: getDescription(def),
                        fields: function() {
                          return makeInputValues(def.fields);
                        },
                        astNode: def
                      });
                    })(def);
                  default:
                    throw new Error(
                      'Type kind "' + def.kind + '" not supported.'
                    );
                }
              })(nodeMap[typeName]);
              if (!innerTypeDef)
                throw new Error('Nothing constructed for "' + typeName + '".');
              return (innerTypeMap[typeName] = innerTypeDef);
            }
            function makeFieldDefMap(def) {
              return (0, _keyValMap2.default)(
                def.fields,
                function(field) {
                  return field.name.value;
                },
                function(field) {
                  return {
                    type: ((typeNode = field.type),
                    (0, _definition.assertOutputType)(produceType(typeNode))),
                    description: getDescription(field),
                    args: makeInputValues(field.arguments),
                    deprecationReason: getDeprecationReason(field),
                    astNode: field
                  };
                  var typeNode;
                }
              );
            }
            function makeInputValues(values) {
              return (0, _keyValMap2.default)(
                values,
                function(value) {
                  return value.name.value;
                },
                function(value) {
                  var typeNode,
                    type = ((typeNode = value.type),
                    (0, _definition.assertInputType)(produceType(typeNode)));
                  return {
                    type: type,
                    description: getDescription(value),
                    defaultValue: (0, _valueFromAST.valueFromAST)(
                      value.defaultValue,
                      type
                    ),
                    astNode: value
                  };
                }
              );
            }
          }
          function getDeprecationReason(node) {
            var deprecated = (0, _values.getDirectiveValues)(
              _directives.GraphQLDeprecatedDirective,
              node
            );
            return deprecated && deprecated.reason;
          }
          function getDescription(node) {
            var loc = node.loc;
            if (loc) {
              for (
                var comments = [],
                  minSpaces = void 0,
                  token = loc.startToken.prev;
                token &&
                token.kind === _lexer.TokenKind.COMMENT &&
                token.next &&
                token.prev &&
                token.line + 1 === token.next.line &&
                token.line !== token.prev.line;

              ) {
                var value = String(token.value),
                  spaces = leadingSpaces(value);
                (void 0 === minSpaces || spaces < minSpaces) &&
                  (minSpaces = spaces),
                  comments.push(value),
                  (token = token.prev);
              }
              return comments
                .reverse()
                .map(function(comment) {
                  return comment.slice(minSpaces);
                })
                .join("\n");
            }
          }
          function leadingSpaces(str) {
            for (var i = 0; i < str.length && " " === str[i]; i++);
            return i;
          }
          function cannotExecuteSchema() {
            throw new Error(
              "Generated Schema cannot use Interface or Union types for execution."
            );
          }
        },
        {
          "../execution/values": 99,
          "../jsutils/invariant": 103,
          "../jsutils/keyValMap": 107,
          "../language/kinds": 111,
          "../language/lexer": 112,
          "../language/parser": 114,
          "../type/definition": 121,
          "../type/directives": 122,
          "../type/introspection": 124,
          "../type/scalars": 125,
          "../type/schema": 126,
          "./valueFromAST": 145
        }
      ],
      131: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.buildClientSchema = function(introspection) {
              var schemaIntrospection = introspection.__schema,
                typeIntrospectionMap = (0, _keyMap2.default)(
                  schemaIntrospection.types,
                  function(type) {
                    return type.name;
                  }
                ),
                typeDefCache = {
                  String: _scalars.GraphQLString,
                  Int: _scalars.GraphQLInt,
                  Float: _scalars.GraphQLFloat,
                  Boolean: _scalars.GraphQLBoolean,
                  ID: _scalars.GraphQLID,
                  __Schema: _introspection.__Schema,
                  __Directive: _introspection.__Directive,
                  __DirectiveLocation: _introspection.__DirectiveLocation,
                  __Type: _introspection.__Type,
                  __Field: _introspection.__Field,
                  __InputValue: _introspection.__InputValue,
                  __EnumValue: _introspection.__EnumValue,
                  __TypeKind: _introspection.__TypeKind
                };
              function getType(typeRef) {
                if (typeRef.kind === _introspection.TypeKind.LIST) {
                  var itemRef = typeRef.ofType;
                  if (!itemRef)
                    throw new Error(
                      "Decorated type deeper than introspection query."
                    );
                  return new _definition.GraphQLList(getType(itemRef));
                }
                if (typeRef.kind === _introspection.TypeKind.NON_NULL) {
                  var nullableRef = typeRef.ofType;
                  if (!nullableRef)
                    throw new Error(
                      "Decorated type deeper than introspection query."
                    );
                  var nullableType = getType(nullableRef);
                  return (
                    nullableType instanceof _definition.GraphQLNonNull &&
                      (0, _invariant2.default)(0, "No nesting nonnull."),
                    new _definition.GraphQLNonNull(nullableType)
                  );
                }
                return getNamedType(typeRef.name);
              }
              function getNamedType(typeName) {
                if (typeDefCache[typeName]) return typeDefCache[typeName];
                var typeIntrospection = typeIntrospectionMap[typeName];
                if (!typeIntrospection)
                  throw new Error(
                    "Invalid or incomplete schema, unknown type: " +
                      typeName +
                      ". Ensure that a full introspection query is used in order to build a client schema."
                  );
                var typeDef = (function(type) {
                  switch (type.kind) {
                    case _introspection.TypeKind.SCALAR:
                      return (
                        (scalarIntrospection = type),
                        new _definition.GraphQLScalarType({
                          name: scalarIntrospection.name,
                          description: scalarIntrospection.description,
                          serialize: function(id) {
                            return id;
                          },
                          parseValue: function() {
                            return !1;
                          },
                          parseLiteral: function() {
                            return !1;
                          }
                        })
                      );
                    case _introspection.TypeKind.OBJECT:
                      return (
                        (objectIntrospection = type),
                        new _definition.GraphQLObjectType({
                          name: objectIntrospection.name,
                          description: objectIntrospection.description,
                          interfaces: objectIntrospection.interfaces.map(
                            getInterfaceType
                          ),
                          fields: function() {
                            return buildFieldDefMap(objectIntrospection);
                          }
                        })
                      );
                    case _introspection.TypeKind.INTERFACE:
                      return (
                        (interfaceIntrospection = type),
                        new _definition.GraphQLInterfaceType({
                          name: interfaceIntrospection.name,
                          description: interfaceIntrospection.description,
                          fields: function() {
                            return buildFieldDefMap(interfaceIntrospection);
                          },
                          resolveType: cannotExecuteClientSchema
                        })
                      );
                    case _introspection.TypeKind.UNION:
                      return (
                        (unionIntrospection = type),
                        new _definition.GraphQLUnionType({
                          name: unionIntrospection.name,
                          description: unionIntrospection.description,
                          types: unionIntrospection.possibleTypes.map(
                            getObjectType
                          ),
                          resolveType: cannotExecuteClientSchema
                        })
                      );
                    case _introspection.TypeKind.ENUM:
                      return (
                        (enumIntrospection = type),
                        new _definition.GraphQLEnumType({
                          name: enumIntrospection.name,
                          description: enumIntrospection.description,
                          values: (0, _keyValMap2.default)(
                            enumIntrospection.enumValues,
                            function(valueIntrospection) {
                              return valueIntrospection.name;
                            },
                            function(valueIntrospection) {
                              return {
                                description: valueIntrospection.description,
                                deprecationReason:
                                  valueIntrospection.deprecationReason
                              };
                            }
                          )
                        })
                      );
                    case _introspection.TypeKind.INPUT_OBJECT:
                      return (
                        (inputObjectIntrospection = type),
                        new _definition.GraphQLInputObjectType({
                          name: inputObjectIntrospection.name,
                          description: inputObjectIntrospection.description,
                          fields: function() {
                            return buildInputValueDefMap(
                              inputObjectIntrospection.inputFields
                            );
                          }
                        })
                      );
                    default:
                      throw new Error(
                        "Invalid or incomplete schema, unknown kind: " +
                          type.kind +
                          ". Ensure that a full introspection query is used in order to build a client schema."
                      );
                  }
                  var inputObjectIntrospection;
                  var enumIntrospection;
                  var unionIntrospection;
                  var interfaceIntrospection;
                  var objectIntrospection;
                  var scalarIntrospection;
                })(typeIntrospection);
                return (typeDefCache[typeName] = typeDef);
              }
              function getObjectType(typeRef) {
                var type = getType(typeRef);
                return (
                  type instanceof _definition.GraphQLObjectType ||
                    (0, _invariant2.default)(
                      0,
                      "Introspection must provide object type for possibleTypes."
                    ),
                  type
                );
              }
              function getInterfaceType(typeRef) {
                var type = getType(typeRef);
                return (
                  type instanceof _definition.GraphQLInterfaceType ||
                    (0, _invariant2.default)(
                      0,
                      "Introspection must provide interface type for interfaces."
                    ),
                  type
                );
              }
              function buildFieldDefMap(typeIntrospection) {
                return (0, _keyValMap2.default)(
                  typeIntrospection.fields,
                  function(fieldIntrospection) {
                    return fieldIntrospection.name;
                  },
                  function(fieldIntrospection) {
                    return {
                      description: fieldIntrospection.description,
                      deprecationReason: fieldIntrospection.deprecationReason,
                      type: ((typeRef = fieldIntrospection.type),
                      (type = getType(typeRef)),
                      (0, _definition.isOutputType)(type) ||
                        (0, _invariant2.default)(
                          0,
                          "Introspection must provide output type for fields."
                        ),
                      type),
                      args: buildInputValueDefMap(fieldIntrospection.args)
                    };
                    var typeRef, type;
                  }
                );
              }
              function buildInputValueDefMap(inputValueIntrospections) {
                return (0, _keyValMap2.default)(
                  inputValueIntrospections,
                  function(inputValue) {
                    return inputValue.name;
                  },
                  buildInputValue
                );
              }
              function buildInputValue(inputValueIntrospection) {
                var type = (function(typeRef) {
                    var type = getType(typeRef);
                    return (
                      (0, _definition.isInputType)(type) ||
                        (0, _invariant2.default)(
                          0,
                          "Introspection must provide input type for arguments."
                        ),
                      type
                    );
                  })(inputValueIntrospection.type),
                  defaultValue = inputValueIntrospection.defaultValue
                    ? (0, _valueFromAST.valueFromAST)(
                        (0, _parser.parseValue)(
                          inputValueIntrospection.defaultValue
                        ),
                        type
                      )
                    : void 0;
                return {
                  name: inputValueIntrospection.name,
                  description: inputValueIntrospection.description,
                  type: type,
                  defaultValue: defaultValue
                };
              }
              var types = schemaIntrospection.types.map(function(
                  typeIntrospection
                ) {
                  return getNamedType(typeIntrospection.name);
                }),
                queryType = getObjectType(schemaIntrospection.queryType),
                mutationType = schemaIntrospection.mutationType
                  ? getObjectType(schemaIntrospection.mutationType)
                  : null,
                subscriptionType = schemaIntrospection.subscriptionType
                  ? getObjectType(schemaIntrospection.subscriptionType)
                  : null,
                directives = schemaIntrospection.directives
                  ? schemaIntrospection.directives.map(function(
                      directiveIntrospection
                    ) {
                      var locations = directiveIntrospection.locations
                        ? directiveIntrospection.locations.slice()
                        : [].concat(
                            directiveIntrospection.onField
                              ? [_directives.DirectiveLocation.FIELD]
                              : [],
                            directiveIntrospection.onOperation
                              ? [
                                  _directives.DirectiveLocation.QUERY,
                                  _directives.DirectiveLocation.MUTATION,
                                  _directives.DirectiveLocation.SUBSCRIPTION
                                ]
                              : [],
                            directiveIntrospection.onFragment
                              ? [
                                  _directives.DirectiveLocation
                                    .FRAGMENT_DEFINITION,
                                  _directives.DirectiveLocation.FRAGMENT_SPREAD,
                                  _directives.DirectiveLocation.INLINE_FRAGMENT
                                ]
                              : []
                          );
                      return new _directives.GraphQLDirective({
                        name: directiveIntrospection.name,
                        description: directiveIntrospection.description,
                        locations: locations,
                        args: buildInputValueDefMap(directiveIntrospection.args)
                      });
                    })
                  : [];
              return new _schema.GraphQLSchema({
                query: queryType,
                mutation: mutationType,
                subscription: subscriptionType,
                types: types,
                directives: directives
              });
            });
          var _invariant2 = _interopRequireDefault(
              require("../jsutils/invariant")
            ),
            _keyMap2 = _interopRequireDefault(require("../jsutils/keyMap")),
            _keyValMap2 = _interopRequireDefault(
              require("../jsutils/keyValMap")
            ),
            _valueFromAST = require("./valueFromAST"),
            _parser = require("../language/parser"),
            _schema = require("../type/schema"),
            _definition = require("../type/definition"),
            _introspection = require("../type/introspection"),
            _scalars = require("../type/scalars"),
            _directives = require("../type/directives");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function cannotExecuteClientSchema() {
            throw new Error(
              "Client Schema cannot use Interface or Union types for execution."
            );
          }
        },
        {
          "../jsutils/invariant": 103,
          "../jsutils/keyMap": 106,
          "../jsutils/keyValMap": 107,
          "../language/parser": 114,
          "../type/definition": 121,
          "../type/directives": 122,
          "../type/introspection": 124,
          "../type/scalars": 125,
          "../type/schema": 126,
          "./valueFromAST": 145
        }
      ],
      132: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.concatAST = function(asts) {
              for (var batchDefinitions = [], i = 0; i < asts.length; i++)
                for (
                  var definitions = asts[i].definitions, j = 0;
                  j < definitions.length;
                  j++
                )
                  batchDefinitions.push(definitions[j]);
              return { kind: "Document", definitions: batchDefinitions };
            });
        },
        {}
      ],
      133: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.extendSchema = function(schema, documentAST) {
              schema instanceof _schema.GraphQLSchema ||
                (0, _invariant2.default)(0, "Must provide valid GraphQLSchema"),
                (!documentAST || documentAST.kind !== Kind.DOCUMENT) &&
                  (0, _invariant2.default)(
                    0,
                    "Must provide valid Document AST"
                  );
              for (
                var typeDefinitionMap = Object.create(null),
                  typeExtensionsMap = Object.create(null),
                  directiveDefinitions = [],
                  i = 0;
                i < documentAST.definitions.length;
                i++
              ) {
                var def = documentAST.definitions[i];
                switch (def.kind) {
                  case Kind.OBJECT_TYPE_DEFINITION:
                  case Kind.INTERFACE_TYPE_DEFINITION:
                  case Kind.ENUM_TYPE_DEFINITION:
                  case Kind.UNION_TYPE_DEFINITION:
                  case Kind.SCALAR_TYPE_DEFINITION:
                  case Kind.INPUT_OBJECT_TYPE_DEFINITION:
                    var typeName = def.name.value;
                    if (schema.getType(typeName))
                      throw new _GraphQLError.GraphQLError(
                        'Type "' +
                          typeName +
                          '" already exists in the schema. It cannot also be defined in this type definition.',
                        [def]
                      );
                    typeDefinitionMap[typeName] = def;
                    break;
                  case Kind.TYPE_EXTENSION_DEFINITION:
                    var extendedTypeName = def.definition.name.value,
                      existingType = schema.getType(extendedTypeName);
                    if (!existingType)
                      throw new _GraphQLError.GraphQLError(
                        'Cannot extend type "' +
                          extendedTypeName +
                          '" because it does not exist in the existing schema.',
                        [def.definition]
                      );
                    if (
                      !(existingType instanceof _definition.GraphQLObjectType)
                    )
                      throw new _GraphQLError.GraphQLError(
                        'Cannot extend non-object type "' +
                          extendedTypeName +
                          '".',
                        [def.definition]
                      );
                    var extensions = typeExtensionsMap[extendedTypeName];
                    extensions ? extensions.push(def) : (extensions = [def]),
                      (typeExtensionsMap[extendedTypeName] = extensions);
                    break;
                  case Kind.DIRECTIVE_DEFINITION:
                    var directiveName = def.name.value,
                      existingDirective = schema.getDirective(directiveName);
                    if (existingDirective)
                      throw new _GraphQLError.GraphQLError(
                        'Directive "' +
                          directiveName +
                          '" already exists in the schema. It cannot be redefined.',
                        [def]
                      );
                    directiveDefinitions.push(def);
                }
              }
              if (
                0 === Object.keys(typeExtensionsMap).length &&
                0 === Object.keys(typeDefinitionMap).length &&
                0 === directiveDefinitions.length
              )
                return schema;
              var typeDefCache = {
                  String: _scalars.GraphQLString,
                  Int: _scalars.GraphQLInt,
                  Float: _scalars.GraphQLFloat,
                  Boolean: _scalars.GraphQLBoolean,
                  ID: _scalars.GraphQLID,
                  __Schema: _introspection.__Schema,
                  __Directive: _introspection.__Directive,
                  __DirectiveLocation: _introspection.__DirectiveLocation,
                  __Type: _introspection.__Type,
                  __Field: _introspection.__Field,
                  __InputValue: _introspection.__InputValue,
                  __EnumValue: _introspection.__EnumValue,
                  __TypeKind: _introspection.__TypeKind
                },
                queryType = getTypeFromDef(schema.getQueryType()),
                existingMutationType = schema.getMutationType(),
                mutationType = existingMutationType
                  ? getTypeFromDef(existingMutationType)
                  : null,
                existingSubscriptionType = schema.getSubscriptionType(),
                subscriptionType = existingSubscriptionType
                  ? getTypeFromDef(existingSubscriptionType)
                  : null,
                typeMap = schema.getTypeMap(),
                types = Object.keys(typeMap).map(function(typeName) {
                  return getTypeFromDef(typeMap[typeName]);
                });
              return (
                Object.keys(typeDefinitionMap).forEach(function(typeName) {
                  types.push(getTypeFromAST(typeDefinitionMap[typeName]));
                }),
                new _schema.GraphQLSchema({
                  query: queryType,
                  mutation: mutationType,
                  subscription: subscriptionType,
                  types: types,
                  directives: (function() {
                    var existingDirectives = schema.getDirectives();
                    existingDirectives ||
                      (0, _invariant2.default)(
                        0,
                        "schema must have default directives"
                      );
                    var newDirectives = directiveDefinitions.map(function(
                      directiveNode
                    ) {
                      return (function(directiveNode) {
                        return new _directives.GraphQLDirective({
                          name: directiveNode.name.value,
                          locations: directiveNode.locations.map(function(
                            node
                          ) {
                            return node.value;
                          }),
                          args:
                            directiveNode.arguments &&
                            buildInputValues(directiveNode.arguments),
                          astNode: directiveNode
                        });
                      })(directiveNode);
                    });
                    return existingDirectives.concat(newDirectives);
                  })(),
                  astNode: schema.astNode
                })
              );
              function getTypeFromDef(typeDef) {
                var type = _getNamedType(typeDef.name);
                return (
                  type ||
                    (0, _invariant2.default)(0, "Missing type from schema"),
                  type
                );
              }
              function getTypeFromAST(node) {
                var type = _getNamedType(node.name.value);
                if (!type)
                  throw new _GraphQLError.GraphQLError(
                    'Unknown type: "' +
                      node.name.value +
                      '". Ensure that this type exists either in the original schema, or is added in a type definition.',
                    [node]
                  );
                return type;
              }
              function getObjectTypeFromAST(node) {
                var type = getTypeFromAST(node);
                return (
                  type instanceof _definition.GraphQLObjectType ||
                    (0, _invariant2.default)(0, "Must be Object type."),
                  type
                );
              }
              function getInterfaceTypeFromAST(node) {
                var type = getTypeFromAST(node);
                return (
                  type instanceof _definition.GraphQLInterfaceType ||
                    (0, _invariant2.default)(0, "Must be Interface type."),
                  type
                );
              }
              function _getNamedType(typeName) {
                var cachedTypeDef = typeDefCache[typeName];
                if (cachedTypeDef) return cachedTypeDef;
                var existingType = schema.getType(typeName);
                if (existingType) {
                  var typeDef = (function(type) {
                    if (type instanceof _definition.GraphQLObjectType)
                      return (function(type) {
                        var name = type.name,
                          extensionASTNodes = type.extensionASTNodes;
                        typeExtensionsMap[name] &&
                          (extensionASTNodes = extensionASTNodes.concat(
                            typeExtensionsMap[name]
                          ));
                        return new _definition.GraphQLObjectType({
                          name: name,
                          description: type.description,
                          interfaces: function() {
                            return (function(type) {
                              var interfaces = type
                                  .getInterfaces()
                                  .map(getTypeFromDef),
                                extensions = typeExtensionsMap[type.name];
                              extensions &&
                                extensions.forEach(function(extension) {
                                  extension.definition.interfaces.forEach(
                                    function(namedType) {
                                      var interfaceName = namedType.name.value;
                                      if (
                                        interfaces.some(function(def) {
                                          return def.name === interfaceName;
                                        })
                                      )
                                        throw new _GraphQLError.GraphQLError(
                                          'Type "' +
                                            type.name +
                                            '" already implements "' +
                                            interfaceName +
                                            '". It cannot also be implemented in this type extension.',
                                          [namedType]
                                        );
                                      interfaces.push(
                                        getInterfaceTypeFromAST(namedType)
                                      );
                                    }
                                  );
                                });
                              return interfaces;
                            })(type);
                          },
                          fields: function() {
                            return extendFieldMap(type);
                          },
                          astNode: type.astNode,
                          extensionASTNodes: extensionASTNodes,
                          isTypeOf: type.isTypeOf
                        });
                      })(type);
                    if (type instanceof _definition.GraphQLInterfaceType)
                      return (function(type) {
                        return new _definition.GraphQLInterfaceType({
                          name: type.name,
                          description: type.description,
                          fields: function() {
                            return extendFieldMap(type);
                          },
                          astNode: type.astNode,
                          resolveType: type.resolveType
                        });
                      })(type);
                    if (type instanceof _definition.GraphQLUnionType)
                      return (function(type) {
                        return new _definition.GraphQLUnionType({
                          name: type.name,
                          description: type.description,
                          types: type.getTypes().map(getTypeFromDef),
                          astNode: type.astNode,
                          resolveType: type.resolveType
                        });
                      })(type);
                    return type;
                  })(existingType);
                  return (typeDefCache[typeName] = typeDef);
                }
                var typeNode = typeDefinitionMap[typeName];
                if (typeNode) {
                  var _typeDef = (function(typeNode) {
                    switch (typeNode.kind) {
                      case Kind.OBJECT_TYPE_DEFINITION:
                        return (function(typeNode) {
                          return new _definition.GraphQLObjectType({
                            name: typeNode.name.value,
                            description: (0, _buildASTSchema.getDescription)(
                              typeNode
                            ),
                            interfaces: function() {
                              return (function(typeNode) {
                                return (
                                  typeNode.interfaces &&
                                  typeNode.interfaces.map(
                                    getInterfaceTypeFromAST
                                  )
                                );
                              })(typeNode);
                            },
                            fields: function() {
                              return buildFieldMap(typeNode);
                            },
                            astNode: typeNode
                          });
                        })(typeNode);
                      case Kind.INTERFACE_TYPE_DEFINITION:
                        return (function(typeNode) {
                          return new _definition.GraphQLInterfaceType({
                            name: typeNode.name.value,
                            description: (0, _buildASTSchema.getDescription)(
                              typeNode
                            ),
                            fields: function() {
                              return buildFieldMap(typeNode);
                            },
                            astNode: typeNode,
                            resolveType: cannotExecuteExtendedSchema
                          });
                        })(typeNode);
                      case Kind.UNION_TYPE_DEFINITION:
                        return (function(typeNode) {
                          return new _definition.GraphQLUnionType({
                            name: typeNode.name.value,
                            description: (0, _buildASTSchema.getDescription)(
                              typeNode
                            ),
                            types: typeNode.types.map(getObjectTypeFromAST),
                            astNode: typeNode,
                            resolveType: cannotExecuteExtendedSchema
                          });
                        })(typeNode);
                      case Kind.SCALAR_TYPE_DEFINITION:
                        return (function(typeNode) {
                          return new _definition.GraphQLScalarType({
                            name: typeNode.name.value,
                            description: (0, _buildASTSchema.getDescription)(
                              typeNode
                            ),
                            astNode: typeNode,
                            serialize: function(id) {
                              return id;
                            },
                            parseValue: function() {
                              return !1;
                            },
                            parseLiteral: function() {
                              return !1;
                            }
                          });
                        })(typeNode);
                      case Kind.ENUM_TYPE_DEFINITION:
                        return (function(typeNode) {
                          return new _definition.GraphQLEnumType({
                            name: typeNode.name.value,
                            description: (0, _buildASTSchema.getDescription)(
                              typeNode
                            ),
                            values: (0, _keyValMap2.default)(
                              typeNode.values,
                              function(enumValue) {
                                return enumValue.name.value;
                              },
                              function(enumValue) {
                                return {
                                  description: (0,
                                  _buildASTSchema.getDescription)(enumValue),
                                  deprecationReason: (0,
                                  _buildASTSchema.getDeprecationReason)(
                                    enumValue
                                  ),
                                  astNode: enumValue
                                };
                              }
                            ),
                            astNode: typeNode
                          });
                        })(typeNode);
                      case Kind.INPUT_OBJECT_TYPE_DEFINITION:
                        return (function(typeNode) {
                          return new _definition.GraphQLInputObjectType({
                            name: typeNode.name.value,
                            description: (0, _buildASTSchema.getDescription)(
                              typeNode
                            ),
                            fields: function() {
                              return buildInputValues(typeNode.fields);
                            },
                            astNode: typeNode
                          });
                        })(typeNode);
                    }
                    throw new TypeError("Unknown type kind " + typeNode.kind);
                  })(typeNode);
                  return (typeDefCache[typeName] = _typeDef);
                }
              }
              function extendFieldMap(type) {
                var newFieldMap = Object.create(null),
                  oldFieldMap = type.getFields();
                Object.keys(oldFieldMap).forEach(function(fieldName) {
                  var field = oldFieldMap[fieldName];
                  newFieldMap[fieldName] = {
                    description: field.description,
                    deprecationReason: field.deprecationReason,
                    type: (function extendFieldType(typeDef) {
                      if (typeDef instanceof _definition.GraphQLList)
                        return new _definition.GraphQLList(
                          extendFieldType(typeDef.ofType)
                        );
                      if (typeDef instanceof _definition.GraphQLNonNull)
                        return new _definition.GraphQLNonNull(
                          extendFieldType(typeDef.ofType)
                        );
                      return getTypeFromDef(typeDef);
                    })(field.type),
                    args: (0, _keyMap2.default)(field.args, function(arg) {
                      return arg.name;
                    }),
                    astNode: field.astNode,
                    resolve: field.resolve
                  };
                });
                var extensions = typeExtensionsMap[type.name];
                return (
                  extensions &&
                    extensions.forEach(function(extension) {
                      extension.definition.fields.forEach(function(field) {
                        var fieldName = field.name.value;
                        if (oldFieldMap[fieldName])
                          throw new _GraphQLError.GraphQLError(
                            'Field "' +
                              type.name +
                              "." +
                              fieldName +
                              '" already exists in the schema. It cannot also be defined in this type extension.',
                            [field]
                          );
                        newFieldMap[fieldName] = {
                          description: (0, _buildASTSchema.getDescription)(
                            field
                          ),
                          type: buildOutputFieldType(field.type),
                          args: buildInputValues(field.arguments),
                          deprecationReason: (0,
                          _buildASTSchema.getDeprecationReason)(field),
                          astNode: field
                        };
                      });
                    }),
                  newFieldMap
                );
              }
              function buildFieldMap(typeNode) {
                return (0, _keyValMap2.default)(
                  typeNode.fields,
                  function(field) {
                    return field.name.value;
                  },
                  function(field) {
                    return {
                      type: buildOutputFieldType(field.type),
                      description: (0, _buildASTSchema.getDescription)(field),
                      args: buildInputValues(field.arguments),
                      deprecationReason: (0,
                      _buildASTSchema.getDeprecationReason)(field),
                      astNode: field
                    };
                  }
                );
              }
              function buildInputValues(values) {
                return (0, _keyValMap2.default)(
                  values,
                  function(value) {
                    return value.name.value;
                  },
                  function(value) {
                    var type = (function buildInputFieldType(typeNode) {
                      if (typeNode.kind === Kind.LIST_TYPE)
                        return new _definition.GraphQLList(
                          buildInputFieldType(typeNode.type)
                        );
                      if (typeNode.kind === Kind.NON_NULL_TYPE) {
                        var nullableType = buildInputFieldType(typeNode.type);
                        return (
                          nullableType instanceof _definition.GraphQLNonNull &&
                            (0, _invariant2.default)(0, "Must be nullable"),
                          new _definition.GraphQLNonNull(nullableType)
                        );
                      }
                      return (
                        (node = typeNode),
                        (0, _definition.assertInputType)(getTypeFromAST(node))
                      );
                      var node;
                    })(value.type);
                    return {
                      type: type,
                      description: (0, _buildASTSchema.getDescription)(value),
                      defaultValue: (0, _valueFromAST.valueFromAST)(
                        value.defaultValue,
                        type
                      ),
                      astNode: value
                    };
                  }
                );
              }
              function buildOutputFieldType(typeNode) {
                if (typeNode.kind === Kind.LIST_TYPE)
                  return new _definition.GraphQLList(
                    buildOutputFieldType(typeNode.type)
                  );
                if (typeNode.kind === Kind.NON_NULL_TYPE) {
                  var nullableType = buildOutputFieldType(typeNode.type);
                  return (
                    nullableType instanceof _definition.GraphQLNonNull &&
                      (0, _invariant2.default)(0, "Must be nullable"),
                    new _definition.GraphQLNonNull(nullableType)
                  );
                }
                return (
                  (node = typeNode),
                  (0, _definition.assertOutputType)(getTypeFromAST(node))
                );
                var node;
              }
            });
          var _invariant2 = _interopRequireDefault(
              require("../jsutils/invariant")
            ),
            _keyMap2 = _interopRequireDefault(require("../jsutils/keyMap")),
            _keyValMap2 = _interopRequireDefault(
              require("../jsutils/keyValMap")
            ),
            _buildASTSchema = require("./buildASTSchema"),
            _valueFromAST = require("./valueFromAST"),
            _GraphQLError = require("../error/GraphQLError"),
            _schema = require("../type/schema"),
            _definition = require("../type/definition"),
            _directives = require("../type/directives"),
            _introspection = require("../type/introspection"),
            _scalars = require("../type/scalars"),
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../language/kinds"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function cannotExecuteExtendedSchema() {
            throw new Error(
              "Extended Schema cannot use Interface or Union types for execution."
            );
          }
        },
        {
          "../error/GraphQLError": 92,
          "../jsutils/invariant": 103,
          "../jsutils/keyMap": 106,
          "../jsutils/keyValMap": 107,
          "../language/kinds": 111,
          "../type/definition": 121,
          "../type/directives": 122,
          "../type/introspection": 124,
          "../type/scalars": 125,
          "../type/schema": 126,
          "./buildASTSchema": 130,
          "./valueFromAST": 145
        }
      ],
      134: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.DangerousChangeType = exports.BreakingChangeType = void 0),
            (exports.findBreakingChanges = function(oldSchema, newSchema) {
              return [].concat(
                findRemovedTypes(oldSchema, newSchema),
                findTypesThatChangedKind(oldSchema, newSchema),
                findFieldsThatChangedType(oldSchema, newSchema),
                findTypesRemovedFromUnions(oldSchema, newSchema),
                findValuesRemovedFromEnums(oldSchema, newSchema),
                findArgChanges(oldSchema, newSchema).breakingChanges,
                findInterfacesRemovedFromObjectTypes(oldSchema, newSchema)
              );
            }),
            (exports.findDangerousChanges = function(oldSchema, newSchema) {
              return [].concat(
                findArgChanges(oldSchema, newSchema).dangerousChanges
              );
            }),
            (exports.findRemovedTypes = findRemovedTypes),
            (exports.findTypesThatChangedKind = findTypesThatChangedKind),
            (exports.findArgChanges = findArgChanges),
            (exports.findFieldsThatChangedType = findFieldsThatChangedType),
            (exports.findFieldsThatChangedTypeOnInputObjectTypes = findFieldsThatChangedTypeOnInputObjectTypes),
            (exports.findTypesRemovedFromUnions = findTypesRemovedFromUnions),
            (exports.findValuesRemovedFromEnums = findValuesRemovedFromEnums),
            (exports.findInterfacesRemovedFromObjectTypes = findInterfacesRemovedFromObjectTypes);
          var _definition = require("../type/definition"),
            BreakingChangeType = (require("../type/schema"),
            (exports.BreakingChangeType = {
              FIELD_CHANGED_KIND: "FIELD_CHANGED_KIND",
              FIELD_REMOVED: "FIELD_REMOVED",
              TYPE_CHANGED_KIND: "TYPE_CHANGED_KIND",
              TYPE_REMOVED: "TYPE_REMOVED",
              TYPE_REMOVED_FROM_UNION: "TYPE_REMOVED_FROM_UNION",
              VALUE_REMOVED_FROM_ENUM: "VALUE_REMOVED_FROM_ENUM",
              ARG_REMOVED: "ARG_REMOVED",
              ARG_CHANGED_KIND: "ARG_CHANGED_KIND",
              NON_NULL_ARG_ADDED: "NON_NULL_ARG_ADDED",
              NON_NULL_INPUT_FIELD_ADDED: "NON_NULL_INPUT_FIELD_ADDED",
              INTERFACE_REMOVED_FROM_OBJECT: "INTERFACE_REMOVED_FROM_OBJECT"
            })),
            DangerousChangeType = (exports.DangerousChangeType = {
              ARG_DEFAULT_VALUE_CHANGE: "ARG_DEFAULT_VALUE_CHANGE"
            });
          function findRemovedTypes(oldSchema, newSchema) {
            var oldTypeMap = oldSchema.getTypeMap(),
              newTypeMap = newSchema.getTypeMap(),
              breakingChanges = [];
            return (
              Object.keys(oldTypeMap).forEach(function(typeName) {
                newTypeMap[typeName] ||
                  breakingChanges.push({
                    type: BreakingChangeType.TYPE_REMOVED,
                    description: typeName + " was removed."
                  });
              }),
              breakingChanges
            );
          }
          function findTypesThatChangedKind(oldSchema, newSchema) {
            var oldTypeMap = oldSchema.getTypeMap(),
              newTypeMap = newSchema.getTypeMap(),
              breakingChanges = [];
            return (
              Object.keys(oldTypeMap).forEach(function(typeName) {
                if (newTypeMap[typeName]) {
                  var oldType = oldTypeMap[typeName],
                    newType = newTypeMap[typeName];
                  oldType instanceof newType.constructor ||
                    breakingChanges.push({
                      type: BreakingChangeType.TYPE_CHANGED_KIND,
                      description:
                        typeName +
                        " changed from " +
                        typeKindName(oldType) +
                        " to " +
                        typeKindName(newType) +
                        "."
                    });
                }
              }),
              breakingChanges
            );
          }
          function findArgChanges(oldSchema, newSchema) {
            var oldTypeMap = oldSchema.getTypeMap(),
              newTypeMap = newSchema.getTypeMap(),
              breakingChanges = [],
              dangerousChanges = [];
            return (
              Object.keys(oldTypeMap).forEach(function(typeName) {
                var oldType = oldTypeMap[typeName],
                  newType = newTypeMap[typeName];
                if (
                  (oldType instanceof _definition.GraphQLObjectType ||
                    oldType instanceof _definition.GraphQLInterfaceType) &&
                  newType instanceof oldType.constructor
                ) {
                  var oldTypeFields = oldType.getFields(),
                    newTypeFields = newType.getFields();
                  Object.keys(oldTypeFields).forEach(function(fieldName) {
                    newTypeFields[fieldName] &&
                      (oldTypeFields[fieldName].args.forEach(function(
                        oldArgDef
                      ) {
                        var newArgDef = newTypeFields[fieldName].args.find(
                          function(arg) {
                            return arg.name === oldArgDef.name;
                          }
                        );
                        newArgDef
                          ? isChangeSafeForInputObjectFieldOrFieldArg(
                              oldArgDef.type,
                              newArgDef.type
                            )
                            ? void 0 !== oldArgDef.defaultValue &&
                              oldArgDef.defaultValue !==
                                newArgDef.defaultValue &&
                              dangerousChanges.push({
                                type:
                                  DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
                                description:
                                  oldType.name +
                                  "." +
                                  fieldName +
                                  " arg " +
                                  oldArgDef.name +
                                  " has changed defaultValue"
                              })
                            : breakingChanges.push({
                                type: BreakingChangeType.ARG_CHANGED_KIND,
                                description:
                                  oldType.name +
                                  "." +
                                  fieldName +
                                  " arg " +
                                  oldArgDef.name +
                                  " has changed type from " +
                                  oldArgDef.type.toString() +
                                  " to " +
                                  newArgDef.type.toString()
                              })
                          : breakingChanges.push({
                              type: BreakingChangeType.ARG_REMOVED,
                              description:
                                oldType.name +
                                "." +
                                fieldName +
                                " arg " +
                                oldArgDef.name +
                                " was removed"
                            });
                      }),
                      newTypeFields[fieldName].args.forEach(function(
                        newArgDef
                      ) {
                        !oldTypeFields[fieldName].args.find(function(arg) {
                          return arg.name === newArgDef.name;
                        }) &&
                          newArgDef.type instanceof
                            _definition.GraphQLNonNull &&
                          breakingChanges.push({
                            type: BreakingChangeType.NON_NULL_ARG_ADDED,
                            description:
                              "A non-null arg " +
                              newArgDef.name +
                              " on " +
                              newType.name +
                              "." +
                              fieldName +
                              " was added"
                          });
                      }));
                  });
                }
              }),
              {
                breakingChanges: breakingChanges,
                dangerousChanges: dangerousChanges
              }
            );
          }
          function typeKindName(type) {
            if (type instanceof _definition.GraphQLScalarType)
              return "a Scalar type";
            if (type instanceof _definition.GraphQLObjectType)
              return "an Object type";
            if (type instanceof _definition.GraphQLInterfaceType)
              return "an Interface type";
            if (type instanceof _definition.GraphQLUnionType)
              return "a Union type";
            if (type instanceof _definition.GraphQLEnumType)
              return "an Enum type";
            if (type instanceof _definition.GraphQLInputObjectType)
              return "an Input type";
            throw new TypeError("Unknown type " + type.constructor.name);
          }
          function findFieldsThatChangedType(oldSchema, newSchema) {
            return [].concat(
              (function(oldSchema, newSchema) {
                var oldTypeMap = oldSchema.getTypeMap(),
                  newTypeMap = newSchema.getTypeMap(),
                  breakingFieldChanges = [];
                return (
                  Object.keys(oldTypeMap).forEach(function(typeName) {
                    var oldType = oldTypeMap[typeName],
                      newType = newTypeMap[typeName];
                    if (
                      (oldType instanceof _definition.GraphQLObjectType ||
                        oldType instanceof _definition.GraphQLInterfaceType) &&
                      newType instanceof oldType.constructor
                    ) {
                      var oldTypeFieldsDef = oldType.getFields(),
                        newTypeFieldsDef = newType.getFields();
                      Object.keys(oldTypeFieldsDef).forEach(function(
                        fieldName
                      ) {
                        if (fieldName in newTypeFieldsDef) {
                          var oldFieldType = oldTypeFieldsDef[fieldName].type,
                            newFieldType = newTypeFieldsDef[fieldName].type;
                          if (
                            !(function isChangeSafeForObjectOrInterfaceField(
                              oldType,
                              newType
                            ) {
                              return (0, _definition.isNamedType)(oldType)
                                ? ((0, _definition.isNamedType)(newType) &&
                                    oldType.name === newType.name) ||
                                    (newType instanceof
                                      _definition.GraphQLNonNull &&
                                      isChangeSafeForObjectOrInterfaceField(
                                        oldType,
                                        newType.ofType
                                      ))
                                : oldType instanceof _definition.GraphQLList
                                  ? (newType instanceof
                                      _definition.GraphQLList &&
                                      isChangeSafeForObjectOrInterfaceField(
                                        oldType.ofType,
                                        newType.ofType
                                      )) ||
                                    (newType instanceof
                                      _definition.GraphQLNonNull &&
                                      isChangeSafeForObjectOrInterfaceField(
                                        oldType,
                                        newType.ofType
                                      ))
                                  : oldType instanceof
                                      _definition.GraphQLNonNull &&
                                    (newType instanceof
                                      _definition.GraphQLNonNull &&
                                      isChangeSafeForObjectOrInterfaceField(
                                        oldType.ofType,
                                        newType.ofType
                                      ));
                            })(oldFieldType, newFieldType)
                          ) {
                            var oldFieldTypeString = (0,
                              _definition.isNamedType)(oldFieldType)
                                ? oldFieldType.name
                                : oldFieldType.toString(),
                              newFieldTypeString = (0, _definition.isNamedType)(
                                newFieldType
                              )
                                ? newFieldType.name
                                : newFieldType.toString();
                            breakingFieldChanges.push({
                              type: BreakingChangeType.FIELD_CHANGED_KIND,
                              description:
                                typeName +
                                "." +
                                fieldName +
                                " changed type from " +
                                oldFieldTypeString +
                                " to " +
                                newFieldTypeString +
                                "."
                            });
                          }
                        } else
                          breakingFieldChanges.push({
                            type: BreakingChangeType.FIELD_REMOVED,
                            description:
                              typeName + "." + fieldName + " was removed."
                          });
                      });
                    }
                  }),
                  breakingFieldChanges
                );
              })(oldSchema, newSchema),
              findFieldsThatChangedTypeOnInputObjectTypes(oldSchema, newSchema)
            );
          }
          function findFieldsThatChangedTypeOnInputObjectTypes(
            oldSchema,
            newSchema
          ) {
            var oldTypeMap = oldSchema.getTypeMap(),
              newTypeMap = newSchema.getTypeMap(),
              breakingFieldChanges = [];
            return (
              Object.keys(oldTypeMap).forEach(function(typeName) {
                var oldType = oldTypeMap[typeName],
                  newType = newTypeMap[typeName];
                if (
                  oldType instanceof _definition.GraphQLInputObjectType &&
                  newType instanceof _definition.GraphQLInputObjectType
                ) {
                  var oldTypeFieldsDef = oldType.getFields(),
                    newTypeFieldsDef = newType.getFields();
                  Object.keys(oldTypeFieldsDef).forEach(function(fieldName) {
                    if (fieldName in newTypeFieldsDef) {
                      var oldFieldType = oldTypeFieldsDef[fieldName].type,
                        newFieldType = newTypeFieldsDef[fieldName].type;
                      if (
                        !isChangeSafeForInputObjectFieldOrFieldArg(
                          oldFieldType,
                          newFieldType
                        )
                      ) {
                        var oldFieldTypeString = (0, _definition.isNamedType)(
                            oldFieldType
                          )
                            ? oldFieldType.name
                            : oldFieldType.toString(),
                          newFieldTypeString = (0, _definition.isNamedType)(
                            newFieldType
                          )
                            ? newFieldType.name
                            : newFieldType.toString();
                        breakingFieldChanges.push({
                          type: BreakingChangeType.FIELD_CHANGED_KIND,
                          description:
                            typeName +
                            "." +
                            fieldName +
                            " changed type from " +
                            oldFieldTypeString +
                            " to " +
                            newFieldTypeString +
                            "."
                        });
                      }
                    } else breakingFieldChanges.push({ type: BreakingChangeType.FIELD_REMOVED, description: typeName + "." + fieldName + " was removed." });
                  }),
                    Object.keys(newTypeFieldsDef).forEach(function(fieldName) {
                      !(fieldName in oldTypeFieldsDef) &&
                        newTypeFieldsDef[fieldName].type instanceof
                          _definition.GraphQLNonNull &&
                        breakingFieldChanges.push({
                          type: BreakingChangeType.NON_NULL_INPUT_FIELD_ADDED,
                          description:
                            "A non-null field " +
                            fieldName +
                            " on input type " +
                            newType.name +
                            " was added."
                        });
                    });
                }
              }),
              breakingFieldChanges
            );
          }
          function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
            return (0, _definition.isNamedType)(oldType)
              ? (0, _definition.isNamedType)(newType) &&
                  oldType.name === newType.name
              : oldType instanceof _definition.GraphQLList
                ? newType instanceof _definition.GraphQLList &&
                  isChangeSafeForInputObjectFieldOrFieldArg(
                    oldType.ofType,
                    newType.ofType
                  )
                : oldType instanceof _definition.GraphQLNonNull &&
                  ((newType instanceof _definition.GraphQLNonNull &&
                    isChangeSafeForInputObjectFieldOrFieldArg(
                      oldType.ofType,
                      newType.ofType
                    )) ||
                    (!(newType instanceof _definition.GraphQLNonNull) &&
                      isChangeSafeForInputObjectFieldOrFieldArg(
                        oldType.ofType,
                        newType
                      )));
          }
          function findTypesRemovedFromUnions(oldSchema, newSchema) {
            var oldTypeMap = oldSchema.getTypeMap(),
              newTypeMap = newSchema.getTypeMap(),
              typesRemovedFromUnion = [];
            return (
              Object.keys(oldTypeMap).forEach(function(typeName) {
                var oldType = oldTypeMap[typeName],
                  newType = newTypeMap[typeName];
                if (
                  oldType instanceof _definition.GraphQLUnionType &&
                  newType instanceof _definition.GraphQLUnionType
                ) {
                  var typeNamesInNewUnion = Object.create(null);
                  newType.getTypes().forEach(function(type) {
                    typeNamesInNewUnion[type.name] = !0;
                  }),
                    oldType.getTypes().forEach(function(type) {
                      typeNamesInNewUnion[type.name] ||
                        typesRemovedFromUnion.push({
                          type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
                          description:
                            type.name +
                            " was removed from union type " +
                            typeName +
                            "."
                        });
                    });
                }
              }),
              typesRemovedFromUnion
            );
          }
          function findValuesRemovedFromEnums(oldSchema, newSchema) {
            var oldTypeMap = oldSchema.getTypeMap(),
              newTypeMap = newSchema.getTypeMap(),
              valuesRemovedFromEnums = [];
            return (
              Object.keys(oldTypeMap).forEach(function(typeName) {
                var oldType = oldTypeMap[typeName],
                  newType = newTypeMap[typeName];
                if (
                  oldType instanceof _definition.GraphQLEnumType &&
                  newType instanceof _definition.GraphQLEnumType
                ) {
                  var valuesInNewEnum = Object.create(null);
                  newType.getValues().forEach(function(value) {
                    valuesInNewEnum[value.name] = !0;
                  }),
                    oldType.getValues().forEach(function(value) {
                      valuesInNewEnum[value.name] ||
                        valuesRemovedFromEnums.push({
                          type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
                          description:
                            value.name +
                            " was removed from enum type " +
                            typeName +
                            "."
                        });
                    });
                }
              }),
              valuesRemovedFromEnums
            );
          }
          function findInterfacesRemovedFromObjectTypes(oldSchema, newSchema) {
            var oldTypeMap = oldSchema.getTypeMap(),
              newTypeMap = newSchema.getTypeMap(),
              breakingChanges = [];
            return (
              Object.keys(oldTypeMap).forEach(function(typeName) {
                var oldType = oldTypeMap[typeName],
                  newType = newTypeMap[typeName];
                if (
                  oldType instanceof _definition.GraphQLObjectType &&
                  newType instanceof _definition.GraphQLObjectType
                ) {
                  var oldInterfaces = oldType.getInterfaces(),
                    newInterfaces = newType.getInterfaces();
                  oldInterfaces.forEach(function(oldInterface) {
                    newInterfaces.some(function(int) {
                      return int.name === oldInterface.name;
                    }) ||
                      breakingChanges.push({
                        type: BreakingChangeType.INTERFACE_REMOVED_FROM_OBJECT,
                        description:
                          typeName +
                          " no longer implements interface " +
                          oldInterface.name +
                          "."
                      });
                  });
                }
              }),
              breakingChanges
            );
          }
        },
        { "../type/definition": 121, "../type/schema": 126 }
      ],
      135: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.findDeprecatedUsages = function(schema, ast) {
              var errors = [],
                typeInfo = new _TypeInfo.TypeInfo(schema);
              return (
                (0, _visitor.visit)(
                  ast,
                  (0, _visitor.visitWithTypeInfo)(typeInfo, {
                    Field: function(node) {
                      var fieldDef = typeInfo.getFieldDef();
                      if (fieldDef && fieldDef.isDeprecated) {
                        var parentType = typeInfo.getParentType();
                        if (parentType) {
                          var reason = fieldDef.deprecationReason;
                          errors.push(
                            new _GraphQLError.GraphQLError(
                              "The field " +
                                parentType.name +
                                "." +
                                fieldDef.name +
                                " is deprecated." +
                                (reason ? " " + reason : ""),
                              [node]
                            )
                          );
                        }
                      }
                    },
                    EnumValue: function(node) {
                      var enumVal = typeInfo.getEnumValue();
                      if (enumVal && enumVal.isDeprecated) {
                        var type = (0, _definition.getNamedType)(
                          typeInfo.getInputType()
                        );
                        if (type) {
                          var reason = enumVal.deprecationReason;
                          errors.push(
                            new _GraphQLError.GraphQLError(
                              "The enum value " +
                                type.name +
                                "." +
                                enumVal.name +
                                " is deprecated." +
                                (reason ? " " + reason : ""),
                              [node]
                            )
                          );
                        }
                      }
                    }
                  })
                ),
                errors
              );
            });
          var _GraphQLError = require("../error/GraphQLError"),
            _visitor = require("../language/visitor"),
            _definition = require("../type/definition"),
            _TypeInfo = (require("../type/schema"), require("./TypeInfo"));
        },
        {
          "../error/GraphQLError": 92,
          "../language/visitor": 117,
          "../type/definition": 121,
          "../type/schema": 126,
          "./TypeInfo": 127
        }
      ],
      136: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.getOperationAST = function(documentAST, operationName) {
              for (
                var operation = null, i = 0;
                i < documentAST.definitions.length;
                i++
              ) {
                var definition = documentAST.definitions[i];
                if (definition.kind === _kinds.OPERATION_DEFINITION)
                  if (operationName) {
                    if (
                      definition.name &&
                      definition.name.value === operationName
                    )
                      return definition;
                  } else {
                    if (operation) return null;
                    operation = definition;
                  }
              }
              return operation;
            });
          var _kinds = require("../language/kinds");
        },
        { "../language/kinds": 111 }
      ],
      137: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _introspectionQuery = require("./introspectionQuery");
          Object.defineProperty(exports, "introspectionQuery", {
            enumerable: !0,
            get: function() {
              return _introspectionQuery.introspectionQuery;
            }
          });
          var _getOperationAST = require("./getOperationAST");
          Object.defineProperty(exports, "getOperationAST", {
            enumerable: !0,
            get: function() {
              return _getOperationAST.getOperationAST;
            }
          });
          var _buildClientSchema = require("./buildClientSchema");
          Object.defineProperty(exports, "buildClientSchema", {
            enumerable: !0,
            get: function() {
              return _buildClientSchema.buildClientSchema;
            }
          });
          var _buildASTSchema = require("./buildASTSchema");
          Object.defineProperty(exports, "buildASTSchema", {
            enumerable: !0,
            get: function() {
              return _buildASTSchema.buildASTSchema;
            }
          }),
            Object.defineProperty(exports, "buildSchema", {
              enumerable: !0,
              get: function() {
                return _buildASTSchema.buildSchema;
              }
            });
          var _extendSchema = require("./extendSchema");
          Object.defineProperty(exports, "extendSchema", {
            enumerable: !0,
            get: function() {
              return _extendSchema.extendSchema;
            }
          });
          var _schemaPrinter = require("./schemaPrinter");
          Object.defineProperty(exports, "printSchema", {
            enumerable: !0,
            get: function() {
              return _schemaPrinter.printSchema;
            }
          }),
            Object.defineProperty(exports, "printType", {
              enumerable: !0,
              get: function() {
                return _schemaPrinter.printType;
              }
            }),
            Object.defineProperty(exports, "printIntrospectionSchema", {
              enumerable: !0,
              get: function() {
                return _schemaPrinter.printIntrospectionSchema;
              }
            });
          var _typeFromAST = require("./typeFromAST");
          Object.defineProperty(exports, "typeFromAST", {
            enumerable: !0,
            get: function() {
              return _typeFromAST.typeFromAST;
            }
          });
          var _valueFromAST = require("./valueFromAST");
          Object.defineProperty(exports, "valueFromAST", {
            enumerable: !0,
            get: function() {
              return _valueFromAST.valueFromAST;
            }
          });
          var _astFromValue = require("./astFromValue");
          Object.defineProperty(exports, "astFromValue", {
            enumerable: !0,
            get: function() {
              return _astFromValue.astFromValue;
            }
          });
          var _TypeInfo = require("./TypeInfo");
          Object.defineProperty(exports, "TypeInfo", {
            enumerable: !0,
            get: function() {
              return _TypeInfo.TypeInfo;
            }
          });
          var _isValidJSValue = require("./isValidJSValue");
          Object.defineProperty(exports, "isValidJSValue", {
            enumerable: !0,
            get: function() {
              return _isValidJSValue.isValidJSValue;
            }
          });
          var _isValidLiteralValue = require("./isValidLiteralValue");
          Object.defineProperty(exports, "isValidLiteralValue", {
            enumerable: !0,
            get: function() {
              return _isValidLiteralValue.isValidLiteralValue;
            }
          });
          var _concatAST = require("./concatAST");
          Object.defineProperty(exports, "concatAST", {
            enumerable: !0,
            get: function() {
              return _concatAST.concatAST;
            }
          });
          var _separateOperations = require("./separateOperations");
          Object.defineProperty(exports, "separateOperations", {
            enumerable: !0,
            get: function() {
              return _separateOperations.separateOperations;
            }
          });
          var _typeComparators = require("./typeComparators");
          Object.defineProperty(exports, "isEqualType", {
            enumerable: !0,
            get: function() {
              return _typeComparators.isEqualType;
            }
          }),
            Object.defineProperty(exports, "isTypeSubTypeOf", {
              enumerable: !0,
              get: function() {
                return _typeComparators.isTypeSubTypeOf;
              }
            }),
            Object.defineProperty(exports, "doTypesOverlap", {
              enumerable: !0,
              get: function() {
                return _typeComparators.doTypesOverlap;
              }
            });
          var _assertValidName = require("./assertValidName");
          Object.defineProperty(exports, "assertValidName", {
            enumerable: !0,
            get: function() {
              return _assertValidName.assertValidName;
            }
          });
          var _findBreakingChanges = require("./findBreakingChanges");
          Object.defineProperty(exports, "BreakingChangeType", {
            enumerable: !0,
            get: function() {
              return _findBreakingChanges.BreakingChangeType;
            }
          }),
            Object.defineProperty(exports, "DangerousChangeType", {
              enumerable: !0,
              get: function() {
                return _findBreakingChanges.DangerousChangeType;
              }
            }),
            Object.defineProperty(exports, "findBreakingChanges", {
              enumerable: !0,
              get: function() {
                return _findBreakingChanges.findBreakingChanges;
              }
            });
          var _findDeprecatedUsages = require("./findDeprecatedUsages");
          Object.defineProperty(exports, "findDeprecatedUsages", {
            enumerable: !0,
            get: function() {
              return _findDeprecatedUsages.findDeprecatedUsages;
            }
          });
        },
        {
          "./TypeInfo": 127,
          "./assertValidName": 128,
          "./astFromValue": 129,
          "./buildASTSchema": 130,
          "./buildClientSchema": 131,
          "./concatAST": 132,
          "./extendSchema": 133,
          "./findBreakingChanges": 134,
          "./findDeprecatedUsages": 135,
          "./getOperationAST": 136,
          "./introspectionQuery": 138,
          "./isValidJSValue": 139,
          "./isValidLiteralValue": 140,
          "./schemaPrinter": 141,
          "./separateOperations": 142,
          "./typeComparators": 143,
          "./typeFromAST": 144,
          "./valueFromAST": 145
        }
      ],
      138: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          exports.introspectionQuery =
            "\n  query IntrospectionQuery {\n    __schema {\n      queryType { name }\n      mutationType { name }\n      subscriptionType { name }\n      types {\n        ...FullType\n      }\n      directives {\n        name\n        description\n        locations\n        args {\n          ...InputValue\n        }\n      }\n    }\n  }\n\n  fragment FullType on __Type {\n    kind\n    name\n    description\n    fields(includeDeprecated: true) {\n      name\n      description\n      args {\n        ...InputValue\n      }\n      type {\n        ...TypeRef\n      }\n      isDeprecated\n      deprecationReason\n    }\n    inputFields {\n      ...InputValue\n    }\n    interfaces {\n      ...TypeRef\n    }\n    enumValues(includeDeprecated: true) {\n      name\n      description\n      isDeprecated\n      deprecationReason\n    }\n    possibleTypes {\n      ...TypeRef\n    }\n  }\n\n  fragment InputValue on __InputValue {\n    name\n    description\n    type { ...TypeRef }\n    defaultValue\n  }\n\n  fragment TypeRef on __Type {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n";
        },
        {}
      ],
      139: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _typeof =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function(obj) {
                  return typeof obj;
                }
              : function(obj) {
                  return obj &&
                    "function" == typeof Symbol &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? "symbol"
                    : typeof obj;
                };
          exports.isValidJSValue = function isValidJSValue(value, type) {
            if (type instanceof _definition.GraphQLNonNull)
              return (0, _isNullish2.default)(value)
                ? ['Expected "' + String(type) + '", found null.']
                : isValidJSValue(value, type.ofType);
            if ((0, _isNullish2.default)(value)) return [];
            if (type instanceof _definition.GraphQLList) {
              var itemType = type.ofType;
              if ((0, _iterall.isCollection)(value)) {
                var errors = [];
                return (
                  (0, _iterall.forEach)(value, function(item, index) {
                    errors.push.apply(
                      errors,
                      isValidJSValue(item, itemType).map(function(error) {
                        return "In element #" + index + ": " + error;
                      })
                    );
                  }),
                  errors
                );
              }
              return isValidJSValue(value, itemType);
            }
            if (type instanceof _definition.GraphQLInputObjectType) {
              if (
                "object" !==
                  (void 0 === value ? "undefined" : _typeof(value)) ||
                null === value
              )
                return ['Expected "' + type.name + '", found not an object.'];
              var fields = type.getFields(),
                _errors = [];
              return (
                Object.keys(value).forEach(function(providedField) {
                  fields[providedField] ||
                    _errors.push(
                      'In field "' + providedField + '": Unknown field.'
                    );
                }),
                Object.keys(fields).forEach(function(fieldName) {
                  var newErrors = isValidJSValue(
                    value[fieldName],
                    fields[fieldName].type
                  );
                  _errors.push.apply(
                    _errors,
                    newErrors.map(function(error) {
                      return 'In field "' + fieldName + '": ' + error;
                    })
                  );
                }),
                _errors
              );
            }
            type instanceof _definition.GraphQLScalarType ||
              type instanceof _definition.GraphQLEnumType ||
              (0, _invariant2.default)(0, "Must be input type");
            try {
              var parseResult = type.parseValue(value);
              if (
                (0, _isNullish2.default)(parseResult) &&
                !type.isValidValue(value)
              )
                return [
                  'Expected type "' +
                    type.name +
                    '", found ' +
                    JSON.stringify(value) +
                    "."
                ];
            } catch (error) {
              return [
                'Expected type "' +
                  type.name +
                  '", found ' +
                  JSON.stringify(value) +
                  ": " +
                  error.message
              ];
            }
            return [];
          };
          var _iterall = require("iterall"),
            _invariant2 = _interopRequireDefault(
              require("../jsutils/invariant")
            ),
            _isNullish2 = _interopRequireDefault(
              require("../jsutils/isNullish")
            ),
            _definition = require("../type/definition");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
        },
        {
          "../jsutils/invariant": 103,
          "../jsutils/isNullish": 105,
          "../type/definition": 121,
          iterall: 175
        }
      ],
      140: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.isValidLiteralValue = function isValidLiteralValue(
              type,
              valueNode
            ) {
              if (type instanceof _definition.GraphQLNonNull)
                return valueNode && valueNode.kind !== Kind.NULL
                  ? isValidLiteralValue(type.ofType, valueNode)
                  : ['Expected "' + String(type) + '", found null.'];
              if (!valueNode || valueNode.kind === Kind.NULL) return [];
              if (valueNode.kind === Kind.VARIABLE) return [];
              if (type instanceof _definition.GraphQLList) {
                var itemType = type.ofType;
                return valueNode.kind === Kind.LIST
                  ? valueNode.values.reduce(function(acc, item, index) {
                      var errors = isValidLiteralValue(itemType, item);
                      return acc.concat(
                        errors.map(function(error) {
                          return "In element #" + index + ": " + error;
                        })
                      );
                    }, [])
                  : isValidLiteralValue(itemType, valueNode);
              }
              if (type instanceof _definition.GraphQLInputObjectType) {
                if (valueNode.kind !== Kind.OBJECT)
                  return ['Expected "' + type.name + '", found not an object.'];
                var fields = type.getFields(),
                  errors = [],
                  fieldNodes = valueNode.fields;
                fieldNodes.forEach(function(providedFieldNode) {
                  fields[providedFieldNode.name.value] ||
                    errors.push(
                      'In field "' +
                        providedFieldNode.name.value +
                        '": Unknown field.'
                    );
                });
                var fieldNodeMap = (0, _keyMap2.default)(fieldNodes, function(
                  fieldNode
                ) {
                  return fieldNode.name.value;
                });
                return (
                  Object.keys(fields).forEach(function(fieldName) {
                    var result = isValidLiteralValue(
                      fields[fieldName].type,
                      fieldNodeMap[fieldName] && fieldNodeMap[fieldName].value
                    );
                    errors.push.apply(
                      errors,
                      result.map(function(error) {
                        return 'In field "' + fieldName + '": ' + error;
                      })
                    );
                  }),
                  errors
                );
              }
              type instanceof _definition.GraphQLScalarType ||
                type instanceof _definition.GraphQLEnumType ||
                (0, _invariant2.default)(0, "Must be input type");
              if (!type.isValidLiteral(valueNode))
                return [
                  'Expected type "' +
                    type.name +
                    '", found ' +
                    (0, _printer.print)(valueNode) +
                    "."
                ];
              return [];
            });
          var _printer = require("../language/printer"),
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../language/kinds")),
            _definition = require("../type/definition"),
            _invariant2 = _interopRequireDefault(
              require("../jsutils/invariant")
            ),
            _keyMap2 = _interopRequireDefault(require("../jsutils/keyMap"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
        },
        {
          "../jsutils/invariant": 103,
          "../jsutils/keyMap": 106,
          "../language/kinds": 111,
          "../language/printer": 115,
          "../type/definition": 121
        }
      ],
      141: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.printSchema = function(schema) {
              return printFilteredSchema(
                schema,
                function(n) {
                  return !isSpecDirective(n);
                },
                isDefinedType
              );
            }),
            (exports.printIntrospectionSchema = function(schema) {
              return printFilteredSchema(
                schema,
                isSpecDirective,
                isIntrospectionType
              );
            }),
            (exports.printType = printType);
          var _invariant2 = _interopRequireDefault(
              require("../jsutils/invariant")
            ),
            _isNullish2 = _interopRequireDefault(
              require("../jsutils/isNullish")
            ),
            _isInvalid2 = _interopRequireDefault(
              require("../jsutils/isInvalid")
            ),
            _astFromValue = require("../utilities/astFromValue"),
            _printer = require("../language/printer"),
            _definition = require("../type/definition"),
            _scalars = require("../type/scalars"),
            _directives = require("../type/directives");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isSpecDirective(directiveName) {
            return (
              "skip" === directiveName ||
              "include" === directiveName ||
              "deprecated" === directiveName
            );
          }
          function isDefinedType(typename) {
            return (
              !isIntrospectionType(typename) &&
              !(function(typename) {
                return (
                  "String" === typename ||
                  "Boolean" === typename ||
                  "Int" === typename ||
                  "Float" === typename ||
                  "ID" === typename
                );
              })(typename)
            );
          }
          function isIntrospectionType(typename) {
            return 0 === typename.indexOf("__");
          }
          function printFilteredSchema(schema, directiveFilter, typeFilter) {
            var directives = schema.getDirectives().filter(function(directive) {
                return directiveFilter(directive.name);
              }),
              typeMap = schema.getTypeMap(),
              types = Object.keys(typeMap)
                .filter(typeFilter)
                .sort(function(name1, name2) {
                  return name1.localeCompare(name2);
                })
                .map(function(typeName) {
                  return typeMap[typeName];
                });
            return (
              [
                (function(schema) {
                  if (
                    (function(schema) {
                      var queryType = schema.getQueryType();
                      if (queryType && "Query" !== queryType.name) return !1;
                      var mutationType = schema.getMutationType();
                      if (mutationType && "Mutation" !== mutationType.name)
                        return !1;
                      var subscriptionType = schema.getSubscriptionType();
                      if (
                        subscriptionType &&
                        "Subscription" !== subscriptionType.name
                      )
                        return !1;
                      return !0;
                    })(schema)
                  )
                    return;
                  var operationTypes = [],
                    queryType = schema.getQueryType();
                  queryType &&
                    operationTypes.push("  query: " + queryType.name);
                  var mutationType = schema.getMutationType();
                  mutationType &&
                    operationTypes.push("  mutation: " + mutationType.name);
                  var subscriptionType = schema.getSubscriptionType();
                  subscriptionType &&
                    operationTypes.push(
                      "  subscription: " + subscriptionType.name
                    );
                  return "schema {\n" + operationTypes.join("\n") + "\n}";
                })(schema)
              ]
                .concat(directives.map(printDirective), types.map(printType))
                .filter(Boolean)
                .join("\n\n") + "\n"
            );
          }
          function printType(type) {
            return type instanceof _definition.GraphQLScalarType
              ? (function(type) {
                  return printDescription(type) + "scalar " + type.name;
                })(type)
              : type instanceof _definition.GraphQLObjectType
                ? (function(type) {
                    var interfaces = type.getInterfaces(),
                      implementedInterfaces = interfaces.length
                        ? " implements " +
                          interfaces
                            .map(function(i) {
                              return i.name;
                            })
                            .join(", ")
                        : "";
                    return (
                      printDescription(type) +
                      "type " +
                      type.name +
                      implementedInterfaces +
                      " {\n" +
                      printFields(type) +
                      "\n}"
                    );
                  })(type)
                : type instanceof _definition.GraphQLInterfaceType
                  ? (function(type) {
                      return (
                        printDescription(type) +
                        "interface " +
                        type.name +
                        " {\n" +
                        printFields(type) +
                        "\n}"
                      );
                    })(type)
                  : type instanceof _definition.GraphQLUnionType
                    ? (function(type) {
                        return (
                          printDescription(type) +
                          "union " +
                          type.name +
                          " = " +
                          type.getTypes().join(" | ")
                        );
                      })(type)
                    : type instanceof _definition.GraphQLEnumType
                      ? (function(type) {
                          return (
                            printDescription(type) +
                            "enum " +
                            type.name +
                            " {\n" +
                            ((values = type.getValues()),
                            values
                              .map(function(value, i) {
                                return (
                                  printDescription(value, "  ", !i) +
                                  "  " +
                                  value.name +
                                  printDeprecated(value)
                                );
                              })
                              .join("\n")) +
                            "\n}"
                          );
                          var values;
                        })(type)
                      : (type instanceof _definition.GraphQLInputObjectType ||
                          (0, _invariant2.default)(0),
                        (function(type) {
                          var fieldMap = type.getFields(),
                            fields = Object.keys(fieldMap).map(function(
                              fieldName
                            ) {
                              return fieldMap[fieldName];
                            });
                          return (
                            printDescription(type) +
                            "input " +
                            type.name +
                            " {\n" +
                            fields
                              .map(function(f, i) {
                                return (
                                  printDescription(f, "  ", !i) +
                                  "  " +
                                  printInputValue(f)
                                );
                              })
                              .join("\n") +
                            "\n}"
                          );
                        })(type));
          }
          function printFields(type) {
            var fieldMap = type.getFields();
            return Object.keys(fieldMap)
              .map(function(fieldName) {
                return fieldMap[fieldName];
              })
              .map(function(f, i) {
                return (
                  printDescription(f, "  ", !i) +
                  "  " +
                  f.name +
                  printArgs(f.args, "  ") +
                  ": " +
                  String(f.type) +
                  printDeprecated(f)
                );
              })
              .join("\n");
          }
          function printArgs(args) {
            var indentation =
              1 < arguments.length && void 0 !== arguments[1]
                ? arguments[1]
                : "";
            return 0 === args.length
              ? ""
              : args.every(function(arg) {
                  return !arg.description;
                })
                ? "(" + args.map(printInputValue).join(", ") + ")"
                : "(\n" +
                  args
                    .map(function(arg, i) {
                      return (
                        printDescription(arg, "  " + indentation, !i) +
                        "  " +
                        indentation +
                        printInputValue(arg)
                      );
                    })
                    .join("\n") +
                  "\n" +
                  indentation +
                  ")";
          }
          function printInputValue(arg) {
            var argDecl = arg.name + ": " + String(arg.type);
            return (
              (0, _isInvalid2.default)(arg.defaultValue) ||
                (argDecl +=
                  " = " +
                  (0, _printer.print)(
                    (0, _astFromValue.astFromValue)(arg.defaultValue, arg.type)
                  )),
              argDecl
            );
          }
          function printDirective(directive) {
            return (
              printDescription(directive) +
              "directive @" +
              directive.name +
              printArgs(directive.args) +
              " on " +
              directive.locations.join(" | ")
            );
          }
          function printDeprecated(fieldOrEnumVal) {
            var reason = fieldOrEnumVal.deprecationReason;
            return (0, _isNullish2.default)(reason)
              ? ""
              : "" === reason ||
                reason === _directives.DEFAULT_DEPRECATION_REASON
                ? " @deprecated"
                : " @deprecated(reason: " +
                  (0, _printer.print)(
                    (0, _astFromValue.astFromValue)(
                      reason,
                      _scalars.GraphQLString
                    )
                  ) +
                  ")";
          }
          function printDescription(def) {
            var indentation =
                1 < arguments.length && void 0 !== arguments[1]
                  ? arguments[1]
                  : "",
              firstInBlock =
                !(2 < arguments.length && void 0 !== arguments[2]) ||
                arguments[2];
            if (!def.description) return "";
            for (
              var lines = def.description.split("\n"),
                description = indentation && !firstInBlock ? "\n" : "",
                i = 0;
              i < lines.length;
              i++
            )
              if ("" === lines[i]) description += indentation + "#\n";
              else
                for (
                  var sublines = breakLine(lines[i], 120 - indentation.length),
                    j = 0;
                  j < sublines.length;
                  j++
                )
                  description += indentation + "# " + sublines[j] + "\n";
            return description;
          }
          function breakLine(line, len) {
            if (line.length < len + 5) return [line];
            var parts = line.split(
              new RegExp("((?: |^).{15," + (len - 40) + "}(?= |$))")
            );
            if (parts.length < 4) return [line];
            for (
              var sublines = [parts[0] + parts[1] + parts[2]], i = 3;
              i < parts.length;
              i += 2
            )
              sublines.push(parts[i].slice(1) + parts[i + 1]);
            return sublines;
          }
        },
        {
          "../jsutils/invariant": 103,
          "../jsutils/isInvalid": 104,
          "../jsutils/isNullish": 105,
          "../language/printer": 115,
          "../type/definition": 121,
          "../type/directives": 122,
          "../type/scalars": 125,
          "../utilities/astFromValue": 129
        }
      ],
      142: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.separateOperations = function(documentAST) {
              var operations = [],
                fragments = Object.create(null),
                positions = new Map(),
                depGraph = Object.create(null),
                fromName = void 0,
                idx = 0;
              (0, _visitor.visit)(documentAST, {
                OperationDefinition: function(node) {
                  (fromName = opName(node)),
                    operations.push(node),
                    positions.set(node, idx++);
                },
                FragmentDefinition: function(node) {
                  (fromName = node.name.value),
                    (fragments[fromName] = node),
                    positions.set(node, idx++);
                },
                FragmentSpread: function(node) {
                  var toName = node.name.value;
                  (depGraph[fromName] ||
                    (depGraph[fromName] = Object.create(null)))[toName] = !0;
                }
              });
              var separatedDocumentASTs = Object.create(null);
              return (
                operations.forEach(function(operation) {
                  var operationName = opName(operation),
                    dependencies = Object.create(null);
                  !(function collectTransitiveDependencies(
                    collected,
                    depGraph,
                    fromName
                  ) {
                    var immediateDeps = depGraph[fromName];
                    immediateDeps &&
                      Object.keys(immediateDeps).forEach(function(toName) {
                        collected[toName] ||
                          ((collected[toName] = !0),
                          collectTransitiveDependencies(
                            collected,
                            depGraph,
                            toName
                          ));
                      });
                  })(dependencies, depGraph, operationName);
                  var definitions = [operation];
                  Object.keys(dependencies).forEach(function(name) {
                    definitions.push(fragments[name]);
                  }),
                    definitions.sort(function(n1, n2) {
                      return (
                        (positions.get(n1) || 0) - (positions.get(n2) || 0)
                      );
                    }),
                    (separatedDocumentASTs[operationName] = {
                      kind: "Document",
                      definitions: definitions
                    });
                }),
                separatedDocumentASTs
              );
            });
          var _visitor = require("../language/visitor");
          function opName(operation) {
            return operation.name ? operation.name.value : "";
          }
        },
        { "../language/visitor": 117 }
      ],
      143: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.isEqualType = function isEqualType(typeA, typeB) {
              if (typeA === typeB) return !0;
              if (
                typeA instanceof _definition.GraphQLNonNull &&
                typeB instanceof _definition.GraphQLNonNull
              )
                return isEqualType(typeA.ofType, typeB.ofType);
              if (
                typeA instanceof _definition.GraphQLList &&
                typeB instanceof _definition.GraphQLList
              )
                return isEqualType(typeA.ofType, typeB.ofType);
              return !1;
            }),
            (exports.isTypeSubTypeOf = function isTypeSubTypeOf(
              schema,
              maybeSubType,
              superType
            ) {
              if (maybeSubType === superType) return !0;
              {
                if (superType instanceof _definition.GraphQLNonNull)
                  return (
                    maybeSubType instanceof _definition.GraphQLNonNull &&
                    isTypeSubTypeOf(
                      schema,
                      maybeSubType.ofType,
                      superType.ofType
                    )
                  );
                if (maybeSubType instanceof _definition.GraphQLNonNull)
                  return isTypeSubTypeOf(
                    schema,
                    maybeSubType.ofType,
                    superType
                  );
              }
              {
                if (superType instanceof _definition.GraphQLList)
                  return (
                    maybeSubType instanceof _definition.GraphQLList &&
                    isTypeSubTypeOf(
                      schema,
                      maybeSubType.ofType,
                      superType.ofType
                    )
                  );
                if (maybeSubType instanceof _definition.GraphQLList) return !1;
              }
              if (
                (0, _definition.isAbstractType)(superType) &&
                maybeSubType instanceof _definition.GraphQLObjectType &&
                schema.isPossibleType(superType, maybeSubType)
              )
                return !0;
              return !1;
            }),
            (exports.doTypesOverlap = function(schema, typeA, typeB) {
              var _typeB = typeB;
              if (typeA === _typeB) return !0;
              if ((0, _definition.isAbstractType)(typeA))
                return (0, _definition.isAbstractType)(_typeB)
                  ? schema.getPossibleTypes(typeA).some(function(type) {
                      return schema.isPossibleType(_typeB, type);
                    })
                  : schema.isPossibleType(typeA, _typeB);
              if ((0, _definition.isAbstractType)(_typeB))
                return schema.isPossibleType(_typeB, typeA);
              return !1;
            });
          var _definition = require("../type/definition");
        },
        { "../type/definition": 121 }
      ],
      144: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.typeFromAST = void 0);
          var obj,
            _invariant = require("../jsutils/invariant"),
            _invariant2 =
              (obj = _invariant) && obj.__esModule ? obj : { default: obj },
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../language/kinds")),
            _definition = require("../type/definition");
          var typeFromAST = (exports.typeFromAST = function(schema, typeNode) {
            var innerType = void 0;
            return typeNode.kind === Kind.LIST_TYPE
              ? (innerType = typeFromAST(schema, typeNode.type)) &&
                  new _definition.GraphQLList(innerType)
              : typeNode.kind === Kind.NON_NULL_TYPE
                ? (innerType = typeFromAST(schema, typeNode.type)) &&
                  new _definition.GraphQLNonNull(innerType)
                : (typeNode.kind !== Kind.NAMED_TYPE &&
                    (0, _invariant2.default)(0, "Must be a named type."),
                  schema.getType(typeNode.name.value));
          });
        },
        {
          "../jsutils/invariant": 103,
          "../language/kinds": 111,
          "../type/definition": 121
        }
      ],
      145: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.valueFromAST = function valueFromAST(
              valueNode,
              type,
              variables
            ) {
              if (!valueNode) return;
              if (type instanceof _definition.GraphQLNonNull) {
                if (valueNode.kind === Kind.NULL) return;
                return valueFromAST(valueNode, type.ofType, variables);
              }
              if (valueNode.kind === Kind.NULL) return null;
              if (valueNode.kind === Kind.VARIABLE) {
                var variableName = valueNode.name.value;
                if (
                  !variables ||
                  (0, _isInvalid2.default)(variables[variableName])
                )
                  return;
                return variables[variableName];
              }
              if (type instanceof _definition.GraphQLList) {
                var itemType = type.ofType;
                if (valueNode.kind === Kind.LIST) {
                  for (
                    var coercedValues = [], itemNodes = valueNode.values, i = 0;
                    i < itemNodes.length;
                    i++
                  )
                    if (isMissingVariable(itemNodes[i], variables)) {
                      if (itemType instanceof _definition.GraphQLNonNull)
                        return;
                      coercedValues.push(null);
                    } else {
                      var itemValue = valueFromAST(
                        itemNodes[i],
                        itemType,
                        variables
                      );
                      if ((0, _isInvalid2.default)(itemValue)) return;
                      coercedValues.push(itemValue);
                    }
                  return coercedValues;
                }
                var coercedValue = valueFromAST(valueNode, itemType, variables);
                if ((0, _isInvalid2.default)(coercedValue)) return;
                return [coercedValue];
              }
              if (type instanceof _definition.GraphQLInputObjectType) {
                if (valueNode.kind !== Kind.OBJECT) return;
                for (
                  var coercedObj = Object.create(null),
                    fields = type.getFields(),
                    fieldNodes = (0, _keyMap2.default)(
                      valueNode.fields,
                      function(field) {
                        return field.name.value;
                      }
                    ),
                    fieldNames = Object.keys(fields),
                    _i = 0;
                  _i < fieldNames.length;
                  _i++
                ) {
                  var fieldName = fieldNames[_i],
                    field = fields[fieldName],
                    fieldNode = fieldNodes[fieldName];
                  if (
                    fieldNode &&
                    !isMissingVariable(fieldNode.value, variables)
                  ) {
                    var fieldValue = valueFromAST(
                      fieldNode.value,
                      field.type,
                      variables
                    );
                    if ((0, _isInvalid2.default)(fieldValue)) return;
                    coercedObj[fieldName] = fieldValue;
                  } else if ((0, _isInvalid2.default)(field.defaultValue)) {
                    if (field.type instanceof _definition.GraphQLNonNull)
                      return;
                  } else coercedObj[fieldName] = field.defaultValue;
                }
                return coercedObj;
              }
              type instanceof _definition.GraphQLScalarType ||
                type instanceof _definition.GraphQLEnumType ||
                (0, _invariant2.default)(0, "Must be input type");
              var parsed = type.parseLiteral(valueNode);
              if (
                (0, _isNullish2.default)(parsed) &&
                !type.isValidLiteral(valueNode)
              )
                return;
              return parsed;
            });
          var _keyMap2 = _interopRequireDefault(require("../jsutils/keyMap")),
            _invariant2 = _interopRequireDefault(
              require("../jsutils/invariant")
            ),
            _isNullish2 = _interopRequireDefault(
              require("../jsutils/isNullish")
            ),
            _isInvalid2 = _interopRequireDefault(
              require("../jsutils/isInvalid")
            ),
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../language/kinds")),
            _definition = require("../type/definition");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function isMissingVariable(valueNode, variables) {
            return (
              valueNode.kind === Kind.VARIABLE &&
              (!variables ||
                (0, _isInvalid2.default)(variables[valueNode.name.value]))
            );
          }
        },
        {
          "../jsutils/invariant": 103,
          "../jsutils/isInvalid": 104,
          "../jsutils/isNullish": 105,
          "../jsutils/keyMap": 106,
          "../language/kinds": 111,
          "../type/definition": 121
        }
      ],
      146: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 });
          var _validate = require("./validate");
          Object.defineProperty(exports, "validate", {
            enumerable: !0,
            get: function() {
              return _validate.validate;
            }
          }),
            Object.defineProperty(exports, "ValidationContext", {
              enumerable: !0,
              get: function() {
                return _validate.ValidationContext;
              }
            });
          var _specifiedRules = require("./specifiedRules");
          Object.defineProperty(exports, "specifiedRules", {
            enumerable: !0,
            get: function() {
              return _specifiedRules.specifiedRules;
            }
          });
          var _ArgumentsOfCorrectType = require("./rules/ArgumentsOfCorrectType");
          Object.defineProperty(exports, "ArgumentsOfCorrectTypeRule", {
            enumerable: !0,
            get: function() {
              return _ArgumentsOfCorrectType.ArgumentsOfCorrectType;
            }
          });
          var _DefaultValuesOfCorrectType = require("./rules/DefaultValuesOfCorrectType");
          Object.defineProperty(exports, "DefaultValuesOfCorrectTypeRule", {
            enumerable: !0,
            get: function() {
              return _DefaultValuesOfCorrectType.DefaultValuesOfCorrectType;
            }
          });
          var _FieldsOnCorrectType = require("./rules/FieldsOnCorrectType");
          Object.defineProperty(exports, "FieldsOnCorrectTypeRule", {
            enumerable: !0,
            get: function() {
              return _FieldsOnCorrectType.FieldsOnCorrectType;
            }
          });
          var _FragmentsOnCompositeTypes = require("./rules/FragmentsOnCompositeTypes");
          Object.defineProperty(exports, "FragmentsOnCompositeTypesRule", {
            enumerable: !0,
            get: function() {
              return _FragmentsOnCompositeTypes.FragmentsOnCompositeTypes;
            }
          });
          var _KnownArgumentNames = require("./rules/KnownArgumentNames");
          Object.defineProperty(exports, "KnownArgumentNamesRule", {
            enumerable: !0,
            get: function() {
              return _KnownArgumentNames.KnownArgumentNames;
            }
          });
          var _KnownDirectives = require("./rules/KnownDirectives");
          Object.defineProperty(exports, "KnownDirectivesRule", {
            enumerable: !0,
            get: function() {
              return _KnownDirectives.KnownDirectives;
            }
          });
          var _KnownFragmentNames = require("./rules/KnownFragmentNames");
          Object.defineProperty(exports, "KnownFragmentNamesRule", {
            enumerable: !0,
            get: function() {
              return _KnownFragmentNames.KnownFragmentNames;
            }
          });
          var _KnownTypeNames = require("./rules/KnownTypeNames");
          Object.defineProperty(exports, "KnownTypeNamesRule", {
            enumerable: !0,
            get: function() {
              return _KnownTypeNames.KnownTypeNames;
            }
          });
          var _LoneAnonymousOperation = require("./rules/LoneAnonymousOperation");
          Object.defineProperty(exports, "LoneAnonymousOperationRule", {
            enumerable: !0,
            get: function() {
              return _LoneAnonymousOperation.LoneAnonymousOperation;
            }
          });
          var _NoFragmentCycles = require("./rules/NoFragmentCycles");
          Object.defineProperty(exports, "NoFragmentCyclesRule", {
            enumerable: !0,
            get: function() {
              return _NoFragmentCycles.NoFragmentCycles;
            }
          });
          var _NoUndefinedVariables = require("./rules/NoUndefinedVariables");
          Object.defineProperty(exports, "NoUndefinedVariablesRule", {
            enumerable: !0,
            get: function() {
              return _NoUndefinedVariables.NoUndefinedVariables;
            }
          });
          var _NoUnusedFragments = require("./rules/NoUnusedFragments");
          Object.defineProperty(exports, "NoUnusedFragmentsRule", {
            enumerable: !0,
            get: function() {
              return _NoUnusedFragments.NoUnusedFragments;
            }
          });
          var _NoUnusedVariables = require("./rules/NoUnusedVariables");
          Object.defineProperty(exports, "NoUnusedVariablesRule", {
            enumerable: !0,
            get: function() {
              return _NoUnusedVariables.NoUnusedVariables;
            }
          });
          var _OverlappingFieldsCanBeMerged = require("./rules/OverlappingFieldsCanBeMerged");
          Object.defineProperty(exports, "OverlappingFieldsCanBeMergedRule", {
            enumerable: !0,
            get: function() {
              return _OverlappingFieldsCanBeMerged.OverlappingFieldsCanBeMerged;
            }
          });
          var _PossibleFragmentSpreads = require("./rules/PossibleFragmentSpreads");
          Object.defineProperty(exports, "PossibleFragmentSpreadsRule", {
            enumerable: !0,
            get: function() {
              return _PossibleFragmentSpreads.PossibleFragmentSpreads;
            }
          });
          var _ProvidedNonNullArguments = require("./rules/ProvidedNonNullArguments");
          Object.defineProperty(exports, "ProvidedNonNullArgumentsRule", {
            enumerable: !0,
            get: function() {
              return _ProvidedNonNullArguments.ProvidedNonNullArguments;
            }
          });
          var _ScalarLeafs = require("./rules/ScalarLeafs");
          Object.defineProperty(exports, "ScalarLeafsRule", {
            enumerable: !0,
            get: function() {
              return _ScalarLeafs.ScalarLeafs;
            }
          });
          var _SingleFieldSubscriptions = require("./rules/SingleFieldSubscriptions");
          Object.defineProperty(exports, "SingleFieldSubscriptionsRule", {
            enumerable: !0,
            get: function() {
              return _SingleFieldSubscriptions.SingleFieldSubscriptions;
            }
          });
          var _UniqueArgumentNames = require("./rules/UniqueArgumentNames");
          Object.defineProperty(exports, "UniqueArgumentNamesRule", {
            enumerable: !0,
            get: function() {
              return _UniqueArgumentNames.UniqueArgumentNames;
            }
          });
          var _UniqueDirectivesPerLocation = require("./rules/UniqueDirectivesPerLocation");
          Object.defineProperty(exports, "UniqueDirectivesPerLocationRule", {
            enumerable: !0,
            get: function() {
              return _UniqueDirectivesPerLocation.UniqueDirectivesPerLocation;
            }
          });
          var _UniqueFragmentNames = require("./rules/UniqueFragmentNames");
          Object.defineProperty(exports, "UniqueFragmentNamesRule", {
            enumerable: !0,
            get: function() {
              return _UniqueFragmentNames.UniqueFragmentNames;
            }
          });
          var _UniqueInputFieldNames = require("./rules/UniqueInputFieldNames");
          Object.defineProperty(exports, "UniqueInputFieldNamesRule", {
            enumerable: !0,
            get: function() {
              return _UniqueInputFieldNames.UniqueInputFieldNames;
            }
          });
          var _UniqueOperationNames = require("./rules/UniqueOperationNames");
          Object.defineProperty(exports, "UniqueOperationNamesRule", {
            enumerable: !0,
            get: function() {
              return _UniqueOperationNames.UniqueOperationNames;
            }
          });
          var _UniqueVariableNames = require("./rules/UniqueVariableNames");
          Object.defineProperty(exports, "UniqueVariableNamesRule", {
            enumerable: !0,
            get: function() {
              return _UniqueVariableNames.UniqueVariableNames;
            }
          });
          var _VariablesAreInputTypes = require("./rules/VariablesAreInputTypes");
          Object.defineProperty(exports, "VariablesAreInputTypesRule", {
            enumerable: !0,
            get: function() {
              return _VariablesAreInputTypes.VariablesAreInputTypes;
            }
          });
          var _VariablesInAllowedPosition = require("./rules/VariablesInAllowedPosition");
          Object.defineProperty(exports, "VariablesInAllowedPositionRule", {
            enumerable: !0,
            get: function() {
              return _VariablesInAllowedPosition.VariablesInAllowedPosition;
            }
          });
        },
        {
          "./rules/ArgumentsOfCorrectType": 147,
          "./rules/DefaultValuesOfCorrectType": 148,
          "./rules/FieldsOnCorrectType": 149,
          "./rules/FragmentsOnCompositeTypes": 150,
          "./rules/KnownArgumentNames": 151,
          "./rules/KnownDirectives": 152,
          "./rules/KnownFragmentNames": 153,
          "./rules/KnownTypeNames": 154,
          "./rules/LoneAnonymousOperation": 155,
          "./rules/NoFragmentCycles": 156,
          "./rules/NoUndefinedVariables": 157,
          "./rules/NoUnusedFragments": 158,
          "./rules/NoUnusedVariables": 159,
          "./rules/OverlappingFieldsCanBeMerged": 160,
          "./rules/PossibleFragmentSpreads": 161,
          "./rules/ProvidedNonNullArguments": 162,
          "./rules/ScalarLeafs": 163,
          "./rules/SingleFieldSubscriptions": 164,
          "./rules/UniqueArgumentNames": 165,
          "./rules/UniqueDirectivesPerLocation": 166,
          "./rules/UniqueFragmentNames": 167,
          "./rules/UniqueInputFieldNames": 168,
          "./rules/UniqueOperationNames": 169,
          "./rules/UniqueVariableNames": 170,
          "./rules/VariablesAreInputTypes": 171,
          "./rules/VariablesInAllowedPosition": 172,
          "./specifiedRules": 173,
          "./validate": 174
        }
      ],
      147: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.badValueMessage = badValueMessage),
            (exports.ArgumentsOfCorrectType = function(context) {
              return {
                Argument: function(node) {
                  var argDef = context.getArgument();
                  if (argDef) {
                    var errors = (0, _isValidLiteralValue.isValidLiteralValue)(
                      argDef.type,
                      node.value
                    );
                    errors &&
                      0 < errors.length &&
                      context.reportError(
                        new _error.GraphQLError(
                          badValueMessage(
                            node.name.value,
                            argDef.type,
                            (0, _printer.print)(node.value),
                            errors
                          ),
                          [node.value]
                        )
                      );
                  }
                  return !1;
                }
              };
            });
          var _error = require("../../error"),
            _printer = require("../../language/printer"),
            _isValidLiteralValue = require("../../utilities/isValidLiteralValue");
          function badValueMessage(argName, type, value, verboseErrors) {
            return (
              'Argument "' +
              argName +
              '" has invalid value ' +
              value +
              "." +
              (verboseErrors ? "\n" + verboseErrors.join("\n") : "")
            );
          }
        },
        {
          "../../error": 94,
          "../../language/printer": 115,
          "../../utilities/isValidLiteralValue": 140
        }
      ],
      148: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.defaultForNonNullArgMessage = defaultForNonNullArgMessage),
            (exports.badValueForDefaultArgMessage = badValueForDefaultArgMessage),
            (exports.DefaultValuesOfCorrectType = function(context) {
              return {
                VariableDefinition: function(node) {
                  var name = node.variable.name.value,
                    defaultValue = node.defaultValue,
                    type = context.getInputType();
                  if (
                    (type instanceof _definition.GraphQLNonNull &&
                      defaultValue &&
                      context.reportError(
                        new _error.GraphQLError(
                          defaultForNonNullArgMessage(name, type, type.ofType),
                          [defaultValue]
                        )
                      ),
                    type && defaultValue)
                  ) {
                    var errors = (0, _isValidLiteralValue.isValidLiteralValue)(
                      type,
                      defaultValue
                    );
                    errors &&
                      0 < errors.length &&
                      context.reportError(
                        new _error.GraphQLError(
                          badValueForDefaultArgMessage(
                            name,
                            type,
                            (0, _printer.print)(defaultValue),
                            errors
                          ),
                          [defaultValue]
                        )
                      );
                  }
                  return !1;
                },
                SelectionSet: function() {
                  return !1;
                },
                FragmentDefinition: function() {
                  return !1;
                }
              };
            });
          var _error = require("../../error"),
            _printer = require("../../language/printer"),
            _definition = require("../../type/definition"),
            _isValidLiteralValue = require("../../utilities/isValidLiteralValue");
          function defaultForNonNullArgMessage(varName, type, guessType) {
            return (
              'Variable "$' +
              varName +
              '" of type "' +
              String(type) +
              '" is required and will not use the default value. Perhaps you meant to use type "' +
              String(guessType) +
              '".'
            );
          }
          function badValueForDefaultArgMessage(
            varName,
            type,
            value,
            verboseErrors
          ) {
            var message = verboseErrors ? "\n" + verboseErrors.join("\n") : "";
            return (
              'Variable "$' +
              varName +
              '" of type "' +
              String(type) +
              '" has invalid default value ' +
              value +
              "." +
              message
            );
          }
        },
        {
          "../../error": 94,
          "../../language/printer": 115,
          "../../type/definition": 121,
          "../../utilities/isValidLiteralValue": 140
        }
      ],
      149: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.undefinedFieldMessage = undefinedFieldMessage),
            (exports.FieldsOnCorrectType = function(context) {
              return {
                Field: function(node) {
                  var type = context.getParentType();
                  if (type) {
                    var fieldDef = context.getFieldDef();
                    if (!fieldDef) {
                      var schema = context.getSchema(),
                        fieldName = node.name.value,
                        suggestedTypeNames = (function(
                          schema,
                          type,
                          fieldName
                        ) {
                          if ((0, _definition.isAbstractType)(type)) {
                            var suggestedObjectTypes = [],
                              interfaceUsageCount = Object.create(null);
                            schema
                              .getPossibleTypes(type)
                              .forEach(function(possibleType) {
                                possibleType.getFields()[fieldName] &&
                                  (suggestedObjectTypes.push(possibleType.name),
                                  possibleType
                                    .getInterfaces()
                                    .forEach(function(possibleInterface) {
                                      possibleInterface.getFields()[
                                        fieldName
                                      ] &&
                                        (interfaceUsageCount[
                                          possibleInterface.name
                                        ] =
                                          (interfaceUsageCount[
                                            possibleInterface.name
                                          ] || 0) + 1);
                                    }));
                              });
                            var suggestedInterfaceTypes = Object.keys(
                              interfaceUsageCount
                            ).sort(function(a, b) {
                              return (
                                interfaceUsageCount[b] - interfaceUsageCount[a]
                              );
                            });
                            return suggestedInterfaceTypes.concat(
                              suggestedObjectTypes
                            );
                          }
                          return [];
                        })(schema, type, fieldName),
                        suggestedFieldNames =
                          0 !== suggestedTypeNames.length
                            ? []
                            : (function(schema, type, fieldName) {
                                if (
                                  type instanceof
                                    _definition.GraphQLObjectType ||
                                  type instanceof
                                    _definition.GraphQLInterfaceType
                                ) {
                                  var possibleFieldNames = Object.keys(
                                    type.getFields()
                                  );
                                  return (0, _suggestionList2.default)(
                                    fieldName,
                                    possibleFieldNames
                                  );
                                }
                                return [];
                              })(0, type, fieldName);
                      context.reportError(
                        new _error.GraphQLError(
                          undefinedFieldMessage(
                            fieldName,
                            type.name,
                            suggestedTypeNames,
                            suggestedFieldNames
                          ),
                          [node]
                        )
                      );
                    }
                  }
                }
              };
            });
          var _error = require("../../error"),
            _suggestionList2 = _interopRequireDefault(
              require("../../jsutils/suggestionList")
            ),
            _quotedOrList2 = _interopRequireDefault(
              require("../../jsutils/quotedOrList")
            ),
            _definition = require("../../type/definition");
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function undefinedFieldMessage(
            fieldName,
            type,
            suggestedTypeNames,
            suggestedFieldNames
          ) {
            var message =
              'Cannot query field "' + fieldName + '" on type "' + type + '".';
            0 !== suggestedTypeNames.length
              ? (message +=
                  " Did you mean to use an inline fragment on " +
                  (0, _quotedOrList2.default)(suggestedTypeNames) +
                  "?")
              : 0 !== suggestedFieldNames.length &&
                (message +=
                  " Did you mean " +
                  (0, _quotedOrList2.default)(suggestedFieldNames) +
                  "?");
            return message;
          }
        },
        {
          "../../error": 94,
          "../../jsutils/quotedOrList": 108,
          "../../jsutils/suggestionList": 109,
          "../../type/definition": 121
        }
      ],
      150: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.inlineFragmentOnNonCompositeErrorMessage = inlineFragmentOnNonCompositeErrorMessage),
            (exports.fragmentOnNonCompositeErrorMessage = fragmentOnNonCompositeErrorMessage),
            (exports.FragmentsOnCompositeTypes = function(context) {
              return {
                InlineFragment: function(node) {
                  if (node.typeCondition) {
                    var type = (0, _typeFromAST.typeFromAST)(
                      context.getSchema(),
                      node.typeCondition
                    );
                    type &&
                      !(0, _definition.isCompositeType)(type) &&
                      context.reportError(
                        new _error.GraphQLError(
                          inlineFragmentOnNonCompositeErrorMessage(
                            (0, _printer.print)(node.typeCondition)
                          ),
                          [node.typeCondition]
                        )
                      );
                  }
                },
                FragmentDefinition: function(node) {
                  var type = (0, _typeFromAST.typeFromAST)(
                    context.getSchema(),
                    node.typeCondition
                  );
                  type &&
                    !(0, _definition.isCompositeType)(type) &&
                    context.reportError(
                      new _error.GraphQLError(
                        fragmentOnNonCompositeErrorMessage(
                          node.name.value,
                          (0, _printer.print)(node.typeCondition)
                        ),
                        [node.typeCondition]
                      )
                    );
                }
              };
            });
          var _error = require("../../error"),
            _printer = require("../../language/printer"),
            _definition = require("../../type/definition"),
            _typeFromAST = require("../../utilities/typeFromAST");
          function inlineFragmentOnNonCompositeErrorMessage(type) {
            return (
              'Fragment cannot condition on non composite type "' +
              String(type) +
              '".'
            );
          }
          function fragmentOnNonCompositeErrorMessage(fragName, type) {
            return (
              'Fragment "' +
              fragName +
              '" cannot condition on non composite type "' +
              String(type) +
              '".'
            );
          }
        },
        {
          "../../error": 94,
          "../../language/printer": 115,
          "../../type/definition": 121,
          "../../utilities/typeFromAST": 144
        }
      ],
      151: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.unknownArgMessage = unknownArgMessage),
            (exports.unknownDirectiveArgMessage = unknownDirectiveArgMessage),
            (exports.KnownArgumentNames = function(context) {
              return {
                Argument: function(node, key, parent, path, ancestors) {
                  var argumentOf = ancestors[ancestors.length - 1];
                  if (argumentOf.kind === Kind.FIELD) {
                    var fieldDef = context.getFieldDef();
                    if (fieldDef) {
                      var fieldArgDef = (0, _find2.default)(
                        fieldDef.args,
                        function(arg) {
                          return arg.name === node.name.value;
                        }
                      );
                      if (!fieldArgDef) {
                        var parentType = context.getParentType();
                        parentType || (0, _invariant2.default)(0),
                          context.reportError(
                            new _error.GraphQLError(
                              unknownArgMessage(
                                node.name.value,
                                fieldDef.name,
                                parentType.name,
                                (0, _suggestionList2.default)(
                                  node.name.value,
                                  fieldDef.args.map(function(arg) {
                                    return arg.name;
                                  })
                                )
                              ),
                              [node]
                            )
                          );
                      }
                    }
                  } else if (argumentOf.kind === Kind.DIRECTIVE) {
                    var directive = context.getDirective();
                    if (directive) {
                      var directiveArgDef = (0, _find2.default)(
                        directive.args,
                        function(arg) {
                          return arg.name === node.name.value;
                        }
                      );
                      directiveArgDef ||
                        context.reportError(
                          new _error.GraphQLError(
                            unknownDirectiveArgMessage(
                              node.name.value,
                              directive.name,
                              (0, _suggestionList2.default)(
                                node.name.value,
                                directive.args.map(function(arg) {
                                  return arg.name;
                                })
                              )
                            ),
                            [node]
                          )
                        );
                    }
                  }
                }
              };
            });
          var _error = require("../../error"),
            _find2 = _interopRequireDefault(require("../../jsutils/find")),
            _invariant2 = _interopRequireDefault(
              require("../../jsutils/invariant")
            ),
            _suggestionList2 = _interopRequireDefault(
              require("../../jsutils/suggestionList")
            ),
            _quotedOrList2 = _interopRequireDefault(
              require("../../jsutils/quotedOrList")
            ),
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../../language/kinds"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function unknownArgMessage(argName, fieldName, type, suggestedArgs) {
            var message =
              'Unknown argument "' +
              argName +
              '" on field "' +
              fieldName +
              '" of type "' +
              String(type) +
              '".';
            return (
              suggestedArgs.length &&
                (message +=
                  " Did you mean " +
                  (0, _quotedOrList2.default)(suggestedArgs) +
                  "?"),
              message
            );
          }
          function unknownDirectiveArgMessage(
            argName,
            directiveName,
            suggestedArgs
          ) {
            var message =
              'Unknown argument "' +
              argName +
              '" on directive "@' +
              directiveName +
              '".';
            return (
              suggestedArgs.length &&
                (message +=
                  " Did you mean " +
                  (0, _quotedOrList2.default)(suggestedArgs) +
                  "?"),
              message
            );
          }
        },
        {
          "../../error": 94,
          "../../jsutils/find": 102,
          "../../jsutils/invariant": 103,
          "../../jsutils/quotedOrList": 108,
          "../../jsutils/suggestionList": 109,
          "../../language/kinds": 111
        }
      ],
      152: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.unknownDirectiveMessage = unknownDirectiveMessage),
            (exports.misplacedDirectiveMessage = misplacedDirectiveMessage),
            (exports.KnownDirectives = function(context) {
              return {
                Directive: function(node, key, parent, path, ancestors) {
                  var directiveDef = (0, _find2.default)(
                    context.getSchema().getDirectives(),
                    function(def) {
                      return def.name === node.name.value;
                    }
                  );
                  if (directiveDef) {
                    var candidateLocation = (function(ancestors) {
                      var appliedTo = ancestors[ancestors.length - 1];
                      switch (appliedTo.kind) {
                        case Kind.OPERATION_DEFINITION:
                          switch (appliedTo.operation) {
                            case "query":
                              return _directives.DirectiveLocation.QUERY;
                            case "mutation":
                              return _directives.DirectiveLocation.MUTATION;
                            case "subscription":
                              return _directives.DirectiveLocation.SUBSCRIPTION;
                          }
                          break;
                        case Kind.FIELD:
                          return _directives.DirectiveLocation.FIELD;
                        case Kind.FRAGMENT_SPREAD:
                          return _directives.DirectiveLocation.FRAGMENT_SPREAD;
                        case Kind.INLINE_FRAGMENT:
                          return _directives.DirectiveLocation.INLINE_FRAGMENT;
                        case Kind.FRAGMENT_DEFINITION:
                          return _directives.DirectiveLocation
                            .FRAGMENT_DEFINITION;
                        case Kind.SCHEMA_DEFINITION:
                          return _directives.DirectiveLocation.SCHEMA;
                        case Kind.SCALAR_TYPE_DEFINITION:
                          return _directives.DirectiveLocation.SCALAR;
                        case Kind.OBJECT_TYPE_DEFINITION:
                          return _directives.DirectiveLocation.OBJECT;
                        case Kind.FIELD_DEFINITION:
                          return _directives.DirectiveLocation.FIELD_DEFINITION;
                        case Kind.INTERFACE_TYPE_DEFINITION:
                          return _directives.DirectiveLocation.INTERFACE;
                        case Kind.UNION_TYPE_DEFINITION:
                          return _directives.DirectiveLocation.UNION;
                        case Kind.ENUM_TYPE_DEFINITION:
                          return _directives.DirectiveLocation.ENUM;
                        case Kind.ENUM_VALUE_DEFINITION:
                          return _directives.DirectiveLocation.ENUM_VALUE;
                        case Kind.INPUT_OBJECT_TYPE_DEFINITION:
                          return _directives.DirectiveLocation.INPUT_OBJECT;
                        case Kind.INPUT_VALUE_DEFINITION:
                          var parentNode = ancestors[ancestors.length - 3];
                          return parentNode.kind ===
                            Kind.INPUT_OBJECT_TYPE_DEFINITION
                            ? _directives.DirectiveLocation
                                .INPUT_FIELD_DEFINITION
                            : _directives.DirectiveLocation.ARGUMENT_DEFINITION;
                      }
                    })(ancestors);
                    candidateLocation
                      ? -1 ===
                          directiveDef.locations.indexOf(candidateLocation) &&
                        context.reportError(
                          new _error.GraphQLError(
                            misplacedDirectiveMessage(
                              node.name.value,
                              candidateLocation
                            ),
                            [node]
                          )
                        )
                      : context.reportError(
                          new _error.GraphQLError(
                            misplacedDirectiveMessage(
                              node.name.value,
                              node.type
                            ),
                            [node]
                          )
                        );
                  } else
                    context.reportError(
                      new _error.GraphQLError(
                        unknownDirectiveMessage(node.name.value),
                        [node]
                      )
                    );
                }
              };
            });
          var obj,
            _error = require("../../error"),
            _find = require("../../jsutils/find"),
            _find2 = (obj = _find) && obj.__esModule ? obj : { default: obj },
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../../language/kinds")),
            _directives = require("../../type/directives");
          function unknownDirectiveMessage(directiveName) {
            return 'Unknown directive "' + directiveName + '".';
          }
          function misplacedDirectiveMessage(directiveName, location) {
            return (
              'Directive "' +
              directiveName +
              '" may not be used on ' +
              location +
              "."
            );
          }
        },
        {
          "../../error": 94,
          "../../jsutils/find": 102,
          "../../language/kinds": 111,
          "../../type/directives": 122
        }
      ],
      153: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.unknownFragmentMessage = unknownFragmentMessage),
            (exports.KnownFragmentNames = function(context) {
              return {
                FragmentSpread: function(node) {
                  var fragmentName = node.name.value,
                    fragment = context.getFragment(fragmentName);
                  fragment ||
                    context.reportError(
                      new _error.GraphQLError(
                        unknownFragmentMessage(fragmentName),
                        [node.name]
                      )
                    );
                }
              };
            });
          var _error = require("../../error");
          function unknownFragmentMessage(fragName) {
            return 'Unknown fragment "' + fragName + '".';
          }
        },
        { "../../error": 94 }
      ],
      154: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.unknownTypeMessage = unknownTypeMessage),
            (exports.KnownTypeNames = function(context) {
              return {
                ObjectTypeDefinition: function() {
                  return !1;
                },
                InterfaceTypeDefinition: function() {
                  return !1;
                },
                UnionTypeDefinition: function() {
                  return !1;
                },
                InputObjectTypeDefinition: function() {
                  return !1;
                },
                NamedType: function(node) {
                  var schema = context.getSchema(),
                    typeName = node.name.value,
                    type = schema.getType(typeName);
                  type ||
                    context.reportError(
                      new _error.GraphQLError(
                        unknownTypeMessage(
                          typeName,
                          (0, _suggestionList2.default)(
                            typeName,
                            Object.keys(schema.getTypeMap())
                          )
                        ),
                        [node]
                      )
                    );
                }
              };
            });
          var _error = require("../../error"),
            _suggestionList2 = _interopRequireDefault(
              require("../../jsutils/suggestionList")
            ),
            _quotedOrList2 = _interopRequireDefault(
              require("../../jsutils/quotedOrList")
            );
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function unknownTypeMessage(type, suggestedTypes) {
            var message = 'Unknown type "' + String(type) + '".';
            return (
              suggestedTypes.length &&
                (message +=
                  " Did you mean " +
                  (0, _quotedOrList2.default)(suggestedTypes) +
                  "?"),
              message
            );
          }
        },
        {
          "../../error": 94,
          "../../jsutils/quotedOrList": 108,
          "../../jsutils/suggestionList": 109
        }
      ],
      155: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.anonOperationNotAloneMessage = anonOperationNotAloneMessage),
            (exports.LoneAnonymousOperation = function(context) {
              var operationCount = 0;
              return {
                Document: function(node) {
                  operationCount = node.definitions.filter(function(
                    definition
                  ) {
                    return definition.kind === _kinds.OPERATION_DEFINITION;
                  }).length;
                },
                OperationDefinition: function(node) {
                  !node.name &&
                    1 < operationCount &&
                    context.reportError(
                      new _error.GraphQLError(
                        "This anonymous operation must be the only defined operation.",
                        [node]
                      )
                    );
                }
              };
            });
          var _error = require("../../error"),
            _kinds = require("../../language/kinds");
          function anonOperationNotAloneMessage() {
            return "This anonymous operation must be the only defined operation.";
          }
        },
        { "../../error": 94, "../../language/kinds": 111 }
      ],
      156: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.cycleErrorMessage = cycleErrorMessage),
            (exports.NoFragmentCycles = function(context) {
              var visitedFrags = Object.create(null),
                spreadPath = [],
                spreadPathIndexByName = Object.create(null);
              return {
                OperationDefinition: function() {
                  return !1;
                },
                FragmentDefinition: function(node) {
                  return (
                    visitedFrags[node.name.value] ||
                      (function detectCycleRecursive(fragment) {
                        var fragmentName = fragment.name.value;
                        visitedFrags[fragmentName] = !0;
                        var spreadNodes = context.getFragmentSpreads(
                          fragment.selectionSet
                        );
                        if (0 === spreadNodes.length) return;
                        spreadPathIndexByName[fragmentName] = spreadPath.length;
                        for (var i = 0; i < spreadNodes.length; i++) {
                          var spreadNode = spreadNodes[i],
                            spreadName = spreadNode.name.value,
                            cycleIndex = spreadPathIndexByName[spreadName];
                          if (void 0 === cycleIndex) {
                            if (
                              (spreadPath.push(spreadNode),
                              !visitedFrags[spreadName])
                            ) {
                              var spreadFragment = context.getFragment(
                                spreadName
                              );
                              spreadFragment &&
                                detectCycleRecursive(spreadFragment);
                            }
                            spreadPath.pop();
                          } else {
                            var cyclePath = spreadPath.slice(cycleIndex);
                            context.reportError(
                              new _error.GraphQLError(
                                cycleErrorMessage(
                                  spreadName,
                                  cyclePath.map(function(s) {
                                    return s.name.value;
                                  })
                                ),
                                cyclePath.concat(spreadNode)
                              )
                            );
                          }
                        }
                        spreadPathIndexByName[fragmentName] = void 0;
                      })(node),
                    !1
                  );
                }
              };
            });
          var _error = require("../../error");
          function cycleErrorMessage(fragName, spreadNames) {
            return (
              'Cannot spread fragment "' +
              fragName +
              '" within itself' +
              (spreadNames.length ? " via " + spreadNames.join(", ") : "") +
              "."
            );
          }
        },
        { "../../error": 94 }
      ],
      157: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.undefinedVarMessage = undefinedVarMessage),
            (exports.NoUndefinedVariables = function(context) {
              var variableNameDefined = Object.create(null);
              return {
                OperationDefinition: {
                  enter: function() {
                    variableNameDefined = Object.create(null);
                  },
                  leave: function(operation) {
                    var usages = context.getRecursiveVariableUsages(operation);
                    usages.forEach(function(_ref) {
                      var node = _ref.node,
                        varName = node.name.value;
                      !0 !== variableNameDefined[varName] &&
                        context.reportError(
                          new _error.GraphQLError(
                            undefinedVarMessage(
                              varName,
                              operation.name && operation.name.value
                            ),
                            [node, operation]
                          )
                        );
                    });
                  }
                },
                VariableDefinition: function(node) {
                  variableNameDefined[node.variable.name.value] = !0;
                }
              };
            });
          var _error = require("../../error");
          function undefinedVarMessage(varName, opName) {
            return opName
              ? 'Variable "$' +
                  varName +
                  '" is not defined by operation "' +
                  opName +
                  '".'
              : 'Variable "$' + varName + '" is not defined.';
          }
        },
        { "../../error": 94 }
      ],
      158: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.unusedFragMessage = unusedFragMessage),
            (exports.NoUnusedFragments = function(context) {
              var operationDefs = [],
                fragmentDefs = [];
              return {
                OperationDefinition: function(node) {
                  return operationDefs.push(node), !1;
                },
                FragmentDefinition: function(node) {
                  return fragmentDefs.push(node), !1;
                },
                Document: {
                  leave: function() {
                    var fragmentNameUsed = Object.create(null);
                    operationDefs.forEach(function(operation) {
                      context
                        .getRecursivelyReferencedFragments(operation)
                        .forEach(function(fragment) {
                          fragmentNameUsed[fragment.name.value] = !0;
                        });
                    }),
                      fragmentDefs.forEach(function(fragmentDef) {
                        var fragName = fragmentDef.name.value;
                        !0 !== fragmentNameUsed[fragName] &&
                          context.reportError(
                            new _error.GraphQLError(
                              unusedFragMessage(fragName),
                              [fragmentDef]
                            )
                          );
                      });
                  }
                }
              };
            });
          var _error = require("../../error");
          function unusedFragMessage(fragName) {
            return 'Fragment "' + fragName + '" is never used.';
          }
        },
        { "../../error": 94 }
      ],
      159: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.unusedVariableMessage = unusedVariableMessage),
            (exports.NoUnusedVariables = function(context) {
              var variableDefs = [];
              return {
                OperationDefinition: {
                  enter: function() {
                    variableDefs = [];
                  },
                  leave: function(operation) {
                    var variableNameUsed = Object.create(null),
                      usages = context.getRecursiveVariableUsages(operation),
                      opName = operation.name ? operation.name.value : null;
                    usages.forEach(function(_ref) {
                      var node = _ref.node;
                      variableNameUsed[node.name.value] = !0;
                    }),
                      variableDefs.forEach(function(variableDef) {
                        var variableName = variableDef.variable.name.value;
                        !0 !== variableNameUsed[variableName] &&
                          context.reportError(
                            new _error.GraphQLError(
                              unusedVariableMessage(variableName, opName),
                              [variableDef]
                            )
                          );
                      });
                  }
                },
                VariableDefinition: function(def) {
                  variableDefs.push(def);
                }
              };
            });
          var _error = require("../../error");
          function unusedVariableMessage(varName, opName) {
            return opName
              ? 'Variable "$' +
                  varName +
                  '" is never used in operation "' +
                  opName +
                  '".'
              : 'Variable "$' + varName + '" is never used.';
          }
        },
        { "../../error": 94 }
      ],
      160: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.fieldsConflictMessage = fieldsConflictMessage),
            (exports.OverlappingFieldsCanBeMerged = function(context) {
              var comparedFragments = new PairSet(),
                cachedFieldsAndFragmentNames = new Map();
              return {
                SelectionSet: function(selectionSet) {
                  var conflicts = (function(
                    context,
                    cachedFieldsAndFragmentNames,
                    comparedFragments,
                    parentType,
                    selectionSet
                  ) {
                    var conflicts = [],
                      _getFieldsAndFragment = getFieldsAndFragmentNames(
                        context,
                        cachedFieldsAndFragmentNames,
                        parentType,
                        selectionSet
                      ),
                      fieldMap = _getFieldsAndFragment[0],
                      fragmentNames = _getFieldsAndFragment[1];
                    !(function(
                      context,
                      conflicts,
                      cachedFieldsAndFragmentNames,
                      comparedFragments,
                      fieldMap
                    ) {
                      Object.keys(fieldMap).forEach(function(responseName) {
                        var fields = fieldMap[responseName];
                        if (1 < fields.length)
                          for (var i = 0; i < fields.length; i++)
                            for (var j = i + 1; j < fields.length; j++) {
                              var conflict = findConflict(
                                context,
                                cachedFieldsAndFragmentNames,
                                comparedFragments,
                                !1,
                                responseName,
                                fields[i],
                                fields[j]
                              );
                              conflict && conflicts.push(conflict);
                            }
                      });
                    })(
                      context,
                      conflicts,
                      cachedFieldsAndFragmentNames,
                      comparedFragments,
                      fieldMap
                    );
                    for (var i = 0; i < fragmentNames.length; i++) {
                      collectConflictsBetweenFieldsAndFragment(
                        context,
                        conflicts,
                        cachedFieldsAndFragmentNames,
                        comparedFragments,
                        !1,
                        fieldMap,
                        fragmentNames[i]
                      );
                      for (var j = i + 1; j < fragmentNames.length; j++)
                        collectConflictsBetweenFragments(
                          context,
                          conflicts,
                          cachedFieldsAndFragmentNames,
                          comparedFragments,
                          !1,
                          fragmentNames[i],
                          fragmentNames[j]
                        );
                    }
                    return conflicts;
                  })(
                    context,
                    cachedFieldsAndFragmentNames,
                    comparedFragments,
                    context.getParentType(),
                    selectionSet
                  );
                  conflicts.forEach(function(_ref2) {
                    var _ref2$ = _ref2[0],
                      responseName = _ref2$[0],
                      reason = _ref2$[1],
                      fields1 = _ref2[1],
                      fields2 = _ref2[2];
                    return context.reportError(
                      new _error.GraphQLError(
                        fieldsConflictMessage(responseName, reason),
                        fields1.concat(fields2)
                      )
                    );
                  });
                }
              };
            });
          var obj,
            _error = require("../../error"),
            _find = require("../../jsutils/find"),
            _find2 = (obj = _find) && obj.__esModule ? obj : { default: obj },
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../../language/kinds")),
            _printer = require("../../language/printer"),
            _definition = require("../../type/definition"),
            _typeFromAST = require("../../utilities/typeFromAST");
          function fieldsConflictMessage(responseName, reason) {
            return (
              'Fields "' +
              responseName +
              '" conflict because ' +
              (function reasonMessage(reason) {
                if (Array.isArray(reason))
                  return reason
                    .map(function(_ref) {
                      var responseName = _ref[0],
                        subreason = _ref[1];
                      return (
                        'subfields "' +
                        responseName +
                        '" conflict because ' +
                        reasonMessage(subreason)
                      );
                    })
                    .join(" and ");
                return reason;
              })(reason) +
              ". Use different aliases on the fields to fetch both if this was intentional."
            );
          }
          function collectConflictsBetweenFieldsAndFragment(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragments,
            areMutuallyExclusive,
            fieldMap,
            fragmentName
          ) {
            var fragment = context.getFragment(fragmentName);
            if (fragment) {
              var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(
                  context,
                  cachedFieldsAndFragmentNames,
                  fragment
                ),
                fieldMap2 = _getReferencedFieldsA[0],
                fragmentNames2 = _getReferencedFieldsA[1];
              collectConflictsBetween(
                context,
                conflicts,
                cachedFieldsAndFragmentNames,
                comparedFragments,
                areMutuallyExclusive,
                fieldMap,
                fieldMap2
              );
              for (var i = 0; i < fragmentNames2.length; i++)
                collectConflictsBetweenFieldsAndFragment(
                  context,
                  conflicts,
                  cachedFieldsAndFragmentNames,
                  comparedFragments,
                  areMutuallyExclusive,
                  fieldMap,
                  fragmentNames2[i]
                );
            }
          }
          function collectConflictsBetweenFragments(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragments,
            areMutuallyExclusive,
            fragmentName1,
            fragmentName2
          ) {
            var fragment1 = context.getFragment(fragmentName1),
              fragment2 = context.getFragment(fragmentName2);
            if (
              fragment1 &&
              fragment2 &&
              fragment1 !== fragment2 &&
              !comparedFragments.has(
                fragmentName1,
                fragmentName2,
                areMutuallyExclusive
              )
            ) {
              comparedFragments.add(
                fragmentName1,
                fragmentName2,
                areMutuallyExclusive
              );
              var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(
                  context,
                  cachedFieldsAndFragmentNames,
                  fragment1
                ),
                fieldMap1 = _getReferencedFieldsA2[0],
                fragmentNames1 = _getReferencedFieldsA2[1],
                _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(
                  context,
                  cachedFieldsAndFragmentNames,
                  fragment2
                ),
                fieldMap2 = _getReferencedFieldsA3[0],
                fragmentNames2 = _getReferencedFieldsA3[1];
              collectConflictsBetween(
                context,
                conflicts,
                cachedFieldsAndFragmentNames,
                comparedFragments,
                areMutuallyExclusive,
                fieldMap1,
                fieldMap2
              );
              for (var j = 0; j < fragmentNames2.length; j++)
                collectConflictsBetweenFragments(
                  context,
                  conflicts,
                  cachedFieldsAndFragmentNames,
                  comparedFragments,
                  areMutuallyExclusive,
                  fragmentName1,
                  fragmentNames2[j]
                );
              for (var i = 0; i < fragmentNames1.length; i++)
                collectConflictsBetweenFragments(
                  context,
                  conflicts,
                  cachedFieldsAndFragmentNames,
                  comparedFragments,
                  areMutuallyExclusive,
                  fragmentNames1[i],
                  fragmentName2
                );
            }
          }
          function collectConflictsBetween(
            context,
            conflicts,
            cachedFieldsAndFragmentNames,
            comparedFragments,
            parentFieldsAreMutuallyExclusive,
            fieldMap1,
            fieldMap2
          ) {
            Object.keys(fieldMap1).forEach(function(responseName) {
              var fields2 = fieldMap2[responseName];
              if (fields2)
                for (
                  var fields1 = fieldMap1[responseName], i = 0;
                  i < fields1.length;
                  i++
                )
                  for (var j = 0; j < fields2.length; j++) {
                    var conflict = findConflict(
                      context,
                      cachedFieldsAndFragmentNames,
                      comparedFragments,
                      parentFieldsAreMutuallyExclusive,
                      responseName,
                      fields1[i],
                      fields2[j]
                    );
                    conflict && conflicts.push(conflict);
                  }
            });
          }
          function findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragments,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          ) {
            var parentType1 = field1[0],
              node1 = field1[1],
              def1 = field1[2],
              parentType2 = field2[0],
              node2 = field2[1],
              def2 = field2[2],
              areMutuallyExclusive =
                parentFieldsAreMutuallyExclusive ||
                (parentType1 !== parentType2 &&
                  parentType1 instanceof _definition.GraphQLObjectType &&
                  parentType2 instanceof _definition.GraphQLObjectType),
              type1 = def1 && def1.type,
              type2 = def2 && def2.type;
            if (!areMutuallyExclusive) {
              var name1 = node1.name.value,
                name2 = node2.name.value;
              if (name1 !== name2)
                return [
                  [
                    responseName,
                    name1 + " and " + name2 + " are different fields"
                  ],
                  [node1],
                  [node2]
                ];
              if (
                !(function(arguments1, arguments2) {
                  if (arguments1.length !== arguments2.length) return !1;
                  return arguments1.every(function(argument1) {
                    var value1,
                      value2,
                      argument2 = (0, _find2.default)(arguments2, function(
                        argument
                      ) {
                        return argument.name.value === argument1.name.value;
                      });
                    return (
                      !!argument2 &&
                      ((value1 = argument1.value),
                      (value2 = argument2.value),
                      (!value1 && !value2) ||
                        (0, _printer.print)(value1) ===
                          (0, _printer.print)(value2))
                    );
                  });
                })(node1.arguments || [], node2.arguments || [])
              )
                return [
                  [responseName, "they have differing arguments"],
                  [node1],
                  [node2]
                ];
            }
            if (
              type1 &&
              type2 &&
              (function doTypesConflict(type1, type2) {
                if (type1 instanceof _definition.GraphQLList)
                  return (
                    !(type2 instanceof _definition.GraphQLList) ||
                    doTypesConflict(type1.ofType, type2.ofType)
                  );
                if (type2 instanceof _definition.GraphQLList)
                  return (
                    !(type1 instanceof _definition.GraphQLList) ||
                    doTypesConflict(type1.ofType, type2.ofType)
                  );
                if (type1 instanceof _definition.GraphQLNonNull)
                  return (
                    !(type2 instanceof _definition.GraphQLNonNull) ||
                    doTypesConflict(type1.ofType, type2.ofType)
                  );
                if (type2 instanceof _definition.GraphQLNonNull)
                  return (
                    !(type1 instanceof _definition.GraphQLNonNull) ||
                    doTypesConflict(type1.ofType, type2.ofType)
                  );
                if (
                  (0, _definition.isLeafType)(type1) ||
                  (0, _definition.isLeafType)(type2)
                )
                  return type1 !== type2;
                return !1;
              })(type1, type2)
            )
              return [
                [
                  responseName,
                  "they return conflicting types " +
                    String(type1) +
                    " and " +
                    String(type2)
                ],
                [node1],
                [node2]
              ];
            var selectionSet1 = node1.selectionSet,
              selectionSet2 = node2.selectionSet;
            return selectionSet1 && selectionSet2
              ? (function(conflicts, responseName, node1, node2) {
                  if (0 < conflicts.length)
                    return [
                      [
                        responseName,
                        conflicts.map(function(_ref3) {
                          var reason = _ref3[0];
                          return reason;
                        })
                      ],
                      conflicts.reduce(
                        function(allFields, _ref4) {
                          var fields1 = _ref4[1];
                          return allFields.concat(fields1);
                        },
                        [node1]
                      ),
                      conflicts.reduce(
                        function(allFields, _ref5) {
                          var fields2 = _ref5[2];
                          return allFields.concat(fields2);
                        },
                        [node2]
                      )
                    ];
                })(
                  (function(
                    context,
                    cachedFieldsAndFragmentNames,
                    comparedFragments,
                    areMutuallyExclusive,
                    parentType1,
                    selectionSet1,
                    parentType2,
                    selectionSet2
                  ) {
                    var conflicts = [],
                      _getFieldsAndFragment2 = getFieldsAndFragmentNames(
                        context,
                        cachedFieldsAndFragmentNames,
                        parentType1,
                        selectionSet1
                      ),
                      fieldMap1 = _getFieldsAndFragment2[0],
                      fragmentNames1 = _getFieldsAndFragment2[1],
                      _getFieldsAndFragment3 = getFieldsAndFragmentNames(
                        context,
                        cachedFieldsAndFragmentNames,
                        parentType2,
                        selectionSet2
                      ),
                      fieldMap2 = _getFieldsAndFragment3[0],
                      fragmentNames2 = _getFieldsAndFragment3[1];
                    collectConflictsBetween(
                      context,
                      conflicts,
                      cachedFieldsAndFragmentNames,
                      comparedFragments,
                      areMutuallyExclusive,
                      fieldMap1,
                      fieldMap2
                    );
                    for (var j = 0; j < fragmentNames2.length; j++)
                      collectConflictsBetweenFieldsAndFragment(
                        context,
                        conflicts,
                        cachedFieldsAndFragmentNames,
                        comparedFragments,
                        areMutuallyExclusive,
                        fieldMap1,
                        fragmentNames2[j]
                      );
                    for (var i = 0; i < fragmentNames1.length; i++)
                      collectConflictsBetweenFieldsAndFragment(
                        context,
                        conflicts,
                        cachedFieldsAndFragmentNames,
                        comparedFragments,
                        areMutuallyExclusive,
                        fieldMap2,
                        fragmentNames1[i]
                      );
                    for (var _i = 0; _i < fragmentNames1.length; _i++)
                      for (var _j = 0; _j < fragmentNames2.length; _j++)
                        collectConflictsBetweenFragments(
                          context,
                          conflicts,
                          cachedFieldsAndFragmentNames,
                          comparedFragments,
                          areMutuallyExclusive,
                          fragmentNames1[_i],
                          fragmentNames2[_j]
                        );
                    return conflicts;
                  })(
                    context,
                    cachedFieldsAndFragmentNames,
                    comparedFragments,
                    areMutuallyExclusive,
                    (0, _definition.getNamedType)(type1),
                    selectionSet1,
                    (0, _definition.getNamedType)(type2),
                    selectionSet2
                  ),
                  responseName,
                  node1,
                  node2
                )
              : void 0;
          }
          function getFieldsAndFragmentNames(
            context,
            cachedFieldsAndFragmentNames,
            parentType,
            selectionSet
          ) {
            var cached = cachedFieldsAndFragmentNames.get(selectionSet);
            if (!cached) {
              var nodeAndDefs = Object.create(null),
                fragmentNames = Object.create(null);
              !(function _collectFieldsAndFragmentNames(
                context,
                parentType,
                selectionSet,
                nodeAndDefs,
                fragmentNames
              ) {
                for (var i = 0; i < selectionSet.selections.length; i++) {
                  var selection = selectionSet.selections[i];
                  switch (selection.kind) {
                    case Kind.FIELD:
                      var fieldName = selection.name.value,
                        fieldDef = void 0;
                      (parentType instanceof _definition.GraphQLObjectType ||
                        parentType instanceof
                          _definition.GraphQLInterfaceType) &&
                        (fieldDef = parentType.getFields()[fieldName]);
                      var responseName = selection.alias
                        ? selection.alias.value
                        : fieldName;
                      nodeAndDefs[responseName] ||
                        (nodeAndDefs[responseName] = []),
                        nodeAndDefs[responseName].push([
                          parentType,
                          selection,
                          fieldDef
                        ]);
                      break;
                    case Kind.FRAGMENT_SPREAD:
                      fragmentNames[selection.name.value] = !0;
                      break;
                    case Kind.INLINE_FRAGMENT:
                      var typeCondition = selection.typeCondition,
                        inlineFragmentType = typeCondition
                          ? (0, _typeFromAST.typeFromAST)(
                              context.getSchema(),
                              typeCondition
                            )
                          : parentType;
                      _collectFieldsAndFragmentNames(
                        context,
                        inlineFragmentType,
                        selection.selectionSet,
                        nodeAndDefs,
                        fragmentNames
                      );
                  }
                }
              })(context, parentType, selectionSet, nodeAndDefs, fragmentNames),
                (cached = [nodeAndDefs, Object.keys(fragmentNames)]),
                cachedFieldsAndFragmentNames.set(selectionSet, cached);
            }
            return cached;
          }
          function getReferencedFieldsAndFragmentNames(
            context,
            cachedFieldsAndFragmentNames,
            fragment
          ) {
            var cached = cachedFieldsAndFragmentNames.get(
              fragment.selectionSet
            );
            return (
              cached ||
              getFieldsAndFragmentNames(
                context,
                cachedFieldsAndFragmentNames,
                (0, _typeFromAST.typeFromAST)(
                  context.getSchema(),
                  fragment.typeCondition
                ),
                fragment.selectionSet
              )
            );
          }
          var PairSet = (function() {
            function PairSet() {
              !(function(instance, Constructor) {
                if (!(instance instanceof Constructor))
                  throw new TypeError("Cannot call a class as a function");
              })(this, PairSet),
                (this._data = Object.create(null));
            }
            return (
              (PairSet.prototype.has = function(a, b, areMutuallyExclusive) {
                var first = this._data[a],
                  result = first && first[b];
                return (
                  void 0 !== result &&
                  (!1 !== areMutuallyExclusive || !1 === result)
                );
              }),
              (PairSet.prototype.add = function(a, b, areMutuallyExclusive) {
                _pairSetAdd(this._data, a, b, areMutuallyExclusive),
                  _pairSetAdd(this._data, b, a, areMutuallyExclusive);
              }),
              PairSet
            );
          })();
          function _pairSetAdd(data, a, b, areMutuallyExclusive) {
            var map = data[a];
            map || ((map = Object.create(null)), (data[a] = map)),
              (map[b] = areMutuallyExclusive);
          }
        },
        {
          "../../error": 94,
          "../../jsutils/find": 102,
          "../../language/kinds": 111,
          "../../language/printer": 115,
          "../../type/definition": 121,
          "../../utilities/typeFromAST": 144
        }
      ],
      161: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.typeIncompatibleSpreadMessage = typeIncompatibleSpreadMessage),
            (exports.typeIncompatibleAnonSpreadMessage = typeIncompatibleAnonSpreadMessage),
            (exports.PossibleFragmentSpreads = function(context) {
              return {
                InlineFragment: function(node) {
                  var fragType = context.getType(),
                    parentType = context.getParentType();
                  fragType &&
                    parentType &&
                    !(0, _typeComparators.doTypesOverlap)(
                      context.getSchema(),
                      fragType,
                      parentType
                    ) &&
                    context.reportError(
                      new _error.GraphQLError(
                        typeIncompatibleAnonSpreadMessage(parentType, fragType),
                        [node]
                      )
                    );
                },
                FragmentSpread: function(node) {
                  var fragName = node.name.value,
                    fragType = (function(context, name) {
                      var frag = context.getFragment(name);
                      return (
                        frag &&
                        (0, _typeFromAST.typeFromAST)(
                          context.getSchema(),
                          frag.typeCondition
                        )
                      );
                    })(context, fragName),
                    parentType = context.getParentType();
                  fragType &&
                    parentType &&
                    !(0, _typeComparators.doTypesOverlap)(
                      context.getSchema(),
                      fragType,
                      parentType
                    ) &&
                    context.reportError(
                      new _error.GraphQLError(
                        typeIncompatibleSpreadMessage(
                          fragName,
                          parentType,
                          fragType
                        ),
                        [node]
                      )
                    );
                }
              };
            });
          var _error = require("../../error"),
            _typeComparators = require("../../utilities/typeComparators"),
            _typeFromAST = require("../../utilities/typeFromAST");
          function typeIncompatibleSpreadMessage(
            fragName,
            parentType,
            fragType
          ) {
            return (
              'Fragment "' +
              fragName +
              '" cannot be spread here as objects of type "' +
              String(parentType) +
              '" can never be of type "' +
              String(fragType) +
              '".'
            );
          }
          function typeIncompatibleAnonSpreadMessage(parentType, fragType) {
            return (
              'Fragment cannot be spread here as objects of type "' +
              String(parentType) +
              '" can never be of type "' +
              String(fragType) +
              '".'
            );
          }
        },
        {
          "../../error": 94,
          "../../utilities/typeComparators": 143,
          "../../utilities/typeFromAST": 144
        }
      ],
      162: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.missingFieldArgMessage = missingFieldArgMessage),
            (exports.missingDirectiveArgMessage = missingDirectiveArgMessage),
            (exports.ProvidedNonNullArguments = function(context) {
              return {
                Field: {
                  leave: function(node) {
                    var fieldDef = context.getFieldDef();
                    if (!fieldDef) return !1;
                    var argNodes = node.arguments || [],
                      argNodeMap = (0, _keyMap2.default)(argNodes, function(
                        arg
                      ) {
                        return arg.name.value;
                      });
                    fieldDef.args.forEach(function(argDef) {
                      var argNode = argNodeMap[argDef.name];
                      !argNode &&
                        argDef.type instanceof _definition.GraphQLNonNull &&
                        context.reportError(
                          new _error.GraphQLError(
                            missingFieldArgMessage(
                              node.name.value,
                              argDef.name,
                              argDef.type
                            ),
                            [node]
                          )
                        );
                    });
                  }
                },
                Directive: {
                  leave: function(node) {
                    var directiveDef = context.getDirective();
                    if (!directiveDef) return !1;
                    var argNodes = node.arguments || [],
                      argNodeMap = (0, _keyMap2.default)(argNodes, function(
                        arg
                      ) {
                        return arg.name.value;
                      });
                    directiveDef.args.forEach(function(argDef) {
                      var argNode = argNodeMap[argDef.name];
                      !argNode &&
                        argDef.type instanceof _definition.GraphQLNonNull &&
                        context.reportError(
                          new _error.GraphQLError(
                            missingDirectiveArgMessage(
                              node.name.value,
                              argDef.name,
                              argDef.type
                            ),
                            [node]
                          )
                        );
                    });
                  }
                }
              };
            });
          var obj,
            _error = require("../../error"),
            _keyMap = require("../../jsutils/keyMap"),
            _keyMap2 =
              (obj = _keyMap) && obj.__esModule ? obj : { default: obj },
            _definition = require("../../type/definition");
          function missingFieldArgMessage(fieldName, argName, type) {
            return (
              'Field "' +
              fieldName +
              '" argument "' +
              argName +
              '" of type "' +
              String(type) +
              '" is required but not provided.'
            );
          }
          function missingDirectiveArgMessage(directiveName, argName, type) {
            return (
              'Directive "@' +
              directiveName +
              '" argument "' +
              argName +
              '" of type "' +
              String(type) +
              '" is required but not provided.'
            );
          }
        },
        {
          "../../error": 94,
          "../../jsutils/keyMap": 106,
          "../../type/definition": 121
        }
      ],
      163: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.noSubselectionAllowedMessage = noSubselectionAllowedMessage),
            (exports.requiredSubselectionMessage = requiredSubselectionMessage),
            (exports.ScalarLeafs = function(context) {
              return {
                Field: function(node) {
                  var type = context.getType();
                  type &&
                    ((0, _definition.isLeafType)(
                      (0, _definition.getNamedType)(type)
                    )
                      ? node.selectionSet &&
                        context.reportError(
                          new _error.GraphQLError(
                            noSubselectionAllowedMessage(node.name.value, type),
                            [node.selectionSet]
                          )
                        )
                      : node.selectionSet ||
                        context.reportError(
                          new _error.GraphQLError(
                            requiredSubselectionMessage(node.name.value, type),
                            [node]
                          )
                        ));
                }
              };
            });
          var _error = require("../../error"),
            _definition = require("../../type/definition");
          function noSubselectionAllowedMessage(fieldName, type) {
            return (
              'Field "' +
              fieldName +
              '" must not have a selection since type "' +
              String(type) +
              '" has no subfields.'
            );
          }
          function requiredSubselectionMessage(fieldName, type) {
            return (
              'Field "' +
              fieldName +
              '" of type "' +
              String(type) +
              '" must have a selection of subfields. Did you mean "' +
              fieldName +
              ' { ... }"?'
            );
          }
        },
        { "../../error": 94, "../../type/definition": 121 }
      ],
      164: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.singleFieldOnlyMessage = singleFieldOnlyMessage),
            (exports.SingleFieldSubscriptions = function(context) {
              return {
                OperationDefinition: function(node) {
                  "subscription" === node.operation &&
                    1 !== node.selectionSet.selections.length &&
                    context.reportError(
                      new _error.GraphQLError(
                        singleFieldOnlyMessage(node.name && node.name.value),
                        node.selectionSet.selections.slice(1)
                      )
                    );
                }
              };
            });
          var _error = require("../../error");
          function singleFieldOnlyMessage(name) {
            return (
              (name
                ? 'Subscription "' + name + '" '
                : "Anonymous Subscription ") +
              "must select only one top level field."
            );
          }
        },
        { "../../error": 94 }
      ],
      165: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.duplicateArgMessage = duplicateArgMessage),
            (exports.UniqueArgumentNames = function(context) {
              var knownArgNames = Object.create(null);
              return {
                Field: function() {
                  knownArgNames = Object.create(null);
                },
                Directive: function() {
                  knownArgNames = Object.create(null);
                },
                Argument: function(node) {
                  var argName = node.name.value;
                  return (
                    knownArgNames[argName]
                      ? context.reportError(
                          new _error.GraphQLError(
                            duplicateArgMessage(argName),
                            [knownArgNames[argName], node.name]
                          )
                        )
                      : (knownArgNames[argName] = node.name),
                    !1
                  );
                }
              };
            });
          var _error = require("../../error");
          function duplicateArgMessage(argName) {
            return 'There can be only one argument named "' + argName + '".';
          }
        },
        { "../../error": 94 }
      ],
      166: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.duplicateDirectiveMessage = duplicateDirectiveMessage),
            (exports.UniqueDirectivesPerLocation = function(context) {
              return {
                enter: function(node) {
                  if (node.directives) {
                    var knownDirectives = Object.create(null);
                    node.directives.forEach(function(directive) {
                      var directiveName = directive.name.value;
                      knownDirectives[directiveName]
                        ? context.reportError(
                            new _error.GraphQLError(
                              duplicateDirectiveMessage(directiveName),
                              [knownDirectives[directiveName], directive]
                            )
                          )
                        : (knownDirectives[directiveName] = directive);
                    });
                  }
                }
              };
            });
          var _error = require("../../error");
          function duplicateDirectiveMessage(directiveName) {
            return (
              'The directive "' +
              directiveName +
              '" can only be used once at this location.'
            );
          }
        },
        { "../../error": 94 }
      ],
      167: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.duplicateFragmentNameMessage = duplicateFragmentNameMessage),
            (exports.UniqueFragmentNames = function(context) {
              var knownFragmentNames = Object.create(null);
              return {
                OperationDefinition: function() {
                  return !1;
                },
                FragmentDefinition: function(node) {
                  var fragmentName = node.name.value;
                  return (
                    knownFragmentNames[fragmentName]
                      ? context.reportError(
                          new _error.GraphQLError(
                            duplicateFragmentNameMessage(fragmentName),
                            [knownFragmentNames[fragmentName], node.name]
                          )
                        )
                      : (knownFragmentNames[fragmentName] = node.name),
                    !1
                  );
                }
              };
            });
          var _error = require("../../error");
          function duplicateFragmentNameMessage(fragName) {
            return 'There can be only one fragment named "' + fragName + '".';
          }
        },
        { "../../error": 94 }
      ],
      168: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.duplicateInputFieldMessage = duplicateInputFieldMessage),
            (exports.UniqueInputFieldNames = function(context) {
              var knownNameStack = [],
                knownNames = Object.create(null);
              return {
                ObjectValue: {
                  enter: function() {
                    knownNameStack.push(knownNames),
                      (knownNames = Object.create(null));
                  },
                  leave: function() {
                    knownNames = knownNameStack.pop();
                  }
                },
                ObjectField: function(node) {
                  var fieldName = node.name.value;
                  return (
                    knownNames[fieldName]
                      ? context.reportError(
                          new _error.GraphQLError(
                            duplicateInputFieldMessage(fieldName),
                            [knownNames[fieldName], node.name]
                          )
                        )
                      : (knownNames[fieldName] = node.name),
                    !1
                  );
                }
              };
            });
          var _error = require("../../error");
          function duplicateInputFieldMessage(fieldName) {
            return (
              'There can be only one input field named "' + fieldName + '".'
            );
          }
        },
        { "../../error": 94 }
      ],
      169: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.duplicateOperationNameMessage = duplicateOperationNameMessage),
            (exports.UniqueOperationNames = function(context) {
              var knownOperationNames = Object.create(null);
              return {
                OperationDefinition: function(node) {
                  var operationName = node.name;
                  return (
                    operationName &&
                      (knownOperationNames[operationName.value]
                        ? context.reportError(
                            new _error.GraphQLError(
                              duplicateOperationNameMessage(
                                operationName.value
                              ),
                              [
                                knownOperationNames[operationName.value],
                                operationName
                              ]
                            )
                          )
                        : (knownOperationNames[
                            operationName.value
                          ] = operationName)),
                    !1
                  );
                },
                FragmentDefinition: function() {
                  return !1;
                }
              };
            });
          var _error = require("../../error");
          function duplicateOperationNameMessage(operationName) {
            return (
              'There can be only one operation named "' + operationName + '".'
            );
          }
        },
        { "../../error": 94 }
      ],
      170: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.duplicateVariableMessage = duplicateVariableMessage),
            (exports.UniqueVariableNames = function(context) {
              var knownVariableNames = Object.create(null);
              return {
                OperationDefinition: function() {
                  knownVariableNames = Object.create(null);
                },
                VariableDefinition: function(node) {
                  var variableName = node.variable.name.value;
                  knownVariableNames[variableName]
                    ? context.reportError(
                        new _error.GraphQLError(
                          duplicateVariableMessage(variableName),
                          [knownVariableNames[variableName], node.variable.name]
                        )
                      )
                    : (knownVariableNames[variableName] = node.variable.name);
                }
              };
            });
          var _error = require("../../error");
          function duplicateVariableMessage(variableName) {
            return (
              'There can be only one variable named "' + variableName + '".'
            );
          }
        },
        { "../../error": 94 }
      ],
      171: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.nonInputTypeOnVarMessage = nonInputTypeOnVarMessage),
            (exports.VariablesAreInputTypes = function(context) {
              return {
                VariableDefinition: function(node) {
                  var type = (0, _typeFromAST.typeFromAST)(
                    context.getSchema(),
                    node.type
                  );
                  if (type && !(0, _definition.isInputType)(type)) {
                    var variableName = node.variable.name.value;
                    context.reportError(
                      new _error.GraphQLError(
                        nonInputTypeOnVarMessage(
                          variableName,
                          (0, _printer.print)(node.type)
                        ),
                        [node.type]
                      )
                    );
                  }
                }
              };
            });
          var _error = require("../../error"),
            _printer = require("../../language/printer"),
            _definition = require("../../type/definition"),
            _typeFromAST = require("../../utilities/typeFromAST");
          function nonInputTypeOnVarMessage(variableName, typeName) {
            return (
              'Variable "$' +
              variableName +
              '" cannot be non-input type "' +
              typeName +
              '".'
            );
          }
        },
        {
          "../../error": 94,
          "../../language/printer": 115,
          "../../type/definition": 121,
          "../../utilities/typeFromAST": 144
        }
      ],
      172: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.badVarPosMessage = badVarPosMessage),
            (exports.VariablesInAllowedPosition = function(context) {
              var varDefMap = Object.create(null);
              return {
                OperationDefinition: {
                  enter: function() {
                    varDefMap = Object.create(null);
                  },
                  leave: function(operation) {
                    var usages = context.getRecursiveVariableUsages(operation);
                    usages.forEach(function(_ref) {
                      var node = _ref.node,
                        type = _ref.type,
                        varName = node.name.value,
                        varDef = varDefMap[varName];
                      if (varDef && type) {
                        var schema = context.getSchema(),
                          varType = (0, _typeFromAST.typeFromAST)(
                            schema,
                            varDef.type
                          );
                        varType &&
                          !(0, _typeComparators.isTypeSubTypeOf)(
                            schema,
                            (function(varType, varDef) {
                              return !varDef.defaultValue ||
                                varType instanceof _definition.GraphQLNonNull
                                ? varType
                                : new _definition.GraphQLNonNull(varType);
                            })(varType, varDef),
                            type
                          ) &&
                          context.reportError(
                            new _error.GraphQLError(
                              badVarPosMessage(varName, varType, type),
                              [varDef, node]
                            )
                          );
                      }
                    });
                  }
                },
                VariableDefinition: function(node) {
                  varDefMap[node.variable.name.value] = node;
                }
              };
            });
          var _error = require("../../error"),
            _definition = require("../../type/definition"),
            _typeComparators = require("../../utilities/typeComparators"),
            _typeFromAST = require("../../utilities/typeFromAST");
          function badVarPosMessage(varName, varType, expectedType) {
            return (
              'Variable "$' +
              varName +
              '" of type "' +
              String(varType) +
              '" used in position expecting type "' +
              String(expectedType) +
              '".'
            );
          }
        },
        {
          "../../error": 94,
          "../../type/definition": 121,
          "../../utilities/typeComparators": 143,
          "../../utilities/typeFromAST": 144
        }
      ],
      173: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.specifiedRules = void 0);
          var _UniqueOperationNames = require("./rules/UniqueOperationNames"),
            _LoneAnonymousOperation = require("./rules/LoneAnonymousOperation"),
            _SingleFieldSubscriptions = require("./rules/SingleFieldSubscriptions"),
            _KnownTypeNames = require("./rules/KnownTypeNames"),
            _FragmentsOnCompositeTypes = require("./rules/FragmentsOnCompositeTypes"),
            _VariablesAreInputTypes = require("./rules/VariablesAreInputTypes"),
            _ScalarLeafs = require("./rules/ScalarLeafs"),
            _FieldsOnCorrectType = require("./rules/FieldsOnCorrectType"),
            _UniqueFragmentNames = require("./rules/UniqueFragmentNames"),
            _KnownFragmentNames = require("./rules/KnownFragmentNames"),
            _NoUnusedFragments = require("./rules/NoUnusedFragments"),
            _PossibleFragmentSpreads = require("./rules/PossibleFragmentSpreads"),
            _NoFragmentCycles = require("./rules/NoFragmentCycles"),
            _UniqueVariableNames = require("./rules/UniqueVariableNames"),
            _NoUndefinedVariables = require("./rules/NoUndefinedVariables"),
            _NoUnusedVariables = require("./rules/NoUnusedVariables"),
            _KnownDirectives = require("./rules/KnownDirectives"),
            _UniqueDirectivesPerLocation = require("./rules/UniqueDirectivesPerLocation"),
            _KnownArgumentNames = require("./rules/KnownArgumentNames"),
            _UniqueArgumentNames = require("./rules/UniqueArgumentNames"),
            _ArgumentsOfCorrectType = require("./rules/ArgumentsOfCorrectType"),
            _ProvidedNonNullArguments = require("./rules/ProvidedNonNullArguments"),
            _DefaultValuesOfCorrectType = require("./rules/DefaultValuesOfCorrectType"),
            _VariablesInAllowedPosition = require("./rules/VariablesInAllowedPosition"),
            _OverlappingFieldsCanBeMerged = require("./rules/OverlappingFieldsCanBeMerged"),
            _UniqueInputFieldNames = require("./rules/UniqueInputFieldNames");
          exports.specifiedRules = [
            _UniqueOperationNames.UniqueOperationNames,
            _LoneAnonymousOperation.LoneAnonymousOperation,
            _SingleFieldSubscriptions.SingleFieldSubscriptions,
            _KnownTypeNames.KnownTypeNames,
            _FragmentsOnCompositeTypes.FragmentsOnCompositeTypes,
            _VariablesAreInputTypes.VariablesAreInputTypes,
            _ScalarLeafs.ScalarLeafs,
            _FieldsOnCorrectType.FieldsOnCorrectType,
            _UniqueFragmentNames.UniqueFragmentNames,
            _KnownFragmentNames.KnownFragmentNames,
            _NoUnusedFragments.NoUnusedFragments,
            _PossibleFragmentSpreads.PossibleFragmentSpreads,
            _NoFragmentCycles.NoFragmentCycles,
            _UniqueVariableNames.UniqueVariableNames,
            _NoUndefinedVariables.NoUndefinedVariables,
            _NoUnusedVariables.NoUnusedVariables,
            _KnownDirectives.KnownDirectives,
            _UniqueDirectivesPerLocation.UniqueDirectivesPerLocation,
            _KnownArgumentNames.KnownArgumentNames,
            _UniqueArgumentNames.UniqueArgumentNames,
            _ArgumentsOfCorrectType.ArgumentsOfCorrectType,
            _ProvidedNonNullArguments.ProvidedNonNullArguments,
            _DefaultValuesOfCorrectType.DefaultValuesOfCorrectType,
            _VariablesInAllowedPosition.VariablesInAllowedPosition,
            _OverlappingFieldsCanBeMerged.OverlappingFieldsCanBeMerged,
            _UniqueInputFieldNames.UniqueInputFieldNames
          ];
        },
        {
          "./rules/ArgumentsOfCorrectType": 147,
          "./rules/DefaultValuesOfCorrectType": 148,
          "./rules/FieldsOnCorrectType": 149,
          "./rules/FragmentsOnCompositeTypes": 150,
          "./rules/KnownArgumentNames": 151,
          "./rules/KnownDirectives": 152,
          "./rules/KnownFragmentNames": 153,
          "./rules/KnownTypeNames": 154,
          "./rules/LoneAnonymousOperation": 155,
          "./rules/NoFragmentCycles": 156,
          "./rules/NoUndefinedVariables": 157,
          "./rules/NoUnusedFragments": 158,
          "./rules/NoUnusedVariables": 159,
          "./rules/OverlappingFieldsCanBeMerged": 160,
          "./rules/PossibleFragmentSpreads": 161,
          "./rules/ProvidedNonNullArguments": 162,
          "./rules/ScalarLeafs": 163,
          "./rules/SingleFieldSubscriptions": 164,
          "./rules/UniqueArgumentNames": 165,
          "./rules/UniqueDirectivesPerLocation": 166,
          "./rules/UniqueFragmentNames": 167,
          "./rules/UniqueInputFieldNames": 168,
          "./rules/UniqueOperationNames": 169,
          "./rules/UniqueVariableNames": 170,
          "./rules/VariablesAreInputTypes": 171,
          "./rules/VariablesInAllowedPosition": 172
        }
      ],
      174: [
        function(require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: !0 }),
            (exports.ValidationContext = void 0),
            (exports.validate = function(schema, ast, rules, typeInfo) {
              return (
                schema || (0, _invariant2.default)(0, "Must provide schema"),
                !ast && (0, _invariant2.default)(0, "Must provide document"),
                !(schema instanceof _schema.GraphQLSchema) &&
                  (0, _invariant2.default)(
                    0,
                    "Schema must be an instance of GraphQLSchema. Also ensure that there are not multiple versions of GraphQL installed in your node_modules directory."
                  ),
                (function(schema, typeInfo, documentAST, rules) {
                  var context = new ValidationContext(
                      schema,
                      documentAST,
                      typeInfo
                    ),
                    visitors = rules.map(function(rule) {
                      return rule(context);
                    });
                  return (
                    (0, _visitor.visit)(
                      documentAST,
                      (0, _visitor.visitWithTypeInfo)(
                        typeInfo,
                        (0, _visitor.visitInParallel)(visitors)
                      )
                    ),
                    context.getErrors()
                  );
                })(
                  schema,
                  typeInfo || new _TypeInfo.TypeInfo(schema),
                  ast,
                  rules || _specifiedRules.specifiedRules
                )
              );
            });
          var obj,
            _invariant = require("../jsutils/invariant"),
            _invariant2 =
              (obj = _invariant) && obj.__esModule ? obj : { default: obj },
            _visitor = (require("../error"), require("../language/visitor")),
            Kind = (function(obj) {
              {
                if (obj && obj.__esModule) return obj;
                var newObj = {};
                if (null != obj)
                  for (var key in obj)
                    Object.prototype.hasOwnProperty.call(obj, key) &&
                      (newObj[key] = obj[key]);
                return (newObj.default = obj), newObj;
              }
            })(require("../language/kinds")),
            _schema = require("../type/schema"),
            _TypeInfo = require("../utilities/TypeInfo"),
            _specifiedRules = require("./specifiedRules");
          var ValidationContext = (exports.ValidationContext = (function() {
            function ValidationContext(schema, ast, typeInfo) {
              !(function(instance, Constructor) {
                if (!(instance instanceof Constructor))
                  throw new TypeError("Cannot call a class as a function");
              })(this, ValidationContext),
                (this._schema = schema),
                (this._ast = ast),
                (this._typeInfo = typeInfo),
                (this._errors = []),
                (this._fragmentSpreads = new Map()),
                (this._recursivelyReferencedFragments = new Map()),
                (this._variableUsages = new Map()),
                (this._recursiveVariableUsages = new Map());
            }
            return (
              (ValidationContext.prototype.reportError = function(error) {
                this._errors.push(error);
              }),
              (ValidationContext.prototype.getErrors = function() {
                return this._errors;
              }),
              (ValidationContext.prototype.getSchema = function() {
                return this._schema;
              }),
              (ValidationContext.prototype.getDocument = function() {
                return this._ast;
              }),
              (ValidationContext.prototype.getFragment = function(name) {
                var fragments = this._fragments;
                return (
                  fragments ||
                    (this._fragments = fragments = this.getDocument().definitions.reduce(
                      function(frags, statement) {
                        return (
                          statement.kind === Kind.FRAGMENT_DEFINITION &&
                            (frags[statement.name.value] = statement),
                          frags
                        );
                      },
                      Object.create(null)
                    )),
                  fragments[name]
                );
              }),
              (ValidationContext.prototype.getFragmentSpreads = function(node) {
                var spreads = this._fragmentSpreads.get(node);
                if (!spreads) {
                  spreads = [];
                  for (var setsToVisit = [node]; 0 !== setsToVisit.length; )
                    for (
                      var set = setsToVisit.pop(), i = 0;
                      i < set.selections.length;
                      i++
                    ) {
                      var selection = set.selections[i];
                      selection.kind === Kind.FRAGMENT_SPREAD
                        ? spreads.push(selection)
                        : selection.selectionSet &&
                          setsToVisit.push(selection.selectionSet);
                    }
                  this._fragmentSpreads.set(node, spreads);
                }
                return spreads;
              }),
              (ValidationContext.prototype.getRecursivelyReferencedFragments = function(
                operation
              ) {
                var fragments = this._recursivelyReferencedFragments.get(
                  operation
                );
                if (!fragments) {
                  fragments = [];
                  for (
                    var collectedNames = Object.create(null),
                      nodesToVisit = [operation.selectionSet];
                    0 !== nodesToVisit.length;

                  )
                    for (
                      var _node = nodesToVisit.pop(),
                        spreads = this.getFragmentSpreads(_node),
                        i = 0;
                      i < spreads.length;
                      i++
                    ) {
                      var fragName = spreads[i].name.value;
                      if (!0 !== collectedNames[fragName]) {
                        collectedNames[fragName] = !0;
                        var fragment = this.getFragment(fragName);
                        fragment &&
                          (fragments.push(fragment),
                          nodesToVisit.push(fragment.selectionSet));
                      }
                    }
                  this._recursivelyReferencedFragments.set(
                    operation,
                    fragments
                  );
                }
                return fragments;
              }),
              (ValidationContext.prototype.getVariableUsages = function(node) {
                var usages = this._variableUsages.get(node);
                if (!usages) {
                  var newUsages = [],
                    typeInfo = new _TypeInfo.TypeInfo(this._schema);
                  (0, _visitor.visit)(
                    node,
                    (0, _visitor.visitWithTypeInfo)(typeInfo, {
                      VariableDefinition: function() {
                        return !1;
                      },
                      Variable: function(variable) {
                        newUsages.push({
                          node: variable,
                          type: typeInfo.getInputType()
                        });
                      }
                    })
                  ),
                    (usages = newUsages),
                    this._variableUsages.set(node, usages);
                }
                return usages;
              }),
              (ValidationContext.prototype.getRecursiveVariableUsages = function(
                operation
              ) {
                var usages = this._recursiveVariableUsages.get(operation);
                if (!usages) {
                  usages = this.getVariableUsages(operation);
                  for (
                    var fragments = this.getRecursivelyReferencedFragments(
                        operation
                      ),
                      i = 0;
                    i < fragments.length;
                    i++
                  )
                    Array.prototype.push.apply(
                      usages,
                      this.getVariableUsages(fragments[i])
                    );
                  this._recursiveVariableUsages.set(operation, usages);
                }
                return usages;
              }),
              (ValidationContext.prototype.getType = function() {
                return this._typeInfo.getType();
              }),
              (ValidationContext.prototype.getParentType = function() {
                return this._typeInfo.getParentType();
              }),
              (ValidationContext.prototype.getInputType = function() {
                return this._typeInfo.getInputType();
              }),
              (ValidationContext.prototype.getFieldDef = function() {
                return this._typeInfo.getFieldDef();
              }),
              (ValidationContext.prototype.getDirective = function() {
                return this._typeInfo.getDirective();
              }),
              (ValidationContext.prototype.getArgument = function() {
                return this._typeInfo.getArgument();
              }),
              ValidationContext
            );
          })());
        },
        {
          "../error": 94,
          "../jsutils/invariant": 103,
          "../language/kinds": 111,
          "../language/visitor": 117,
          "../type/schema": 126,
          "../utilities/TypeInfo": 127,
          "./specifiedRules": 173
        }
      ],
      175: [
        function(require, module, exports) {
          var SYMBOL_ITERATOR = "function" == typeof Symbol && Symbol.iterator,
            $$iterator = SYMBOL_ITERATOR || "@@iterator";
          function isIterable(obj) {
            return !!getIteratorMethod(obj);
          }
          function isArrayLike(obj) {
            var length = null != obj && obj.length;
            return "number" == typeof length && 0 <= length && length % 1 == 0;
          }
          function getIterator(iterable) {
            var method = getIteratorMethod(iterable);
            if (method) return method.call(iterable);
          }
          function getIteratorMethod(iterable) {
            if (null != iterable) {
              var method =
                (SYMBOL_ITERATOR && iterable[SYMBOL_ITERATOR]) ||
                iterable["@@iterator"];
              if ("function" == typeof method) return method;
            }
          }
          function createIterator(collection) {
            if (null != collection) {
              var iterator = getIterator(collection);
              if (iterator) return iterator;
              if (isArrayLike(collection))
                return new ArrayLikeIterator(collection);
            }
          }
          function ArrayLikeIterator(obj) {
            (this._o = obj), (this._i = 0);
          }
          (exports.$$iterator = $$iterator),
            (exports.isIterable = isIterable),
            (exports.isArrayLike = isArrayLike),
            (exports.isCollection = function(obj) {
              return (
                Object(obj) === obj && (isArrayLike(obj) || isIterable(obj))
              );
            }),
            (exports.getIterator = getIterator),
            (exports.getIteratorMethod = getIteratorMethod),
            (exports.createIterator = createIterator),
            (ArrayLikeIterator.prototype[$$iterator] = function() {
              return this;
            }),
            (ArrayLikeIterator.prototype.next = function() {
              return void 0 === this._o || this._i >= this._o.length
                ? { value: (this._o = void 0), done: !0 }
                : { value: this._o[this._i++], done: !1 };
            }),
            (exports.forEach = function(collection, callback, thisArg) {
              if (null != collection) {
                if ("function" == typeof collection.forEach)
                  return collection.forEach(callback, thisArg);
                var i = 0,
                  iterator = getIterator(collection);
                if (iterator) {
                  for (var step; !(step = iterator.next()).done; )
                    if (
                      (callback.call(thisArg, step.value, i++, collection),
                      9999999 < i)
                    )
                      throw new TypeError("Near-infinite iteration.");
                } else if (isArrayLike(collection))
                  for (; i < collection.length; i++)
                    collection.hasOwnProperty(i) &&
                      callback.call(thisArg, collection[i], i, collection);
              }
            });
          var SYMBOL_ASYNC_ITERATOR =
              "function" == typeof Symbol && Symbol.asyncIterator,
            $$asyncIterator = SYMBOL_ASYNC_ITERATOR || "@@asyncIterator";
          function getAsyncIterator(asyncIterable) {
            var method = getAsyncIteratorMethod(asyncIterable);
            if (method) return method.call(asyncIterable);
          }
          function getAsyncIteratorMethod(asyncIterable) {
            if (null != asyncIterable) {
              var method =
                (SYMBOL_ASYNC_ITERATOR &&
                  asyncIterable[SYMBOL_ASYNC_ITERATOR]) ||
                asyncIterable["@@asyncIterator"];
              if ("function" == typeof method) return method;
            }
          }
          function createAsyncIterator(source) {
            if (null != source) {
              var asyncIterator = getAsyncIterator(source);
              if (asyncIterator) return asyncIterator;
              var iterator = createIterator(source);
              if (iterator) return new AsyncFromSyncIterator(iterator);
            }
          }
          function AsyncFromSyncIterator(iterator) {
            this._i = iterator;
          }
          (exports.$$asyncIterator = $$asyncIterator),
            (exports.isAsyncIterable = function(obj) {
              return !!getAsyncIteratorMethod(obj);
            }),
            (exports.getAsyncIterator = getAsyncIterator),
            (exports.getAsyncIteratorMethod = getAsyncIteratorMethod),
            (exports.createAsyncIterator = createAsyncIterator),
            (AsyncFromSyncIterator.prototype[$$asyncIterator] = function() {
              return this;
            }),
            (AsyncFromSyncIterator.prototype.next = function() {
              var step = this._i.next();
              return Promise.resolve(step.value).then(function(value) {
                return { value: value, done: step.done };
              });
            }),
            (exports.forAwaitEach = function(source, callback, thisArg) {
              var asyncIterator = createAsyncIterator(source);
              if (asyncIterator) {
                var i = 0;
                return new Promise(function(resolve, reject) {
                  !(function next() {
                    return asyncIterator
                      .next()
                      .then(function(step) {
                        step.done
                          ? resolve()
                          : Promise.resolve(
                              callback.call(thisArg, step.value, i++, source)
                            )
                              .then(next)
                              .catch(reject);
                      })
                      .catch(reject);
                  })();
                });
              }
            });
        },
        {}
      ],
      176: [
        function(require, module, exports) {
          "use strict";
          function assign(obj) {
            return (
              Array.prototype.slice
                .call(arguments, 1)
                .forEach(function(source) {
                  source &&
                    Object.keys(source).forEach(function(key) {
                      obj[key] = source[key];
                    });
                }),
              obj
            );
          }
          function _class(obj) {
            return Object.prototype.toString.call(obj);
          }
          function isFunction(obj) {
            return "[object Function]" === _class(obj);
          }
          function escapeRE(str) {
            return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
          }
          var defaultOptions = { fuzzyLink: !0, fuzzyEmail: !0, fuzzyIP: !1 };
          var defaultSchemas = {
              "http:": {
                validate: function(text, pos, self) {
                  var tail = text.slice(pos);
                  return (
                    self.re.http ||
                      (self.re.http = new RegExp(
                        "^\\/\\/" +
                          self.re.src_auth +
                          self.re.src_host_port_strict +
                          self.re.src_path,
                        "i"
                      )),
                    self.re.http.test(tail)
                      ? tail.match(self.re.http)[0].length
                      : 0
                  );
                }
              },
              "https:": "http:",
              "ftp:": "http:",
              "//": {
                validate: function(text, pos, self) {
                  var tail = text.slice(pos);
                  return (
                    self.re.no_http ||
                      (self.re.no_http = new RegExp(
                        "^" +
                          self.re.src_auth +
                          "(?:localhost|(?:(?:" +
                          self.re.src_domain +
                          ")\\.)+" +
                          self.re.src_domain_root +
                          ")" +
                          self.re.src_port +
                          self.re.src_host_terminator +
                          self.re.src_path,
                        "i"
                      )),
                    self.re.no_http.test(tail)
                      ? 3 <= pos && ":" === text[pos - 3]
                        ? 0
                        : 3 <= pos && "/" === text[pos - 3]
                          ? 0
                          : tail.match(self.re.no_http)[0].length
                      : 0
                  );
                }
              },
              "mailto:": {
                validate: function(text, pos, self) {
                  var tail = text.slice(pos);
                  return (
                    self.re.mailto ||
                      (self.re.mailto = new RegExp(
                        "^" +
                          self.re.src_email_name +
                          "@" +
                          self.re.src_host_strict,
                        "i"
                      )),
                    self.re.mailto.test(tail)
                      ? tail.match(self.re.mailto)[0].length
                      : 0
                  );
                }
              }
            },
            tlds_2ch_src_re =
              "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",
            tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split(
              "|"
            );
          function compile(self) {
            var re = (self.re = require("./lib/re")(self.__opts__)),
              tlds = self.__tlds__.slice();
            function untpl(tpl) {
              return tpl.replace("%TLDS%", re.src_tlds);
            }
            self.onCompile(),
              self.__tlds_replaced__ || tlds.push(tlds_2ch_src_re),
              tlds.push(re.src_xn),
              (re.src_tlds = tlds.join("|")),
              (re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i")),
              (re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i")),
              (re.link_no_ip_fuzzy = RegExp(
                untpl(re.tpl_link_no_ip_fuzzy),
                "i"
              )),
              (re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i"));
            var aliases = [];
            function schemaError(name, val) {
              throw new Error(
                '(LinkifyIt) Invalid schema "' + name + '": ' + val
              );
            }
            (self.__compiled__ = {}),
              Object.keys(self.__schemas__).forEach(function(name) {
                var val = self.__schemas__[name];
                if (null !== val) {
                  var re,
                    compiled = { validate: null, link: null };
                  if (
                    ((self.__compiled__[name] = compiled),
                    "[object Object]" === _class(val))
                  )
                    return (
                      !(function(obj) {
                        return "[object RegExp]" === _class(obj);
                      })(val.validate)
                        ? isFunction(val.validate)
                          ? (compiled.validate = val.validate)
                          : schemaError(name, val)
                        : (compiled.validate = ((re = val.validate),
                          function(text, pos) {
                            var tail = text.slice(pos);
                            return re.test(tail) ? tail.match(re)[0].length : 0;
                          })),
                      void (isFunction(val.normalize)
                        ? (compiled.normalize = val.normalize)
                        : val.normalize
                          ? schemaError(name, val)
                          : (compiled.normalize = function(match, self) {
                              self.normalize(match);
                            }))
                    );
                  !(function(obj) {
                    return "[object String]" === _class(obj);
                  })(val)
                    ? schemaError(name, val)
                    : aliases.push(name);
                }
              }),
              aliases.forEach(function(alias) {
                self.__compiled__[self.__schemas__[alias]] &&
                  ((self.__compiled__[alias].validate =
                    self.__compiled__[self.__schemas__[alias]].validate),
                  (self.__compiled__[alias].normalize =
                    self.__compiled__[self.__schemas__[alias]].normalize));
              }),
              (self.__compiled__[""] = {
                validate: null,
                normalize: function(match, self) {
                  self.normalize(match);
                }
              });
            var slist = Object.keys(self.__compiled__)
              .filter(function(name) {
                return 0 < name.length && self.__compiled__[name];
              })
              .map(escapeRE)
              .join("|");
            (self.re.schema_test = RegExp(
              "(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")",
              "i"
            )),
              (self.re.schema_search = RegExp(
                "(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")",
                "ig"
              )),
              (self.re.pretest = RegExp(
                "(" +
                  self.re.schema_test.source +
                  ")|(" +
                  self.re.host_fuzzy_test.source +
                  ")|@",
                "i"
              )),
              (function(self) {
                (self.__index__ = -1), (self.__text_cache__ = "");
              })(self);
          }
          function createMatch(self, shift) {
            var match = new function(self, shift) {
              var start = self.__index__,
                end = self.__last_index__,
                text = self.__text_cache__.slice(start, end);
              (this.schema = self.__schema__.toLowerCase()),
                (this.index = start + shift),
                (this.lastIndex = end + shift),
                (this.raw = text),
                (this.text = text),
                (this.url = text);
            }(self, shift);
            return (
              self.__compiled__[match.schema].normalize(match, self), match
            );
          }
          function LinkifyIt(schemas, options) {
            if (!(this instanceof LinkifyIt))
              return new LinkifyIt(schemas, options);
            var obj;
            options ||
              ((obj = schemas),
              Object.keys(obj || {}).reduce(function(acc, k) {
                return acc || defaultOptions.hasOwnProperty(k);
              }, !1) && ((options = schemas), (schemas = {}))),
              (this.__opts__ = assign({}, defaultOptions, options)),
              (this.__index__ = -1),
              (this.__last_index__ = -1),
              (this.__schema__ = ""),
              (this.__text_cache__ = ""),
              (this.__schemas__ = assign({}, defaultSchemas, schemas)),
              (this.__compiled__ = {}),
              (this.__tlds__ = tlds_default),
              (this.__tlds_replaced__ = !1),
              (this.re = {}),
              compile(this);
          }
          (LinkifyIt.prototype.add = function(schema, definition) {
            return (this.__schemas__[schema] = definition), compile(this), this;
          }),
            (LinkifyIt.prototype.set = function(options) {
              return (this.__opts__ = assign(this.__opts__, options)), this;
            }),
            (LinkifyIt.prototype.test = function(text) {
              if (
                ((this.__text_cache__ = text),
                (this.__index__ = -1),
                !text.length)
              )
                return !1;
              var m, ml, me, len, shift, next, re, tld_pos;
              if (this.re.schema_test.test(text))
                for (
                  (re = this.re.schema_search).lastIndex = 0;
                  null !== (m = re.exec(text));

                )
                  if ((len = this.testSchemaAt(text, m[2], re.lastIndex))) {
                    (this.__schema__ = m[2]),
                      (this.__index__ = m.index + m[1].length),
                      (this.__last_index__ = m.index + m[0].length + len);
                    break;
                  }
              return (
                this.__opts__.fuzzyLink &&
                  this.__compiled__["http:"] &&
                  0 <= (tld_pos = text.search(this.re.host_fuzzy_test)) &&
                  (this.__index__ < 0 || tld_pos < this.__index__) &&
                  null !==
                    (ml = text.match(
                      this.__opts__.fuzzyIP
                        ? this.re.link_fuzzy
                        : this.re.link_no_ip_fuzzy
                    )) &&
                  ((shift = ml.index + ml[1].length),
                  (this.__index__ < 0 || shift < this.__index__) &&
                    ((this.__schema__ = ""),
                    (this.__index__ = shift),
                    (this.__last_index__ = ml.index + ml[0].length))),
                this.__opts__.fuzzyEmail &&
                  this.__compiled__["mailto:"] &&
                  0 <= text.indexOf("@") &&
                  null !== (me = text.match(this.re.email_fuzzy)) &&
                  ((shift = me.index + me[1].length),
                  (next = me.index + me[0].length),
                  (this.__index__ < 0 ||
                    shift < this.__index__ ||
                    (shift === this.__index__ && next > this.__last_index__)) &&
                    ((this.__schema__ = "mailto:"),
                    (this.__index__ = shift),
                    (this.__last_index__ = next))),
                0 <= this.__index__
              );
            }),
            (LinkifyIt.prototype.pretest = function(text) {
              return this.re.pretest.test(text);
            }),
            (LinkifyIt.prototype.testSchemaAt = function(text, schema, pos) {
              return this.__compiled__[schema.toLowerCase()]
                ? this.__compiled__[schema.toLowerCase()].validate(
                    text,
                    pos,
                    this
                  )
                : 0;
            }),
            (LinkifyIt.prototype.match = function(text) {
              var shift = 0,
                result = [];
              0 <= this.__index__ &&
                this.__text_cache__ === text &&
                (result.push(createMatch(this, shift)),
                (shift = this.__last_index__));
              for (
                var tail = shift ? text.slice(shift) : text;
                this.test(tail);

              )
                result.push(createMatch(this, shift)),
                  (tail = tail.slice(this.__last_index__)),
                  (shift += this.__last_index__);
              return result.length ? result : null;
            }),
            (LinkifyIt.prototype.tlds = function(list, keepOld) {
              return (
                (list = Array.isArray(list) ? list : [list]),
                keepOld
                  ? (this.__tlds__ = this.__tlds__
                      .concat(list)
                      .sort()
                      .filter(function(el, idx, arr) {
                        return el !== arr[idx - 1];
                      })
                      .reverse())
                  : ((this.__tlds__ = list.slice()),
                    (this.__tlds_replaced__ = !0)),
                compile(this),
                this
              );
            }),
            (LinkifyIt.prototype.normalize = function(match) {
              match.schema || (match.url = "http://" + match.url),
                "mailto:" !== match.schema ||
                  /^mailto:/i.test(match.url) ||
                  (match.url = "mailto:" + match.url);
            }),
            (LinkifyIt.prototype.onCompile = function() {}),
            (module.exports = LinkifyIt);
        },
        { "./lib/re": 177 }
      ],
      177: [
        function(require, module, exports) {
          "use strict";
          module.exports = function(opts) {
            var re = {};
            (re.src_Any = require("uc.micro/properties/Any/regex").source),
              (re.src_Cc = require("uc.micro/categories/Cc/regex").source),
              (re.src_Z = require("uc.micro/categories/Z/regex").source),
              (re.src_P = require("uc.micro/categories/P/regex").source),
              (re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|")),
              (re.src_ZCc = [re.src_Z, re.src_Cc].join("|"));
            return (
              (re.src_pseudo_letter =
                "(?:(?![><｜]|" + re.src_ZPCc + ")" + re.src_Any + ")"),
              (re.src_ip4 =
                "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)"),
              (re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?"),
              (re.src_port =
                "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?"),
              (re.src_host_terminator =
                "(?=$|[><｜]|" +
                re.src_ZPCc +
                ")(?!-|_|:\\d|\\.-|\\.(?!$|" +
                re.src_ZPCc +
                "))"),
              (re.src_path =
                "(?:[/?#](?:(?!" +
                re.src_ZCc +
                "|[><｜]|[()[\\]{}.,\"'?!\\-]).|\\[(?:(?!" +
                re.src_ZCc +
                "|\\]).)*\\]|\\((?:(?!" +
                re.src_ZCc +
                "|[)]).)*\\)|\\{(?:(?!" +
                re.src_ZCc +
                '|[}]).)*\\}|\\"(?:(?!' +
                re.src_ZCc +
                '|["]).)+\\"|\\\'(?:(?!' +
                re.src_ZCc +
                "|[']).)+\\'|\\'(?=" +
                re.src_pseudo_letter +
                "|[-]).|\\.{2,3}[a-zA-Z0-9%/]|\\.(?!" +
                re.src_ZCc +
                "|[.]).|" +
                (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") +
                "\\,(?!" +
                re.src_ZCc +
                ").|\\!(?!" +
                re.src_ZCc +
                "|[!]).|\\?(?!" +
                re.src_ZCc +
                "|[?]).)+|\\/)?"),
              (re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+'),
              (re.src_xn = "xn--[a-z0-9\\-]{1,59}"),
              (re.src_domain_root =
                "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})"),
              (re.src_domain =
                "(?:" +
                re.src_xn +
                "|(?:" +
                re.src_pseudo_letter +
                ")|(?:" +
                re.src_pseudo_letter +
                "(?:-(?!-)|" +
                re.src_pseudo_letter +
                "){0,61}" +
                re.src_pseudo_letter +
                "))"),
              (re.src_host =
                "(?:(?:(?:(?:" +
                re.src_domain +
                ")\\.)*" +
                re.src_domain +
                "))"),
              (re.tpl_host_fuzzy =
                "(?:" +
                re.src_ip4 +
                "|(?:(?:(?:" +
                re.src_domain +
                ")\\.)+(?:%TLDS%)))"),
              (re.tpl_host_no_ip_fuzzy =
                "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))"),
              (re.src_host_strict = re.src_host + re.src_host_terminator),
              (re.tpl_host_fuzzy_strict =
                re.tpl_host_fuzzy + re.src_host_terminator),
              (re.src_host_port_strict =
                re.src_host + re.src_port + re.src_host_terminator),
              (re.tpl_host_port_fuzzy_strict =
                re.tpl_host_fuzzy + re.src_port + re.src_host_terminator),
              (re.tpl_host_port_no_ip_fuzzy_strict =
                re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator),
              (re.tpl_host_fuzzy_test =
                "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" +
                re.src_ZPCc +
                "|>|$))"),
              (re.tpl_email_fuzzy =
                "(^|[><｜]|\\(|" +
                re.src_ZCc +
                ")(" +
                re.src_email_name +
                "@" +
                re.tpl_host_fuzzy_strict +
                ")"),
              (re.tpl_link_fuzzy =
                "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" +
                re.src_ZPCc +
                "))((?![$+<=>^`|｜])" +
                re.tpl_host_port_fuzzy_strict +
                re.src_path +
                ")"),
              (re.tpl_link_no_ip_fuzzy =
                "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" +
                re.src_ZPCc +
                "))((?![$+<=>^`|｜])" +
                re.tpl_host_port_no_ip_fuzzy_strict +
                re.src_path +
                ")"),
              re
            );
          };
        },
        {
          "uc.micro/categories/Cc/regex": 242,
          "uc.micro/categories/P/regex": 244,
          "uc.micro/categories/Z/regex": 245,
          "uc.micro/properties/Any/regex": 247
        }
      ],
      178: [
        function(require, module, exports) {
          "use strict";
          module.exports = require("./lib/");
        },
        { "./lib/": 187 }
      ],
      179: [
        function(require, module, exports) {
          "use strict";
          module.exports = require("entities/maps/entities.json");
        },
        { "entities/maps/entities.json": 67 }
      ],
      180: [
        function(require, module, exports) {
          "use strict";
          module.exports = [
            "address",
            "article",
            "aside",
            "base",
            "basefont",
            "blockquote",
            "body",
            "caption",
            "center",
            "col",
            "colgroup",
            "dd",
            "details",
            "dialog",
            "dir",
            "div",
            "dl",
            "dt",
            "fieldset",
            "figcaption",
            "figure",
            "footer",
            "form",
            "frame",
            "frameset",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "head",
            "header",
            "hr",
            "html",
            "iframe",
            "legend",
            "li",
            "link",
            "main",
            "menu",
            "menuitem",
            "meta",
            "nav",
            "noframes",
            "ol",
            "optgroup",
            "option",
            "p",
            "param",
            "section",
            "source",
            "summary",
            "table",
            "tbody",
            "td",
            "tfoot",
            "th",
            "thead",
            "title",
            "tr",
            "track",
            "ul"
          ];
        },
        {}
      ],
      181: [
        function(require, module, exports) {
          "use strict";
          var open_tag =
              "<[A-Za-z][A-Za-z0-9\\-]*(?:\\s+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:\\s*=\\s*(?:[^\"'=<>`\\x00-\\x20]+|'[^']*'|\"[^\"]*\"))?)*\\s*\\/?>",
            close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>",
            HTML_TAG_RE = new RegExp(
              "^(?:" +
                open_tag +
                "|" +
                close_tag +
                "|\x3c!----\x3e|\x3c!--(?:-?[^>-])(?:-?[^-])*--\x3e|<[?].*?[?]>|<![A-Z]+\\s+[^>]*>|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>)"
            ),
            HTML_OPEN_CLOSE_TAG_RE = new RegExp(
              "^(?:" + open_tag + "|" + close_tag + ")"
            );
          (module.exports.HTML_TAG_RE = HTML_TAG_RE),
            (module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE);
        },
        {}
      ],
      182: [
        function(require, module, exports) {
          "use strict";
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          function has(object, key) {
            return _hasOwnProperty.call(object, key);
          }
          function isValidEntityCode(c) {
            return (
              !(55296 <= c && c <= 57343) &&
              (!(64976 <= c && c <= 65007) &&
                (65535 != (65535 & c) &&
                  65534 != (65535 & c) &&
                  (!(0 <= c && c <= 8) &&
                    (11 !== c &&
                      (!(14 <= c && c <= 31) &&
                        (!(127 <= c && c <= 159) && !(1114111 < c)))))))
            );
          }
          function fromCodePoint(c) {
            if (65535 < c) {
              var surrogate1 = 55296 + ((c -= 65536) >> 10),
                surrogate2 = 56320 + (1023 & c);
              return String.fromCharCode(surrogate1, surrogate2);
            }
            return String.fromCharCode(c);
          }
          var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g,
            UNESCAPE_ALL_RE = new RegExp(
              UNESCAPE_MD_RE.source + "|" + /&([a-z#][a-z0-9]{1,31});/gi.source,
              "gi"
            ),
            DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i,
            entities = require("./entities");
          var HTML_ESCAPE_TEST_RE = /[&<>"]/,
            HTML_ESCAPE_REPLACE_RE = /[&<>"]/g,
            HTML_REPLACEMENTS = {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;"
            };
          function replaceUnsafeChar(ch) {
            return HTML_REPLACEMENTS[ch];
          }
          var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
          var UNICODE_PUNCT_RE = require("uc.micro/categories/P/regex");
          (exports.lib = {}),
            (exports.lib.mdurl = require("mdurl")),
            (exports.lib.ucmicro = require("uc.micro")),
            (exports.assign = function(obj) {
              return (
                Array.prototype.slice
                  .call(arguments, 1)
                  .forEach(function(source) {
                    if (source) {
                      if ("object" != typeof source)
                        throw new TypeError(source + "must be object");
                      Object.keys(source).forEach(function(key) {
                        obj[key] = source[key];
                      });
                    }
                  }),
                obj
              );
            }),
            (exports.isString = function(obj) {
              return (
                "[object String]" ===
                (function(obj) {
                  return Object.prototype.toString.call(obj);
                })(obj)
              );
            }),
            (exports.has = has),
            (exports.unescapeMd = function(str) {
              return str.indexOf("\\") < 0
                ? str
                : str.replace(UNESCAPE_MD_RE, "$1");
            }),
            (exports.unescapeAll = function(str) {
              return str.indexOf("\\") < 0 && str.indexOf("&") < 0
                ? str
                : str.replace(UNESCAPE_ALL_RE, function(
                    match,
                    escaped,
                    entity
                  ) {
                    return (
                      escaped ||
                      (function(match, name) {
                        var code = 0;
                        return has(entities, name)
                          ? entities[name]
                          : 35 === name.charCodeAt(0) &&
                            DIGITAL_ENTITY_TEST_RE.test(name) &&
                            isValidEntityCode(
                              (code =
                                "x" === name[1].toLowerCase()
                                  ? parseInt(name.slice(2), 16)
                                  : parseInt(name.slice(1), 10))
                            )
                            ? fromCodePoint(code)
                            : match;
                      })(match, entity)
                    );
                  });
            }),
            (exports.isValidEntityCode = isValidEntityCode),
            (exports.fromCodePoint = fromCodePoint),
            (exports.escapeHtml = function(str) {
              return HTML_ESCAPE_TEST_RE.test(str)
                ? str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar)
                : str;
            }),
            (exports.arrayReplaceAt = function(src, pos, newElements) {
              return [].concat(
                src.slice(0, pos),
                newElements,
                src.slice(pos + 1)
              );
            }),
            (exports.isSpace = function(code) {
              switch (code) {
                case 9:
                case 32:
                  return !0;
              }
              return !1;
            }),
            (exports.isWhiteSpace = function(code) {
              if (8192 <= code && code <= 8202) return !0;
              switch (code) {
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 32:
                case 160:
                case 5760:
                case 8239:
                case 8287:
                case 12288:
                  return !0;
              }
              return !1;
            }),
            (exports.isMdAsciiPunct = function(ch) {
              switch (ch) {
                case 33:
                case 34:
                case 35:
                case 36:
                case 37:
                case 38:
                case 39:
                case 40:
                case 41:
                case 42:
                case 43:
                case 44:
                case 45:
                case 46:
                case 47:
                case 58:
                case 59:
                case 60:
                case 61:
                case 62:
                case 63:
                case 64:
                case 91:
                case 92:
                case 93:
                case 94:
                case 95:
                case 96:
                case 123:
                case 124:
                case 125:
                case 126:
                  return !0;
                default:
                  return !1;
              }
            }),
            (exports.isPunctChar = function(ch) {
              return UNICODE_PUNCT_RE.test(ch);
            }),
            (exports.escapeRE = function(str) {
              return str.replace(REGEXP_ESCAPE_RE, "\\$&");
            }),
            (exports.normalizeReference = function(str) {
              return str
                .trim()
                .replace(/\s+/g, " ")
                .toUpperCase();
            });
        },
        {
          "./entities": 179,
          mdurl: 233,
          "uc.micro": 246,
          "uc.micro/categories/P/regex": 244
        }
      ],
      183: [
        function(require, module, exports) {
          "use strict";
          (exports.parseLinkLabel = require("./parse_link_label")),
            (exports.parseLinkDestination = require("./parse_link_destination")),
            (exports.parseLinkTitle = require("./parse_link_title"));
        },
        {
          "./parse_link_destination": 184,
          "./parse_link_label": 185,
          "./parse_link_title": 186
        }
      ],
      184: [
        function(require, module, exports) {
          "use strict";
          var isSpace = require("../common/utils").isSpace,
            unescapeAll = require("../common/utils").unescapeAll;
          module.exports = function(str, pos, max) {
            var code,
              level,
              start = pos,
              result = { ok: !1, pos: 0, lines: 0, str: "" };
            if (60 === str.charCodeAt(pos)) {
              for (pos++; pos < max; ) {
                if (10 === (code = str.charCodeAt(pos)) || isSpace(code))
                  return result;
                if (62 === code)
                  return (
                    (result.pos = pos + 1),
                    (result.str = unescapeAll(str.slice(start + 1, pos))),
                    (result.ok = !0),
                    result
                  );
                92 === code && pos + 1 < max ? (pos += 2) : pos++;
              }
              return result;
            }
            for (
              level = 0;
              pos < max &&
              32 !== (code = str.charCodeAt(pos)) &&
              !(code < 32 || 127 === code);

            )
              if (92 === code && pos + 1 < max) pos += 2;
              else {
                if ((40 === code && level++, 41 === code)) {
                  if (0 === level) break;
                  level--;
                }
                pos++;
              }
            return (
              start === pos ||
                0 !== level ||
                ((result.str = unescapeAll(str.slice(start, pos))),
                (result.lines = 0),
                (result.pos = pos),
                (result.ok = !0)),
              result
            );
          };
        },
        { "../common/utils": 182 }
      ],
      185: [
        function(require, module, exports) {
          "use strict";
          module.exports = function(state, start, disableNested) {
            var level,
              found,
              marker,
              prevPos,
              labelEnd = -1,
              max = state.posMax,
              oldPos = state.pos;
            for (state.pos = start + 1, level = 1; state.pos < max; ) {
              if (
                93 === (marker = state.src.charCodeAt(state.pos)) &&
                0 === --level
              ) {
                found = !0;
                break;
              }
              if (
                ((prevPos = state.pos),
                state.md.inline.skipToken(state),
                91 === marker)
              )
                if (prevPos === state.pos - 1) level++;
                else if (disableNested) return (state.pos = oldPos), -1;
            }
            return (
              found && (labelEnd = state.pos), (state.pos = oldPos), labelEnd
            );
          };
        },
        {}
      ],
      186: [
        function(require, module, exports) {
          "use strict";
          var unescapeAll = require("../common/utils").unescapeAll;
          module.exports = function(str, pos, max) {
            var code,
              marker,
              lines = 0,
              start = pos,
              result = { ok: !1, pos: 0, lines: 0, str: "" };
            if (max <= pos) return result;
            if (
              34 !== (marker = str.charCodeAt(pos)) &&
              39 !== marker &&
              40 !== marker
            )
              return result;
            for (pos++, 40 === marker && (marker = 41); pos < max; ) {
              if ((code = str.charCodeAt(pos)) === marker)
                return (
                  (result.pos = pos + 1),
                  (result.lines = lines),
                  (result.str = unescapeAll(str.slice(start + 1, pos))),
                  (result.ok = !0),
                  result
                );
              10 === code
                ? lines++
                : 92 === code &&
                  pos + 1 < max &&
                  (pos++, 10 === str.charCodeAt(pos) && lines++),
                pos++;
            }
            return result;
          };
        },
        { "../common/utils": 182 }
      ],
      187: [
        function(require, module, exports) {
          "use strict";
          var utils = require("./common/utils"),
            helpers = require("./helpers"),
            Renderer = require("./renderer"),
            ParserCore = require("./parser_core"),
            ParserBlock = require("./parser_block"),
            ParserInline = require("./parser_inline"),
            LinkifyIt = require("linkify-it"),
            mdurl = require("mdurl"),
            punycode = require("punycode"),
            config = {
              default: require("./presets/default"),
              zero: require("./presets/zero"),
              commonmark: require("./presets/commonmark")
            },
            BAD_PROTO_RE = /^(vbscript|javascript|file|data):/,
            GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
          function validateLink(url) {
            var str = url.trim().toLowerCase();
            return !BAD_PROTO_RE.test(str) || !!GOOD_DATA_RE.test(str);
          }
          var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
          function normalizeLink(url) {
            var parsed = mdurl.parse(url, !0);
            if (
              parsed.hostname &&
              (!parsed.protocol ||
                0 <= RECODE_HOSTNAME_FOR.indexOf(parsed.protocol))
            )
              try {
                parsed.hostname = punycode.toASCII(parsed.hostname);
              } catch (er) {}
            return mdurl.encode(mdurl.format(parsed));
          }
          function normalizeLinkText(url) {
            var parsed = mdurl.parse(url, !0);
            if (
              parsed.hostname &&
              (!parsed.protocol ||
                0 <= RECODE_HOSTNAME_FOR.indexOf(parsed.protocol))
            )
              try {
                parsed.hostname = punycode.toUnicode(parsed.hostname);
              } catch (er) {}
            return mdurl.decode(mdurl.format(parsed));
          }
          function MarkdownIt(presetName, options) {
            if (!(this instanceof MarkdownIt))
              return new MarkdownIt(presetName, options);
            options ||
              utils.isString(presetName) ||
              ((options = presetName || {}), (presetName = "default")),
              (this.inline = new ParserInline()),
              (this.block = new ParserBlock()),
              (this.core = new ParserCore()),
              (this.renderer = new Renderer()),
              (this.linkify = new LinkifyIt()),
              (this.validateLink = validateLink),
              (this.normalizeLink = normalizeLink),
              (this.normalizeLinkText = normalizeLinkText),
              (this.utils = utils),
              (this.helpers = utils.assign({}, helpers)),
              (this.options = {}),
              this.configure(presetName),
              options && this.set(options);
          }
          (MarkdownIt.prototype.set = function(options) {
            return utils.assign(this.options, options), this;
          }),
            (MarkdownIt.prototype.configure = function(presets) {
              var presetName,
                self = this;
              if (
                utils.isString(presets) &&
                !(presets = config[(presetName = presets)])
              )
                throw new Error(
                  'Wrong `markdown-it` preset "' + presetName + '", check name'
                );
              if (!presets)
                throw new Error("Wrong `markdown-it` preset, can't be empty");
              return (
                presets.options && self.set(presets.options),
                presets.components &&
                  Object.keys(presets.components).forEach(function(name) {
                    presets.components[name].rules &&
                      self[name].ruler.enableOnly(
                        presets.components[name].rules
                      ),
                      presets.components[name].rules2 &&
                        self[name].ruler2.enableOnly(
                          presets.components[name].rules2
                        );
                  }),
                this
              );
            }),
            (MarkdownIt.prototype.enable = function(list, ignoreInvalid) {
              var result = [];
              Array.isArray(list) || (list = [list]),
                ["core", "block", "inline"].forEach(function(chain) {
                  result = result.concat(this[chain].ruler.enable(list, !0));
                }, this),
                (result = result.concat(this.inline.ruler2.enable(list, !0)));
              var missed = list.filter(function(name) {
                return result.indexOf(name) < 0;
              });
              if (missed.length && !ignoreInvalid)
                throw new Error(
                  "MarkdownIt. Failed to enable unknown rule(s): " + missed
                );
              return this;
            }),
            (MarkdownIt.prototype.disable = function(list, ignoreInvalid) {
              var result = [];
              Array.isArray(list) || (list = [list]),
                ["core", "block", "inline"].forEach(function(chain) {
                  result = result.concat(this[chain].ruler.disable(list, !0));
                }, this),
                (result = result.concat(this.inline.ruler2.disable(list, !0)));
              var missed = list.filter(function(name) {
                return result.indexOf(name) < 0;
              });
              if (missed.length && !ignoreInvalid)
                throw new Error(
                  "MarkdownIt. Failed to disable unknown rule(s): " + missed
                );
              return this;
            }),
            (MarkdownIt.prototype.use = function(plugin) {
              var args = [this].concat(
                Array.prototype.slice.call(arguments, 1)
              );
              return plugin.apply(plugin, args), this;
            }),
            (MarkdownIt.prototype.parse = function(src, env) {
              if ("string" != typeof src)
                throw new Error("Input data should be a String");
              var state = new this.core.State(src, this, env);
              return this.core.process(state), state.tokens;
            }),
            (MarkdownIt.prototype.render = function(src, env) {
              return (
                (env = env || {}),
                this.renderer.render(this.parse(src, env), this.options, env)
              );
            }),
            (MarkdownIt.prototype.parseInline = function(src, env) {
              var state = new this.core.State(src, this, env);
              return (
                (state.inlineMode = !0), this.core.process(state), state.tokens
              );
            }),
            (MarkdownIt.prototype.renderInline = function(src, env) {
              return (
                (env = env || {}),
                this.renderer.render(
                  this.parseInline(src, env),
                  this.options,
                  env
                )
              );
            }),
            (module.exports = MarkdownIt);
        },
        {
          "./common/utils": 182,
          "./helpers": 183,
          "./parser_block": 188,
          "./parser_core": 189,
          "./parser_inline": 190,
          "./presets/commonmark": 191,
          "./presets/default": 192,
          "./presets/zero": 193,
          "./renderer": 194,
          "linkify-it": 176,
          mdurl: 233,
          punycode: 241
        }
      ],
      188: [
        function(require, module, exports) {
          "use strict";
          var Ruler = require("./ruler"),
            _rules = [
              [
                "table",
                require("./rules_block/table"),
                ["paragraph", "reference"]
              ],
              ["code", require("./rules_block/code")],
              [
                "fence",
                require("./rules_block/fence"),
                ["paragraph", "reference", "blockquote", "list"]
              ],
              [
                "blockquote",
                require("./rules_block/blockquote"),
                ["paragraph", "reference", "blockquote", "list"]
              ],
              [
                "hr",
                require("./rules_block/hr"),
                ["paragraph", "reference", "blockquote", "list"]
              ],
              [
                "list",
                require("./rules_block/list"),
                ["paragraph", "reference", "blockquote"]
              ],
              ["reference", require("./rules_block/reference")],
              [
                "heading",
                require("./rules_block/heading"),
                ["paragraph", "reference", "blockquote"]
              ],
              ["lheading", require("./rules_block/lheading")],
              [
                "html_block",
                require("./rules_block/html_block"),
                ["paragraph", "reference", "blockquote"]
              ],
              ["paragraph", require("./rules_block/paragraph")]
            ];
          function ParserBlock() {
            this.ruler = new Ruler();
            for (var i = 0; i < _rules.length; i++)
              this.ruler.push(_rules[i][0], _rules[i][1], {
                alt: (_rules[i][2] || []).slice()
              });
          }
          (ParserBlock.prototype.tokenize = function(
            state,
            startLine,
            endLine
          ) {
            for (
              var i,
                rules = this.ruler.getRules(""),
                len = rules.length,
                line = startLine,
                hasEmptyLines = !1,
                maxNesting = state.md.options.maxNesting;
              line < endLine &&
              ((state.line = line = state.skipEmptyLines(line)),
              !(endLine <= line)) &&
              !(state.sCount[line] < state.blkIndent);

            ) {
              if (state.level >= maxNesting) {
                state.line = endLine;
                break;
              }
              for (i = 0; i < len && !rules[i](state, line, endLine, !1); i++);
              (state.tight = !hasEmptyLines),
                state.isEmpty(state.line - 1) && (hasEmptyLines = !0),
                (line = state.line) < endLine &&
                  state.isEmpty(line) &&
                  ((hasEmptyLines = !0), line++, (state.line = line));
            }
          }),
            (ParserBlock.prototype.parse = function(src, md, env, outTokens) {
              var state;
              src &&
                ((state = new this.State(src, md, env, outTokens)),
                this.tokenize(state, state.line, state.lineMax));
            }),
            (ParserBlock.prototype.State = require("./rules_block/state_block")),
            (module.exports = ParserBlock);
        },
        {
          "./ruler": 195,
          "./rules_block/blockquote": 196,
          "./rules_block/code": 197,
          "./rules_block/fence": 198,
          "./rules_block/heading": 199,
          "./rules_block/hr": 200,
          "./rules_block/html_block": 201,
          "./rules_block/lheading": 202,
          "./rules_block/list": 203,
          "./rules_block/paragraph": 204,
          "./rules_block/reference": 205,
          "./rules_block/state_block": 206,
          "./rules_block/table": 207
        }
      ],
      189: [
        function(require, module, exports) {
          "use strict";
          var Ruler = require("./ruler"),
            _rules = [
              ["normalize", require("./rules_core/normalize")],
              ["block", require("./rules_core/block")],
              ["inline", require("./rules_core/inline")],
              ["linkify", require("./rules_core/linkify")],
              ["replacements", require("./rules_core/replacements")],
              ["smartquotes", require("./rules_core/smartquotes")]
            ];
          function Core() {
            this.ruler = new Ruler();
            for (var i = 0; i < _rules.length; i++)
              this.ruler.push(_rules[i][0], _rules[i][1]);
          }
          (Core.prototype.process = function(state) {
            var i, l, rules;
            for (
              i = 0, l = (rules = this.ruler.getRules("")).length;
              i < l;
              i++
            )
              rules[i](state);
          }),
            (Core.prototype.State = require("./rules_core/state_core")),
            (module.exports = Core);
        },
        {
          "./ruler": 195,
          "./rules_core/block": 208,
          "./rules_core/inline": 209,
          "./rules_core/linkify": 210,
          "./rules_core/normalize": 211,
          "./rules_core/replacements": 212,
          "./rules_core/smartquotes": 213,
          "./rules_core/state_core": 214
        }
      ],
      190: [
        function(require, module, exports) {
          "use strict";
          var Ruler = require("./ruler"),
            _rules = [
              ["text", require("./rules_inline/text")],
              ["newline", require("./rules_inline/newline")],
              ["escape", require("./rules_inline/escape")],
              ["backticks", require("./rules_inline/backticks")],
              [
                "strikethrough",
                require("./rules_inline/strikethrough").tokenize
              ],
              ["emphasis", require("./rules_inline/emphasis").tokenize],
              ["link", require("./rules_inline/link")],
              ["image", require("./rules_inline/image")],
              ["autolink", require("./rules_inline/autolink")],
              ["html_inline", require("./rules_inline/html_inline")],
              ["entity", require("./rules_inline/entity")]
            ],
            _rules2 = [
              ["balance_pairs", require("./rules_inline/balance_pairs")],
              [
                "strikethrough",
                require("./rules_inline/strikethrough").postProcess
              ],
              ["emphasis", require("./rules_inline/emphasis").postProcess],
              ["text_collapse", require("./rules_inline/text_collapse")]
            ];
          function ParserInline() {
            var i;
            for (this.ruler = new Ruler(), i = 0; i < _rules.length; i++)
              this.ruler.push(_rules[i][0], _rules[i][1]);
            for (this.ruler2 = new Ruler(), i = 0; i < _rules2.length; i++)
              this.ruler2.push(_rules2[i][0], _rules2[i][1]);
          }
          (ParserInline.prototype.skipToken = function(state) {
            var ok,
              i,
              pos = state.pos,
              rules = this.ruler.getRules(""),
              len = rules.length,
              maxNesting = state.md.options.maxNesting,
              cache = state.cache;
            if (void 0 === cache[pos]) {
              if (state.level < maxNesting)
                for (
                  i = 0;
                  i < len &&
                  (state.level++,
                  (ok = rules[i](state, !0)),
                  state.level--,
                  !ok);
                  i++
                );
              else state.pos = state.posMax;
              ok || state.pos++, (cache[pos] = state.pos);
            } else state.pos = cache[pos];
          }),
            (ParserInline.prototype.tokenize = function(state) {
              for (
                var ok,
                  i,
                  rules = this.ruler.getRules(""),
                  len = rules.length,
                  end = state.posMax,
                  maxNesting = state.md.options.maxNesting;
                state.pos < end;

              ) {
                if (state.level < maxNesting)
                  for (i = 0; i < len && !(ok = rules[i](state, !1)); i++);
                if (ok) {
                  if (state.pos >= end) break;
                } else state.pending += state.src[state.pos++];
              }
              state.pending && state.pushPending();
            }),
            (ParserInline.prototype.parse = function(str, md, env, outTokens) {
              var i,
                rules,
                len,
                state = new this.State(str, md, env, outTokens);
              for (
                this.tokenize(state),
                  len = (rules = this.ruler2.getRules("")).length,
                  i = 0;
                i < len;
                i++
              )
                rules[i](state);
            }),
            (ParserInline.prototype.State = require("./rules_inline/state_inline")),
            (module.exports = ParserInline);
        },
        {
          "./ruler": 195,
          "./rules_inline/autolink": 215,
          "./rules_inline/backticks": 216,
          "./rules_inline/balance_pairs": 217,
          "./rules_inline/emphasis": 218,
          "./rules_inline/entity": 219,
          "./rules_inline/escape": 220,
          "./rules_inline/html_inline": 221,
          "./rules_inline/image": 222,
          "./rules_inline/link": 223,
          "./rules_inline/newline": 224,
          "./rules_inline/state_inline": 225,
          "./rules_inline/strikethrough": 226,
          "./rules_inline/text": 227,
          "./rules_inline/text_collapse": 228
        }
      ],
      191: [
        function(require, module, exports) {
          "use strict";
          module.exports = {
            options: {
              html: !0,
              xhtmlOut: !0,
              breaks: !1,
              langPrefix: "language-",
              linkify: !1,
              typographer: !1,
              quotes: "“”‘’",
              highlight: null,
              maxNesting: 20
            },
            components: {
              core: { rules: ["normalize", "block", "inline"] },
              block: {
                rules: [
                  "blockquote",
                  "code",
                  "fence",
                  "heading",
                  "hr",
                  "html_block",
                  "lheading",
                  "list",
                  "reference",
                  "paragraph"
                ]
              },
              inline: {
                rules: [
                  "autolink",
                  "backticks",
                  "emphasis",
                  "entity",
                  "escape",
                  "html_inline",
                  "image",
                  "link",
                  "newline",
                  "text"
                ],
                rules2: ["balance_pairs", "emphasis", "text_collapse"]
              }
            }
          };
        },
        {}
      ],
      192: [
        function(require, module, exports) {
          "use strict";
          module.exports = {
            options: {
              html: !1,
              xhtmlOut: !1,
              breaks: !1,
              langPrefix: "language-",
              linkify: !1,
              typographer: !1,
              quotes: "“”‘’",
              highlight: null,
              maxNesting: 100
            },
            components: { core: {}, block: {}, inline: {} }
          };
        },
        {}
      ],
      193: [
        function(require, module, exports) {
          "use strict";
          module.exports = {
            options: {
              html: !1,
              xhtmlOut: !1,
              breaks: !1,
              langPrefix: "language-",
              linkify: !1,
              typographer: !1,
              quotes: "“”‘’",
              highlight: null,
              maxNesting: 20
            },
            components: {
              core: { rules: ["normalize", "block", "inline"] },
              block: { rules: ["paragraph"] },
              inline: {
                rules: ["text"],
                rules2: ["balance_pairs", "text_collapse"]
              }
            }
          };
        },
        {}
      ],
      194: [
        function(require, module, exports) {
          "use strict";
          var assign = require("./common/utils").assign,
            unescapeAll = require("./common/utils").unescapeAll,
            escapeHtml = require("./common/utils").escapeHtml,
            default_rules = {};
          function Renderer() {
            this.rules = assign({}, default_rules);
          }
          (default_rules.code_inline = function(
            tokens,
            idx,
            options,
            env,
            slf
          ) {
            var token = tokens[idx];
            return (
              "<code" +
              slf.renderAttrs(token) +
              ">" +
              escapeHtml(tokens[idx].content) +
              "</code>"
            );
          }),
            (default_rules.code_block = function(
              tokens,
              idx,
              options,
              env,
              slf
            ) {
              var token = tokens[idx];
              return (
                "<pre" +
                slf.renderAttrs(token) +
                "><code>" +
                escapeHtml(tokens[idx].content) +
                "</code></pre>\n"
              );
            }),
            (default_rules.fence = function(tokens, idx, options, env, slf) {
              var highlighted,
                i,
                tmpAttrs,
                tmpToken,
                token = tokens[idx],
                info = token.info ? unescapeAll(token.info).trim() : "",
                langName = "";
              return (
                info && (langName = info.split(/\s+/g)[0]),
                0 ===
                (highlighted =
                  (options.highlight &&
                    options.highlight(token.content, langName)) ||
                  escapeHtml(token.content)).indexOf("<pre")
                  ? highlighted + "\n"
                  : info
                    ? ((i = token.attrIndex("class")),
                      (tmpAttrs = token.attrs ? token.attrs.slice() : []),
                      i < 0
                        ? tmpAttrs.push([
                            "class",
                            options.langPrefix + langName
                          ])
                        : (tmpAttrs[i][1] +=
                            " " + options.langPrefix + langName),
                      (tmpToken = { attrs: tmpAttrs }),
                      "<pre><code" +
                        slf.renderAttrs(tmpToken) +
                        ">" +
                        highlighted +
                        "</code></pre>\n")
                    : "<pre><code" +
                      slf.renderAttrs(token) +
                      ">" +
                      highlighted +
                      "</code></pre>\n"
              );
            }),
            (default_rules.image = function(tokens, idx, options, env, slf) {
              var token = tokens[idx];
              return (
                (token.attrs[
                  token.attrIndex("alt")
                ][1] = slf.renderInlineAsText(token.children, options, env)),
                slf.renderToken(tokens, idx, options)
              );
            }),
            (default_rules.hardbreak = function(tokens, idx, options) {
              return options.xhtmlOut ? "<br />\n" : "<br>\n";
            }),
            (default_rules.softbreak = function(tokens, idx, options) {
              return options.breaks
                ? options.xhtmlOut ? "<br />\n" : "<br>\n"
                : "\n";
            }),
            (default_rules.text = function(tokens, idx) {
              return escapeHtml(tokens[idx].content);
            }),
            (default_rules.html_block = function(tokens, idx) {
              return tokens[idx].content;
            }),
            (default_rules.html_inline = function(tokens, idx) {
              return tokens[idx].content;
            }),
            (Renderer.prototype.renderAttrs = function(token) {
              var i, l, result;
              if (!token.attrs) return "";
              for (result = "", i = 0, l = token.attrs.length; i < l; i++)
                result +=
                  " " +
                  escapeHtml(token.attrs[i][0]) +
                  '="' +
                  escapeHtml(token.attrs[i][1]) +
                  '"';
              return result;
            }),
            (Renderer.prototype.renderToken = function(tokens, idx, options) {
              var nextToken,
                result = "",
                needLf = !1,
                token = tokens[idx];
              return token.hidden
                ? ""
                : (token.block &&
                    -1 !== token.nesting &&
                    idx &&
                    tokens[idx - 1].hidden &&
                    (result += "\n"),
                  (result += (-1 === token.nesting ? "</" : "<") + token.tag),
                  (result += this.renderAttrs(token)),
                  0 === token.nesting && options.xhtmlOut && (result += " /"),
                  token.block &&
                    ((needLf = !0),
                    1 === token.nesting &&
                      idx + 1 < tokens.length &&
                      ("inline" === (nextToken = tokens[idx + 1]).type ||
                      nextToken.hidden
                        ? (needLf = !1)
                        : -1 === nextToken.nesting &&
                          nextToken.tag === token.tag &&
                          (needLf = !1))),
                  (result += needLf ? ">\n" : ">"));
            }),
            (Renderer.prototype.renderInline = function(tokens, options, env) {
              for (
                var type,
                  result = "",
                  rules = this.rules,
                  i = 0,
                  len = tokens.length;
                i < len;
                i++
              )
                void 0 !== rules[(type = tokens[i].type)]
                  ? (result += rules[type](tokens, i, options, env, this))
                  : (result += this.renderToken(tokens, i, options));
              return result;
            }),
            (Renderer.prototype.renderInlineAsText = function(
              tokens,
              options,
              env
            ) {
              for (var result = "", i = 0, len = tokens.length; i < len; i++)
                "text" === tokens[i].type
                  ? (result += tokens[i].content)
                  : "image" === tokens[i].type &&
                    (result += this.renderInlineAsText(
                      tokens[i].children,
                      options,
                      env
                    ));
              return result;
            }),
            (Renderer.prototype.render = function(tokens, options, env) {
              var i,
                len,
                type,
                result = "",
                rules = this.rules;
              for (i = 0, len = tokens.length; i < len; i++)
                "inline" === (type = tokens[i].type)
                  ? (result += this.renderInline(
                      tokens[i].children,
                      options,
                      env
                    ))
                  : void 0 !== rules[type]
                    ? (result += rules[tokens[i].type](
                        tokens,
                        i,
                        options,
                        env,
                        this
                      ))
                    : (result += this.renderToken(tokens, i, options, env));
              return result;
            }),
            (module.exports = Renderer);
        },
        { "./common/utils": 182 }
      ],
      195: [
        function(require, module, exports) {
          "use strict";
          function Ruler() {
            (this.__rules__ = []), (this.__cache__ = null);
          }
          (Ruler.prototype.__find__ = function(name) {
            for (var i = 0; i < this.__rules__.length; i++)
              if (this.__rules__[i].name === name) return i;
            return -1;
          }),
            (Ruler.prototype.__compile__ = function() {
              var self = this,
                chains = [""];
              self.__rules__.forEach(function(rule) {
                rule.enabled &&
                  rule.alt.forEach(function(altName) {
                    chains.indexOf(altName) < 0 && chains.push(altName);
                  });
              }),
                (self.__cache__ = {}),
                chains.forEach(function(chain) {
                  (self.__cache__[chain] = []),
                    self.__rules__.forEach(function(rule) {
                      rule.enabled &&
                        ((chain && rule.alt.indexOf(chain) < 0) ||
                          self.__cache__[chain].push(rule.fn));
                    });
                });
            }),
            (Ruler.prototype.at = function(name, fn, options) {
              var index = this.__find__(name),
                opt = options || {};
              if (-1 === index)
                throw new Error("Parser rule not found: " + name);
              (this.__rules__[index].fn = fn),
                (this.__rules__[index].alt = opt.alt || []),
                (this.__cache__ = null);
            }),
            (Ruler.prototype.before = function(
              beforeName,
              ruleName,
              fn,
              options
            ) {
              var index = this.__find__(beforeName),
                opt = options || {};
              if (-1 === index)
                throw new Error("Parser rule not found: " + beforeName);
              this.__rules__.splice(index, 0, {
                name: ruleName,
                enabled: !0,
                fn: fn,
                alt: opt.alt || []
              }),
                (this.__cache__ = null);
            }),
            (Ruler.prototype.after = function(
              afterName,
              ruleName,
              fn,
              options
            ) {
              var index = this.__find__(afterName),
                opt = options || {};
              if (-1 === index)
                throw new Error("Parser rule not found: " + afterName);
              this.__rules__.splice(index + 1, 0, {
                name: ruleName,
                enabled: !0,
                fn: fn,
                alt: opt.alt || []
              }),
                (this.__cache__ = null);
            }),
            (Ruler.prototype.push = function(ruleName, fn, options) {
              var opt = options || {};
              this.__rules__.push({
                name: ruleName,
                enabled: !0,
                fn: fn,
                alt: opt.alt || []
              }),
                (this.__cache__ = null);
            }),
            (Ruler.prototype.enable = function(list, ignoreInvalid) {
              Array.isArray(list) || (list = [list]);
              var result = [];
              return (
                list.forEach(function(name) {
                  var idx = this.__find__(name);
                  if (idx < 0) {
                    if (ignoreInvalid) return;
                    throw new Error("Rules manager: invalid rule name " + name);
                  }
                  (this.__rules__[idx].enabled = !0), result.push(name);
                }, this),
                (this.__cache__ = null),
                result
              );
            }),
            (Ruler.prototype.enableOnly = function(list, ignoreInvalid) {
              Array.isArray(list) || (list = [list]),
                this.__rules__.forEach(function(rule) {
                  rule.enabled = !1;
                }),
                this.enable(list, ignoreInvalid);
            }),
            (Ruler.prototype.disable = function(list, ignoreInvalid) {
              Array.isArray(list) || (list = [list]);
              var result = [];
              return (
                list.forEach(function(name) {
                  var idx = this.__find__(name);
                  if (idx < 0) {
                    if (ignoreInvalid) return;
                    throw new Error("Rules manager: invalid rule name " + name);
                  }
                  (this.__rules__[idx].enabled = !1), result.push(name);
                }, this),
                (this.__cache__ = null),
                result
              );
            }),
            (Ruler.prototype.getRules = function(chainName) {
              return (
                null === this.__cache__ && this.__compile__(),
                this.__cache__[chainName] || []
              );
            }),
            (module.exports = Ruler);
        },
        {}
      ],
      196: [
        function(require, module, exports) {
          "use strict";
          var isSpace = require("../common/utils").isSpace;
          module.exports = function(state, startLine, endLine, silent) {
            var adjustTab,
              ch,
              i,
              initial,
              l,
              lastLineEmpty,
              lines,
              nextLine,
              offset,
              oldBMarks,
              oldBSCount,
              oldIndent,
              oldParentType,
              oldSCount,
              oldTShift,
              spaceAfterMarker,
              terminate,
              terminatorRules,
              token,
              wasOutdented,
              oldLineMax = state.lineMax,
              pos = state.bMarks[startLine] + state.tShift[startLine],
              max = state.eMarks[startLine];
            if (4 <= state.sCount[startLine] - state.blkIndent) return !1;
            if (62 !== state.src.charCodeAt(pos++)) return !1;
            if (silent) return !0;
            for (
              initial = offset =
                state.sCount[startLine] +
                pos -
                (state.bMarks[startLine] + state.tShift[startLine]),
                32 === state.src.charCodeAt(pos)
                  ? (pos++,
                    initial++,
                    offset++,
                    (adjustTab = !1),
                    (spaceAfterMarker = !0))
                  : 9 === state.src.charCodeAt(pos)
                    ? ((spaceAfterMarker = !0),
                      (state.bsCount[startLine] + offset) % 4 == 3
                        ? (pos++, initial++, offset++, (adjustTab = !1))
                        : (adjustTab = !0))
                    : (spaceAfterMarker = !1),
                oldBMarks = [state.bMarks[startLine]],
                state.bMarks[startLine] = pos;
              pos < max && ((ch = state.src.charCodeAt(pos)), isSpace(ch));

            )
              9 === ch
                ? (offset +=
                    4 -
                    (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) %
                      4)
                : offset++,
                pos++;
            for (
              oldBSCount = [state.bsCount[startLine]],
                state.bsCount[startLine] =
                  state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0),
                lastLineEmpty = max <= pos,
                oldSCount = [state.sCount[startLine]],
                state.sCount[startLine] = offset - initial,
                oldTShift = [state.tShift[startLine]],
                state.tShift[startLine] = pos - state.bMarks[startLine],
                terminatorRules = state.md.block.ruler.getRules("blockquote"),
                oldParentType = state.parentType,
                state.parentType = "blockquote",
                wasOutdented = !1,
                nextLine = startLine + 1;
              nextLine < endLine &&
              (state.sCount[nextLine] < state.blkIndent && (wasOutdented = !0),
              (pos = state.bMarks[nextLine] + state.tShift[nextLine]),
              !((max = state.eMarks[nextLine]) <= pos));
              nextLine++
            )
              if (62 !== state.src.charCodeAt(pos++) || wasOutdented) {
                if (lastLineEmpty) break;
                for (
                  terminate = !1, i = 0, l = terminatorRules.length;
                  i < l;
                  i++
                )
                  if (terminatorRules[i](state, nextLine, endLine, !0)) {
                    terminate = !0;
                    break;
                  }
                if (terminate) {
                  (state.lineMax = nextLine),
                    0 !== state.blkIndent &&
                      (oldBMarks.push(state.bMarks[nextLine]),
                      oldBSCount.push(state.bsCount[nextLine]),
                      oldTShift.push(state.tShift[nextLine]),
                      oldSCount.push(state.sCount[nextLine]),
                      (state.sCount[nextLine] -= state.blkIndent));
                  break;
                }
                oldBMarks.push(state.bMarks[nextLine]),
                  oldBSCount.push(state.bsCount[nextLine]),
                  oldTShift.push(state.tShift[nextLine]),
                  oldSCount.push(state.sCount[nextLine]),
                  (state.sCount[nextLine] = -1);
              } else {
                for (
                  initial = offset =
                    state.sCount[nextLine] +
                    pos -
                    (state.bMarks[nextLine] + state.tShift[nextLine]),
                    32 === state.src.charCodeAt(pos)
                      ? (pos++,
                        initial++,
                        offset++,
                        (adjustTab = !1),
                        (spaceAfterMarker = !0))
                      : 9 === state.src.charCodeAt(pos)
                        ? ((spaceAfterMarker = !0),
                          (state.bsCount[nextLine] + offset) % 4 == 3
                            ? (pos++, initial++, offset++, (adjustTab = !1))
                            : (adjustTab = !0))
                        : (spaceAfterMarker = !1),
                    oldBMarks.push(state.bMarks[nextLine]),
                    state.bMarks[nextLine] = pos;
                  pos < max && ((ch = state.src.charCodeAt(pos)), isSpace(ch));

                )
                  9 === ch
                    ? (offset +=
                        4 -
                        (offset +
                          state.bsCount[nextLine] +
                          (adjustTab ? 1 : 0)) %
                          4)
                    : offset++,
                    pos++;
                (lastLineEmpty = max <= pos),
                  oldBSCount.push(state.bsCount[nextLine]),
                  (state.bsCount[nextLine] =
                    state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0)),
                  oldSCount.push(state.sCount[nextLine]),
                  (state.sCount[nextLine] = offset - initial),
                  oldTShift.push(state.tShift[nextLine]),
                  (state.tShift[nextLine] = pos - state.bMarks[nextLine]);
              }
            for (
              oldIndent = state.blkIndent,
                state.blkIndent = 0,
                (token = state.push(
                  "blockquote_open",
                  "blockquote",
                  1
                )).markup =
                  ">",
                token.map = lines = [startLine, 0],
                state.md.block.tokenize(state, startLine, nextLine),
                (token = state.push(
                  "blockquote_close",
                  "blockquote",
                  -1
                )).markup =
                  ">",
                state.lineMax = oldLineMax,
                state.parentType = oldParentType,
                lines[1] = state.line,
                i = 0;
              i < oldTShift.length;
              i++
            )
              (state.bMarks[i + startLine] = oldBMarks[i]),
                (state.tShift[i + startLine] = oldTShift[i]),
                (state.sCount[i + startLine] = oldSCount[i]),
                (state.bsCount[i + startLine] = oldBSCount[i]);
            return (state.blkIndent = oldIndent), !0;
          };
        },
        { "../common/utils": 182 }
      ],
      197: [
        function(require, module, exports) {
          "use strict";
          module.exports = function(state, startLine, endLine) {
            var nextLine, last, token;
            if (state.sCount[startLine] - state.blkIndent < 4) return !1;
            for (last = nextLine = startLine + 1; nextLine < endLine; )
              if (state.isEmpty(nextLine)) nextLine++;
              else {
                if (!(4 <= state.sCount[nextLine] - state.blkIndent)) break;
                last = ++nextLine;
              }
            return (
              (state.line = last),
              ((token = state.push(
                "code_block",
                "code",
                0
              )).content = state.getLines(
                startLine,
                last,
                4 + state.blkIndent,
                !0
              )),
              (token.map = [startLine, state.line]),
              !0
            );
          };
        },
        {}
      ],
      198: [
        function(require, module, exports) {
          "use strict";
          module.exports = function(state, startLine, endLine, silent) {
            var marker,
              len,
              params,
              nextLine,
              mem,
              token,
              markup,
              haveEndMarker = !1,
              pos = state.bMarks[startLine] + state.tShift[startLine],
              max = state.eMarks[startLine];
            if (4 <= state.sCount[startLine] - state.blkIndent) return !1;
            if (max < pos + 3) return !1;
            if (126 !== (marker = state.src.charCodeAt(pos)) && 96 !== marker)
              return !1;
            if (
              ((mem = pos),
              (len = (pos = state.skipChars(pos, marker)) - mem) < 3)
            )
              return !1;
            if (
              ((markup = state.src.slice(mem, pos)),
              0 <=
                (params = state.src.slice(pos, max)).indexOf(
                  String.fromCharCode(marker)
                ))
            )
              return !1;
            if (silent) return !0;
            for (
              nextLine = startLine;
              !(endLine <= ++nextLine) &&
              !(
                (pos = mem = state.bMarks[nextLine] + state.tShift[nextLine]) <
                  (max = state.eMarks[nextLine]) &&
                state.sCount[nextLine] < state.blkIndent
              );

            )
              if (
                state.src.charCodeAt(pos) === marker &&
                !(
                  4 <= state.sCount[nextLine] - state.blkIndent ||
                  (pos = state.skipChars(pos, marker)) - mem < len ||
                  (pos = state.skipSpaces(pos)) < max
                )
              ) {
                haveEndMarker = !0;
                break;
              }
            return (
              (len = state.sCount[startLine]),
              (state.line = nextLine + (haveEndMarker ? 1 : 0)),
              ((token = state.push("fence", "code", 0)).info = params),
              (token.content = state.getLines(
                startLine + 1,
                nextLine,
                len,
                !0
              )),
              (token.markup = markup),
              (token.map = [startLine, state.line]),
              !0
            );
          };
        },
        {}
      ],
      199: [
        function(require, module, exports) {
          "use strict";
          var isSpace = require("../common/utils").isSpace;
          module.exports = function(state, startLine, endLine, silent) {
            var ch,
              level,
              tmp,
              token,
              pos = state.bMarks[startLine] + state.tShift[startLine],
              max = state.eMarks[startLine];
            if (4 <= state.sCount[startLine] - state.blkIndent) return !1;
            if (35 !== (ch = state.src.charCodeAt(pos)) || max <= pos)
              return !1;
            for (
              level = 1, ch = state.src.charCodeAt(++pos);
              35 === ch && pos < max && level <= 6;

            )
              level++, (ch = state.src.charCodeAt(++pos));
            return (
              !(6 < level || (pos < max && !isSpace(ch))) &&
              (silent ||
                ((max = state.skipSpacesBack(max, pos)),
                pos < (tmp = state.skipCharsBack(max, 35, pos)) &&
                  isSpace(state.src.charCodeAt(tmp - 1)) &&
                  (max = tmp),
                (state.line = startLine + 1),
                ((token = state.push(
                  "heading_open",
                  "h" + String(level),
                  1
                )).markup = "########".slice(0, level)),
                (token.map = [startLine, state.line]),
                ((token = state.push(
                  "inline",
                  "",
                  0
                )).content = state.src.slice(pos, max).trim()),
                (token.map = [startLine, state.line]),
                (token.children = []),
                ((token = state.push(
                  "heading_close",
                  "h" + String(level),
                  -1
                )).markup = "########".slice(0, level))),
              !0)
            );
          };
        },
        { "../common/utils": 182 }
      ],
      200: [
        function(require, module, exports) {
          "use strict";
          var isSpace = require("../common/utils").isSpace;
          module.exports = function(state, startLine, endLine, silent) {
            var marker,
              cnt,
              ch,
              token,
              pos = state.bMarks[startLine] + state.tShift[startLine],
              max = state.eMarks[startLine];
            if (4 <= state.sCount[startLine] - state.blkIndent) return !1;
            if (
              42 !== (marker = state.src.charCodeAt(pos++)) &&
              45 !== marker &&
              95 !== marker
            )
              return !1;
            for (cnt = 1; pos < max; ) {
              if ((ch = state.src.charCodeAt(pos++)) !== marker && !isSpace(ch))
                return !1;
              ch === marker && cnt++;
            }
            return (
              !(cnt < 3) &&
              (silent ||
                ((state.line = startLine + 1),
                ((token = state.push("hr", "hr", 0)).map = [
                  startLine,
                  state.line
                ]),
                (token.markup = Array(cnt + 1).join(
                  String.fromCharCode(marker)
                ))),
              !0)
            );
          };
        },
        { "../common/utils": 182 }
      ],
      201: [
        function(require, module, exports) {
          "use strict";
          var block_names = require("../common/html_blocks"),
            HTML_OPEN_CLOSE_TAG_RE = require("../common/html_re")
              .HTML_OPEN_CLOSE_TAG_RE,
            HTML_SEQUENCES = [
              [
                /^<(script|pre|style)(?=(\s|>|$))/i,
                /<\/(script|pre|style)>/i,
                !0
              ],
              [/^<!--/, /-->/, !0],
              [/^<\?/, /\?>/, !0],
              [/^<![A-Z]/, />/, !0],
              [/^<!\[CDATA\[/, /\]\]>/, !0],
              [
                new RegExp(
                  "^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))",
                  "i"
                ),
                /^$/,
                !0
              ],
              [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, !1]
            ];
          module.exports = function(state, startLine, endLine, silent) {
            var i,
              nextLine,
              token,
              lineText,
              pos = state.bMarks[startLine] + state.tShift[startLine],
              max = state.eMarks[startLine];
            if (4 <= state.sCount[startLine] - state.blkIndent) return !1;
            if (!state.md.options.html) return !1;
            if (60 !== state.src.charCodeAt(pos)) return !1;
            for (
              lineText = state.src.slice(pos, max), i = 0;
              i < HTML_SEQUENCES.length && !HTML_SEQUENCES[i][0].test(lineText);
              i++
            );
            if (i === HTML_SEQUENCES.length) return !1;
            if (silent) return HTML_SEQUENCES[i][2];
            if (
              ((nextLine = startLine + 1), !HTML_SEQUENCES[i][1].test(lineText))
            )
              for (
                ;
                nextLine < endLine &&
                !(state.sCount[nextLine] < state.blkIndent);
                nextLine++
              )
                if (
                  ((pos = state.bMarks[nextLine] + state.tShift[nextLine]),
                  (max = state.eMarks[nextLine]),
                  (lineText = state.src.slice(pos, max)),
                  HTML_SEQUENCES[i][1].test(lineText))
                ) {
                  0 !== lineText.length && nextLine++;
                  break;
                }
            return (
              (state.line = nextLine),
              ((token = state.push("html_block", "", 0)).map = [
                startLine,
                nextLine
              ]),
              (token.content = state.getLines(
                startLine,
                nextLine,
                state.blkIndent,
                !0
              )),
              !0
            );
          };
        },
        { "../common/html_blocks": 180, "../common/html_re": 181 }
      ],
      202: [
        function(require, module, exports) {
          "use strict";
          module.exports = function(state, startLine, endLine) {
            var content,
              terminate,
              i,
              l,
              token,
              pos,
              max,
              level,
              marker,
              oldParentType,
              nextLine = startLine + 1,
              terminatorRules = state.md.block.ruler.getRules("paragraph");
            if (4 <= state.sCount[startLine] - state.blkIndent) return !1;
            for (
              oldParentType = state.parentType, state.parentType = "paragraph";
              nextLine < endLine && !state.isEmpty(nextLine);
              nextLine++
            )
              if (!(3 < state.sCount[nextLine] - state.blkIndent)) {
                if (
                  state.sCount[nextLine] >= state.blkIndent &&
                  (pos = state.bMarks[nextLine] + state.tShift[nextLine]) <
                    (max = state.eMarks[nextLine]) &&
                  (45 === (marker = state.src.charCodeAt(pos)) ||
                    61 === marker) &&
                  ((pos = state.skipChars(pos, marker)),
                  max <= (pos = state.skipSpaces(pos)))
                ) {
                  level = 61 === marker ? 1 : 2;
                  break;
                }
                if (!(state.sCount[nextLine] < 0)) {
                  for (
                    terminate = !1, i = 0, l = terminatorRules.length;
                    i < l;
                    i++
                  )
                    if (terminatorRules[i](state, nextLine, endLine, !0)) {
                      terminate = !0;
                      break;
                    }
                  if (terminate) break;
                }
              }
            return (
              !!level &&
              ((content = state
                .getLines(startLine, nextLine, state.blkIndent, !1)
                .trim()),
              (state.line = nextLine + 1),
              ((token = state.push(
                "heading_open",
                "h" + String(level),
                1
              )).markup = String.fromCharCode(marker)),
              (token.map = [startLine, state.line]),
              ((token = state.push("inline", "", 0)).content = content),
              (token.map = [startLine, state.line - 1]),
              (token.children = []),
              ((token = state.push(
                "heading_close",
                "h" + String(level),
                -1
              )).markup = String.fromCharCode(marker)),
              (state.parentType = oldParentType),
              !0)
            );
          };
        },
        {}
      ],
      203: [
        function(require, module, exports) {
          "use strict";
          var isSpace = require("../common/utils").isSpace;
          function skipBulletListMarker(state, startLine) {
            var marker, pos, max, ch;
            return (
              (pos = state.bMarks[startLine] + state.tShift[startLine]),
              (max = state.eMarks[startLine]),
              42 !== (marker = state.src.charCodeAt(pos++)) &&
              45 !== marker &&
              43 !== marker
                ? -1
                : pos < max && ((ch = state.src.charCodeAt(pos)), !isSpace(ch))
                  ? -1
                  : pos
            );
          }
          function skipOrderedListMarker(state, startLine) {
            var ch,
              start = state.bMarks[startLine] + state.tShift[startLine],
              pos = start,
              max = state.eMarks[startLine];
            if (max <= pos + 1) return -1;
            if ((ch = state.src.charCodeAt(pos++)) < 48 || 57 < ch) return -1;
            for (;;) {
              if (max <= pos) return -1;
              if (!(48 <= (ch = state.src.charCodeAt(pos++)) && ch <= 57)) {
                if (41 === ch || 46 === ch) break;
                return -1;
              }
              if (10 <= pos - start) return -1;
            }
            return pos < max && ((ch = state.src.charCodeAt(pos)), !isSpace(ch))
              ? -1
              : pos;
          }
          module.exports = function(state, startLine, endLine, silent) {
            var ch,
              contentStart,
              i,
              indent,
              indentAfterMarker,
              initial,
              isOrdered,
              itemLines,
              l,
              listLines,
              listTokIdx,
              markerCharCode,
              markerValue,
              max,
              nextLine,
              offset,
              oldIndent,
              oldLIndent,
              oldParentType,
              oldTShift,
              oldTight,
              pos,
              posAfterMarker,
              prevEmptyEnd,
              start,
              terminate,
              terminatorRules,
              token,
              isTerminatingParagraph = !1,
              tight = !0;
            if (4 <= state.sCount[startLine] - state.blkIndent) return !1;
            if (
              (silent &&
                "paragraph" === state.parentType &&
                state.tShift[startLine] >= state.blkIndent &&
                (isTerminatingParagraph = !0),
              0 <= (posAfterMarker = skipOrderedListMarker(state, startLine)))
            ) {
              if (
                ((isOrdered = !0),
                (start = state.bMarks[startLine] + state.tShift[startLine]),
                (markerValue = Number(
                  state.src.substr(start, posAfterMarker - start - 1)
                )),
                isTerminatingParagraph && 1 !== markerValue)
              )
                return !1;
            } else {
              if (
                !(
                  0 <= (posAfterMarker = skipBulletListMarker(state, startLine))
                )
              )
                return !1;
              isOrdered = !1;
            }
            if (
              isTerminatingParagraph &&
              state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]
            )
              return !1;
            if (
              ((markerCharCode = state.src.charCodeAt(posAfterMarker - 1)),
              silent)
            )
              return !0;
            for (
              listTokIdx = state.tokens.length,
                isOrdered
                  ? ((token = state.push("ordered_list_open", "ol", 1)),
                    1 !== markerValue &&
                      (token.attrs = [["start", markerValue]]))
                  : (token = state.push("bullet_list_open", "ul", 1)),
                token.map = listLines = [startLine, 0],
                token.markup = String.fromCharCode(markerCharCode),
                nextLine = startLine,
                prevEmptyEnd = !1,
                terminatorRules = state.md.block.ruler.getRules("list"),
                oldParentType = state.parentType,
                state.parentType = "list";
              nextLine < endLine;

            ) {
              for (
                pos = posAfterMarker,
                  max = state.eMarks[nextLine],
                  initial = offset =
                    state.sCount[nextLine] +
                    posAfterMarker -
                    (state.bMarks[startLine] + state.tShift[startLine]);
                pos < max;

              ) {
                if (9 === (ch = state.src.charCodeAt(pos)))
                  offset += 4 - (offset + state.bsCount[nextLine]) % 4;
                else {
                  if (32 !== ch) break;
                  offset++;
                }
                pos++;
              }
              if (
                (4 <
                  (indentAfterMarker =
                    max <= (contentStart = pos) ? 1 : offset - initial) &&
                  (indentAfterMarker = 1),
                (indent = initial + indentAfterMarker),
                ((token = state.push(
                  "list_item_open",
                  "li",
                  1
                )).markup = String.fromCharCode(markerCharCode)),
                (token.map = itemLines = [startLine, 0]),
                (oldIndent = state.blkIndent),
                (oldTight = state.tight),
                (oldTShift = state.tShift[startLine]),
                (oldLIndent = state.sCount[startLine]),
                (state.blkIndent = indent),
                (state.tight = !0),
                (state.tShift[startLine] =
                  contentStart - state.bMarks[startLine]),
                (state.sCount[startLine] = offset),
                max <= contentStart && state.isEmpty(startLine + 1)
                  ? (state.line = Math.min(state.line + 2, endLine))
                  : state.md.block.tokenize(state, startLine, endLine, !0),
                (state.tight && !prevEmptyEnd) || (tight = !1),
                (prevEmptyEnd =
                  1 < state.line - startLine && state.isEmpty(state.line - 1)),
                (state.blkIndent = oldIndent),
                (state.tShift[startLine] = oldTShift),
                (state.sCount[startLine] = oldLIndent),
                (state.tight = oldTight),
                ((token = state.push(
                  "list_item_close",
                  "li",
                  -1
                )).markup = String.fromCharCode(markerCharCode)),
                (nextLine = startLine = state.line),
                (itemLines[1] = nextLine),
                (contentStart = state.bMarks[startLine]),
                endLine <= nextLine)
              )
                break;
              if (state.sCount[nextLine] < state.blkIndent) break;
              for (
                terminate = !1, i = 0, l = terminatorRules.length;
                i < l;
                i++
              )
                if (terminatorRules[i](state, nextLine, endLine, !0)) {
                  terminate = !0;
                  break;
                }
              if (terminate) break;
              if (isOrdered) {
                if (
                  (posAfterMarker = skipOrderedListMarker(state, nextLine)) < 0
                )
                  break;
              } else if (
                (posAfterMarker = skipBulletListMarker(state, nextLine)) < 0
              )
                break;
              if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1))
                break;
            }
            return (
              ((token = isOrdered
                ? state.push("ordered_list_close", "ol", -1)
                : state.push(
                    "bullet_list_close",
                    "ul",
                    -1
                  )).markup = String.fromCharCode(markerCharCode)),
              (listLines[1] = nextLine),
              (state.line = nextLine),
              (state.parentType = oldParentType),
              tight &&
                (function(state, idx) {
                  var i,
                    l,
                    level = state.level + 2;
                  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++)
                    state.tokens[i].level === level &&
                      "paragraph_open" === state.tokens[i].type &&
                      ((state.tokens[i + 2].hidden = !0),
                      (state.tokens[i].hidden = !0),
                      (i += 2));
                })(state, listTokIdx),
              !0
            );
          };
        },
        { "../common/utils": 182 }
      ],
      204: [
        function(require, module, exports) {
          "use strict";
          module.exports = function(state, startLine) {
            var content,
              terminate,
              i,
              l,
              token,
              oldParentType,
              nextLine = startLine + 1,
              terminatorRules = state.md.block.ruler.getRules("paragraph"),
              endLine = state.lineMax;
            for (
              oldParentType = state.parentType, state.parentType = "paragraph";
              nextLine < endLine && !state.isEmpty(nextLine);
              nextLine++
            )
              if (
                !(
                  3 < state.sCount[nextLine] - state.blkIndent ||
                  state.sCount[nextLine] < 0
                )
              ) {
                for (
                  terminate = !1, i = 0, l = terminatorRules.length;
                  i < l;
                  i++
                )
                  if (terminatorRules[i](state, nextLine, endLine, !0)) {
                    terminate = !0;
                    break;
                  }
                if (terminate) break;
              }
            return (
              (content = state
                .getLines(startLine, nextLine, state.blkIndent, !1)
                .trim()),
              (state.line = nextLine),
              ((token = state.push("paragraph_open", "p", 1)).map = [
                startLine,
                state.line
              ]),
              ((token = state.push("inline", "", 0)).content = content),
              (token.map = [startLine, state.line]),
              (token.children = []),
              (token = state.push("paragraph_close", "p", -1)),
              (state.parentType = oldParentType),
              !0
            );
          };
        },
        {}
      ],
      205: [
        function(require, module, exports) {
          "use strict";
          var normalizeReference = require("../common/utils")
              .normalizeReference,
            isSpace = require("../common/utils").isSpace;
          module.exports = function(state, startLine, _endLine, silent) {
            var ch,
              destEndPos,
              destEndLineNo,
              endLine,
              href,
              i,
              l,
              label,
              labelEnd,
              oldParentType,
              res,
              start,
              str,
              terminate,
              terminatorRules,
              title,
              lines = 0,
              pos = state.bMarks[startLine] + state.tShift[startLine],
              max = state.eMarks[startLine],
              nextLine = startLine + 1;
            if (4 <= state.sCount[startLine] - state.blkIndent) return !1;
            if (91 !== state.src.charCodeAt(pos)) return !1;
            for (; ++pos < max; )
              if (
                93 === state.src.charCodeAt(pos) &&
                92 !== state.src.charCodeAt(pos - 1)
              ) {
                if (pos + 1 === max) return !1;
                if (58 !== state.src.charCodeAt(pos + 1)) return !1;
                break;
              }
            for (
              endLine = state.lineMax,
                terminatorRules = state.md.block.ruler.getRules("reference"),
                oldParentType = state.parentType,
                state.parentType = "reference";
              nextLine < endLine && !state.isEmpty(nextLine);
              nextLine++
            )
              if (
                !(
                  3 < state.sCount[nextLine] - state.blkIndent ||
                  state.sCount[nextLine] < 0
                )
              ) {
                for (
                  terminate = !1, i = 0, l = terminatorRules.length;
                  i < l;
                  i++
                )
                  if (terminatorRules[i](state, nextLine, endLine, !0)) {
                    terminate = !0;
                    break;
                  }
                if (terminate) break;
              }
            for (
              max = (str = state
                .getLines(startLine, nextLine, state.blkIndent, !1)
                .trim()).length,
                pos = 1;
              pos < max;
              pos++
            ) {
              if (91 === (ch = str.charCodeAt(pos))) return !1;
              if (93 === ch) {
                labelEnd = pos;
                break;
              }
              10 === ch
                ? lines++
                : 92 === ch &&
                  ++pos < max &&
                  10 === str.charCodeAt(pos) &&
                  lines++;
            }
            if (labelEnd < 0 || 58 !== str.charCodeAt(labelEnd + 1)) return !1;
            for (pos = labelEnd + 2; pos < max; pos++)
              if (10 === (ch = str.charCodeAt(pos))) lines++;
              else if (!isSpace(ch)) break;
            if (
              !(res = state.md.helpers.parseLinkDestination(str, pos, max)).ok
            )
              return !1;
            if (
              ((href = state.md.normalizeLink(res.str)),
              !state.md.validateLink(href))
            )
              return !1;
            for (
              pos = res.pos,
                destEndLineNo = lines += res.lines,
                start = destEndPos = pos;
              pos < max;
              pos++
            )
              if (10 === (ch = str.charCodeAt(pos))) lines++;
              else if (!isSpace(ch)) break;
            for (
              res = state.md.helpers.parseLinkTitle(str, pos, max),
                pos < max && start !== pos && res.ok
                  ? ((title = res.str), (pos = res.pos), (lines += res.lines))
                  : ((title = ""), (pos = destEndPos), (lines = destEndLineNo));
              pos < max && ((ch = str.charCodeAt(pos)), isSpace(ch));

            )
              pos++;
            if (pos < max && 10 !== str.charCodeAt(pos) && title)
              for (
                title = "", pos = destEndPos, lines = destEndLineNo;
                pos < max && ((ch = str.charCodeAt(pos)), isSpace(ch));

              )
                pos++;
            return (
              !(pos < max && 10 !== str.charCodeAt(pos)) &&
              (!!(label = normalizeReference(str.slice(1, labelEnd))) &&
                (silent ||
                  (void 0 === state.env.references &&
                    (state.env.references = {}),
                  void 0 === state.env.references[label] &&
                    (state.env.references[label] = {
                      title: title,
                      href: href
                    }),
                  (state.parentType = oldParentType),
                  (state.line = startLine + lines + 1)),
                !0))
            );
          };
        },
        { "../common/utils": 182 }
      ],
      206: [
        function(require, module, exports) {
          "use strict";
          var Token = require("../token"),
            isSpace = require("../common/utils").isSpace;
          function StateBlock(src, md, env, tokens) {
            var ch, s, start, pos, len, indent, offset, indent_found;
            for (
              this.src = src,
                this.md = md,
                this.env = env,
                this.tokens = tokens,
                this.bMarks = [],
                this.eMarks = [],
                this.tShift = [],
                this.sCount = [],
                this.bsCount = [],
                this.blkIndent = 0,
                this.line = 0,
                this.lineMax = 0,
                this.tight = !1,
                this.ddIndent = -1,
                this.parentType = "root",
                this.level = 0,
                this.result = "",
                indent_found = !1,
                start = pos = indent = offset = 0,
                len = (s = this.src).length;
              pos < len;
              pos++
            ) {
              if (((ch = s.charCodeAt(pos)), !indent_found)) {
                if (isSpace(ch)) {
                  indent++, 9 === ch ? (offset += 4 - offset % 4) : offset++;
                  continue;
                }
                indent_found = !0;
              }
              (10 !== ch && pos !== len - 1) ||
                (10 !== ch && pos++,
                this.bMarks.push(start),
                this.eMarks.push(pos),
                this.tShift.push(indent),
                this.sCount.push(offset),
                this.bsCount.push(0),
                (indent_found = !1),
                (offset = indent = 0),
                (start = pos + 1));
            }
            this.bMarks.push(s.length),
              this.eMarks.push(s.length),
              this.tShift.push(0),
              this.sCount.push(0),
              this.bsCount.push(0),
              (this.lineMax = this.bMarks.length - 1);
          }
          (StateBlock.prototype.push = function(type, tag, nesting) {
            var token = new Token(type, tag, nesting);
            return (
              (token.block = !0),
              nesting < 0 && this.level--,
              (token.level = this.level),
              0 < nesting && this.level++,
              this.tokens.push(token),
              token
            );
          }),
            (StateBlock.prototype.isEmpty = function(line) {
              return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
            }),
            (StateBlock.prototype.skipEmptyLines = function(from) {
              for (
                var max = this.lineMax;
                from < max &&
                !(this.bMarks[from] + this.tShift[from] < this.eMarks[from]);
                from++
              );
              return from;
            }),
            (StateBlock.prototype.skipSpaces = function(pos) {
              for (
                var ch, max = this.src.length;
                pos < max && ((ch = this.src.charCodeAt(pos)), isSpace(ch));
                pos++
              );
              return pos;
            }),
            (StateBlock.prototype.skipSpacesBack = function(pos, min) {
              if (pos <= min) return pos;
              for (; min < pos; )
                if (!isSpace(this.src.charCodeAt(--pos))) return pos + 1;
              return pos;
            }),
            (StateBlock.prototype.skipChars = function(pos, code) {
              for (
                var max = this.src.length;
                pos < max && this.src.charCodeAt(pos) === code;
                pos++
              );
              return pos;
            }),
            (StateBlock.prototype.skipCharsBack = function(pos, code, min) {
              if (pos <= min) return pos;
              for (; min < pos; )
                if (code !== this.src.charCodeAt(--pos)) return pos + 1;
              return pos;
            }),
            (StateBlock.prototype.getLines = function(
              begin,
              end,
              indent,
              keepLastLF
            ) {
              var i,
                lineIndent,
                ch,
                first,
                last,
                queue,
                lineStart,
                line = begin;
              if (end <= begin) return "";
              for (
                queue = new Array(end - begin), i = 0;
                line < end;
                line++, i++
              ) {
                for (
                  lineIndent = 0,
                    lineStart = first = this.bMarks[line],
                    last =
                      line + 1 < end || keepLastLF
                        ? this.eMarks[line] + 1
                        : this.eMarks[line];
                  first < last && lineIndent < indent;

                ) {
                  if (((ch = this.src.charCodeAt(first)), isSpace(ch)))
                    9 === ch
                      ? (lineIndent +=
                          4 - (lineIndent + this.bsCount[line]) % 4)
                      : lineIndent++;
                  else {
                    if (!(first - lineStart < this.tShift[line])) break;
                    lineIndent++;
                  }
                  first++;
                }
                queue[i] =
                  indent < lineIndent
                    ? new Array(lineIndent - indent + 1).join(" ") +
                      this.src.slice(first, last)
                    : this.src.slice(first, last);
              }
              return queue.join("");
            }),
            (StateBlock.prototype.Token = Token),
            (module.exports = StateBlock);
        },
        { "../common/utils": 182, "../token": 229 }
      ],
      207: [
        function(require, module, exports) {
          "use strict";
          var isSpace = require("../common/utils").isSpace;
          function getLine(state, line) {
            var pos = state.bMarks[line] + state.blkIndent,
              max = state.eMarks[line];
            return state.src.substr(pos, max - pos);
          }
          function escapedSplit(str) {
            var ch,
              result = [],
              pos = 0,
              max = str.length,
              escapes = 0,
              lastPos = 0,
              backTicked = !1,
              lastBackTick = 0;
            for (ch = str.charCodeAt(pos); pos < max; )
              96 === ch
                ? backTicked
                  ? ((backTicked = !1), (lastBackTick = pos))
                  : escapes % 2 == 0 &&
                    ((backTicked = !0), (lastBackTick = pos))
                : 124 !== ch ||
                  escapes % 2 != 0 ||
                  backTicked ||
                  (result.push(str.substring(lastPos, pos)),
                  (lastPos = pos + 1)),
                92 === ch ? escapes++ : (escapes = 0),
                ++pos === max &&
                  backTicked &&
                  ((backTicked = !1), (pos = lastBackTick + 1)),
                (ch = str.charCodeAt(pos));
            return result.push(str.substring(lastPos)), result;
          }
          module.exports = function(state, startLine, endLine, silent) {
            var ch,
              lineText,
              pos,
              i,
              nextLine,
              columns,
              columnCount,
              token,
              aligns,
              t,
              tableLines,
              tbodyLines;
            if (endLine < startLine + 2) return !1;
            if (
              ((nextLine = startLine + 1),
              state.sCount[nextLine] < state.blkIndent)
            )
              return !1;
            if (4 <= state.sCount[nextLine] - state.blkIndent) return !1;
            if (
              (pos = state.bMarks[nextLine] + state.tShift[nextLine]) >=
              state.eMarks[nextLine]
            )
              return !1;
            if (
              124 !== (ch = state.src.charCodeAt(pos++)) &&
              45 !== ch &&
              58 !== ch
            )
              return !1;
            for (; pos < state.eMarks[nextLine]; ) {
              if (
                124 !== (ch = state.src.charCodeAt(pos)) &&
                45 !== ch &&
                58 !== ch &&
                !isSpace(ch)
              )
                return !1;
              pos++;
            }
            for (
              columns = (lineText = getLine(state, startLine + 1)).split("|"),
                aligns = [],
                i = 0;
              i < columns.length;
              i++
            ) {
              if (!(t = columns[i].trim())) {
                if (0 === i || i === columns.length - 1) continue;
                return !1;
              }
              if (!/^:?-+:?$/.test(t)) return !1;
              58 === t.charCodeAt(t.length - 1)
                ? aligns.push(58 === t.charCodeAt(0) ? "center" : "right")
                : 58 === t.charCodeAt(0)
                  ? aligns.push("left")
                  : aligns.push("");
            }
            if (
              -1 === (lineText = getLine(state, startLine).trim()).indexOf("|")
            )
              return !1;
            if (4 <= state.sCount[startLine] - state.blkIndent) return !1;
            if (
              (columnCount = (columns = escapedSplit(
                lineText.replace(/^\||\|$/g, "")
              )).length) > aligns.length
            )
              return !1;
            if (silent) return !0;
            for (
              (token = state.push(
                "table_open",
                "table",
                1
              )).map = tableLines = [startLine, 0],
                (token = state.push("thead_open", "thead", 1)).map = [
                  startLine,
                  startLine + 1
                ],
                (token = state.push("tr_open", "tr", 1)).map = [
                  startLine,
                  startLine + 1
                ],
                i = 0;
              i < columns.length;
              i++
            )
              ((token = state.push("th_open", "th", 1)).map = [
                startLine,
                startLine + 1
              ]),
                aligns[i] &&
                  (token.attrs = [["style", "text-align:" + aligns[i]]]),
                ((token = state.push("inline", "", 0)).content = columns[
                  i
                ].trim()),
                (token.map = [startLine, startLine + 1]),
                (token.children = []),
                (token = state.push("th_close", "th", -1));
            for (
              token = state.push("tr_close", "tr", -1),
                token = state.push("thead_close", "thead", -1),
                (token = state.push(
                  "tbody_open",
                  "tbody",
                  1
                )).map = tbodyLines = [startLine + 2, 0],
                nextLine = startLine + 2;
              nextLine < endLine &&
              !(state.sCount[nextLine] < state.blkIndent) &&
              -1 !==
                (lineText = getLine(state, nextLine).trim()).indexOf("|") &&
              !(4 <= state.sCount[nextLine] - state.blkIndent);
              nextLine++
            ) {
              for (
                columns = escapedSplit(lineText.replace(/^\||\|$/g, "")),
                  token = state.push("tr_open", "tr", 1),
                  i = 0;
                i < columnCount;
                i++
              )
                (token = state.push("td_open", "td", 1)),
                  aligns[i] &&
                    (token.attrs = [["style", "text-align:" + aligns[i]]]),
                  ((token = state.push("inline", "", 0)).content = columns[i]
                    ? columns[i].trim()
                    : ""),
                  (token.children = []),
                  (token = state.push("td_close", "td", -1));
              token = state.push("tr_close", "tr", -1);
            }
            return (
              (token = state.push("tbody_close", "tbody", -1)),
              (token = state.push("table_close", "table", -1)),
              (tableLines[1] = tbodyLines[1] = nextLine),
              (state.line = nextLine),
              !0
            );
          };
        },
        { "../common/utils": 182 }
      ],
      208: [
        function(require, module, exports) {
          "use strict";
          module.exports = function(state) {
            var token;
            state.inlineMode
              ? (((token = new state.Token("inline", "", 0)).content =
                  state.src),
                (token.map = [0, 1]),
                (token.children = []),
                state.tokens.push(token))
              : state.md.block.parse(
                  state.src,
                  state.md,
                  state.env,
                  state.tokens
                );
          };
        },
        {}
      ],
      209: [
        function(require, module, exports) {
          "use strict";
          module.exports = function(state) {
            var tok,
              i,
              l,
              tokens = state.tokens;
            for (i = 0, l = tokens.length; i < l; i++)
              "inline" === (tok = tokens[i]).type &&
                state.md.inline.parse(
                  tok.content,
                  state.md,
                  state.env,
                  tok.children
                );
          };
        },
        {}
      ],
      210: [
        function(require, module, exports) {
          "use strict";
          var arrayReplaceAt = require("../common/utils").arrayReplaceAt;
          function isLinkClose(str) {
            return /^<\/a\s*>/i.test(str);
          }
          module.exports = function(state) {
            var i,
              j,
              l,
              tokens,
              token,
              currentToken,
              nodes,
              ln,
              text,
              pos,
              lastPos,
              level,
              htmlLinkLevel,
              url,
              fullUrl,
              urlText,
              links,
              str,
              blockTokens = state.tokens;
            if (state.md.options.linkify)
              for (j = 0, l = blockTokens.length; j < l; j++)
                if (
                  "inline" === blockTokens[j].type &&
                  state.md.linkify.pretest(blockTokens[j].content)
                )
                  for (
                    htmlLinkLevel = 0,
                      i = (tokens = blockTokens[j].children).length - 1;
                    0 <= i;
                    i--
                  )
                    if ("link_close" !== (currentToken = tokens[i]).type) {
                      if (
                        ("html_inline" === currentToken.type &&
                          ((str = currentToken.content),
                          /^<a[>\s]/i.test(str) &&
                            0 < htmlLinkLevel &&
                            htmlLinkLevel--,
                          isLinkClose(currentToken.content) && htmlLinkLevel++),
                        !(0 < htmlLinkLevel) &&
                          "text" === currentToken.type &&
                          state.md.linkify.test(currentToken.content))
                      ) {
                        for (
                          text = currentToken.content,
                            links = state.md.linkify.match(text),
                            nodes = [],
                            level = currentToken.level,
                            ln = lastPos = 0;
                          ln < links.length;
                          ln++
                        )
                          (url = links[ln].url),
                            (fullUrl = state.md.normalizeLink(url)),
                            state.md.validateLink(fullUrl) &&
                              ((urlText = links[ln].text),
                              (urlText = links[ln].schema
                                ? "mailto:" !== links[ln].schema ||
                                  /^mailto:/i.test(urlText)
                                  ? state.md.normalizeLinkText(urlText)
                                  : state.md
                                      .normalizeLinkText("mailto:" + urlText)
                                      .replace(/^mailto:/, "")
                                : state.md
                                    .normalizeLinkText("http://" + urlText)
                                    .replace(/^http:\/\//, "")),
                              lastPos < (pos = links[ln].index) &&
                                (((token = new state.Token(
                                  "text",
                                  "",
                                  0
                                )).content = text.slice(lastPos, pos)),
                                (token.level = level),
                                nodes.push(token)),
                              ((token = new state.Token(
                                "link_open",
                                "a",
                                1
                              )).attrs = [["href", fullUrl]]),
                              (token.level = level++),
                              (token.markup = "linkify"),
                              (token.info = "auto"),
                              nodes.push(token),
                              ((token = new state.Token(
                                "text",
                                "",
                                0
                              )).content = urlText),
                              (token.level = level),
                              nodes.push(token),
                              ((token = new state.Token(
                                "link_close",
                                "a",
                                -1
                              )).level = --level),
                              (token.markup = "linkify"),
                              (token.info = "auto"),
                              nodes.push(token),
                              (lastPos = links[ln].lastIndex));
                        lastPos < text.length &&
                          (((token = new state.Token(
                            "text",
                            "",
                            0
                          )).content = text.slice(lastPos)),
                          (token.level = level),
                          nodes.push(token)),
                          (blockTokens[j].children = tokens = arrayReplaceAt(
                            tokens,
                            i,
                            nodes
                          ));
                      }
                    } else
                      for (
                        i--;
                        tokens[i].level !== currentToken.level &&
                        "link_open" !== tokens[i].type;

                      )
                        i--;
          };
        },
        { "../common/utils": 182 }
      ],
      211: [
        function(require, module, exports) {
          "use strict";
          var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g,
            NULL_RE = /\u0000/g;
          module.exports = function(state) {
            var str;
            (str = (str = state.src.replace(NEWLINES_RE, "\n")).replace(
              NULL_RE,
              "�"
            )),
              (state.src = str);
          };
        },
        {}
      ],
      212: [
        function(require, module, exports) {
          "use strict";
          var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/,
            SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i,
            SCOPED_ABBR_RE = /\((c|tm|r|p)\)/gi,
            SCOPED_ABBR = { c: "©", r: "®", p: "§", tm: "™" };
          function replaceFn(match, name) {
            return SCOPED_ABBR[name.toLowerCase()];
          }
          function replace_scoped(inlineTokens) {
            var i,
              token,
              inside_autolink = 0;
            for (i = inlineTokens.length - 1; 0 <= i; i--)
              "text" !== (token = inlineTokens[i]).type ||
                inside_autolink ||
                (token.content = token.content.replace(
                  SCOPED_ABBR_RE,
                  replaceFn
                )),
                "link_open" === token.type &&
                  "auto" === token.info &&
                  inside_autolink--,
                "link_close" === token.type &&
                  "auto" === token.info &&
                  inside_autolink++;
          }
          function replace_rare(inlineTokens) {
            var i,
              token,
              inside_autolink = 0;
            for (i = inlineTokens.length - 1; 0 <= i; i--)
              "text" !== (token = inlineTokens[i]).type ||
                inside_autolink ||
                (RARE_RE.test(token.content) &&
                  (token.content = token.content
                    .replace(/\+-/g, "±")
                    .replace(/\.{2,}/g, "…")
                    .replace(/([?!])…/g, "$1..")
                    .replace(/([?!]){4,}/g, "$1$1$1")
                    .replace(/,{2,}/g, ",")
                    .replace(/(^|[^-])---([^-]|$)/gm, "$1—$2")
                    .replace(/(^|\s)--(\s|$)/gm, "$1–$2")
                    .replace(/(^|[^-\s])--([^-\s]|$)/gm, "$1–$2"))),
                "link_open" === token.type &&
                  "auto" === token.info &&
                  inside_autolink--,
                "link_close" === token.type &&
                  "auto" === token.info &&
                  inside_autolink++;
          }
          module.exports = function(state) {
            var blkIdx;
            if (state.md.options.typographer)
              for (blkIdx = state.tokens.length - 1; 0 <= blkIdx; blkIdx--)
                "inline" === state.tokens[blkIdx].type &&
                  (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content) &&
                    replace_scoped(state.tokens[blkIdx].children),
                  RARE_RE.test(state.tokens[blkIdx].content) &&
                    replace_rare(state.tokens[blkIdx].children));
          };
        },
        {}
      ],
      213: [
        function(require, module, exports) {
          "use strict";
          var isWhiteSpace = require("../common/utils").isWhiteSpace,
            isPunctChar = require("../common/utils").isPunctChar,
            isMdAsciiPunct = require("../common/utils").isMdAsciiPunct,
            QUOTE_TEST_RE = /['"]/,
            QUOTE_RE = /['"]/g,
            APOSTROPHE = "’";
          function replaceAt(str, index, ch) {
            return str.substr(0, index) + ch + str.substr(index + 1);
          }
          function process_inlines(tokens, state) {
            var i,
              token,
              text,
              t,
              pos,
              max,
              thisLevel,
              item,
              lastChar,
              nextChar,
              isLastPunctChar,
              isNextPunctChar,
              isLastWhiteSpace,
              isNextWhiteSpace,
              canOpen,
              canClose,
              j,
              isSingle,
              stack,
              openQuote,
              closeQuote;
            for (stack = [], i = 0; i < tokens.length; i++) {
              for (
                token = tokens[i],
                  thisLevel = tokens[i].level,
                  j = stack.length - 1;
                0 <= j && !(stack[j].level <= thisLevel);
                j--
              );
              if (((stack.length = j + 1), "text" === token.type)) {
                (pos = 0), (max = (text = token.content).length);
                OUTER: for (
                  ;
                  pos < max &&
                  ((QUOTE_RE.lastIndex = pos), (t = QUOTE_RE.exec(text)));

                ) {
                  if (
                    ((canOpen = canClose = !0),
                    (pos = t.index + 1),
                    (isSingle = "'" === t[0]),
                    (lastChar = 32),
                    0 <= t.index - 1)
                  )
                    lastChar = text.charCodeAt(t.index - 1);
                  else
                    for (
                      j = i - 1;
                      0 <= j &&
                      ("softbreak" !== tokens[j].type &&
                        "hardbreak" !== tokens[j].type);
                      j--
                    )
                      if ("text" === tokens[j].type) {
                        lastChar = tokens[j].content.charCodeAt(
                          tokens[j].content.length - 1
                        );
                        break;
                      }
                  if (((nextChar = 32), pos < max))
                    nextChar = text.charCodeAt(pos);
                  else
                    for (
                      j = i + 1;
                      j < tokens.length &&
                      ("softbreak" !== tokens[j].type &&
                        "hardbreak" !== tokens[j].type);
                      j++
                    )
                      if ("text" === tokens[j].type) {
                        nextChar = tokens[j].content.charCodeAt(0);
                        break;
                      }
                  if (
                    ((isLastPunctChar =
                      isMdAsciiPunct(lastChar) ||
                      isPunctChar(String.fromCharCode(lastChar))),
                    (isNextPunctChar =
                      isMdAsciiPunct(nextChar) ||
                      isPunctChar(String.fromCharCode(nextChar))),
                    (isLastWhiteSpace = isWhiteSpace(lastChar)),
                    (isNextWhiteSpace = isWhiteSpace(nextChar))
                      ? (canOpen = !1)
                      : isNextPunctChar &&
                        (isLastWhiteSpace || isLastPunctChar || (canOpen = !1)),
                    isLastWhiteSpace
                      ? (canClose = !1)
                      : isLastPunctChar &&
                        (isNextWhiteSpace ||
                          isNextPunctChar ||
                          (canClose = !1)),
                    34 === nextChar &&
                      '"' === t[0] &&
                      48 <= lastChar &&
                      lastChar <= 57 &&
                      (canClose = canOpen = !1),
                    canOpen &&
                      canClose &&
                      ((canOpen = !1), (canClose = isNextPunctChar)),
                    canOpen || canClose)
                  ) {
                    if (canClose)
                      for (
                        j = stack.length - 1;
                        0 <= j &&
                        ((item = stack[j]), !(stack[j].level < thisLevel));
                        j--
                      )
                        if (
                          item.single === isSingle &&
                          stack[j].level === thisLevel
                        ) {
                          (item = stack[j]),
                            isSingle
                              ? ((openQuote = state.md.options.quotes[2]),
                                (closeQuote = state.md.options.quotes[3]))
                              : ((openQuote = state.md.options.quotes[0]),
                                (closeQuote = state.md.options.quotes[1])),
                            (token.content = replaceAt(
                              token.content,
                              t.index,
                              closeQuote
                            )),
                            (tokens[item.token].content = replaceAt(
                              tokens[item.token].content,
                              item.pos,
                              openQuote
                            )),
                            (pos += closeQuote.length - 1),
                            item.token === i && (pos += openQuote.length - 1),
                            (max = (text = token.content).length),
                            (stack.length = j);
                          continue OUTER;
                        }
                    canOpen
                      ? stack.push({
                          token: i,
                          pos: t.index,
                          single: isSingle,
                          level: thisLevel
                        })
                      : canClose &&
                        isSingle &&
                        (token.content = replaceAt(
                          token.content,
                          t.index,
                          APOSTROPHE
                        ));
                  } else
                    isSingle &&
                      (token.content = replaceAt(
                        token.content,
                        t.index,
                        APOSTROPHE
                      ));
                }
              }
            }
          }
          module.exports = function(state) {
            var blkIdx;
            if (state.md.options.typographer)
              for (blkIdx = state.tokens.length - 1; 0 <= blkIdx; blkIdx--)
                "inline" === state.tokens[blkIdx].type &&
                  QUOTE_TEST_RE.test(state.tokens[blkIdx].content) &&
                  process_inlines(state.tokens[blkIdx].children, state);
          };
        },
        { "../common/utils": 182 }
      ],
      214: [
        function(require, module, exports) {
          "use strict";
          var Token = require("../token");
          function StateCore(src, md, env) {
            (this.src = src),
              (this.env = env),
              (this.tokens = []),
              (this.inlineMode = !1),
              (this.md = md);
          }
          (StateCore.prototype.Token = Token), (module.exports = StateCore);
        },
        { "../token": 229 }
      ],
      215: [
        function(require, module, exports) {
          "use strict";
          var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/,
            AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;
          module.exports = function(state, silent) {
            var tail,
              linkMatch,
              emailMatch,
              url,
              fullUrl,
              token,
              pos = state.pos;
            return (
              60 === state.src.charCodeAt(pos) &&
              (!((tail = state.src.slice(pos)).indexOf(">") < 0) &&
                (AUTOLINK_RE.test(tail)
                  ? ((url = (linkMatch = tail.match(AUTOLINK_RE))[0].slice(
                      1,
                      -1
                    )),
                    (fullUrl = state.md.normalizeLink(url)),
                    !!state.md.validateLink(fullUrl) &&
                      (silent ||
                        (((token = state.push("link_open", "a", 1)).attrs = [
                          ["href", fullUrl]
                        ]),
                        (token.markup = "autolink"),
                        (token.info = "auto"),
                        ((token = state.push(
                          "text",
                          "",
                          0
                        )).content = state.md.normalizeLinkText(url)),
                        ((token = state.push("link_close", "a", -1)).markup =
                          "autolink"),
                        (token.info = "auto")),
                      (state.pos += linkMatch[0].length),
                      !0))
                  : !!EMAIL_RE.test(tail) &&
                    ((url = (emailMatch = tail.match(EMAIL_RE))[0].slice(
                      1,
                      -1
                    )),
                    (fullUrl = state.md.normalizeLink("mailto:" + url)),
                    !!state.md.validateLink(fullUrl) &&
                      (silent ||
                        (((token = state.push("link_open", "a", 1)).attrs = [
                          ["href", fullUrl]
                        ]),
                        (token.markup = "autolink"),
                        (token.info = "auto"),
                        ((token = state.push(
                          "text",
                          "",
                          0
                        )).content = state.md.normalizeLinkText(url)),
                        ((token = state.push("link_close", "a", -1)).markup =
                          "autolink"),
                        (token.info = "auto")),
                      (state.pos += emailMatch[0].length),
                      !0))))
            );
          };
        },
        {}
      ],
      216: [
        function(require, module, exports) {
          "use strict";
          module.exports = function(state, silent) {
            var start,
              max,
              marker,
              matchStart,
              matchEnd,
              token,
              pos = state.pos;
            if (96 !== state.src.charCodeAt(pos)) return !1;
            for (
              start = pos, pos++, max = state.posMax;
              pos < max && 96 === state.src.charCodeAt(pos);

            )
              pos++;
            for (
              marker = state.src.slice(start, pos), matchStart = matchEnd = pos;
              -1 !== (matchStart = state.src.indexOf("`", matchEnd));

            ) {
              for (
                matchEnd = matchStart + 1;
                matchEnd < max && 96 === state.src.charCodeAt(matchEnd);

              )
                matchEnd++;
              if (matchEnd - matchStart === marker.length)
                return (
                  silent ||
                    (((token = state.push(
                      "code_inline",
                      "code",
                      0
                    )).markup = marker),
                    (token.content = state.src
                      .slice(pos, matchStart)
                      .replace(/[ \n]+/g, " ")
                      .trim())),
                  (state.pos = matchEnd),
                  !0
                );
            }
            return (
              silent || (state.pending += marker),
              (state.pos += marker.length),
              !0
            );
          };
        },
        {}
      ],
      217: [
        function(require, module, exports) {
          "use strict";
          module.exports = function(state) {
            var i,
              j,
              lastDelim,
              currDelim,
              delimiters = state.delimiters,
              max = state.delimiters.length;
            for (i = 0; i < max; i++)
              if ((lastDelim = delimiters[i]).close)
                for (j = i - lastDelim.jump - 1; 0 <= j; ) {
                  if (
                    (currDelim = delimiters[j]).open &&
                    currDelim.marker === lastDelim.marker &&
                    currDelim.end < 0 &&
                    currDelim.level === lastDelim.level
                  )
                    if (
                      !(
                        (currDelim.close || lastDelim.open) &&
                        void 0 !== currDelim.length &&
                        void 0 !== lastDelim.length &&
                        (currDelim.length + lastDelim.length) % 3 == 0
                      )
                    ) {
                      (lastDelim.jump = i - j),
                        (lastDelim.open = !1),
                        (currDelim.end = i),
                        (currDelim.jump = 0);
                      break;
                    }
                  j -= currDelim.jump + 1;
                }
          };
        },
        {}
      ],
      218: [
        function(require, module, exports) {
          "use strict";
          (module.exports.tokenize = function(state, silent) {
            var i,
              scanned,
              start = state.pos,
              marker = state.src.charCodeAt(start);
            if (silent) return !1;
            if (95 !== marker && 42 !== marker) return !1;
            for (
              scanned = state.scanDelims(state.pos, 42 === marker), i = 0;
              i < scanned.length;
              i++
            )
              (state.push("text", "", 0).content = String.fromCharCode(marker)),
                state.delimiters.push({
                  marker: marker,
                  length: scanned.length,
                  jump: i,
                  token: state.tokens.length - 1,
                  level: state.level,
                  end: -1,
                  open: scanned.can_open,
                  close: scanned.can_close
                });
            return (state.pos += scanned.length), !0;
          }),
            (module.exports.postProcess = function(state) {
              var i,
                startDelim,
                endDelim,
                token,
                ch,
                isStrong,
                delimiters = state.delimiters;
              for (i = state.delimiters.length - 1; 0 <= i; i--)
                (95 !== (startDelim = delimiters[i]).marker &&
                  42 !== startDelim.marker) ||
                  (-1 !== startDelim.end &&
                    ((endDelim = delimiters[startDelim.end]),
                    (isStrong =
                      0 < i &&
                      delimiters[i - 1].end === startDelim.end + 1 &&
                      delimiters[i - 1].token === startDelim.token - 1 &&
                      delimiters[startDelim.end + 1].token ===
                        endDelim.token + 1 &&
                      delimiters[i - 1].marker === startDelim.marker),
                    (ch = String.fromCharCode(startDelim.marker)),
                    ((token = state.tokens[startDelim.token]).type = isStrong
                      ? "strong_open"
                      : "em_open"),
                    (token.tag = isStrong ? "strong" : "em"),
                    (token.nesting = 1),
                    (token.markup = isStrong ? ch + ch : ch),
                    (token.content = ""),
                    ((token = state.tokens[endDelim.token]).type = isStrong
                      ? "strong_close"
                      : "em_close"),
                    (token.tag = isStrong ? "strong" : "em"),
                    (token.nesting = -1),
                    (token.markup = isStrong ? ch + ch : ch),
                    (token.content = ""),
                    isStrong &&
                      ((state.tokens[delimiters[i - 1].token].content = ""),
                      (state.tokens[
                        delimiters[startDelim.end + 1].token
                      ].content =
                        ""),
                      i--)));
            });
        },
        {}
      ],
      219: [
        function(require, module, exports) {
          "use strict";
          var entities = require("../common/entities"),
            has = require("../common/utils").has,
            isValidEntityCode = require("../common/utils").isValidEntityCode,
            fromCodePoint = require("../common/utils").fromCodePoint,
            DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i,
            NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
          module.exports = function(state, silent) {
            var code,
              match,
              pos = state.pos,
              max = state.posMax;
            if (38 !== state.src.charCodeAt(pos)) return !1;
            if (pos + 1 < max)
              if (35 === state.src.charCodeAt(pos + 1)) {
                if ((match = state.src.slice(pos).match(DIGITAL_RE)))
                  return (
                    silent ||
                      ((code =
                        "x" === match[1][0].toLowerCase()
                          ? parseInt(match[1].slice(1), 16)
                          : parseInt(match[1], 10)),
                      (state.pending += isValidEntityCode(code)
                        ? fromCodePoint(code)
                        : fromCodePoint(65533))),
                    (state.pos += match[0].length),
                    !0
                  );
              } else if (
                (match = state.src.slice(pos).match(NAMED_RE)) &&
                has(entities, match[1])
              )
                return (
                  silent || (state.pending += entities[match[1]]),
                  (state.pos += match[0].length),
                  !0
                );
            return silent || (state.pending += "&"), state.pos++, !0;
          };
        },
        { "../common/entities": 179, "../common/utils": 182 }
      ],
      220: [
        function(require, module, exports) {
          "use strict";
          for (
            var isSpace = require("../common/utils").isSpace,
              ESCAPED = [],
              i = 0;
            i < 256;
            i++
          )
            ESCAPED.push(0);
          "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
            ESCAPED[ch.charCodeAt(0)] = 1;
          }),
            (module.exports = function(state, silent) {
              var ch,
                pos = state.pos,
                max = state.posMax;
              if (92 !== state.src.charCodeAt(pos)) return !1;
              if (++pos < max) {
                if ((ch = state.src.charCodeAt(pos)) < 256 && 0 !== ESCAPED[ch])
                  return (
                    silent || (state.pending += state.src[pos]),
                    (state.pos += 2),
                    !0
                  );
                if (10 === ch) {
                  for (
                    silent || state.push("hardbreak", "br", 0), pos++;
                    pos < max &&
                    ((ch = state.src.charCodeAt(pos)), isSpace(ch));

                  )
                    pos++;
                  return (state.pos = pos), !0;
                }
              }
              return silent || (state.pending += "\\"), state.pos++, !0;
            });
        },
        { "../common/utils": 182 }
      ],
      221: [
        function(require, module, exports) {
          "use strict";
          var HTML_TAG_RE = require("../common/html_re").HTML_TAG_RE;
          module.exports = function(state, silent) {
            var ch,
              match,
              max,
              pos = state.pos;
            return (
              !!state.md.options.html &&
              ((max = state.posMax),
              !(60 !== state.src.charCodeAt(pos) || max <= pos + 2) &&
                (!(
                  33 !== (ch = state.src.charCodeAt(pos + 1)) &&
                  63 !== ch &&
                  47 !== ch &&
                  !(function(ch) {
                    var lc = 32 | ch;
                    return 97 <= lc && lc <= 122;
                  })(ch)
                ) &&
                  (!!(match = state.src.slice(pos).match(HTML_TAG_RE)) &&
                    (silent ||
                      (state.push(
                        "html_inline",
                        "",
                        0
                      ).content = state.src.slice(pos, pos + match[0].length)),
                    (state.pos += match[0].length),
                    !0))))
            );
          };
        },
        { "../common/html_re": 181 }
      ],
      222: [
        function(require, module, exports) {
          "use strict";
          var normalizeReference = require("../common/utils")
              .normalizeReference,
            isSpace = require("../common/utils").isSpace;
          module.exports = function(state, silent) {
            var attrs,
              code,
              content,
              label,
              labelEnd,
              labelStart,
              pos,
              ref,
              res,
              title,
              token,
              tokens,
              start,
              href = "",
              oldPos = state.pos,
              max = state.posMax;
            if (33 !== state.src.charCodeAt(state.pos)) return !1;
            if (91 !== state.src.charCodeAt(state.pos + 1)) return !1;
            if (
              ((labelStart = state.pos + 2),
              (labelEnd = state.md.helpers.parseLinkLabel(
                state,
                state.pos + 1,
                !1
              )) < 0)
            )
              return !1;
            if (
              (pos = labelEnd + 1) < max &&
              40 === state.src.charCodeAt(pos)
            ) {
              for (
                pos++;
                pos < max &&
                ((code = state.src.charCodeAt(pos)),
                isSpace(code) || 10 === code);
                pos++
              );
              if (max <= pos) return !1;
              for (
                start = pos,
                  (res = state.md.helpers.parseLinkDestination(
                    state.src,
                    pos,
                    state.posMax
                  )).ok &&
                    ((href = state.md.normalizeLink(res.str)),
                    state.md.validateLink(href)
                      ? (pos = res.pos)
                      : (href = "")),
                  start = pos;
                pos < max &&
                ((code = state.src.charCodeAt(pos)),
                isSpace(code) || 10 === code);
                pos++
              );
              if (
                ((res = state.md.helpers.parseLinkTitle(
                  state.src,
                  pos,
                  state.posMax
                )),
                pos < max && start !== pos && res.ok)
              )
                for (
                  title = res.str, pos = res.pos;
                  pos < max &&
                  ((code = state.src.charCodeAt(pos)),
                  isSpace(code) || 10 === code);
                  pos++
                );
              else title = "";
              if (max <= pos || 41 !== state.src.charCodeAt(pos))
                return (state.pos = oldPos), !1;
              pos++;
            } else {
              if (void 0 === state.env.references) return !1;
              if (
                (pos < max && 91 === state.src.charCodeAt(pos)
                  ? ((start = pos + 1),
                    0 <= (pos = state.md.helpers.parseLinkLabel(state, pos))
                      ? (label = state.src.slice(start, pos++))
                      : (pos = labelEnd + 1))
                  : (pos = labelEnd + 1),
                label || (label = state.src.slice(labelStart, labelEnd)),
                !(ref = state.env.references[normalizeReference(label)]))
              )
                return (state.pos = oldPos), !1;
              (href = ref.href), (title = ref.title);
            }
            return (
              silent ||
                ((content = state.src.slice(labelStart, labelEnd)),
                state.md.inline.parse(
                  content,
                  state.md,
                  state.env,
                  (tokens = [])
                ),
                ((token = state.push("image", "img", 0)).attrs = attrs = [
                  ["src", href],
                  ["alt", ""]
                ]),
                (token.children = tokens),
                (token.content = content),
                title && attrs.push(["title", title])),
              (state.pos = pos),
              (state.posMax = max),
              !0
            );
          };
        },
        { "../common/utils": 182 }
      ],
      223: [
        function(require, module, exports) {
          "use strict";
          var normalizeReference = require("../common/utils")
              .normalizeReference,
            isSpace = require("../common/utils").isSpace;
          module.exports = function(state, silent) {
            var attrs,
              code,
              label,
              labelEnd,
              labelStart,
              pos,
              res,
              ref,
              title,
              href = "",
              oldPos = state.pos,
              max = state.posMax,
              start = state.pos,
              parseReference = !0;
            if (91 !== state.src.charCodeAt(state.pos)) return !1;
            if (
              ((labelStart = state.pos + 1),
              (labelEnd = state.md.helpers.parseLinkLabel(
                state,
                state.pos,
                !0
              )) < 0)
            )
              return !1;
            if (
              (pos = labelEnd + 1) < max &&
              40 === state.src.charCodeAt(pos)
            ) {
              for (
                parseReference = !1, pos++;
                pos < max &&
                ((code = state.src.charCodeAt(pos)),
                isSpace(code) || 10 === code);
                pos++
              );
              if (max <= pos) return !1;
              for (
                start = pos,
                  (res = state.md.helpers.parseLinkDestination(
                    state.src,
                    pos,
                    state.posMax
                  )).ok &&
                    ((href = state.md.normalizeLink(res.str)),
                    state.md.validateLink(href)
                      ? (pos = res.pos)
                      : (href = "")),
                  start = pos;
                pos < max &&
                ((code = state.src.charCodeAt(pos)),
                isSpace(code) || 10 === code);
                pos++
              );
              if (
                ((res = state.md.helpers.parseLinkTitle(
                  state.src,
                  pos,
                  state.posMax
                )),
                pos < max && start !== pos && res.ok)
              )
                for (
                  title = res.str, pos = res.pos;
                  pos < max &&
                  ((code = state.src.charCodeAt(pos)),
                  isSpace(code) || 10 === code);
                  pos++
                );
              else title = "";
              (max <= pos || 41 !== state.src.charCodeAt(pos)) &&
                (parseReference = !0),
                pos++;
            }
            if (parseReference) {
              if (void 0 === state.env.references) return !1;
              if (
                (pos < max && 91 === state.src.charCodeAt(pos)
                  ? ((start = pos + 1),
                    0 <= (pos = state.md.helpers.parseLinkLabel(state, pos))
                      ? (label = state.src.slice(start, pos++))
                      : (pos = labelEnd + 1))
                  : (pos = labelEnd + 1),
                label || (label = state.src.slice(labelStart, labelEnd)),
                !(ref = state.env.references[normalizeReference(label)]))
              )
                return (state.pos = oldPos), !1;
              (href = ref.href), (title = ref.title);
            }
            return (
              silent ||
                ((state.pos = labelStart),
                (state.posMax = labelEnd),
                (state.push("link_open", "a", 1).attrs = attrs = [
                  ["href", href]
                ]),
                title && attrs.push(["title", title]),
                state.md.inline.tokenize(state),
                state.push("link_close", "a", -1)),
              (state.pos = pos),
              (state.posMax = max),
              !0
            );
          };
        },
        { "../common/utils": 182 }
      ],
      224: [
        function(require, module, exports) {
          "use strict";
          var isSpace = require("../common/utils").isSpace;
          module.exports = function(state, silent) {
            var pmax,
              max,
              pos = state.pos;
            if (10 !== state.src.charCodeAt(pos)) return !1;
            for (
              pmax = state.pending.length - 1,
                max = state.posMax,
                silent ||
                  (0 <= pmax && 32 === state.pending.charCodeAt(pmax)
                    ? 1 <= pmax && 32 === state.pending.charCodeAt(pmax - 1)
                      ? ((state.pending = state.pending.replace(/ +$/, "")),
                        state.push("hardbreak", "br", 0))
                      : ((state.pending = state.pending.slice(0, -1)),
                        state.push("softbreak", "br", 0))
                    : state.push("softbreak", "br", 0)),
                pos++;
              pos < max && isSpace(state.src.charCodeAt(pos));

            )
              pos++;
            return (state.pos = pos), !0;
          };
        },
        { "../common/utils": 182 }
      ],
      225: [
        function(require, module, exports) {
          "use strict";
          var Token = require("../token"),
            isWhiteSpace = require("../common/utils").isWhiteSpace,
            isPunctChar = require("../common/utils").isPunctChar,
            isMdAsciiPunct = require("../common/utils").isMdAsciiPunct;
          function StateInline(src, md, env, outTokens) {
            (this.src = src),
              (this.env = env),
              (this.md = md),
              (this.tokens = outTokens),
              (this.pos = 0),
              (this.posMax = this.src.length),
              (this.level = 0),
              (this.pending = ""),
              (this.pendingLevel = 0),
              (this.cache = {}),
              (this.delimiters = []);
          }
          (StateInline.prototype.pushPending = function() {
            var token = new Token("text", "", 0);
            return (
              (token.content = this.pending),
              (token.level = this.pendingLevel),
              this.tokens.push(token),
              (this.pending = ""),
              token
            );
          }),
            (StateInline.prototype.push = function(type, tag, nesting) {
              this.pending && this.pushPending();
              var token = new Token(type, tag, nesting);
              return (
                nesting < 0 && this.level--,
                (token.level = this.level),
                0 < nesting && this.level++,
                (this.pendingLevel = this.level),
                this.tokens.push(token),
                token
              );
            }),
            (StateInline.prototype.scanDelims = function(start, canSplitWord) {
              var lastChar,
                nextChar,
                count,
                can_open,
                can_close,
                isLastWhiteSpace,
                isLastPunctChar,
                isNextWhiteSpace,
                isNextPunctChar,
                pos = start,
                left_flanking = !0,
                right_flanking = !0,
                max = this.posMax,
                marker = this.src.charCodeAt(start);
              for (
                lastChar = 0 < start ? this.src.charCodeAt(start - 1) : 32;
                pos < max && this.src.charCodeAt(pos) === marker;

              )
                pos++;
              return (
                (count = pos - start),
                (nextChar = pos < max ? this.src.charCodeAt(pos) : 32),
                (isLastPunctChar =
                  isMdAsciiPunct(lastChar) ||
                  isPunctChar(String.fromCharCode(lastChar))),
                (isNextPunctChar =
                  isMdAsciiPunct(nextChar) ||
                  isPunctChar(String.fromCharCode(nextChar))),
                (isLastWhiteSpace = isWhiteSpace(lastChar)),
                (isNextWhiteSpace = isWhiteSpace(nextChar))
                  ? (left_flanking = !1)
                  : isNextPunctChar &&
                    (isLastWhiteSpace ||
                      isLastPunctChar ||
                      (left_flanking = !1)),
                isLastWhiteSpace
                  ? (right_flanking = !1)
                  : isLastPunctChar &&
                    (isNextWhiteSpace ||
                      isNextPunctChar ||
                      (right_flanking = !1)),
                canSplitWord
                  ? ((can_open = left_flanking), (can_close = right_flanking))
                  : ((can_open =
                      left_flanking && (!right_flanking || isLastPunctChar)),
                    (can_close =
                      right_flanking && (!left_flanking || isNextPunctChar))),
                { can_open: can_open, can_close: can_close, length: count }
              );
            }),
            (StateInline.prototype.Token = Token),
            (module.exports = StateInline);
        },
        { "../common/utils": 182, "../token": 229 }
      ],
      226: [
        function(require, module, exports) {
          "use strict";
          (module.exports.tokenize = function(state, silent) {
            var i,
              scanned,
              len,
              ch,
              start = state.pos,
              marker = state.src.charCodeAt(start);
            if (silent) return !1;
            if (126 !== marker) return !1;
            if (
              ((len = (scanned = state.scanDelims(state.pos, !0)).length),
              (ch = String.fromCharCode(marker)),
              len < 2)
            )
              return !1;
            for (
              len % 2 && ((state.push("text", "", 0).content = ch), len--),
                i = 0;
              i < len;
              i += 2
            )
              (state.push("text", "", 0).content = ch + ch),
                state.delimiters.push({
                  marker: marker,
                  jump: i,
                  token: state.tokens.length - 1,
                  level: state.level,
                  end: -1,
                  open: scanned.can_open,
                  close: scanned.can_close
                });
            return (state.pos += scanned.length), !0;
          }),
            (module.exports.postProcess = function(state) {
              var i,
                j,
                startDelim,
                endDelim,
                token,
                loneMarkers = [],
                delimiters = state.delimiters,
                max = state.delimiters.length;
              for (i = 0; i < max; i++)
                126 === (startDelim = delimiters[i]).marker &&
                  -1 !== startDelim.end &&
                  ((endDelim = delimiters[startDelim.end]),
                  ((token = state.tokens[startDelim.token]).type = "s_open"),
                  (token.tag = "s"),
                  (token.nesting = 1),
                  (token.markup = "~~"),
                  (token.content = ""),
                  ((token = state.tokens[endDelim.token]).type = "s_close"),
                  (token.tag = "s"),
                  (token.nesting = -1),
                  (token.markup = "~~"),
                  (token.content = ""),
                  "text" === state.tokens[endDelim.token - 1].type &&
                    "~" === state.tokens[endDelim.token - 1].content &&
                    loneMarkers.push(endDelim.token - 1));
              for (; loneMarkers.length; ) {
                for (
                  j = (i = loneMarkers.pop()) + 1;
                  j < state.tokens.length && "s_close" === state.tokens[j].type;

                )
                  j++;
                i !== --j &&
                  ((token = state.tokens[j]),
                  (state.tokens[j] = state.tokens[i]),
                  (state.tokens[i] = token));
              }
            });
        },
        {}
      ],
      227: [
        function(require, module, exports) {
          "use strict";
          function isTerminatorChar(ch) {
            switch (ch) {
              case 10:
              case 33:
              case 35:
              case 36:
              case 37:
              case 38:
              case 42:
              case 43:
              case 45:
              case 58:
              case 60:
              case 61:
              case 62:
              case 64:
              case 91:
              case 92:
              case 93:
              case 94:
              case 95:
              case 96:
              case 123:
              case 125:
              case 126:
                return !0;
              default:
                return !1;
            }
          }
          module.exports = function(state, silent) {
            for (
              var pos = state.pos;
              pos < state.posMax &&
              !isTerminatorChar(state.src.charCodeAt(pos));

            )
              pos++;
            return (
              pos !== state.pos &&
              (silent || (state.pending += state.src.slice(state.pos, pos)),
              (state.pos = pos),
              !0)
            );
          };
        },
        {}
      ],
      228: [
        function(require, module, exports) {
          "use strict";
          module.exports = function(state) {
            var curr,
              last,
              level = 0,
              tokens = state.tokens,
              max = state.tokens.length;
            for (curr = last = 0; curr < max; curr++)
              (level += tokens[curr].nesting),
                (tokens[curr].level = level),
                "text" === tokens[curr].type &&
                curr + 1 < max &&
                "text" === tokens[curr + 1].type
                  ? (tokens[curr + 1].content =
                      tokens[curr].content + tokens[curr + 1].content)
                  : (curr !== last && (tokens[last] = tokens[curr]), last++);
            curr !== last && (tokens.length = last);
          };
        },
        {}
      ],
      229: [
        function(require, module, exports) {
          "use strict";
          function Token(type, tag, nesting) {
            (this.type = type),
              (this.tag = tag),
              (this.attrs = null),
              (this.map = null),
              (this.nesting = nesting),
              (this.level = 0),
              (this.children = null),
              (this.content = ""),
              (this.markup = ""),
              (this.info = ""),
              (this.meta = null),
              (this.block = !1),
              (this.hidden = !1);
          }
          (Token.prototype.attrIndex = function(name) {
            var attrs, i, len;
            if (!this.attrs) return -1;
            for (i = 0, len = (attrs = this.attrs).length; i < len; i++)
              if (attrs[i][0] === name) return i;
            return -1;
          }),
            (Token.prototype.attrPush = function(attrData) {
              this.attrs
                ? this.attrs.push(attrData)
                : (this.attrs = [attrData]);
            }),
            (Token.prototype.attrSet = function(name, value) {
              var idx = this.attrIndex(name),
                attrData = [name, value];
              idx < 0 ? this.attrPush(attrData) : (this.attrs[idx] = attrData);
            }),
            (Token.prototype.attrGet = function(name) {
              var idx = this.attrIndex(name),
                value = null;
              return 0 <= idx && (value = this.attrs[idx][1]), value;
            }),
            (Token.prototype.attrJoin = function(name, value) {
              var idx = this.attrIndex(name);
              idx < 0
                ? this.attrPush([name, value])
                : (this.attrs[idx][1] = this.attrs[idx][1] + " " + value);
            }),
            (module.exports = Token);
        },
        {}
      ],
      230: [
        function(require, module, exports) {
          "use strict";
          var decodeCache = {};
          function decode(string, exclude) {
            var cache;
            return (
              "string" != typeof exclude && (exclude = decode.defaultChars),
              (cache = (function(exclude) {
                var i,
                  ch,
                  cache = decodeCache[exclude];
                if (cache) return cache;
                for (cache = decodeCache[exclude] = [], i = 0; i < 128; i++)
                  (ch = String.fromCharCode(i)), cache.push(ch);
                for (i = 0; i < exclude.length; i++)
                  cache[(ch = exclude.charCodeAt(i))] =
                    "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
                return cache;
              })(exclude)),
              string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
                var i,
                  l,
                  b1,
                  b2,
                  b3,
                  b4,
                  chr,
                  result = "";
                for (i = 0, l = seq.length; i < l; i += 3)
                  (b1 = parseInt(seq.slice(i + 1, i + 3), 16)) < 128
                    ? (result += cache[b1])
                    : 192 == (224 & b1) &&
                      i + 3 < l &&
                      128 ==
                        (192 & (b2 = parseInt(seq.slice(i + 4, i + 6), 16)))
                      ? ((result +=
                          (chr = ((b1 << 6) & 1984) | (63 & b2)) < 128
                            ? "��"
                            : String.fromCharCode(chr)),
                        (i += 3))
                      : 224 == (240 & b1) &&
                        i + 6 < l &&
                        ((b2 = parseInt(seq.slice(i + 4, i + 6), 16)),
                        (b3 = parseInt(seq.slice(i + 7, i + 9), 16)),
                        128 == (192 & b2) && 128 == (192 & b3))
                        ? ((result +=
                            (chr =
                              ((b1 << 12) & 61440) |
                              ((b2 << 6) & 4032) |
                              (63 & b3)) < 2048 ||
                            (55296 <= chr && chr <= 57343)
                              ? "���"
                              : String.fromCharCode(chr)),
                          (i += 6))
                        : 240 == (248 & b1) &&
                          i + 9 < l &&
                          ((b2 = parseInt(seq.slice(i + 4, i + 6), 16)),
                          (b3 = parseInt(seq.slice(i + 7, i + 9), 16)),
                          (b4 = parseInt(seq.slice(i + 10, i + 12), 16)),
                          128 == (192 & b2) &&
                            128 == (192 & b3) &&
                            128 == (192 & b4))
                          ? ((chr =
                              ((b1 << 18) & 1835008) |
                              ((b2 << 12) & 258048) |
                              ((b3 << 6) & 4032) |
                              (63 & b4)) < 65536 || 1114111 < chr
                              ? (result += "����")
                              : ((chr -= 65536),
                                (result += String.fromCharCode(
                                  55296 + (chr >> 10),
                                  56320 + (1023 & chr)
                                ))),
                            (i += 9))
                          : (result += "�");
                return result;
              })
            );
          }
          (decode.defaultChars = ";/?:@&=+$,#"),
            (decode.componentChars = ""),
            (module.exports = decode);
        },
        {}
      ],
      231: [
        function(require, module, exports) {
          "use strict";
          var encodeCache = {};
          function encode(string, exclude, keepEscaped) {
            var i,
              l,
              code,
              nextCode,
              cache,
              result = "";
            for (
              "string" != typeof exclude &&
                ((keepEscaped = exclude), (exclude = encode.defaultChars)),
                void 0 === keepEscaped && (keepEscaped = !0),
                cache = (function(exclude) {
                  var i,
                    ch,
                    cache = encodeCache[exclude];
                  if (cache) return cache;
                  for (cache = encodeCache[exclude] = [], i = 0; i < 128; i++)
                    (ch = String.fromCharCode(i)),
                      /^[0-9a-z]$/i.test(ch)
                        ? cache.push(ch)
                        : cache.push(
                            "%" + ("0" + i.toString(16).toUpperCase()).slice(-2)
                          );
                  for (i = 0; i < exclude.length; i++)
                    cache[exclude.charCodeAt(i)] = exclude[i];
                  return cache;
                })(exclude),
                i = 0,
                l = string.length;
              i < l;
              i++
            )
              if (
                ((code = string.charCodeAt(i)),
                keepEscaped &&
                  37 === code &&
                  i + 2 < l &&
                  /^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3)))
              )
                (result += string.slice(i, i + 3)), (i += 2);
              else if (code < 128) result += cache[code];
              else if (55296 <= code && code <= 57343) {
                if (
                  55296 <= code &&
                  code <= 56319 &&
                  i + 1 < l &&
                  56320 <= (nextCode = string.charCodeAt(i + 1)) &&
                  nextCode <= 57343
                ) {
                  (result += encodeURIComponent(string[i] + string[i + 1])),
                    i++;
                  continue;
                }
                result += "%EF%BF%BD";
              } else result += encodeURIComponent(string[i]);
            return result;
          }
          (encode.defaultChars = ";/?:@&=+$,-_.!~*'()#"),
            (encode.componentChars = "-_.!~*'()"),
            (module.exports = encode);
        },
        {}
      ],
      232: [
        function(require, module, exports) {
          "use strict";
          module.exports = function(url) {
            var result = "";
            return (
              (result += url.protocol || ""),
              (result += url.slashes ? "//" : ""),
              (result += url.auth ? url.auth + "@" : ""),
              url.hostname && -1 !== url.hostname.indexOf(":")
                ? (result += "[" + url.hostname + "]")
                : (result += url.hostname || ""),
              (result += url.port ? ":" + url.port : ""),
              (result += url.pathname || ""),
              (result += url.search || ""),
              (result += url.hash || "")
            );
          };
        },
        {}
      ],
      233: [
        function(require, module, exports) {
          "use strict";
          (module.exports.encode = require("./encode")),
            (module.exports.decode = require("./decode")),
            (module.exports.format = require("./format")),
            (module.exports.parse = require("./parse"));
        },
        { "./decode": 230, "./encode": 231, "./format": 232, "./parse": 234 }
      ],
      234: [
        function(require, module, exports) {
          "use strict";
          function Url() {
            (this.protocol = null),
              (this.slashes = null),
              (this.auth = null),
              (this.port = null),
              (this.hostname = null),
              (this.hash = null),
              (this.search = null),
              (this.pathname = null);
          }
          var protocolPattern = /^([a-z0-9.+-]+:)/i,
            portPattern = /:[0-9]*$/,
            simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
            unwise = ["{", "}", "|", "\\", "^", "`"].concat([
              "<",
              ">",
              '"',
              "`",
              " ",
              "\r",
              "\n",
              "\t"
            ]),
            autoEscape = ["'"].concat(unwise),
            nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape),
            hostEndingChars = ["/", "?", "#"],
            hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
            hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
            hostlessProtocol = { javascript: !0, "javascript:": !0 },
            slashedProtocol = {
              http: !0,
              https: !0,
              ftp: !0,
              gopher: !0,
              file: !0,
              "http:": !0,
              "https:": !0,
              "ftp:": !0,
              "gopher:": !0,
              "file:": !0
            };
          (Url.prototype.parse = function(url, slashesDenoteHost) {
            var i,
              l,
              lowerProto,
              hec,
              slashes,
              rest = url;
            if (
              ((rest = rest.trim()),
              !slashesDenoteHost && 1 === url.split("#").length)
            ) {
              var simplePath = simplePathPattern.exec(rest);
              if (simplePath)
                return (
                  (this.pathname = simplePath[1]),
                  simplePath[2] && (this.search = simplePath[2]),
                  this
                );
            }
            var proto = protocolPattern.exec(rest);
            if (
              (proto &&
                ((lowerProto = (proto = proto[0]).toLowerCase()),
                (this.protocol = proto),
                (rest = rest.substr(proto.length))),
              (slashesDenoteHost ||
                proto ||
                rest.match(/^\/\/[^@\/]+@[^@\/]+/)) &&
                (!(slashes = "//" === rest.substr(0, 2)) ||
                  (proto && hostlessProtocol[proto]) ||
                  ((rest = rest.substr(2)), (this.slashes = !0))),
              !hostlessProtocol[proto] &&
                (slashes || (proto && !slashedProtocol[proto])))
            ) {
              var auth,
                atSign,
                hostEnd = -1;
              for (i = 0; i < hostEndingChars.length; i++)
                -1 !== (hec = rest.indexOf(hostEndingChars[i])) &&
                  (-1 === hostEnd || hec < hostEnd) &&
                  (hostEnd = hec);
              for (
                -1 !==
                  (atSign =
                    -1 === hostEnd
                      ? rest.lastIndexOf("@")
                      : rest.lastIndexOf("@", hostEnd)) &&
                  ((auth = rest.slice(0, atSign)),
                  (rest = rest.slice(atSign + 1)),
                  (this.auth = auth)),
                  hostEnd = -1,
                  i = 0;
                i < nonHostChars.length;
                i++
              )
                -1 !== (hec = rest.indexOf(nonHostChars[i])) &&
                  (-1 === hostEnd || hec < hostEnd) &&
                  (hostEnd = hec);
              -1 === hostEnd && (hostEnd = rest.length),
                ":" === rest[hostEnd - 1] && hostEnd--;
              var host = rest.slice(0, hostEnd);
              (rest = rest.slice(hostEnd)),
                this.parseHost(host),
                (this.hostname = this.hostname || "");
              var ipv6Hostname =
                "[" === this.hostname[0] &&
                "]" === this.hostname[this.hostname.length - 1];
              if (!ipv6Hostname) {
                var hostparts = this.hostname.split(/\./);
                for (i = 0, l = hostparts.length; i < l; i++) {
                  var part = hostparts[i];
                  if (part && !part.match(hostnamePartPattern)) {
                    for (var newpart = "", j = 0, k = part.length; j < k; j++)
                      127 < part.charCodeAt(j)
                        ? (newpart += "x")
                        : (newpart += part[j]);
                    if (!newpart.match(hostnamePartPattern)) {
                      var validParts = hostparts.slice(0, i),
                        notHost = hostparts.slice(i + 1),
                        bit = part.match(hostnamePartStart);
                      bit && (validParts.push(bit[1]), notHost.unshift(bit[2])),
                        notHost.length && (rest = notHost.join(".") + rest),
                        (this.hostname = validParts.join("."));
                      break;
                    }
                  }
                }
              }
              255 < this.hostname.length && (this.hostname = ""),
                ipv6Hostname &&
                  (this.hostname = this.hostname.substr(
                    1,
                    this.hostname.length - 2
                  ));
            }
            var hash = rest.indexOf("#");
            -1 !== hash &&
              ((this.hash = rest.substr(hash)), (rest = rest.slice(0, hash)));
            var qm = rest.indexOf("?");
            return (
              -1 !== qm &&
                ((this.search = rest.substr(qm)), (rest = rest.slice(0, qm))),
              rest && (this.pathname = rest),
              slashedProtocol[lowerProto] &&
                this.hostname &&
                !this.pathname &&
                (this.pathname = ""),
              this
            );
          }),
            (Url.prototype.parseHost = function(host) {
              var port = portPattern.exec(host);
              port &&
                (":" !== (port = port[0]) && (this.port = port.substr(1)),
                (host = host.substr(0, host.length - port.length))),
                host && (this.hostname = host);
            }),
            (module.exports = function(url, slashesDenoteHost) {
              if (url && url instanceof Url) return url;
              var u = new Url();
              return u.parse(url, slashesDenoteHost), u;
            });
        },
        {}
      ],
      235: [
        function(require, module, exports) {
          var cachedSetTimeout,
            cachedClearTimeout,
            process = (module.exports = {});
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
            if (
              (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
              setTimeout
            )
              return (cachedSetTimeout = setTimeout), setTimeout(fun, 0);
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          !(function() {
            try {
              cachedSetTimeout =
                "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              cachedClearTimeout =
                "function" == typeof clearTimeout
                  ? clearTimeout
                  : defaultClearTimeout;
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          var currentQueue,
            queue = [],
            draining = !1,
            queueIndex = -1;
          function cleanUpNextTick() {
            draining &&
              currentQueue &&
              ((draining = !1),
              currentQueue.length
                ? (queue = currentQueue.concat(queue))
                : (queueIndex = -1),
              queue.length && drainQueue());
          }
          function drainQueue() {
            if (!draining) {
              var timeout = runTimeout(cleanUpNextTick);
              draining = !0;
              for (var len = queue.length; len; ) {
                for (currentQueue = queue, queue = []; ++queueIndex < len; )
                  currentQueue && currentQueue[queueIndex].run();
                (queueIndex = -1), (len = queue.length);
              }
              (currentQueue = null),
                (draining = !1),
                (function(marker) {
                  if (cachedClearTimeout === clearTimeout)
                    return clearTimeout(marker);
                  if (
                    (cachedClearTimeout === defaultClearTimeout ||
                      !cachedClearTimeout) &&
                    clearTimeout
                  )
                    return (
                      (cachedClearTimeout = clearTimeout), clearTimeout(marker)
                    );
                  try {
                    cachedClearTimeout(marker);
                  } catch (e) {
                    try {
                      return cachedClearTimeout.call(null, marker);
                    } catch (e) {
                      return cachedClearTimeout.call(this, marker);
                    }
                  }
                })(timeout);
            }
          }
          function Item(fun, array) {
            (this.fun = fun), (this.array = array);
          }
          function noop() {}
          (process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (1 < arguments.length)
              for (var i = 1; i < arguments.length; i++)
                args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)),
              1 !== queue.length || draining || runTimeout(drainQueue);
          }),
            (Item.prototype.run = function() {
              this.fun.apply(null, this.array);
            }),
            (process.title = "browser"),
            (process.browser = !0),
            (process.env = {}),
            (process.argv = []),
            (process.version = ""),
            (process.versions = {}),
            (process.on = noop),
            (process.addListener = noop),
            (process.once = noop),
            (process.off = noop),
            (process.removeListener = noop),
            (process.removeAllListeners = noop),
            (process.emit = noop),
            (process.prependListener = noop),
            (process.prependOnceListener = noop),
            (process.listeners = function(name) {
              return [];
            }),
            (process.binding = function(name) {
              throw new Error("process.binding is not supported");
            }),
            (process.cwd = function() {
              return "/";
            }),
            (process.chdir = function(dir) {
              throw new Error("process.chdir is not supported");
            }),
            (process.umask = function() {
              return 0;
            });
        },
        {}
      ],
      236: [
        function(require, module, exports) {
          (function(process) {
            "use strict";
            if ("production" !== process.env.NODE_ENV)
              var invariant = require("fbjs/lib/invariant"),
                warning = require("fbjs/lib/warning"),
                ReactPropTypesSecret = require("./lib/ReactPropTypesSecret"),
                loggedTypeFailures = {};
            module.exports = function(
              typeSpecs,
              values,
              location,
              componentName,
              getStack
            ) {
              if ("production" !== process.env.NODE_ENV)
                for (var typeSpecName in typeSpecs)
                  if (typeSpecs.hasOwnProperty(typeSpecName)) {
                    var error;
                    try {
                      invariant(
                        "function" == typeof typeSpecs[typeSpecName],
                        "%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.",
                        componentName || "React class",
                        location,
                        typeSpecName
                      ),
                        (error = typeSpecs[typeSpecName](
                          values,
                          typeSpecName,
                          componentName,
                          location,
                          null,
                          ReactPropTypesSecret
                        ));
                    } catch (ex) {
                      error = ex;
                    }
                    if (
                      (warning(
                        !error || error instanceof Error,
                        "%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).",
                        componentName || "React class",
                        location,
                        typeSpecName,
                        typeof error
                      ),
                      error instanceof Error &&
                        !(error.message in loggedTypeFailures))
                    ) {
                      loggedTypeFailures[error.message] = !0;
                      var stack = getStack ? getStack() : "";
                      warning(
                        !1,
                        "Failed %s type: %s%s",
                        location,
                        error.message,
                        null != stack ? stack : ""
                      );
                    }
                  }
            };
          }.call(this, require("_process")));
        },
        {
          "./lib/ReactPropTypesSecret": 240,
          _process: 235,
          "fbjs/lib/invariant": 69,
          "fbjs/lib/warning": 70
        }
      ],
      237: [
        function(require, module, exports) {
          "use strict";
          var emptyFunction = require("fbjs/lib/emptyFunction"),
            invariant = require("fbjs/lib/invariant");
          module.exports = function() {
            function shim() {
              invariant(
                !1,
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
              );
            }
            function getShim() {
              return shim;
            }
            var ReactPropTypes = {
              array: (shim.isRequired = shim),
              bool: shim,
              func: shim,
              number: shim,
              object: shim,
              string: shim,
              symbol: shim,
              any: shim,
              arrayOf: getShim,
              element: shim,
              instanceOf: getShim,
              node: shim,
              objectOf: getShim,
              oneOf: getShim,
              oneOfType: getShim,
              shape: getShim
            };
            return (
              (ReactPropTypes.checkPropTypes = emptyFunction),
              (ReactPropTypes.PropTypes = ReactPropTypes)
            );
          };
        },
        { "fbjs/lib/emptyFunction": 68, "fbjs/lib/invariant": 69 }
      ],
      238: [
        function(require, module, exports) {
          (function(process) {
            "use strict";
            var emptyFunction = require("fbjs/lib/emptyFunction"),
              invariant = require("fbjs/lib/invariant"),
              warning = require("fbjs/lib/warning"),
              ReactPropTypesSecret = require("./lib/ReactPropTypesSecret"),
              checkPropTypes = require("./checkPropTypes");
            module.exports = function(isValidElement, throwOnDirectAccess) {
              var ITERATOR_SYMBOL =
                  "function" == typeof Symbol && Symbol.iterator,
                FAUX_ITERATOR_SYMBOL = "@@iterator";
              var ANONYMOUS = "<<anonymous>>",
                ReactPropTypes = {
                  array: createPrimitiveTypeChecker("array"),
                  bool: createPrimitiveTypeChecker("boolean"),
                  func: createPrimitiveTypeChecker("function"),
                  number: createPrimitiveTypeChecker("number"),
                  object: createPrimitiveTypeChecker("object"),
                  string: createPrimitiveTypeChecker("string"),
                  symbol: createPrimitiveTypeChecker("symbol"),
                  any: createChainableTypeChecker(
                    emptyFunction.thatReturnsNull
                  ),
                  arrayOf: function(typeChecker) {
                    return createChainableTypeChecker(function(
                      props,
                      propName,
                      componentName,
                      location,
                      propFullName
                    ) {
                      if ("function" != typeof typeChecker)
                        return new PropTypeError(
                          "Property `" +
                            propFullName +
                            "` of component `" +
                            componentName +
                            "` has invalid PropType notation inside arrayOf."
                        );
                      var propValue = props[propName];
                      if (!Array.isArray(propValue)) {
                        var propType = getPropType(propValue);
                        return new PropTypeError(
                          "Invalid " +
                            location +
                            " `" +
                            propFullName +
                            "` of type `" +
                            propType +
                            "` supplied to `" +
                            componentName +
                            "`, expected an array."
                        );
                      }
                      for (var i = 0; i < propValue.length; i++) {
                        var error = typeChecker(
                          propValue,
                          i,
                          componentName,
                          location,
                          propFullName + "[" + i + "]",
                          ReactPropTypesSecret
                        );
                        if (error instanceof Error) return error;
                      }
                      return null;
                    });
                  },
                  element: createChainableTypeChecker(function(
                    props,
                    propName,
                    componentName,
                    location,
                    propFullName
                  ) {
                    var propValue = props[propName];
                    if (!isValidElement(propValue)) {
                      var propType = getPropType(propValue);
                      return new PropTypeError(
                        "Invalid " +
                          location +
                          " `" +
                          propFullName +
                          "` of type `" +
                          propType +
                          "` supplied to `" +
                          componentName +
                          "`, expected a single ReactElement."
                      );
                    }
                    return null;
                  }),
                  instanceOf: function(expectedClass) {
                    return createChainableTypeChecker(function(
                      props,
                      propName,
                      componentName,
                      location,
                      propFullName
                    ) {
                      if (!(props[propName] instanceof expectedClass)) {
                        var expectedClassName = expectedClass.name || ANONYMOUS,
                          actualClassName = (function(propValue) {
                            if (
                              !propValue.constructor ||
                              !propValue.constructor.name
                            )
                              return ANONYMOUS;
                            return propValue.constructor.name;
                          })(props[propName]);
                        return new PropTypeError(
                          "Invalid " +
                            location +
                            " `" +
                            propFullName +
                            "` of type `" +
                            actualClassName +
                            "` supplied to `" +
                            componentName +
                            "`, expected instance of `" +
                            expectedClassName +
                            "`."
                        );
                      }
                      return null;
                    });
                  },
                  node: createChainableTypeChecker(function(
                    props,
                    propName,
                    componentName,
                    location,
                    propFullName
                  ) {
                    return isNode(props[propName])
                      ? null
                      : new PropTypeError(
                          "Invalid " +
                            location +
                            " `" +
                            propFullName +
                            "` supplied to `" +
                            componentName +
                            "`, expected a ReactNode."
                        );
                  }),
                  objectOf: function(typeChecker) {
                    return createChainableTypeChecker(function(
                      props,
                      propName,
                      componentName,
                      location,
                      propFullName
                    ) {
                      if ("function" != typeof typeChecker)
                        return new PropTypeError(
                          "Property `" +
                            propFullName +
                            "` of component `" +
                            componentName +
                            "` has invalid PropType notation inside objectOf."
                        );
                      var propValue = props[propName],
                        propType = getPropType(propValue);
                      if ("object" !== propType)
                        return new PropTypeError(
                          "Invalid " +
                            location +
                            " `" +
                            propFullName +
                            "` of type `" +
                            propType +
                            "` supplied to `" +
                            componentName +
                            "`, expected an object."
                        );
                      for (var key in propValue)
                        if (propValue.hasOwnProperty(key)) {
                          var error = typeChecker(
                            propValue,
                            key,
                            componentName,
                            location,
                            propFullName + "." + key,
                            ReactPropTypesSecret
                          );
                          if (error instanceof Error) return error;
                        }
                      return null;
                    });
                  },
                  oneOf: function(expectedValues) {
                    if (!Array.isArray(expectedValues))
                      return (
                        "production" !== process.env.NODE_ENV &&
                          warning(
                            !1,
                            "Invalid argument supplied to oneOf, expected an instance of array."
                          ),
                        emptyFunction.thatReturnsNull
                      );
                    return createChainableTypeChecker(function(
                      props,
                      propName,
                      componentName,
                      location,
                      propFullName
                    ) {
                      for (
                        var propValue = props[propName], i = 0;
                        i < expectedValues.length;
                        i++
                      )
                        if (is(propValue, expectedValues[i])) return null;
                      var valuesString = JSON.stringify(expectedValues);
                      return new PropTypeError(
                        "Invalid " +
                          location +
                          " `" +
                          propFullName +
                          "` of value `" +
                          propValue +
                          "` supplied to `" +
                          componentName +
                          "`, expected one of " +
                          valuesString +
                          "."
                      );
                    });
                  },
                  oneOfType: function(arrayOfTypeCheckers) {
                    if (!Array.isArray(arrayOfTypeCheckers))
                      return (
                        "production" !== process.env.NODE_ENV &&
                          warning(
                            !1,
                            "Invalid argument supplied to oneOfType, expected an instance of array."
                          ),
                        emptyFunction.thatReturnsNull
                      );
                    return createChainableTypeChecker(function(
                      props,
                      propName,
                      componentName,
                      location,
                      propFullName
                    ) {
                      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
                        var checker = arrayOfTypeCheckers[i];
                        if (
                          null ==
                          checker(
                            props,
                            propName,
                            componentName,
                            location,
                            propFullName,
                            ReactPropTypesSecret
                          )
                        )
                          return null;
                      }
                      return new PropTypeError(
                        "Invalid " +
                          location +
                          " `" +
                          propFullName +
                          "` supplied to `" +
                          componentName +
                          "`."
                      );
                    });
                  },
                  shape: function(shapeTypes) {
                    return createChainableTypeChecker(function(
                      props,
                      propName,
                      componentName,
                      location,
                      propFullName
                    ) {
                      var propValue = props[propName],
                        propType = getPropType(propValue);
                      if ("object" !== propType)
                        return new PropTypeError(
                          "Invalid " +
                            location +
                            " `" +
                            propFullName +
                            "` of type `" +
                            propType +
                            "` supplied to `" +
                            componentName +
                            "`, expected `object`."
                        );
                      for (var key in shapeTypes) {
                        var checker = shapeTypes[key];
                        if (checker) {
                          var error = checker(
                            propValue,
                            key,
                            componentName,
                            location,
                            propFullName + "." + key,
                            ReactPropTypesSecret
                          );
                          if (error) return error;
                        }
                      }
                      return null;
                    });
                  }
                };
              function is(x, y) {
                return x === y ? 0 !== x || 1 / x == 1 / y : x != x && y != y;
              }
              function PropTypeError(message) {
                (this.message = message), (this.stack = "");
              }
              function createChainableTypeChecker(validate) {
                if ("production" !== process.env.NODE_ENV)
                  var manualPropTypeCallCache = {},
                    manualPropTypeWarningCount = 0;
                function checkType(
                  isRequired,
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName,
                  secret
                ) {
                  if (
                    ((componentName = componentName || ANONYMOUS),
                    (propFullName = propFullName || propName),
                    secret !== ReactPropTypesSecret)
                  )
                    if (throwOnDirectAccess)
                      invariant(
                        !1,
                        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                      );
                    else if (
                      "production" !== process.env.NODE_ENV &&
                      "undefined" != typeof console
                    ) {
                      var cacheKey = componentName + ":" + propName;
                      !manualPropTypeCallCache[cacheKey] &&
                        manualPropTypeWarningCount < 3 &&
                        (warning(
                          !1,
                          "You are manually calling a React.PropTypes validation function for the `%s` prop on `%s`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.",
                          propFullName,
                          componentName
                        ),
                        (manualPropTypeCallCache[cacheKey] = !0),
                        manualPropTypeWarningCount++);
                    }
                  return null == props[propName]
                    ? isRequired
                      ? null === props[propName]
                        ? new PropTypeError(
                            "The " +
                              location +
                              " `" +
                              propFullName +
                              "` is marked as required in `" +
                              componentName +
                              "`, but its value is `null`."
                          )
                        : new PropTypeError(
                            "The " +
                              location +
                              " `" +
                              propFullName +
                              "` is marked as required in `" +
                              componentName +
                              "`, but its value is `undefined`."
                          )
                      : null
                    : validate(
                        props,
                        propName,
                        componentName,
                        location,
                        propFullName
                      );
                }
                var chainedCheckType = checkType.bind(null, !1);
                return (
                  (chainedCheckType.isRequired = checkType.bind(null, !0)),
                  chainedCheckType
                );
              }
              function createPrimitiveTypeChecker(expectedType) {
                return createChainableTypeChecker(function(
                  props,
                  propName,
                  componentName,
                  location,
                  propFullName,
                  secret
                ) {
                  var propValue = props[propName];
                  return getPropType(propValue) !== expectedType
                    ? new PropTypeError(
                        "Invalid " +
                          location +
                          " `" +
                          propFullName +
                          "` of type `" +
                          (function(propValue) {
                            var propType = getPropType(propValue);
                            if ("object" === propType) {
                              if (propValue instanceof Date) return "date";
                              if (propValue instanceof RegExp) return "regexp";
                            }
                            return propType;
                          })(propValue) +
                          "` supplied to `" +
                          componentName +
                          "`, expected `" +
                          expectedType +
                          "`."
                      )
                    : null;
                });
              }
              function isNode(propValue) {
                switch (typeof propValue) {
                  case "number":
                  case "string":
                  case "undefined":
                    return !0;
                  case "boolean":
                    return !propValue;
                  case "object":
                    if (Array.isArray(propValue))
                      return propValue.every(isNode);
                    if (null === propValue || isValidElement(propValue))
                      return !0;
                    var iteratorFn = (function(maybeIterable) {
                      var iteratorFn =
                        maybeIterable &&
                        ((ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL]) ||
                          maybeIterable[FAUX_ITERATOR_SYMBOL]);
                      if ("function" == typeof iteratorFn) return iteratorFn;
                    })(propValue);
                    if (!iteratorFn) return !1;
                    var step,
                      iterator = iteratorFn.call(propValue);
                    if (iteratorFn !== propValue.entries) {
                      for (; !(step = iterator.next()).done; )
                        if (!isNode(step.value)) return !1;
                    } else
                      for (; !(step = iterator.next()).done; ) {
                        var entry = step.value;
                        if (entry && !isNode(entry[1])) return !1;
                      }
                    return !0;
                  default:
                    return !1;
                }
              }
              function getPropType(propValue) {
                var propType = typeof propValue;
                return Array.isArray(propValue)
                  ? "array"
                  : propValue instanceof RegExp
                    ? "object"
                    : (function(propType, propValue) {
                        return (
                          "symbol" === propType ||
                          "Symbol" === propValue["@@toStringTag"] ||
                          ("function" == typeof Symbol &&
                            propValue instanceof Symbol)
                        );
                      })(propType, propValue)
                      ? "symbol"
                      : propType;
              }
              return (
                (PropTypeError.prototype = Error.prototype),
                (ReactPropTypes.checkPropTypes = checkPropTypes),
                (ReactPropTypes.PropTypes = ReactPropTypes)
              );
            };
          }.call(this, require("_process")));
        },
        {
          "./checkPropTypes": 236,
          "./lib/ReactPropTypesSecret": 240,
          _process: 235,
          "fbjs/lib/emptyFunction": 68,
          "fbjs/lib/invariant": 69,
          "fbjs/lib/warning": 70
        }
      ],
      239: [
        function(require, module, exports) {
          (function(process) {
            if ("production" !== process.env.NODE_ENV) {
              var REACT_ELEMENT_TYPE =
                ("function" == typeof Symbol &&
                  Symbol.for &&
                  Symbol.for("react.element")) ||
                60103;
              module.exports = require("./factoryWithTypeCheckers")(function(
                object
              ) {
                return (
                  "object" == typeof object &&
                  null !== object &&
                  object.$$typeof === REACT_ELEMENT_TYPE
                );
              },
              !0);
            } else module.exports = require("./factoryWithThrowingShims")();
          }.call(this, require("_process")));
        },
        {
          "./factoryWithThrowingShims": 237,
          "./factoryWithTypeCheckers": 238,
          _process: 235
        }
      ],
      240: [
        function(require, module, exports) {
          "use strict";
          module.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
        },
        {}
      ],
      241: [
        function(require, module, exports) {
          (function(global) {
            !(function(root) {
              var freeExports =
                  "object" == typeof exports &&
                  exports &&
                  !exports.nodeType &&
                  exports,
                freeModule =
                  "object" == typeof module &&
                  module &&
                  !module.nodeType &&
                  module,
                freeGlobal = "object" == typeof global && global;
              (freeGlobal.global !== freeGlobal &&
                freeGlobal.window !== freeGlobal &&
                freeGlobal.self !== freeGlobal) ||
                (root = freeGlobal);
              var punycode,
                key,
                maxInt = 2147483647,
                base = 36,
                tMin = 1,
                tMax = 26,
                skew = 38,
                damp = 700,
                initialBias = 72,
                initialN = 128,
                delimiter = "-",
                regexPunycode = /^xn--/,
                regexNonASCII = /[^\x20-\x7E]/,
                regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
                errors = {
                  overflow: "Overflow: input needs wider integers to process",
                  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                  "invalid-input": "Invalid input"
                },
                baseMinusTMin = base - tMin,
                floor = Math.floor,
                stringFromCharCode = String.fromCharCode;
              function error(type) {
                throw new RangeError(errors[type]);
              }
              function map(array, fn) {
                for (var length = array.length, result = []; length--; )
                  result[length] = fn(array[length]);
                return result;
              }
              function mapDomain(string, fn) {
                var parts = string.split("@"),
                  result = "";
                return (
                  1 < parts.length &&
                    ((result = parts[0] + "@"), (string = parts[1])),
                  result +
                    map(
                      (string = string.replace(regexSeparators, ".")).split(
                        "."
                      ),
                      fn
                    ).join(".")
                );
              }
              function ucs2decode(string) {
                for (
                  var value,
                    extra,
                    output = [],
                    counter = 0,
                    length = string.length;
                  counter < length;

                )
                  55296 <= (value = string.charCodeAt(counter++)) &&
                  value <= 56319 &&
                  counter < length
                    ? 56320 == (64512 & (extra = string.charCodeAt(counter++)))
                      ? output.push(
                          ((1023 & value) << 10) + (1023 & extra) + 65536
                        )
                      : (output.push(value), counter--)
                    : output.push(value);
                return output;
              }
              function ucs2encode(array) {
                return map(array, function(value) {
                  var output = "";
                  return (
                    65535 < value &&
                      ((output += stringFromCharCode(
                        (((value -= 65536) >>> 10) & 1023) | 55296
                      )),
                      (value = 56320 | (1023 & value))),
                    (output += stringFromCharCode(value))
                  );
                }).join("");
              }
              function digitToBasic(digit, flag) {
                return digit + 22 + 75 * (digit < 26) - ((0 != flag) << 5);
              }
              function adapt(delta, numPoints, firstTime) {
                var k = 0;
                for (
                  delta = firstTime ? floor(delta / damp) : delta >> 1,
                    delta += floor(delta / numPoints);
                  (baseMinusTMin * tMax) >> 1 < delta;
                  k += base
                )
                  delta = floor(delta / baseMinusTMin);
                return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
              }
              function decode(input) {
                var out,
                  basic,
                  j,
                  index,
                  oldi,
                  w,
                  k,
                  digit,
                  t,
                  baseMinusT,
                  codePoint,
                  output = [],
                  inputLength = input.length,
                  i = 0,
                  n = initialN,
                  bias = initialBias;
                for (
                  (basic = input.lastIndexOf(delimiter)) < 0 && (basic = 0),
                    j = 0;
                  j < basic;
                  ++j
                )
                  128 <= input.charCodeAt(j) && error("not-basic"),
                    output.push(input.charCodeAt(j));
                for (index = 0 < basic ? basic + 1 : 0; index < inputLength; ) {
                  for (
                    oldi = i, w = 1, k = base;
                    inputLength <= index && error("invalid-input"),
                      (codePoint = input.charCodeAt(index++)),
                      (base <=
                        (digit =
                          codePoint - 48 < 10
                            ? codePoint - 22
                            : codePoint - 65 < 26
                              ? codePoint - 65
                              : codePoint - 97 < 26 ? codePoint - 97 : base) ||
                        digit > floor((maxInt - i) / w)) &&
                        error("overflow"),
                      (i += digit * w),
                      !(
                        digit <
                        (t =
                          k <= bias ? tMin : bias + tMax <= k ? tMax : k - bias)
                      );
                    k += base
                  )
                    w > floor(maxInt / (baseMinusT = base - t)) &&
                      error("overflow"),
                      (w *= baseMinusT);
                  (bias = adapt(
                    i - oldi,
                    (out = output.length + 1),
                    0 == oldi
                  )),
                    floor(i / out) > maxInt - n && error("overflow"),
                    (n += floor(i / out)),
                    (i %= out),
                    output.splice(i++, 0, n);
                }
                return ucs2encode(output);
              }
              function encode(input) {
                var n,
                  delta,
                  handledCPCount,
                  basicLength,
                  bias,
                  j,
                  m,
                  q,
                  k,
                  t,
                  currentValue,
                  inputLength,
                  handledCPCountPlusOne,
                  baseMinusT,
                  qMinusT,
                  output = [];
                for (
                  inputLength = (input = ucs2decode(input)).length,
                    n = initialN,
                    bias = initialBias,
                    j = delta = 0;
                  j < inputLength;
                  ++j
                )
                  (currentValue = input[j]) < 128 &&
                    output.push(stringFromCharCode(currentValue));
                for (
                  handledCPCount = basicLength = output.length,
                    basicLength && output.push(delimiter);
                  handledCPCount < inputLength;

                ) {
                  for (m = maxInt, j = 0; j < inputLength; ++j)
                    n <= (currentValue = input[j]) &&
                      currentValue < m &&
                      (m = currentValue);
                  for (
                    m - n >
                      floor(
                        (maxInt - delta) /
                          (handledCPCountPlusOne = handledCPCount + 1)
                      ) && error("overflow"),
                      delta += (m - n) * handledCPCountPlusOne,
                      n = m,
                      j = 0;
                    j < inputLength;
                    ++j
                  )
                    if (
                      ((currentValue = input[j]) < n &&
                        ++delta > maxInt &&
                        error("overflow"),
                      currentValue == n)
                    ) {
                      for (
                        q = delta, k = base;
                        !(
                          q <
                          (t =
                            k <= bias
                              ? tMin
                              : bias + tMax <= k ? tMax : k - bias)
                        );
                        k += base
                      )
                        (qMinusT = q - t),
                          (baseMinusT = base - t),
                          output.push(
                            stringFromCharCode(
                              digitToBasic(t + qMinusT % baseMinusT, 0)
                            )
                          ),
                          (q = floor(qMinusT / baseMinusT));
                      output.push(stringFromCharCode(digitToBasic(q, 0))),
                        (bias = adapt(
                          delta,
                          handledCPCountPlusOne,
                          handledCPCount == basicLength
                        )),
                        (delta = 0),
                        ++handledCPCount;
                    }
                  ++delta, ++n;
                }
                return output.join("");
              }
              if (
                ((punycode = {
                  version: "1.4.1",
                  ucs2: { decode: ucs2decode, encode: ucs2encode },
                  decode: decode,
                  encode: encode,
                  toASCII: function(input) {
                    return mapDomain(input, function(string) {
                      return regexNonASCII.test(string)
                        ? "xn--" + encode(string)
                        : string;
                    });
                  },
                  toUnicode: function(input) {
                    return mapDomain(input, function(string) {
                      return regexPunycode.test(string)
                        ? decode(string.slice(4).toLowerCase())
                        : string;
                    });
                  }
                }),
                freeExports && freeModule)
              )
                if (module.exports == freeExports)
                  freeModule.exports = punycode;
                else
                  for (key in punycode)
                    punycode.hasOwnProperty(key) &&
                      (freeExports[key] = punycode[key]);
              else root.punycode = punycode;
            })(this);
          }.call(
            this,
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        {}
      ],
      242: [
        function(require, module, exports) {
          module.exports = /[\0-\x1F\x7F-\x9F]/;
        },
        {}
      ],
      243: [
        function(require, module, exports) {
          module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
        },
        {}
      ],
      244: [
        function(require, module, exports) {
          module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E49\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
        },
        {}
      ],
      245: [
        function(require, module, exports) {
          module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/;
        },
        {}
      ],
      246: [
        function(require, module, exports) {
          "use strict";
          (exports.Any = require("./properties/Any/regex")),
            (exports.Cc = require("./categories/Cc/regex")),
            (exports.Cf = require("./categories/Cf/regex")),
            (exports.P = require("./categories/P/regex")),
            (exports.Z = require("./categories/Z/regex"));
        },
        {
          "./categories/Cc/regex": 242,
          "./categories/Cf/regex": 243,
          "./categories/P/regex": 244,
          "./categories/Z/regex": 245,
          "./properties/Any/regex": 247
        }
      ],
      247: [
        function(require, module, exports) {
          module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
        },
        {}
      ],
      248: [
        function(require, module, exports) {
          "function" == typeof Object.create
            ? (module.exports = function(ctor, superCtor) {
                (ctor.super_ = superCtor),
                  (ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                      value: ctor,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  }));
              })
            : (module.exports = function(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                (TempCtor.prototype = superCtor.prototype),
                  (ctor.prototype = new TempCtor()),
                  (ctor.prototype.constructor = ctor);
              });
        },
        {}
      ],
      249: [
        function(require, module, exports) {
          module.exports = function(arg) {
            return (
              arg &&
              "object" == typeof arg &&
              "function" == typeof arg.copy &&
              "function" == typeof arg.fill &&
              "function" == typeof arg.readUInt8
            );
          };
        },
        {}
      ],
      250: [
        function(require, module, exports) {
          (function(process, global) {
            var formatRegExp = /%[sdj%]/g;
            (exports.format = function(f) {
              if (!isString(f)) {
                for (var objects = [], i = 0; i < arguments.length; i++)
                  objects.push(inspect(arguments[i]));
                return objects.join(" ");
              }
              i = 1;
              for (
                var args = arguments,
                  len = args.length,
                  str = String(f).replace(formatRegExp, function(x) {
                    if ("%%" === x) return "%";
                    if (len <= i) return x;
                    switch (x) {
                      case "%s":
                        return String(args[i++]);
                      case "%d":
                        return Number(args[i++]);
                      case "%j":
                        try {
                          return JSON.stringify(args[i++]);
                        } catch (_) {
                          return "[Circular]";
                        }
                      default:
                        return x;
                    }
                  }),
                  x = args[i];
                i < len;
                x = args[++i]
              )
                isNull(x) || !isObject(x)
                  ? (str += " " + x)
                  : (str += " " + inspect(x));
              return str;
            }),
              (exports.deprecate = function(fn, msg) {
                if (isUndefined(global.process))
                  return function() {
                    return exports.deprecate(fn, msg).apply(this, arguments);
                  };
                if (!0 === process.noDeprecation) return fn;
                var warned = !1;
                return function() {
                  if (!warned) {
                    if (process.throwDeprecation) throw new Error(msg);
                    process.traceDeprecation
                      ? console.trace(msg)
                      : console.error(msg),
                      (warned = !0);
                  }
                  return fn.apply(this, arguments);
                };
              });
            var debugEnviron,
              debugs = {};
            function inspect(obj, opts) {
              var ctx = { seen: [], stylize: stylizeNoColor };
              return (
                3 <= arguments.length && (ctx.depth = arguments[2]),
                4 <= arguments.length && (ctx.colors = arguments[3]),
                isBoolean(opts)
                  ? (ctx.showHidden = opts)
                  : opts && exports._extend(ctx, opts),
                isUndefined(ctx.showHidden) && (ctx.showHidden = !1),
                isUndefined(ctx.depth) && (ctx.depth = 2),
                isUndefined(ctx.colors) && (ctx.colors = !1),
                isUndefined(ctx.customInspect) && (ctx.customInspect = !0),
                ctx.colors && (ctx.stylize = stylizeWithColor),
                formatValue(ctx, obj, ctx.depth)
              );
            }
            function stylizeWithColor(str, styleType) {
              var style = inspect.styles[styleType];
              return style
                ? "[" +
                    inspect.colors[style][0] +
                    "m" +
                    str +
                    "[" +
                    inspect.colors[style][1] +
                    "m"
                : str;
            }
            function stylizeNoColor(str, styleType) {
              return str;
            }
            function formatValue(ctx, value, recurseTimes) {
              if (
                ctx.customInspect &&
                value &&
                isFunction(value.inspect) &&
                value.inspect !== exports.inspect &&
                (!value.constructor || value.constructor.prototype !== value)
              ) {
                var ret = value.inspect(recurseTimes, ctx);
                return (
                  isString(ret) || (ret = formatValue(ctx, ret, recurseTimes)),
                  ret
                );
              }
              var primitive = (function(ctx, value) {
                if (isUndefined(value))
                  return ctx.stylize("undefined", "undefined");
                if (isString(value)) {
                  var simple =
                    "'" +
                    JSON.stringify(value)
                      .replace(/^"|"$/g, "")
                      .replace(/'/g, "\\'")
                      .replace(/\\"/g, '"') +
                    "'";
                  return ctx.stylize(simple, "string");
                }
                if (isNumber(value)) return ctx.stylize("" + value, "number");
                if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
                if (isNull(value)) return ctx.stylize("null", "null");
              })(ctx, value);
              if (primitive) return primitive;
              var keys = Object.keys(value),
                visibleKeys = (function(array) {
                  var hash = {};
                  return (
                    array.forEach(function(val, idx) {
                      hash[val] = !0;
                    }),
                    hash
                  );
                })(keys);
              if (
                (ctx.showHidden && (keys = Object.getOwnPropertyNames(value)),
                isError(value) &&
                  (0 <= keys.indexOf("message") ||
                    0 <= keys.indexOf("description")))
              )
                return formatError(value);
              if (0 === keys.length) {
                if (isFunction(value)) {
                  var name = value.name ? ": " + value.name : "";
                  return ctx.stylize("[Function" + name + "]", "special");
                }
                if (isRegExp(value))
                  return ctx.stylize(
                    RegExp.prototype.toString.call(value),
                    "regexp"
                  );
                if (isDate(value))
                  return ctx.stylize(
                    Date.prototype.toString.call(value),
                    "date"
                  );
                if (isError(value)) return formatError(value);
              }
              var output,
                base = "",
                array = !1,
                braces = ["{", "}"];
              (isArray(value) && ((array = !0), (braces = ["[", "]"])),
              isFunction(value)) &&
                (base =
                  " [Function" + (value.name ? ": " + value.name : "") + "]");
              return (
                isRegExp(value) &&
                  (base = " " + RegExp.prototype.toString.call(value)),
                isDate(value) &&
                  (base = " " + Date.prototype.toUTCString.call(value)),
                isError(value) && (base = " " + formatError(value)),
                0 !== keys.length || (array && 0 != value.length)
                  ? recurseTimes < 0
                    ? isRegExp(value)
                      ? ctx.stylize(
                          RegExp.prototype.toString.call(value),
                          "regexp"
                        )
                      : ctx.stylize("[Object]", "special")
                    : (ctx.seen.push(value),
                      (output = array
                        ? (function(
                            ctx,
                            value,
                            recurseTimes,
                            visibleKeys,
                            keys
                          ) {
                            for (
                              var output = [], i = 0, l = value.length;
                              i < l;
                              ++i
                            )
                              hasOwnProperty(value, String(i))
                                ? output.push(
                                    formatProperty(
                                      ctx,
                                      value,
                                      recurseTimes,
                                      visibleKeys,
                                      String(i),
                                      !0
                                    )
                                  )
                                : output.push("");
                            return (
                              keys.forEach(function(key) {
                                key.match(/^\d+$/) ||
                                  output.push(
                                    formatProperty(
                                      ctx,
                                      value,
                                      recurseTimes,
                                      visibleKeys,
                                      key,
                                      !0
                                    )
                                  );
                              }),
                              output
                            );
                          })(ctx, value, recurseTimes, visibleKeys, keys)
                        : keys.map(function(key) {
                            return formatProperty(
                              ctx,
                              value,
                              recurseTimes,
                              visibleKeys,
                              key,
                              array
                            );
                          })),
                      ctx.seen.pop(),
                      (function(output, base, braces) {
                        if (
                          60 <
                          output.reduce(function(prev, cur) {
                            return (
                              0,
                              0 <= cur.indexOf("\n") && 0,
                              prev +
                                cur.replace(/\u001b\[\d\d?m/g, "").length +
                                1
                            );
                          }, 0)
                        )
                          return (
                            braces[0] +
                            ("" === base ? "" : base + "\n ") +
                            " " +
                            output.join(",\n  ") +
                            " " +
                            braces[1]
                          );
                        return (
                          braces[0] +
                          base +
                          " " +
                          output.join(", ") +
                          " " +
                          braces[1]
                        );
                      })(output, base, braces))
                  : braces[0] + base + braces[1]
              );
            }
            function formatError(value) {
              return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatProperty(
              ctx,
              value,
              recurseTimes,
              visibleKeys,
              key,
              array
            ) {
              var name, str, desc;
              if (
                ((desc = Object.getOwnPropertyDescriptor(value, key) || {
                  value: value[key]
                }).get
                  ? (str = desc.set
                      ? ctx.stylize("[Getter/Setter]", "special")
                      : ctx.stylize("[Getter]", "special"))
                  : desc.set && (str = ctx.stylize("[Setter]", "special")),
                hasOwnProperty(visibleKeys, key) || (name = "[" + key + "]"),
                str ||
                  (ctx.seen.indexOf(desc.value) < 0
                    ? -1 <
                        (str = isNull(recurseTimes)
                          ? formatValue(ctx, desc.value, null)
                          : formatValue(
                              ctx,
                              desc.value,
                              recurseTimes - 1
                            )).indexOf("\n") &&
                      (str = array
                        ? str
                            .split("\n")
                            .map(function(line) {
                              return "  " + line;
                            })
                            .join("\n")
                            .substr(2)
                        : "\n" +
                          str
                            .split("\n")
                            .map(function(line) {
                              return "   " + line;
                            })
                            .join("\n"))
                    : (str = ctx.stylize("[Circular]", "special"))),
                isUndefined(name))
              ) {
                if (array && key.match(/^\d+$/)) return str;
                (name = JSON.stringify("" + key)).match(
                  /^"([a-zA-Z_][a-zA-Z_0-9]*)"$/
                )
                  ? ((name = name.substr(1, name.length - 2)),
                    (name = ctx.stylize(name, "name")))
                  : ((name = name
                      .replace(/'/g, "\\'")
                      .replace(/\\"/g, '"')
                      .replace(/(^"|"$)/g, "'")),
                    (name = ctx.stylize(name, "string")));
              }
              return name + ": " + str;
            }
            function isArray(ar) {
              return Array.isArray(ar);
            }
            function isBoolean(arg) {
              return "boolean" == typeof arg;
            }
            function isNull(arg) {
              return null === arg;
            }
            function isNumber(arg) {
              return "number" == typeof arg;
            }
            function isString(arg) {
              return "string" == typeof arg;
            }
            function isUndefined(arg) {
              return void 0 === arg;
            }
            function isRegExp(re) {
              return isObject(re) && "[object RegExp]" === objectToString(re);
            }
            function isObject(arg) {
              return "object" == typeof arg && null !== arg;
            }
            function isDate(d) {
              return isObject(d) && "[object Date]" === objectToString(d);
            }
            function isError(e) {
              return (
                isObject(e) &&
                ("[object Error]" === objectToString(e) || e instanceof Error)
              );
            }
            function isFunction(arg) {
              return "function" == typeof arg;
            }
            function objectToString(o) {
              return Object.prototype.toString.call(o);
            }
            function pad(n) {
              return n < 10 ? "0" + n.toString(10) : n.toString(10);
            }
            (exports.debuglog = function(set) {
              if (
                (isUndefined(debugEnviron) &&
                  (debugEnviron = process.env.NODE_DEBUG || ""),
                (set = set.toUpperCase()),
                !debugs[set])
              )
                if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                  var pid = process.pid;
                  debugs[set] = function() {
                    var msg = exports.format.apply(exports, arguments);
                    console.error("%s %d: %s", set, pid, msg);
                  };
                } else debugs[set] = function() {};
              return debugs[set];
            }),
              ((exports.inspect = inspect).colors = {
                bold: [1, 22],
                italic: [3, 23],
                underline: [4, 24],
                inverse: [7, 27],
                white: [37, 39],
                grey: [90, 39],
                black: [30, 39],
                blue: [34, 39],
                cyan: [36, 39],
                green: [32, 39],
                magenta: [35, 39],
                red: [31, 39],
                yellow: [33, 39]
              }),
              (inspect.styles = {
                special: "cyan",
                number: "yellow",
                boolean: "yellow",
                undefined: "grey",
                null: "bold",
                string: "green",
                date: "magenta",
                regexp: "red"
              }),
              (exports.isArray = isArray),
              (exports.isBoolean = isBoolean),
              (exports.isNull = isNull),
              (exports.isNullOrUndefined = function(arg) {
                return null == arg;
              }),
              (exports.isNumber = isNumber),
              (exports.isString = isString),
              (exports.isSymbol = function(arg) {
                return "symbol" == typeof arg;
              }),
              (exports.isUndefined = isUndefined),
              (exports.isRegExp = isRegExp),
              (exports.isObject = isObject),
              (exports.isDate = isDate),
              (exports.isError = isError),
              (exports.isFunction = isFunction),
              (exports.isPrimitive = function(arg) {
                return (
                  null === arg ||
                  "boolean" == typeof arg ||
                  "number" == typeof arg ||
                  "string" == typeof arg ||
                  "symbol" == typeof arg ||
                  void 0 === arg
                );
              }),
              (exports.isBuffer = require("./support/isBuffer"));
            var months = [
              "Jan",
              "Feb",
              "Mar",
              "Apr",
              "May",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Oct",
              "Nov",
              "Dec"
            ];
            function hasOwnProperty(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            (exports.log = function() {
              var d, time;
              console.log(
                "%s - %s",
                ((d = new Date()),
                (time = [
                  pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())
                ].join(":")),
                [d.getDate(), months[d.getMonth()], time].join(" ")),
                exports.format.apply(exports, arguments)
              );
            }),
              (exports.inherits = require("inherits")),
              (exports._extend = function(origin, add) {
                if (!add || !isObject(add)) return origin;
                for (var keys = Object.keys(add), i = keys.length; i--; )
                  origin[keys[i]] = add[keys[i]];
                return origin;
              });
          }.call(
            this,
            require("_process"),
            "undefined" != typeof global
              ? global
              : "undefined" != typeof self
                ? self
                : "undefined" != typeof window ? window : {}
          ));
        },
        { "./support/isBuffer": 249, _process: 235, inherits: 248 }
      ]
    },
    {},
    [23]
  )(23);
});
